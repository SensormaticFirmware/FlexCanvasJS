

//Create elements
var canvasManager = new CanvasManager();
var dropdown = new DropdownElement();

function init()
{
	//Attach the DOM canvas to our CanvasManager
	canvasManager.setCanvas(document.getElementById("flexCanvasApplication"));
	
	var dropdownLocaleCollection = new ListCollection();
	dropdownLocaleCollection.addItem({key:"en-us", label:"English"});
	dropdownLocaleCollection.addItem({key:"es-es", label:"Espanol"});
	
	dropdownLocale = new DropdownElement();
	dropdownLocale.setListCollection(dropdownLocaleCollection);
	dropdownLocale.setSelectedIndex(0);
	
	//Add dropdown to CanvasManager
	canvasManager.addElement(dropdownLocale);
}








///////////////////////////////////////////////////////
//////////////////Tween////////////////////////////////
	
/**
 * @class Tween
 * 
 * Tween is a helper class that is used to interpolate values
 * across a given time span and is essentially just a calculator. 
 * It can be used for nearly any type of animation and supports
 * easing for acceleration and deceleration. 
 * 
 * If you're unsure about easing, a hint is that SineInOut is a kind of magic salt 
 * you can sprinkle on just about any linear animation that usually makes everything 
 * look smoother and less jarring without being obvious.
 * 
 * @constructor Tween 
 * Creates new Tween instance.
 */
function Tween()
{
	/**
	 * @member startVal Number
	 * Beginning value at the start time of the tween.
	 */
	this.startVal = 0;
	
	/**
	 * @member endVal Number
	 * Ending value at the end time of the tween duration.
	 */
	this.endVal = 0;
	
	/**
	 * @member duration Number
	 * Duration in milliseconds the tween will run.
	 */
	this.duration = 0;
	
	/**
	 * @member startTime Number
	 * Time in milliseconds that the tween should start as returned by Date.now().
	 */
	this.startTime = null;
	
	/**
	 * @member easingFunction Function
	 * Easing function to use when calculating the tween value. This is used
	 * to create acceleration/deceleration. Setting this to null will result
	 * in a linear tween. This is a function that accepts a fraction
	 * between 0 and 1 and returns a fraction between 0 and 1. The result is used
	 * to calculate the value based on progress and start/end values. There are several
	 * standard easing functions built in as static functions of Tween that you can set to this.
	 */
	this.easingFunction = null;
}
	
//Tween is base object, no inheritance.
Tween.prototype.constructor = Tween;


/**
 * @function getProgress
 * Gets the current progress of the tween based on the start time and the current time.
 * 
 * @param time Number
 * The current time as returned by Date.now().
 * 
 * @returns Number
 * Fraction between 0 and 1.
 */
Tween.prototype.getProgress = 
	function (time)
	{
		if (time >= this.startTime + this.duration)
			return 1;
		else if (time <= this.startTime)
			return 0;
		
		return (time - this.startTime) / this.duration;
	};
	
/**
 * @function getValue
 * Gets the current value based on the supplied time.
 * 
 * @param time Number
 * The current time as returned by Date.now().
 * 
 * @returns Number
 * A number between the start and end values (inclusive).
 */	
Tween.prototype.getValue = 
	function (time)
	{
		var progress = this.getProgress(time);
		
		if (progress == 1)
			return this.endVal;
		else if (progress == 0)
			return this.startVal;
	
		if (this.easingFunction != null)
			progress = this.easingFunction(progress);
		
		var range = Math.abs(this.endVal - this.startVal);
		
		if (this.startVal < this.endVal)
			return this.startVal + (range * progress);
		
		return this.startVal - (range * progress);
	};

//////Static//////////////////
	
/**
 * @function easeInQuad
 * @static
 * Use for quadratic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */	
Tween.easeInQuad = 
	function (fraction)
	{
		return fraction * fraction;
	};
	
/**
 * @function easeOutQuad
 * @static
 * Use for quadratic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeOutQuad = 
	function (fraction)
	{
		return 1 - Tween.easeInQuad(1 - fraction);
	};

/**
 * @function easeInOutQuad
 * @static
 * Use for quadratic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInOutQuad = 
	function (fraction)
	{
		if (fraction < 0.5)
			return Tween.easeInQuad(fraction * 2.0) / 2.0;
		
		return 1 - (Tween.easeInQuad((1 - fraction) * 2.0) / 2.0);  
	};
	
/**
 * @function easeInCubic
 * @static
 * Use for cubic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInCubic = 
	function (fraction)
	{
		return Math.pow(fraction, 3);
	};
	
/**
 * @function easeOutCubic
 * @static
 * Use for cubic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeOutCubic = 
	function (fraction)
	{
		return 1 - Tween.easeInCubic(1 - fraction);
	};

/**
 * @function easeInOutCubic
 * @static
 * Use for cubic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInOutCubic = 
	function (fraction)
	{
		if (fraction < 0.5)
			return Tween.easeInCubic(fraction * 2.0) / 2.0;
		
		return 1 - (Tween.easeInCubic((1 - fraction) * 2.0) / 2.0);  
	};	
	
/**
 * @function easeOutSine
 * @static
 * Use for sine easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeOutSine = 
	function (fraction)
	{
		return Math.sin(fraction * (Math.PI / 2.0));
	};

/**
 * @function easeInSine
 * @static
 * Use for sine easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInSine = 
	function (fraction)
	{
		return 1 - Tween.easeOutSine(1 - fraction);
	};	
	
/**
 * @function easeInOutSine
 * @static
 * Use for sine easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInOutSine = 
	function (fraction)
	{
		if (fraction < 0.5)
			return Tween.easeInSine(fraction * 2.0) / 2.0;
		
		return 1 - (Tween.easeInSine((1 - fraction) * 2.0) / 2.0);  
	};
	
	


///////////////////////////////////////////////////////////////////////////	
///////////////////////StyleProxy////////////////////////////////////////		
	
/**
 * @class StyleProxy
 * 
 * Internal class used to wrap CanvasElements to proxy styles to other elements. 
 * This should only be used by component developers. When a proxy is assigned
 * to an element, the proxy is included in its style chain lookup after assigned
 * styles (instance, and styleDefinition) but before default styles.   
 * 
 * @constructor StyleProxy 
 * Creates new StyleProxy instance.
 * 
 * @param styleProxyElement CanvasElement
 * The element to proxy styles from.
 * 
 * @param styleProxyMap Object
 * A map of styleNames to proxy. This Object is walked for members so
 * should always be created using a null prototype: Object.create(null) and
 * members created for each styleName to proxy (set to true). 
 * 
 * MyProxyMap = Object.create(null);
 * MyProxyMap.StyleName1 = true;
 * MyProxyMap.StyleName2 = true;
 * 
 * MyProxyMap._Arbitrary = true; 
 * 
 * _Arbitrary is a special flag that indicates all styles that are not defined / unknown 
 * by the element will also be proxied.
 * 
 * For example, a Button will proxy several styles to its skins such as "BackgroundColor" by including
 * them in the proxy map it passes to its skins. Styles like "Visible" however, are omitted from the proxy
 * map. Also, the button sets the _Arbitrary flag so any styles the Button is not aware of and does not define itself, 
 * are automatically proxied to the skin, without having to be added to the proxy map. 
 * This is so that skins may have custom styles and still be blanket set by setting the Button style itself. 
 */
function StyleProxy(styleProxyElement, styleProxyMap)
{
	this._proxyElement = styleProxyElement;
	this._proxyMap = styleProxyMap;
}

//No Inheritance
StyleProxy.prototype.constructor = StyleProxy;

	


//////////////////////////////////////////////////////////////////////
/////////////////////DispatcherEvent//////////////////////////////////

/**
 * @class DispatcherEvent
 * Base class for all events.
 * 
 * @constructor DispatcherEvent 
 * Creates new DispatcherEvent instance
 * 
 * @param type String
 * String representing the event type
 * 
 */
function DispatcherEvent(type)
{
	this._type = type;
	
	this._target = null;
	this._canceled = false;
}

//DispatcherEvent is base object, no inheritance.
DispatcherEvent.prototype.constructor = DispatcherEvent;


/**
 * @function getType
 * Gets the event type
 * 
 * @returns String
 * String representing the event type
 */
DispatcherEvent.prototype.getType = 
	function ()
	{
		return this._type;
	};

	
/**
 * @function getTarget
 * Gets event target
 * 
 * @returns Object
 * Object that originally dispatched the event 
 */	
DispatcherEvent.prototype.getTarget = 
	function ()
	{
		return this._target;
	};

/**
 * @function cancelEvent
 * Prevents processing of any subsequent event handlers
 */
DispatcherEvent.prototype.cancelEvent = 
	function ()
	{
		this._canceled = true;
	};	
	
/**
 * @function getIsCanceled
 * Checks if the event has been canceled
 * 
 * @returns boolean
 * Returns true if the event has been canceled, otherwise false
 */	
DispatcherEvent.prototype.getIsCanceled = 
	function ()
	{
		return this._canceled;
	};
	
/**
 * @function clone
 * Duplicates an instance of an Event or Event subclass. 
 * The event dispatcher calls this when dispatching or re-dispatching events to multiple targets. 
 * When creating a custom event class, you should override this and call the base class's clone() 
 * then copy the new event properties to the cloned instance.
 * 
 * @returns DispatcherEvent
 * A new event object instance identical to the cloned instance.
 */	
DispatcherEvent.prototype.clone = 
	function ()
	{
		var clonedEvent = this._cloneInstance();
		
		clonedEvent._target = this._target;
		clonedEvent._canceled = this._canceled;
		
		return clonedEvent;
	};
	
/**
 * @function _cloneInstance
 * Calls and returns the constructor() of the appropriate event subclass when cloning an event. 
 * When creating a custom event class, you should override this and return the appropriate event subclass type.
 * 
 * @returns DispatcherEvent
 * A new event instance of the same type being cloned.
 */	
DispatcherEvent.prototype._cloneInstance = 
	function ()
	{
		return new DispatcherEvent(this._type);
	};	
	
	


/**
 * @depends DispatcherEvent.js
 */

//////////////////////////////////////////////////////////////////////
/////////////////////StyleChangedEvent////////////////////////////////	
	
/**
 * @class StyleChangedEvent
 * @inherits DispatcherEvent
 * 
 * Event that is dispatched when a style is changed of type "stylechanged". 
 * This is typically an internal event that the system uses to monitor 
 * style changes to Elements, StyleDefnitions, or any style-able objects.
 * 
 * 
 * @constructor StyleChangedEvent 
 * Creates new StyleChangedEvent instance.
 * 
 * @param styleName String
 * String representing style type that was updated
 */
function StyleChangedEvent(styleName)
{
	StyleChangedEvent.base.prototype.constructor.call(this, "stylechanged");
	
	this._styleName = styleName;
}	
	
//Inherit from DispatcherEvent
StyleChangedEvent.prototype = Object.create(DispatcherEvent.prototype);
StyleChangedEvent.prototype.constructor = StyleChangedEvent;
StyleChangedEvent.base = DispatcherEvent;

/**
 * @function getStyleName
 * Gets the style name of the style which has changed
 * 
 * @returns String
 * String representing the style that has changed
 */
StyleChangedEvent.prototype.getStyleName = 
	function ()
	{
		return this._styleName;
	};
	
//@override
StyleChangedEvent.prototype.clone =
	function ()
	{
		var clonedEvent = StyleChangedEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@override
StyleChangedEvent.prototype._cloneInstance = 
	function ()
	{
		return new StyleChangedEvent(this._styleName, this._oldValue, this._newValue);
	};
	
	


/**
 * @depends DispatcherEvent.js
 */

//////////////////////////////////////////////////////////////////////
/////////////////////ElementEvent/////////////////////////////////////	

/**
 * @class ElementEvent
 * @inherits DispatcherEvent
 * 
 * Base class for CanvasElement UI events. ElementEvents support
 * capture and bubbling phase when dispatched from CanvasElement(s). A bubbling event
 * invokes capture listeners from the root parent to the target child element and then
 * bubbling (normal) listeners from the target element to the root parent. 
 * Bubbling events are used to detect events dispatched on child elements.
 * Capture events are typically not needed but sometimes useful if you wish to 
 * detect an event before the target has a chance to process it.
 * 
 * For Example, when a Button dispatches a ElementMouseEvent.
 * The event propagates from the root parent (CanvasManager) down the display chain
 * from child to child dispatching capture events to any parents with registered listeners. 
 * Once reaching the target element (Button) the event then propagates back up the display chain 
 * from parent to parent dispatching bubbling events.  
 * You may cancel the event at any time to stop the event flow.
 * 
 * 
 * @constructor ElementEvent 
 * Creates new ElementEvent instance.
 * 
 * @param type String
 * String representing the event type
 * 
 * @param bubbles boolean
 * True if the ElementEvent should be dispatch capture and bubbling events.
 */

function ElementEvent(type, bubbles)
{
	ElementEvent.base.prototype.constructor.call(this, type);
	
	this._currentTarget = null;
	this._bubbles = bubbles;
	this._phase = null;  // "capture" || "bubble"
	this._defaultPrevented = false;
}

//Inherit from DispatcherEvent
ElementEvent.prototype = Object.create(DispatcherEvent.prototype);
ElementEvent.prototype.constructor = ElementEvent;
ElementEvent.base = DispatcherEvent;

/**
 * @function getCurrentTarget
 * 
 * Gets the element that is currently dispatching the event. Note that is
 * is not always the same as getTarget() which returns the element that
 * originally dispatched the event. 
 * 
 * For Example, when a click listener is registered to an element, and a child of that
 * element dispatches a click (like a Button), the target will be the child (Button) and the 
 * current target will be the element that registered the click listener.
 * 
 * 
 * @returns CanvasElement
 * The element that is currently dispatching the event.
 */
ElementEvent.prototype.getCurrentTarget = 
	function ()
	{
		return this._currentTarget;
	};

/**
 * @function getPhase
 * 
 * Gets the current phase of the event. ("bubbling" or "capture")
 * 
 * @returns String
 * String representing the event's current phase when dispatched ("bubbling" or "capture")
 */
ElementEvent.prototype.getPhase = 
	function ()
	{
		return this._phase;
	};
	
/**
 * @function preventDefault
 * 
 * Prevents the event's typical action from being taken. This is also sometimes used to "consume"
 * the event so it is only processed once. Such as preventing a mousewheel event from scrolling multiple
 * parent/child views at once. A scroll-able child will call preventDefault() to "consume" the event
 * and prevent any parents from also scrolling.
 */	
ElementEvent.prototype.preventDefault = 
	function ()
	{
		this._defaultPrevented = true;
	};

/**
 * @function getDefaultPrevented
 * 
 * Gets the default prevented state of the event.
 * 
 * @returns boolean
 * Returns true if preventDefault() has been called, false otherwise.
 */	
ElementEvent.prototype.getDefaultPrevented = 
	function ()
	{
		return this._defaultPrevented;
	};
	
//@Override	
ElementEvent.prototype.clone = 
	function ()
	{
		var clonedEvent = ElementEvent.base.prototype.clone.call(this);
		
		clonedEvent._currentTarget = this._currentTarget;
		clonedEvent._phase = this._phase;
		clonedEvent._defaultPrevented = this._defaultPrevented;
		clonedEvent._bubbles = this._bubbles; //Need to set, some subclasses always pass true in constructor.
		
		return clonedEvent;
	};
	
//@Override	
ElementEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementEvent(this._type, this._bubbles);
	};


/**
 * @depends ElementEvent.js
 */

//////////////////////////////////////////////////////////////////////////	
/////////////////////ElementMouseEvent////////////////////////////////////

/**
 * @class ElementMouseEvent
 * @inherits ElementEvent
 * 
 * Event class used to represent mouse events of type "mousedown", "mouseup" or "click". 
 * Every "mousedown" event is always paired with a "mouseup" event. Note that the mouse is
 * not necessarily still over the same object when "mouseup" is dispatched. The user may have
 * pressed and then moved the mouse before releasing. A "click" event however, is only dispatched
 * if the mouse is still over the "mousedown" object when the mouse is released.
 * 
 * @constructor ElementMouseEvent 
 * Creates new ElementMouseEvent instance.
 * 
 * @param type String
 * String representing the event type ("mousedown", "mouseup", or "click")
 * 
 * @param x int
 * The X coordinate of the mouse relative to the object dispatching the mouse event.
 * 
 * @param y int
 * The Y coordinate of the mouse relative to the object dispatching the mouse event.
 */
function ElementMouseEvent(type, x, y)
{
	ElementMouseEvent.base.prototype.constructor.call(this, type, true);
	
	this._x = x; 
	this._y = y;
}

//Inherit from ElementEvent
ElementMouseEvent.prototype = Object.create(ElementEvent.prototype);
ElementMouseEvent.prototype.constructor = ElementMouseEvent;
ElementMouseEvent.base = ElementEvent;

/**
 * @function getX
 * 
 * Gets the X coordinate of the mouse relative to the object dispatching the mouse event. 
 * 
 * @returns int
 * The X coordinate of the mouse relative to the object dispatching the mouse event. 
 */
ElementMouseEvent.prototype.getX = 
	function()
	{
		return this._x;
	};
	
/**
 * @function getY
 * 
 * Gets the Y coordinate of the mouse relative to the object dispatching the mouse event. 
 * 
 * @returns int
 * The Y coordinate of the mouse relative to the object dispatching the mouse event. 
 */	
ElementMouseEvent.prototype.getY = 
	function()
	{
		return this._y;
	};
	
//@Override
ElementMouseEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementMouseEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
ElementMouseEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementMouseEvent(this._type, this._x, this._y);
	};
	


/**
 * @depends ElementMouseEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementMouseWheelEvent///////////////////////////////

/**
 * @class ElementMouseWheelEvent
 * @inherits ElementMouseEvent
 * 
 * Event class used to represent mouse wheel events of type "wheel". 
 * 
 * 
 * @constructor ElementMouseWheelEvent 
 * Creates new ElementMouseWheelEvent instance.
 * 
 * @param x int
 * The X coordinate of the mouse relative to the object dispatching the mouse event.
 * 
 * @param y int
 * The Y coordinate of the mouse relative to the object dispatching the mouse event.
 * 
 * @param deltaX int
 * The change of the X position of the the mouse wheel. (Currently -1, 0, or +1)
 * 
 * @param deltaY int
 * The change of the Y position of the the mouse wheel. (Currently -1, 0, or +1)
 */
function ElementMouseWheelEvent(x, y, deltaX, deltaY)
{
	ElementMouseWheelEvent.base.prototype.constructor.call(this, "wheel", x, y);

	this._deltaX = deltaX;
	this._deltaY = deltaY;
}

//Inherit from ElementMouseEvent
ElementMouseWheelEvent.prototype = Object.create(ElementMouseEvent.prototype);
ElementMouseWheelEvent.prototype.constructor = ElementMouseWheelEvent;
ElementMouseWheelEvent.base = ElementMouseEvent;	

/**
 * @function getDeltaX
 * 
 * Gets the change of the X position of the mouse wheel. The system normalizes this
 * across browsers to values -1, 0, or +1. 
 * 
 * @returns int
 * The change of the X position of the mouse wheel.
 */
ElementMouseWheelEvent.prototype.getDeltaX = 
	function()
	{
		return this._deltaX;
	};
	
/**
 * @function getDeltaY
 * 
 * Gets the change of the Y position of the mouse wheel. The system normalizes this
 * across browsers to values -1, 0, or +1. 
 * 
 * @returns int
 * The change of the Y position of the mouse wheel.
 */	
ElementMouseWheelEvent.prototype.getDeltaY = 
	function()
	{
		return this._deltaY;
	};
	
//@Override
ElementMouseWheelEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementMouseWheelEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
ElementMouseWheelEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementMouseWheelEvent(this._x, this._y, this._deltaX, this._deltaY);
	};
	


/**
 * @depends ElementEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementListItemClickEvent////////////////////////////

/**
 * @class ElementListItemClickEvent
 * @inherits ElementEvent
 * 
 * Event class dispatched when a DataRenderer is clicked of type "listitemclick". 
 * 
 * 
 * @constructor ElementListItemClickEvent 
 * Creates new ElementListItemClickEvent instance.
 * 
 * @param item Object
 * The collection item associated with the DataRenderer that was clicked.
 * 
 * @param index int
 * The collection index associated with the DataRenderer that was clicked.
 */
function ElementListItemClickEvent(item, index)
{
	ElementListItemClickEvent.base.prototype.constructor.call(this, "listitemclick", false);
	
	this._item = item;
	this._index = index;
}

//Inherit from ElementEvent
ElementListItemClickEvent.prototype = Object.create(ElementEvent.prototype);
ElementListItemClickEvent.prototype.constructor = ElementListItemClickEvent;
ElementListItemClickEvent.base = ElementEvent;	

/**
 * @function getItem
 * Gets the collection item associated with the DataRenderer that was clicked.
 * 
 * @returns Object
 * The collection item associated with the DataRenderer that was clicked.
 */
ElementListItemClickEvent.prototype.getItem = 
	function()
	{
		return this._item;
	};

/**
 * @function getIndex
 * Gets the collection index associated with the DataRenderer that was clicked.
 * 
 * @returns int
 * The collection index associated with the DataRenderer that was clicked.
 */	
ElementListItemClickEvent.prototype.getIndex = 
	function()
	{
		return this._index;
	};

//@Override
ElementListItemClickEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementListItemClickEvent.base.prototype.clone.call(this);

		//No additional property copies (handled by constructor)

		return clonedEvent;
};

//@Override
ElementListItemClickEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementListItemClickEvent(this._item, this._index);
	};	


/**
 * @depends ElementEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementKeyboardEvent/////////////////////////////////

/**
 * @class ElementKeyboardEvent
 * @inherits ElementEvent
 * 
 * Event class used to represent keyboard events of type "keydown" or "keyup". 
 * Note that unlike mouse events, every "keydown" is not necessarily paired with a "keyup".
 * When a key is held down, "keydown" events will repeatedly be dispatched until the key
 * is released which will then dispatch a "keyup" event.
 * 
 * @constructor ElementKeyboardEvent 
 * Creates new ElementKeyboardEvent instance.
 * 
 * @param type String
 * String representing the event type ("keydown" or "keyup")
 * 
 * @param key String
 * Printable representation of the key. If the key is not printable such as
 * Shift or Return this should be an emtpy string "".
 * 
 * @param keyCode int
 * The keycode of the key that caused the event.
 * 
 * @param ctrl boolean
 * True if the ctrl key is pressed, false otherwise.
 * 
 * @param alt boolean
 * True if the alt key is pressed, false otherwise.
 * 
 * @param shift boolean
 * True if the shift key is pressed, false otherwise.
 * 
 * @param meta boolean
 * True if the meta key (such as windows key) is pressed, false otherwise.
 */
function ElementKeyboardEvent(type, key, keyCode, ctrl, alt, shift, meta)
{
	ElementKeyboardEvent.base.prototype.constructor.call(this, type, true);
	
	//IE key names are different... normalize
	if (key == "Spacebar")
		key = " ";
	else if (key == "Left")
		key = "ArrowLeft";
	else if (key == "Right")
		key = "ArrowRight";		
	else if (key == "Del")
		key = "Delete";
	
	this._key = key;
	this._keyCode = keyCode;
	
	this._ctrl = ctrl;
	this._alt = alt;
	this._shift = shift;
	this._meta = meta;
}

//Inherit from ElementEvent
ElementKeyboardEvent.prototype = Object.create(ElementEvent.prototype);
ElementKeyboardEvent.prototype.constructor = ElementKeyboardEvent;
ElementKeyboardEvent.base = ElementEvent;	

/**
 * @function getKey
 * 
 * Gets the printable version of the key which caused the event. 
 * 
 * @returns String
 * The printable version of the key which caused the event. Empty string "" if the
 * key is not printable.
 */
ElementKeyboardEvent.prototype.getKey = 
	function ()
	{
		return this._key;
	};
	
/**
 * @function getKeyCode
 * 
 * Gets the key code of the key which caused the event. 
 * 
 * @returns int
 * The keycode of the key which caused the event.
 */	
ElementKeyboardEvent.prototype.getKeyCode = 
	function ()
	{
		return this._keyCode;
	};	

/**
 * @function getCtrl
 * 
 * Gets the state of the ctrl key. 
 * 
 * @returns boolean
 * True if the ctrl key is pressed, otherwise false.
 */	
ElementKeyboardEvent.prototype.getCtrl = 
	function ()
	{
		return this._ctrl;
	};		

/**
 * @function getAlt
 * 
 * Gets the state of the alt key. 
 * 
 * @returns boolean
 * True if the alt key is pressed, otherwise false.
 */		
ElementKeyboardEvent.prototype.getAlt = 
	function ()
	{
		return this._alt;
	};

/**
 * @function getShift
 * 
 * Gets the state of the shift key. 
 * 
 * @returns boolean
 * True if the shift key is pressed, otherwise false.
 */	
ElementKeyboardEvent.prototype.getShift = 
	function ()
	{
		return this._shift;
	};	
	
/**
 * @function getMeta
 * 
 * Gets the state of the meta key (such as the windows key). 
 * 
 * @returns boolean
 * True if the meta key is pressed, otherwise false.
 */		
ElementKeyboardEvent.prototype.getMeta = 
	function ()
	{
		return this._meta;
	};		
	
//@Override
ElementKeyboardEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementKeyboardEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
ElementKeyboardEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementKeyboardEvent(this._type, 
				this._key, this._keyCode, 
				this._ctrl, this._alt, this._shift, this._meta);
	};	
	


/**
 * @depends ElementListItemClickEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementGridItemClickEvent////////////////////////////

/**
 * @class ElementGridItemClickEvent
 * @inherits ElementListItemClickEvent
 * 
 * Event class dispatched when a DataGrid DataRenderer is clicked of type "listitemclick". 
 * 
 * 
 * @constructor ElementGridItemClickEvent 
 * Creates new ElementGridItemClickEvent instance.
 * 
 * @param item Object
 * The collection item associated with the DataRenderer that was clicked.
 * 
 * @param index int
 * The collection index associated with the DataRenderer that was clicked.
 * 
 * @param columnIndex int
 * The column index associated with the DataRenderer that was clicked.
 */
function ElementGridItemClickEvent(item, index, columnIndex)
{
	ElementGridItemClickEvent.base.prototype.constructor.call(this, item, index);
	
	this._columnIndex = columnIndex;
}

//Inherit from ElementListItemClickEvent
ElementGridItemClickEvent.prototype = Object.create(ElementListItemClickEvent.prototype);
ElementGridItemClickEvent.prototype.constructor = ElementGridItemClickEvent;
ElementGridItemClickEvent.base = ElementListItemClickEvent;	

/**
 * @function getColumnIndex
 * Gets the column index that dispatched the event.
 * 
 * @returns int
 * Column index.
 */
ElementGridItemClickEvent.prototype.getColumnIndex = 
	function()
	{
		return this._columnIndex;
	};

//@Override
ElementGridItemClickEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementGridItemClickEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};

//@Override
ElementGridItemClickEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementListItemClickEvent(this._item, this._index, this._columnIndex);
	};	


/**
 * @depends DispatcherEvent.js
 */

///////////////////////////////////////////////////////////////////
//////////////////CollectionChangedEvent///////////////////////////	
	
/**
 * @class CollectionChangedEvent
 * @inherits DispatcherEvent
 * 
 * Event that is dispatched when a data collection is changed of type "collectionchanged". 
 * This is typically an internal event that the data driven containers use to monitor 
 * changes to their data collections.
 * 
 * 
 * @constructor CollectionChangedEvent 
 * Creates new CollectionChangedEvent instance.
 * 
 * @param kind String
 * String representing type of change that occurred to the collection.
 * Allowable values are "add", "remove", "update", and "reset".
 * 
 * @param index int
 * Index position the change occurred (or -1 if kind is "reset").
 */
function CollectionChangedEvent(kind, index)
{
	CollectionChangedEvent.base.prototype.constructor.call(this, "collectionchanged");
	
	this._kind = kind;
	this._index = index;
}	
	
//Inherit from DispatcherEvent
CollectionChangedEvent.prototype = Object.create(DispatcherEvent.prototype);
CollectionChangedEvent.prototype.constructor = CollectionChangedEvent;
CollectionChangedEvent.base = DispatcherEvent;

/**
 * @function getKind
 * Gets the kind of the collection event. Possible types are "add", "remove", "update", and "reset".
 * 
 * @returns String
 * The kind of the collection event.
 */
CollectionChangedEvent.prototype.getKind = 
	function ()
	{
		return this._kind;
	};
	
/**
 * @function getIndex
 * Gets the index of the data collection that the change occurred.
 * 
 * @returns int
 * The index of the data collection that the change occurred.
 */	
CollectionChangedEvent.prototype.getIndex = 
	function ()
	{
		return this._index;
	};

//@Override
CollectionChangedEvent.prototype.clone =
	function ()
	{
		var clonedEvent = CollectionChangedEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
CollectionChangedEvent.prototype._cloneInstance = 
	function ()
	{
		return new CollectionChangedEvent(this._kind, this._index);
	};
	
	


/**
 * @depends DispatcherEvent.js
 */

//////////////////////////////////////////////////////////////////////
/////////////////////AddedRemovedEvent////////////////////////////////		
	
/**
 * @class AddedRemovedEvent
 * @inherits DispatcherEvent
 * 
 * Event that is dispatched when a CanvasElement is added or removed from
 * a CanvasManager and can be of type "added" or "removed". This is used to detect
 * when an Element is added or removed from the display and to create / destroy or 
 * associate / dissociate resources. For example, CanvasElement uses these events
 * to add and remove event listeners to its associated StyleDefinitions which are 
 * external resources and would cause memory leaks if not cleaned up. 
 * 
 * 
 * @constructor AddedRemovedEvent 
 * Creates new AddedRemovedEvent instance.
 * 
 * @param type String
 * String representing the event type ("added" or "removed")
 * 
 * @param manager CanvasManager
 * The CanvasManager instance that the element is being added or removed.
 */
function AddedRemovedEvent(type, manager)
{
	AddedRemovedEvent.base.prototype.constructor.call(this, type);
	
	this._manager = manager;
}	
	
//Inherit from DispatcherEvent
AddedRemovedEvent.prototype = Object.create(DispatcherEvent.prototype);
AddedRemovedEvent.prototype.constructor = AddedRemovedEvent;
AddedRemovedEvent.base = DispatcherEvent;

/**
 * @function getManager
 * Gets the CanvasManager instance that the Element has been added or removed. 
 * Note that when an element is removed, the Element is no longer associated with the CanvasManager
 * so you must use this method to get the appropriate CanvasManager reference.
 * 
 * @returns CanvasManager
 * The CanvasManager instance the element is now associated with when added, or no longer associated with when removed.
 */
AddedRemovedEvent.prototype.getManager = 
	function ()
	{
		return this._manager;
	};
	
//@Override
AddedRemovedEvent.prototype.clone =
	function ()
	{
		var clonedEvent = AddedRemovedEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
AddedRemovedEvent.prototype._cloneInstance = 
	function ()
	{
		return new AddedRemovedEvent(this._type, this._manager);
	};	
	
	


//////////////////////////////////////////////////////////////////////
/////////////////////EventDispatcher//////////////////////////////////
	
/**
 * @class EventDispatcher
 * Base class for all objects that dispatch events.
 * 
 * @constructor EventDispatcher 
 * Creates new EventDispatcher instance.
 */
function EventDispatcher()
{
	this._eventListeners = Object.create(null); //Map of arrays by event name.
}
	
//EventDispatcher is base object, no inheritance.
EventDispatcher.prototype.constructor = EventDispatcher;

///////////EventDispatcher Public Functions///////////////////////////

/**
 * @function addEventListener
 * Registers an event lister function to be called when an event occurs.
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function to be called when the event occurs.
 */
EventDispatcher.prototype.addEventListener = 
	function (type, callback)
	{
		if (this._eventListeners[type] == null)
			this._eventListeners[type] = [];
		
		this._eventListeners[type].push(callback);
	};

/**
 * @function removeEventListener
 * Removes a callback from the EventDispatcher
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be removed.
 * 
 * @returns boolean
 * Returns true if the callback was successfully removed, otherwise false
 * such as if the function callback was not previously registered.
 */	
EventDispatcher.prototype.removeEventListener = 
	function (type, callback)
	{
		if (!(type in this._eventListeners))
			return false;
	
		for (var i = 0; i < this._eventListeners[type].length; i++)
		{
			if (this._eventListeners[type][i] == callback)
			{
				this._eventListeners[type].splice(i, 1);
				return true;
			}
		}
		
		return false;
	};

/**
 * @function hasEventListener
 * Checks if an event listener has been registered with this EventDispatcher
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be called when the event occurs. This may be null to check
 * if the EventDispatcher has any events registered for the provided type.
 * 
 * @returns boolean
 * Returns true if the EventDispatcher has the provided callback registered for the 
 * provided type, or any callback for the provided type if the callback parameter is null.
 * Otherwise, returns false.
 */	
EventDispatcher.prototype.hasEventListener = 
	function (type, callback)
	{
		if (!(type in this._eventListeners))
			return false;
	
		if (callback == null)
		{
			if (this._eventListeners[type].length > 0)
				return true;
			
			return false;
		}
		
		
		for (var i = 0; i < this._eventListeners[type].length; i++)
		{
			if (this._eventListeners[type][i] == callback)
				return true;
		}
		
		return false;
	};

///////////EventDispatcher Internal Functions///////////////////////////	
	
/**
 * @function _dispatchEvent
 * Dispatches an event to be processed by registered event listeners. The Event's target is the
 * EventDispatcher which called _dispatchEvent. The Event will be cloned prior to passing to callback functions
 * to ensure the callback cannot modify the Event data or properties. You can check if the event was canceled
 * by calling the Event's getIsCanceled after dispatching it. Re-dispatching the same event will re-set its canceled state to false.
 * 
 * @param event DispatcherEvent
 * The DispatcherEvent class or subclass to be dispatched. 
 */	
EventDispatcher.prototype._dispatchEvent = 
	function (event)
	{
		event._canceled = false;
	
		if (event._type in this._eventListeners && this._eventListeners[event._type].length > 0)
		{
			//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
			//we dont want to miss an event, or inconsistently dispatch newly added events.
			var listeners = this._eventListeners[event._type].slice();
			
			//TODO: Sort by priority (no priority available yet).
			
			var cloneEvent = null;
			for (var i = 0; i < listeners.length; i++)
			{
				//Clone the event so the handler can't fudge our event data.
				cloneEvent = event.clone(); 
				cloneEvent._target = this;				

				listeners[i](cloneEvent);
				
				if (cloneEvent._canceled == true)
				{
					event._canceled = true;
					return;
				}
			}
		}
	};	
	
	
	


/**
 * @depends EventDispatcher.js
 */

///////////////////////////////////////////////////////////////////
///////////////////////ToggleButtonGroup///////////////////////////

/**
 * @class ToggleButtonGroup
 * @inherits EventDispatcher
 * 
 * Convenience helper class for grouping ToggleButtons or subclasses.
 * The ToggleButtonGroup can be assigned to set of toggle buttons
 * and will only allow a single ToggleButton to be selected at a time.
 * When a ToggleButton changes state, the ToggleButtonGroup will dispatch
 * a changed event. Use this for functionality like RadioButtons and Tabs.
 * 
 * @constructor ToggleButtonGroup 
 * Creates new ToggleButtonGroup instance.
 */
function ToggleButtonGroup()
{
	ToggleButtonGroup.base.prototype.constructor.call(this);
	
	this._selectedButton = null;
	
	this._toggleButtons = [];
	
	var _self = this;
	
	this._toggleButtonChangedInstance =
		function (event)
		{
			_self._toggleButtonChanged(event);
		};
}

//Inherit from EventDispatcher
ToggleButtonGroup.prototype = Object.create(EventDispatcher.prototype);
ToggleButtonGroup.prototype.constructor = ToggleButtonGroup;
ToggleButtonGroup.base = EventDispatcher;

////////////Events/////////////////////////////////////

/**
 * @event changed DispatcherEvent
 * Dispatched when the selected ToggleButton is changed due to user interaction.
 */

//////////////Public Functions/////////////////////////////////////////

/**
 * @function addButton
 * Adds a ToggleButton or subclass to be managed by ToggleButtonGroup.
 * 
 * @param toggleButton ToggleButtonElement
 * ToggleButton or subclass to be managed by ToggleButtonGroup.
 * 
 * @returns boolean
 * True when successfully added, false if is not a instance of ToggleButton or already added.
 */	
ToggleButtonGroup.prototype.addButton = 
	function (toggleButton)
	{
		if (toggleButton == null || 
			toggleButton instanceof ToggleButtonElement == false ||
			this._toggleButtons.indexOf(toggleButton) > -1)
			return false;
		
		this._toggleButtons.push(toggleButton);
		toggleButton.addEventListener("changed", this._toggleButtonChangedInstance);
		
		return true;
	};

/**
 * @function removeButton
 * Removes a ToggleButton or subclass currently being managed by ToggleButtonGroup
 * 
 * @param toggleButton ToggleButtonElement
 * ToggleButton or subclass to be removed from ToggleButtonGroup.
 * 
 * @returns boolean
 * True when successfully removed, false if the toggle button is not currently managed by ToggleButtonGroup.
 */		
ToggleButtonGroup.prototype.removeButton = 
	function (toggleButton)
	{
		var index = this._toggleButtons.indexOf(toggleButton);
	
		if (index == -1)
			return false;
		
		this._toggleButtons.splice(index, 1);
		toggleButton.removeEventListener("changed", this._toggleButtonChangedInstance);
	};	

/**
 * @function clearButtons
 * Removes all ToggleButtons currently managed by ToggleButtonGroup.
 */		
ToggleButtonGroup.prototype.clearButtons = 
	function ()
	{
		for (var i = 0; i < this._toggleButtons.length; i++)
			this._toggleButtons[i].removeEventListener("changed", this._toggleButtonChangedInstance);
		
		this._toggleButtons = [];
	};
	
/**
 * @function setSelectedButton
 * Sets the ToggleButton to be selected.
 * 
 * @param toggleButton ToggleButtonElement
 * ToggleButton or subclass to be selected. May be set to null.
 */	
ToggleButtonGroup.prototype.setSelectedButton = 
	function (toggleButton)
	{
		if (this._selectedButton = toggleButton)
			this._selectedButton.setSelected(true);
		else if (toggleButton == null || this._toggleButtons.indexOf(toggleButton) > -1)
		{
			this._selectedButton = toggleButton;
			
			if (this._selectedButton != null)
				this._selectedButton.setSelected(true);
			
			for (var i = 0; i < this._toggleButtons.length; i++)
			{
				if (this._toggleButtons[i] != toggleButton)
					this._toggleButtons[i].setSelected(false);
			}
		}
	};
	
/**
 * @function getSelectedButton
 * Gets the selected ToggleButton.
 * 
 * @returns ToggleButtonElement
 * ToggleButton or subclass currently selected. May be null.
 */		
ToggleButtonGroup.prototype.getSelectedButton = 
	function ()
	{
		return this._selectedButton;
	};
	
////////////////////Internal/////////////////////////
	
	
/**
 * @function _toggleButtonChanged
 * Event handler for managed ToggleButton's "changed" event. 
 * Updates toggle button selected states and dispatches "changed" event.
 * 
 * @param event ElementEvent
 * ElementEvent to be processed.
 */		
ToggleButtonGroup.prototype._toggleButtonChanged = 
	function (elementEvent)
	{
		var toggleButton = elementEvent.getTarget();
		
		if (toggleButton.getSelected() == true)
			this._selectedButton = toggleButton;
		else
			this._selectedButton = null;
		
		for (var i = 0; i < this._toggleButtons.length; i++)
		{
			if (this._toggleButtons[i] != toggleButton)
				this._toggleButtons[i].setSelected(false);
		}
		
		//Dispatch changed event.
		if (this.hasEventListener("changed", null) == true)
			this._dispatchEvent(new DispatcherEvent("changed", false));
	};
	
	


/**
 * @depends EventDispatcher.js
 */

///////////////////////////////////////////////////////////////////
///////////////////////StyleDefinition/////////////////////////////	

/**
 * @class StyleDefinition
 * @inherits EventDispatcher
 * 
 * Stores a key value data set of style values by name.
 * 
 * 
 * @constructor StyleDefinition 
 * Creates new StyleDefinition instance.
 */
function StyleDefinition()
{
	StyleDefinition.base.prototype.constructor.call(this);

	this._styleMap = Object.create(null);
}

//Inherit from EventDispatcher
StyleDefinition.prototype = Object.create(EventDispatcher.prototype);
StyleDefinition.prototype.constructor = StyleDefinition;
StyleDefinition.base = EventDispatcher;

/**
 * @event stylechanged StyleChangedEvent
 * 
 * Dispatched when a style is added, cleared, or changed.
 */


/**
 * @function getStyle
 * Gets the stored style value for this object.
 * 
 * @param styleName String
 * String representing the style to return.
 * 
 * @returns Any
 * Returns the associated style value if found, otherwise undefined.
 */	
StyleDefinition.prototype.getStyle = 
	function (styleName)
	{
		if (styleName in this._styleMap)
			return this._styleMap[styleName];
		
		return undefined;
	};

/**
 * @function setStyle
 * Sets the stored style value for this object.
 * 
 * @param styleName String
 * String representing the style to set.
 * 
 * @param value Any
 * The value to store. This may be null or undefined. 
 * Note that a null style is different from an absent (undefined) style. A null style
 * will terminate a style chain lookup and return null value. An undefined style will cause
 * the system to look further up the style chain for a value. Passing undefined is the
 * same as calling clearStyle().
 */
StyleDefinition.prototype.setStyle = 
	function (styleName, value)
	{
		var oldStyle = undefined;
		if (styleName in this._styleMap)
			oldStyle = this._styleMap[styleName];
		
		//No change
		if (oldStyle === value)
			return;
	
		if (this.hasEventListener("stylechanged", null) == true)
		{
			oldStyle = this.getStyle(styleName);
			
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
			
			var newStyle = this.getStyle(styleName);
			
			//Strict equality required (undefined !== null)
			if (newStyle !== oldStyle)
				this._dispatchEvent(new StyleChangedEvent(styleName));
		}
		else
		{
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
		}
	};

/**
 * @function clearStyle
 * Clears style data from this object. This is the same 
 * passing undefined to setStyle().
 * 
 * @param styleName String
 * String representing the style to clear.
 */		
StyleDefinition.prototype.clearStyle = 
	function (styleName)
	{
		this.setStyle(styleName, undefined);
	};
	
	


/**
 * @depends StyleDefinition.js
 */

///////////////////////////////////////////////////////////////////////////	
/////////////////////////StyleData/////////////////////////////////////////

/**
 * @class StyleData
 * 
 * Storage class for style data.
 * 
 * 
 * @constructor StyleData 
 * Creates new StyleData instance.
 * 
 * @param styleName String
 * String representing style name for associated data.
 */

function StyleData(styleName)
{
	/**
	 * @member styleName string
	 * Name of associated style
	 */
	this.styleName = styleName;
	
	/**
	 * @member value Any
	 * Value of associated style 
	 */
	this.value = undefined;
	
	/**
	 * @member priority Array
	 * Array of integers representing the position 
	 * in the style chain the style was found.
	 */
	this.priority = [];
}

//StyleData is base object, no inheritance.
StyleData.prototype.constructor = StyleData;

/**
 * @function equals
 * 
 * Checks if two instances of StyleData contain the same values.
 * 
 * @param equalToStyleData StyleData
 * StyleData instance to compare.
 * 
 * @returns boolean
 * Returns true when both instances contain the same values.
 */
StyleData.prototype.equals = 
	function (equalToStyleData)
	{
		if (equalToStyleData.styleName != this.styleName || 
			equalToStyleData.priority.length != this.priority.length ||
			equalToStyleData.value !== this.value)	//Strict equality required (undefined !== null)
		{
			return false;
		}
			
		for (var i = 0; i < this.priority.length; i++)
		{
			if (equalToStyleData.priority[i] != this.priority[i])
				return false;
		}
		
		return true;
	};
	
/**
 * @function comparePriority
 * Compares the style priority (position in style chain) of two StyleData instances.
 * 
 * @param compareToStyleData StyleData
 * StyleData instance to compare.
 * 
 * @returns int
 * Returns -1 if this instance is lower priority than compareToStyleData.
 * Returns +1 if this instance is higher priority than compareToStyleData.
 * Returns 0 if this instance is the same priority as compareToStyleData.
 */	
StyleData.prototype.comparePriority = 
	function (compareToStyleData)
	{
		var minLength = Math.min(this.priority.length, compareToStyleData.priority.length);
		
		for (var i = 0; i < minLength; i++)
		{
			if (this.priority[i] < compareToStyleData.priority[i])
				return +1;
			
			if (this.priority[i] > compareToStyleData.priority[i])
				return -1;
		}

		//Dont worry about different lengths... 
		//Anything with an equal priority will be the same length.
		return 0;
	};
	

	
/**
 * @function clone
 * Duplicates an instance of StyleData (deep copy). 
 * 
 * @returns StyleData
 * A new StyleData instance identical to the cloned instance.
 */	
	StyleData.prototype.clone = 
	function ()
	{
		var cloned = new StyleData(this.styleName);
		cloned.value = this.value;
		cloned.priority = this.priority.slice();
		
		return cloned;
	};	
	
	

///////////////////////////////////////////////////////////////////////////	
///////////////////////StyleableBase///////////////////////////////////////
	
/**
 * @class StyleableBase
 * @inherits StyleDefinition
 * 
 * Internal abstract base class for classes that define styles. 
 * 
 * StylableBase defines no styles itself, but allows subclasses to define them by adding  
 * and populating static Object _StyleTypes and StyleDefinition StyleDefault on the class.
 * See example.
 * 
 * inheritable: Only applicable for CanvasElements.
 * If no explicit style is set (instance, style definition, or proxy) look up the
 * parent chain for the first element supporting the style with inheritable.
 * If no style is found up the parent chain, use the element's default style.
 * 
 * Subclasses can add new styles and override the style types or defaults of their base
 * classes by creating their own _StyleTypes and StyleDefault objects.
 * 
 * Example:
 * 
 * StylableBaseSubclass._StyleTypes = Object.create(null);
 * StylableBaseSubclass._StyleTypes.Visible = 				{inheritable:false};		
 * StylableBaseSubclass._StyleTypes.BorderType = 			{inheritable:false};		
 * StylableBaseSubclass._StyleTypes.SkinStyle = 			{inheritable:false};		
 * StylableBaseSubclass._StyleTypes.TextStyle =				{inheritable:true};			
 * StylableBaseSubclass._StyleTypes.TextFont =				{inheritable:true};			
 * StylableBaseSubclass._StyleTypes.TextSize =				{inheritable:true};			
 * 
 * StylableBaseSubclass.StyleDefault = new StyleDefinition();
 * StylableBaseSubclass.StyleDefault.setStyle("Visible", 				true);
 * StylableBaseSubclass.StyleDefault.setStyle("BorderType", 			"none");
 * StylableBaseSubclass.StyleDefault.setStyle("SkinStyle", 				null);
 * StylableBaseSubclass.StyleDefault.setStyle("TextStyle", 				"normal");
 * StylableBaseSubclass.StyleDefault.setStyle("TextFont", 				"Arial");
 * StylableBaseSubclass.StyleDefault.setStyle("TextSize", 				12);
 * 
 * 
 * @constructor StyleableBase 
 * Creates new StyleableBase instance.
 */
function StyleableBase()
{
	StyleableBase.base.prototype.constructor.call(this);
}
	
//Inherit from StyleDefinition
StyleableBase.prototype = Object.create(StyleDefinition.prototype);
StyleableBase.prototype.constructor = StyleableBase;
StyleableBase.base = StyleDefinition;

//Priority enum
StyleableBase.StylePriorities = 
	{
		INSTANCE:0,
		CLASS:1
	};

//////////////Public//////////////////////

//@override	
StyleableBase.prototype.getStyle = 
	function (styleName)
	{
		return this.getStyleData(styleName).value;
	};	

//@override
StyleableBase.prototype.setStyle = 
	function (styleName, value)
	{
		var oldStyle = undefined;
		if (styleName in this._styleMap)
			oldStyle = this._styleMap[styleName];
		
		//No change
		if (oldStyle === value)
			return;
		
		if (this.hasEventListener("stylechanged", null) == true)
		{
			var oldStyleData = this.getStyleData(styleName);			
			
			//Change style
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
			
			var newStyleData = this.getStyleData(styleName);
			
			if (oldStyleData.equals(newStyleData) == false)
				this._dispatchEvent(new StyleChangedEvent(styleName));
		}
		else
		{
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
		}
	};
	
/**
 * @function getStyleData
 * 
 * Gets the style data for the supplied style name, this includes
 * additional info than getStyle() such as the style priority.
 * 
 * @param styleName String
 * String representing style to return the associated StyleData.
 * 
 * @returns StyleData
 * Returns the associated StyleData
 */	
StyleableBase.prototype.getStyleData = 
	function (styleName)
	{
		var styleData = new StyleData(styleName);
	
		styleData.value = StyleableBase.base.prototype.getStyle.call(this, styleName);
		if (styleData.value !== undefined)
		{
			styleData.priority.push(StyleableBase.StylePriorities.INSTANCE);
			return styleData;			
		}
		
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(StyleableBase.StylePriorities.CLASS);
		
		return styleData;
	};
	
///////////////Internal///////////////////	
	
//@private	
StyleableBase.prototype._getStyleType = 
	function (styleName)
	{
		var thisProto = Object.getPrototypeOf(this);
		if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
			return null;
		
		var thisClass = thisProto.constructor;
		
		while (true)
		{
			if ("_StyleTypes" in thisClass && styleName in thisClass._StyleTypes)
				return thisClass._StyleTypes[styleName];
			
			thisProto = Object.getPrototypeOf(thisProto);
			if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
				return null;
			
			thisClass = thisProto.constructor;
		}
	};

/**
 * @function _getDefaultStyle
 * 
 * Gets default value for the supplied style. 
 * 
 * @param styleName String
 * String representing the default style to return.
 * 
 * @returns Any
 * Returns the associated default style value if found, otherwise undefined.
 */	
StyleableBase.prototype._getDefaultStyle = 
	function (styleName)
	{
		return this._getDefaultStyleData(styleName).value;
	};	
	
/**
 * @function _getDefaultStyleData
 * 
 * Gets default StyleData for the supplied style. 
 *  
 * @param styleName String
 * String representing the default style to return.
 * 
 * @returns StyleData
 * Returns the associated default StyleData.
 */	
StyleableBase.prototype._getDefaultStyleData = 
	function (styleName)
	{
		var styleData = new StyleData(styleName);
		
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(StyleableBase.StylePriorities.CLASS);
		
		return styleData;
	};
	
//@private	
StyleableBase.prototype._getClassStyle = 
	function (styleName)
	{
		var styleValue = undefined;
		
		var thisProto = Object.getPrototypeOf(this);
		if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
			return styleValue;
		
		var thisClass = thisProto.constructor;
		
		while (true)
		{
			if ("StyleDefault" in thisClass)
			{
				styleValue = thisClass.StyleDefault.getStyle(styleName);
				if (styleValue !== undefined)
					return styleValue;
			}
			
			thisProto = Object.getPrototypeOf(thisProto);
			if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
				return styleValue;
			
			thisClass = thisProto.constructor;
		}
	};	
	


/**
 * @depends StyleableBase.js
 */

////////////////////////////////////////////////////////
////////////////////ShapeBase///////////////////////////

/**
 * @class ShapeBase
 * @inherits StyleableBase
 * 
 * Abstract base class for drawing vector shape paths.
 * 
 * @constructor ShapeBase 
 * Creates new ShapeBase instance.
 */
function ShapeBase()
{
	ShapeBase.base.prototype.constructor.call(this);
}

//Inherit from StyleableBase
ShapeBase.prototype = Object.create(StyleableBase.prototype);
ShapeBase.prototype.constructor = ShapeBase;
ShapeBase.base = StyleableBase;

////////////Public//////////////////////

/**
 * @function drawShape
 * Used to draw a sub-path shape path to the supplied Canvas2DContext using the supplied metrics.
 * Override this to draw custom shapes. Do *not* call beginPath() as that will destroy previous 
 * sub-paths and *do not* do any filling or other context calls. Only draw and closePath() the sub-path.
 * 
 * @param ctx Canvas2DContext
 * The Canvas2DContext to draw the sub-path on.
 * 
 * @param metrics DrawMetrics
 * DrawMetrics object to use as the bounding box for the sub-path.
 */
ShapeBase.prototype.drawShape = 
	function (ctx, metrics)
	{
		//Stub for override.
	};
	
	


/**
 * @depends ShapeBase.js
 */

////////////////////////////////////////////////////////
/////////////RoundedRectangleShape//////////////////////	

/**
 * @class RoundedRectangleShape
 * @inherits ShapeBase
 * 
 * Draws rectangles and rounded rectangles.
 * 
 * @constructor RoundedRectangleShape 
 * Creates new RoundedRectangleShape instance.
 */
function RoundedRectangleShape()
{
	RoundedRectangleShape.base.prototype.constructor.call(this);
}

//Inherit from ShapeBase
RoundedRectangleShape.prototype = Object.create(ShapeBase.prototype);
RoundedRectangleShape.prototype.constructor = RoundedRectangleShape;
RoundedRectangleShape.base = ShapeBase;

/////////////Style Types///////////////////////////////

RoundedRectangleShape._StyleTypes = Object.create(null);

/**
 * @style CornerRadius Number
 * 
 * Radius size in pixels for the rectangle's corners. 
 * CornerRadius effects all corners of the rectangle.
 */
RoundedRectangleShape._StyleTypes.CornerRadius = 					{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopLeft Number
 * 
 * Radius size in pixels for the rectangle's top left corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusTopLeft = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopRight Number
 * 
 * Radius size in pixels for the rectangle's top right corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusTopRight = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomLeft Number
 * 
 * Radius size in pixels for the rectangle's bottom left corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusBottomLeft = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomRight Number
 * 
 * Radius size in pixels for the rectangle's bottom right corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusBottomRight = 		{inheritable:false};		// number || null


////////////Style Defaults////////////////////////////

RoundedRectangleShape.StyleDefault = new StyleDefinition();

RoundedRectangleShape.StyleDefault.setStyle("CornerRadius", 					0);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusTopLeft",				null);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusTopRight",				null);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusBottomLeft",			null);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusBottomRight",			null);

////////////Public//////////////////////

//@Override
RoundedRectangleShape.prototype.drawShape = 
	function (ctx, metrics)
	{
		var x = metrics.getX();
		var y = metrics.getY();
		
		var width = metrics.getWidth();
		var height = metrics.getHeight();
		
		var c = this.getStyle("CornerRadius");
		var cTl = this.getStyle("CornerRadiusTopLeft");
		var cTr = this.getStyle("CornerRadiusTopRight");
		var cBl = this.getStyle("CornerRadiusBottomLeft");
		var cBr = this.getStyle("CornerRadiusBottomRight");
		
		if (c == null)
			c = 0;
		if (cTl == null)
			cTl = c;
		if (cTr == null)
			cTr = c;
		if (cBl == null)
			cBl = c;
		if (cBr == null)
			cBr = c;
		
		ctx.moveTo(x, y + cTl);
		
		if (cTl > 0)
			ctx.arcTo(x, y, 
				x + cTl, y, 
				cTl);
		
		ctx.lineTo(x + width - cTr, y);
		
		if (cTr > 0)
			ctx.arcTo(x + width, y, 
				x + width, y + cTr, 
				cTr);
		
		ctx.lineTo(x + width, y + height - cBr);
		
		if (cBr > 0)
			ctx.arcTo(x + width, y + height, 
				x + width - cBr, y + height, 
				cBr);
		
		ctx.lineTo(x + cBl, y + height);
		
		if (cBl > 0)
			ctx.arcTo(x, y + height, 
				x, y + height - cBl, 
				cBl);
		
		ctx.closePath();
	};
	
	


/**
 * @depends ShapeBase.js
 */

////////////////////////////////////////////////////////
/////////////////EllipseShape///////////////////////////

/**
 * @class EllipseShape
 * @inherits ShapeBase
 * 
 * Draws an ellipse that fills the supplied metrics rectangle.
 * 
 * @constructor EllipseShape 
 * Creates new EllipseShape instance.
 */
function EllipseShape()
{
	EllipseShape.base.prototype.constructor.call(this);
}

//Inherit from ShapeBase
EllipseShape.prototype = Object.create(ShapeBase.prototype);
EllipseShape.prototype.constructor = EllipseShape;
EllipseShape.base = ShapeBase;

////////////Public//////////////////////

//@Override
EllipseShape.prototype.drawShape = 
	function (ctx, metrics)
	{
		var w = metrics.getWidth();
		var h = metrics.getHeight();
		
		var spline4Magic = 0.551784;
		var xOffset = (w / 2) * spline4Magic;
		var yOffset = (h / 2) * spline4Magic;
		
		var xStart = metrics.getX();
		var yStart = metrics.getY();
		var xMiddle = xStart + (w / 2);
		var yMiddle = yStart + (h / 2);
		var xEnd = xStart + w;
		var yEnd = yStart + h;
		
		ctx.moveTo(xStart, yMiddle);
		ctx.bezierCurveTo(xStart, yMiddle - yOffset, xMiddle - xOffset, yStart, xMiddle, yStart);
		ctx.bezierCurveTo(xMiddle + xOffset, yStart, xEnd, yMiddle - yOffset, xEnd, yMiddle);
		ctx.bezierCurveTo(xEnd, yMiddle + yOffset, xMiddle + xOffset, yEnd, xMiddle, yEnd);
		ctx.bezierCurveTo(xMiddle - xOffset, yEnd, xStart, yMiddle + yOffset, xStart, yMiddle);
		ctx.closePath();
	};
	
	


/**
 * @depends ShapeBase.js
 */

////////////////////////////////////////////////////////
/////////////////ArrowShape/////////////////////////////	

/**
 * @class ArrowShape
 * @inherits ShapeBase
 * 
 * Draws a variety of arrow-ish shapes such as triangles, rounded pointers,
 * and traditional arrows.
 * 
 * @constructor ArrowShape 
 * Creates new ArrowShape instance.
 */
function ArrowShape()
{
	ArrowShape.base.prototype.constructor.call(this);
}

//Inherit from ShapeBase
ArrowShape.prototype = Object.create(ShapeBase.prototype);
ArrowShape.prototype.constructor = ArrowShape;
ArrowShape.base = ShapeBase;

/////////////Style Types///////////////////////////////

ArrowShape._StyleTypes = Object.create(null);

/**
 * @style Direction String
 * 
 * Determines the direction that the arrow or triangle will point. Acceptable values are "up", "down", "left", and "right".
 * Other styles are named as such when the Arrow is pointed "up". Styles do not change with orientation.
 */
ArrowShape._StyleTypes.Direction = 						{inheritable:false};		// "up" || "down" || "left" || "right"

/**
 * @style RectBaseWidth Number
 * 
 * The size in pixels used for the width of the rectangular base of the arrow. Setting this to zero creates a triangle.
 * It is preferrable to use RectBasePercentWidth so that the arrow can scale.
 */
ArrowShape._StyleTypes.RectBaseWidth = 					{inheritable:false};		// number || null

/**
 * @style RectBaseHeight Number
 * 
 * The size in pixels used for the height of the rectangular base of the arrow. Setting this to zero creates a triangle.
 * It is preferrable to use RectBasePercentHeight so that the arrow can scale.
 */
ArrowShape._StyleTypes.RectBaseHeight = 				{inheritable:false};		// number || null

/**
 * @style RectBasePercentWidth Number
 * 
 * The percentage of available width to use for the width of the rectangular base of the arrow. 
 * Acceptable values are between 0 and 100. Setting this to zero will create a triangle.
 */
ArrowShape._StyleTypes.RectBasePercentWidth = 			{inheritable:false};		// number || null

/**
 * @style RectBasePercentHeight Number
 * 
 * The percentage of available height to use for the height of the rectangular base of the arrow. 
 * Acceptable values are between 0 and 100. Setting this to zero will create a triangle.
 */
ArrowShape._StyleTypes.RectBasePercentHeight = 			{inheritable:false};		// number || null

/**
 * @style CornerRadius Number
 * 
 * Radius size in pixels for the rectangular base's corners. 
 * CornerRadius effects all corners of the rectangular base. 
 */
ArrowShape._StyleTypes.CornerRadius = 					{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopLeft Number
 * 
 * Radius size in pixels for the rectangular base's top left corner. 
 * This will override the CornerRadius style unless it is null.
 */
ArrowShape._StyleTypes.CornerRadiusTopLeft = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopRight Number
 * 
 * Radius size in pixels for the rectangular base's top right corner. 
 * This will override the CornerRadius style unless it is null.
 */
ArrowShape._StyleTypes.CornerRadiusTopRight = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomLeft Number
 * 
 * Radius size in pixels for the rectangular base's bottom left corner. 
 * This will override the CornerRadius style unless it is null. Rounding both bottom corners
 * will give the effect of a rounded pointer. 
 */
ArrowShape._StyleTypes.CornerRadiusBottomLeft = 		{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomRight Number
 * 
 * Radius size in pixels for the rectangular base's bottom right corner. 
 * This will override the CornerRadius style unless it is null. Rounding both bottom corners
 * will give the effect of a rounded pointer. 
 */
ArrowShape._StyleTypes.CornerRadiusBottomRight = 		{inheritable:false};		// number || null


////////////Default Styles///////////////////////////

ArrowShape.StyleDefault = new StyleDefinition();

ArrowShape.StyleDefault.setStyle("Direction", 						"up");	// "up" || "down" || "left" || "right"

ArrowShape.StyleDefault.setStyle("RectBaseWidth", 					null); 	// number || null
ArrowShape.StyleDefault.setStyle("RectBaseHeight", 					null); 	// number || null
ArrowShape.StyleDefault.setStyle("RectBasePercentWidth", 			null);	// number || null
ArrowShape.StyleDefault.setStyle("RectBasePercentHeight", 			null); 	// number || null

ArrowShape.StyleDefault.setStyle("CornerRadius", 					0);		// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusTopLeft",				null);	// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusTopRight",			null);	// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusBottomLeft",			null);	// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusBottomRight",			null);	// number || null


////////////Public//////////////////////

ArrowShape.prototype.drawShape = 
	function (ctx, metrics)
	{
		var direction = this.getStyle("Direction");
		
		if (direction != "up" && direction != "down" && direction != "left" && direction != "right")
			return;
		
		var x = metrics.getX();
		var y = metrics.getY();
		var width = metrics.getWidth();
		var height = metrics.getHeight();
		
		var c = this.getStyle("CornerRadius");
		var cornerTl = this.getStyle("CornerRadiusTopLeft");
		var cornerTr = this.getStyle("CornerRadiusTopRight");
		var cornerBl = this.getStyle("CornerRadiusBottomLeft");
		var cornerBr = this.getStyle("CornerRadiusBottomRight");
		
		if (c == null)
			c = 0;
		if (cornerTl == null)
			cornerTl = c;
		if (cornerTr == null)
			cornerTr = c;
		if (cornerBl == null)
			cornerBl = c;
		if (cornerBr == null)
			cornerBr = c;
		
		var baseWidth = this.getStyle("RectBaseWidth");
		var baseHeight = this.getStyle("RectBaseHeight");
		
		if (baseWidth == null)
		{
			var rectWidthPercent = this.getStyle("RectBasePercentWidth");
			if (rectWidthPercent == null)
				baseWidth = 0;
			else
				baseWidth = Math.round(w * (rectWidthPercent / 100));
		}
		if (baseHeight == null)
		{
			var rectHeightPercent = this.getStyle("RectBasePercentHeight");
			if (rectHeightPercent == null)
				baseHeight = 0;
			else
				baseHeight = Math.round(h * (rectHeightPercent / 100));
		}
		
		if (baseWidth == 0 || baseHeight == 0)
		{
			baseWidth = 0;
			baseHeight = 0;
		}
		
		if (direction == "down")
		{
			ctx.moveTo(x + ((width - baseWidth) / 2), 
				y + cornerTl);
			
			if (cornerTl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y, 
					x + ((width - baseWidth) / 2) + cornerTl, y, 
					cornerTl);
			
			ctx.lineTo(x + ((width - baseWidth) / 2) + baseWidth - cornerTr, 
				y);
			
			if (cornerTr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y, 
					x + ((width - baseWidth) / 2) + baseWidth, y + cornerTr, 
					cornerTr);
			
			ctx.lineTo(x + ((width - baseWidth) / 2) + baseWidth, y + baseHeight - cornerBr);
			
			if (cornerBr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y + baseHeight,
					Math.min(x + ((width - baseWidth) / 2) + baseWidth + cornerBr, x + width), y + baseHeight,
					Math.min(cornerBr, (width - baseWidth) / 2));			
			
			ctx.lineTo(x + width, y + baseHeight);
			ctx.lineTo(x + (width / 2), y + height);
			ctx.lineTo(x, y + baseHeight);
			
			ctx.lineTo(Math.max(x + ((width - baseWidth) / 2) - cornerBl, x), y + baseHeight);
			
			if (cornerBl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y + baseHeight,
					x + ((width - baseWidth) / 2), y + baseHeight - cornerBl,
					Math.min(cornerBl, (width - baseWidth) / 2));
		}
		else if (direction == "left")
		{
			ctx.moveTo(x + width - cornerTr, 
					y +  ((height - baseHeight) / 2));
			
			if (cornerTr > 0)
				ctx.arcTo(x + width, y +  ((height - baseHeight) / 2), 
					x + width, y +  ((height - baseHeight) / 2) + cornerTr, 
					cornerTr);
			
			ctx.lineTo(x + width, 
				y + ((height - baseHeight) / 2) + baseHeight - cornerBr);
			
			if (cornerBr > 0)
				ctx.arcTo(x + width, y + ((height - baseHeight) / 2) + baseHeight, 
					x + width - cornerBr, y + ((height - baseHeight) / 2) + baseHeight, 
					cornerBr);
			
			ctx.lineTo(x + width - baseWidth + cornerBl, y + ((height - baseHeight) / 2) + baseHeight);
			
			if (cornerBl > 0)
				ctx.arcTo(x + width - baseWidth, y + ((height - baseHeight) / 2) + baseHeight,
					x + width - baseWidth, Math.min(y + ((height - baseHeight) / 2) + baseHeight + cornerBl, y + height),
					Math.min(cornerBl, (height - baseHeight) / 2));
			
			
			ctx.lineTo(x + width - baseWidth, y + height);
			ctx.lineTo(x, y + (height / 2));
			ctx.lineTo(x + width - baseWidth, y);
			
			ctx.lineTo(x + width - baseWidth, Math.max(y, y + ((height - baseHeight) / 2) - cornerTl));

			if (cornerTl > 0)
				ctx.arcTo(x + width - baseWidth, y + ((height - baseHeight) / 2),
					x + width - baseWidth + cornerTl, y + ((height - baseHeight) / 2),
					Math.min(cornerTl, (height - baseHeight) / 2));
		}
		else if (direction == "up")
		{
			ctx.moveTo(x + ((width - baseWidth) / 2) + baseWidth, 
				y + height - cornerBr);
			
			if (cornerBr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y + height, 
					x + ((width - baseWidth) / 2) + baseWidth - cornerBr, y + height, 
					cornerBr);
			
			ctx.lineTo(x + ((width - baseWidth) / 2) + cornerBl, 
				y + height);
			
			if (cornerBl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y + height, 
					x + ((width - baseWidth) / 2), y + height - cornerBl, 
					cornerBl);
			
			ctx.lineTo(x + ((width - baseWidth) / 2), y + height - baseHeight + cornerTl);
			
			if (cornerTl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y + height - baseHeight,
					Math.max(x + ((width - baseWidth) / 2) - cornerTl, x), y + height - baseHeight,
					Math.min(cornerTl, (width - baseWidth) / 2));			
			
			
			ctx.lineTo(x, y + height - baseHeight);
			ctx.lineTo(x + (width / 2), y);
			ctx.lineTo(x + width, y + height - baseHeight);
			
			
			ctx.lineTo(Math.min(x + ((width - baseWidth) / 2) + baseWidth + cornerTr, x + width), y + height - baseHeight);
			
			if (cornerTr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y + height - baseHeight,
					x + ((width - baseWidth) / 2) + baseWidth, y + height - baseHeight + cornerTr,
					Math.min(cornerTr, (width - baseWidth) / 2));
		}
		else if (direction == "right")
		{
			ctx.moveTo(x + cornerBl, 
				y +  ((height - baseHeight) / 2) + baseHeight);
			
			if (cornerBl > 0)
				ctx.arcTo(x, y +  ((height - baseHeight) / 2) + baseHeight, 
					x, y +  ((height - baseHeight) / 2) + baseHeight - cornerBl, 
					cornerBl);
			
			ctx.lineTo(x, 
				y + ((height - baseHeight) / 2) + cornerTl);
			
			if (cornerTl > 0)
				ctx.arcTo(x, y + ((height - baseHeight) / 2), 
					x + cornerTl, y + ((height - baseHeight) / 2), 
					cornerTl);
			
			ctx.lineTo(x + baseWidth - cornerTr, y + ((height - baseHeight) / 2));
			
			if (cornerTr > 0)
				ctx.arcTo(x + baseWidth, y + ((height - baseHeight) / 2),
					x + baseWidth, Math.max(y + ((height - baseHeight) / 2) - cornerTr, y),
					Math.min(cornerTr, (height - baseHeight) / 2));
			
			
			ctx.lineTo(x + baseWidth, y);
			ctx.lineTo(x + width, y + (height / 2));
			ctx.lineTo(x + baseWidth, y + height);
			
			ctx.lineTo(x + baseWidth, Math.min(y + height, y + ((height - baseHeight) / 2) + baseHeight + cornerBr));

			if (cornerBr > 0)
				ctx.arcTo(x + baseWidth, y + ((height - baseHeight) / 2) + baseHeight,
					x + baseWidth - cornerBr, y + ((height - baseHeight) / 2) + baseHeight,
					Math.min(cornerBr, (height - baseHeight) / 2));
		}
		
		ctx.closePath();
	};	
	
	


/**
 * @depends EventDispatcher.js
 */

///////////////////////////////////////////////////////////////////
///////////////////////ListCollection//////////////////////////////	

/**
 * @class ListCollection
 * @inherits EventDispatcher
 * 
 * ListCollection is a wrapper for an Array that dispatches "collectionchanged"
 * events when the collection is modified. This is used by data driven containers
 * like the DataList or DataGrid to track and respond to changes on their associated data.
 * 
 * 
 * @constructor ListCollection 
 * Creates new ListCollection instance.
 * 
 * @param sourceArray Array
 * Backing array to be used as the collection's source. This is used
 * if you have an existing array you want to give to the ListCollection
 * to manage. Setting this to null will cause the ListCollection to create 
 * its own internal array.
 */
function ListCollection(sourceArray)
{
	ListCollection.base.prototype.constructor.call(this);
	
	this._backingArray = [];		
	this._collectionSort = null;	
	
	if (sourceArray != null)
		this._backingArray = sourceArray;
}

//Inherit from EventDispatcher
ListCollection.prototype = Object.create(EventDispatcher.prototype);
ListCollection.prototype.constructor = ListCollection;
ListCollection.base = EventDispatcher;

/**
 * @event collectionchanged CollectionChangedEvent
 * Dispatched when the collection is modified. CollectionChangedEvents can be of kinds "add", "remove", "update", "reset",
 * and include the index which has been changed.
 */


////////////Public///////////////////////////////

/**
 * @function getLength
 * Gets the number of elements in the collection.
 * 
 * @returns int
 * The number of elements in the collection.
 */
ListCollection.prototype.getLength = 
	function ()
	{
		return this._backingArray.length;
	};

/**
 * @function setSourceArray
 * Sets the source array to be used for the collection and dispatches a "collectionchanged" "reset" event.
 * 
 * @param sourceArray Array
 * The source array to be used for the collection.
 */	
ListCollection.prototype.setSourceArray = 
	function (sourceArray)
	{
		this._backingArray = sourceArray;
		this._dispatchEvent(new CollectionChangedEvent("reset", -1));
	};
	
/**
 * @function getSourceArray
 * Gets the source array currently used for the collection.
 * 
 * @returns Array
 * The source array currently used for the collection.
 */		
ListCollection.prototype.getSourceArray = 
	function ()
	{
		return this._backingArray;
	};
	
/**
 * @function setCollectionSort
 * Sets the CollectionSort to be used when calling sort().
 * 
 * @param collectionSort CollectionSort
 * The CollectionSort to be used when calling sort(). (or null)
 */	
ListCollection.prototype.setCollectionSort = 
	function (collectionSort)
	{
		if (this._collectionSort == collectionSort)
			return; 
			
		if (!(collectionSort instanceof CollectionSort))
			throw "Invalid CollectionSort";
			
		this._collectionSort = collectionSort;
	};
	
/**
 * @function getCollectionSort
 * Gets the CollectionSort used when calling sort().
 * 
 * @returns CollectionSort
 * The CollectionSort to be used when calling sort().
 */	
ListCollection.prototype.getCollectionSort = 
	function ()
	{
		return this._collectionSort;
	};
	
/**
 * @function sort
 * Sorts the collection and dispatches a "collectionchanged" "reset" event.
 */	
ListCollection.prototype.sort = 
	function ()
	{
		if (this._backingArray == null)
			return;
	
		if (this._collectionSort == null)
			this._backingArray.sort();
		else
			this._collectionSort.sort(this._backingArray);
		
		this._dispatchEvent(new CollectionChangedEvent("reset", -1));
	};
	
/**
 * @function getItemIndex
 * Gets the collection index of the item.
 * 
 * @param item Object
 * The item to which to return the collection index.
 * 
 * @returns int
 * The collection index or -1 if the item is not in the collection.
 */	
ListCollection.prototype.getItemIndex = 
	function (item)
	{
		if (item == null)
			return -1;
		
		return this._backingArray.indexOf(item);
	};
	
/**
 * @function getItemAt
 * Gets an item in the collection at the supplied index.
 * 
 * @param index int
 * The index to which to return the collection item.
 * 
 * @returns Object
 * The collection item or null if the index is out of range.
 */		
ListCollection.prototype.getItemAt = 
	function (index)
	{
		if (index < 0 || index >= this._backingArray.length)
			return null;
	
		return this._backingArray[index];
	};
	
/**
 * @function addItem
 * Adds an item to the end of the collection and dispatches a "collectionchanged" "add" event.
 * 
 * @param item Object
 * The item to add to the collection
 * 
 * @returns Object
 * The item just added to the collection.
 */	
ListCollection.prototype.addItem = 
	function (item)
	{
		return this.addItemAt(item, this._backingArray.length);
	};
	
/**
 * @function addItemAt
 * Adds an item to the collection at the supplied index and dispatches a "collectionchanged" "add" event.
 * 
 * @param item Object
 * The item to add to the collection
 * 
 * @param index int
 * The index to insert the item.
 * 
 * @returns Object
 * The item just added to the collection, or null if the index was out of range.
 */		
ListCollection.prototype.addItemAt = 
	function (item, index)
	{
		if (index < 0 || index > this._backingArray.length || item == null)
			return null;
		
		this._backingArray.splice(index, 0, item);
		
		this._dispatchEvent(new CollectionChangedEvent("add", index));
		
		return item;
	};
	
/**
 * @function removeItem
 * Removes an item from the collection and dispatches a "collectionchanged" "remove" event.
 * 
 * @param item Object
 * The item to remove from the collection.
 * 
 * @returns Object
 * The item just removed from the collection, or null if the item was not in the collection.
 */			
ListCollection.prototype.removeItem = 
	function (item)
	{
		return this.removeItemAt(this._backingArray.indexOf(item));
	};
	
/**
 * @function removeItemAt
 * Removes an item from the collection at the supplied index and dispatches a "collectionchanged" "remove" event.
 * 
 * @param index int
 * The index to remove the item.
 * 
 * @returns Object
 * The item just removed to the collection, or null if the index was out of range.
 */		
ListCollection.prototype.removeItemAt = 
	function (index)
	{
		if (index < 0 || index >= this._backingArray.length)
			return null;
		
		var removed = this._backingArray.splice(index, 1)[0]; //Returns array of removed items.
		
		this._dispatchEvent(new CollectionChangedEvent("remove", index));
		
		return removed;
	};

/**
 * @function replaceItemAt
 * Replaces an item in the collection at the supplied index and dispatches a "collectionchanged" "update" event.
 * 
 * @param item Object
 * The new item to which replace the existing item.
 * 
 * @param index int
 * The index to replace.
 * 
 * @returns Object
 * The item just replaced, or null if the index was out of range.
 */
ListCollection.prototype.replaceItemAt = 
	function (item, index)
	{
		if (index < 0 || index >= this._backingArray.length)
			return null;
		
		var oldItem = this._backingArray[index];
		this._backingArray[index] = item;
		
		this.indexUpdated(index);
		
		return oldItem;
	};
	
/**
 * @function clear
 * Clears the collection and dispatches a "collectionchanged" "reset" event.
 */	
ListCollection.prototype.clear = 
	function ()
	{
		this._backingArray = [];
		
		this._dispatchEvent(new CollectionChangedEvent("reset", -1));
	};
	
/**
 * @function indexUpdated
 * Dispatches a "collectionchanged" "update" event. When a data objects internal
 * data is changed, call this to update the Container such as a DataList or DataGrid.
 * 
 * @param index int
 * The index to dispatch the "update" event.
 */	
ListCollection.prototype.indexUpdated = 
	function (index)
	{
		this._dispatchEvent(new CollectionChangedEvent("update", index));
	};


/////////////////////////////////////////////////////////////////////
/////////////////////DrawMetrics/////////////////////////////////////	

/**
 * @class DrawMetrics
 * 
 * Simple data structure to represent bounds. (X, Y, Width, Height). 
 * 
 * 
 * @constructor DrawMetrics 
 * Creates new DrawMetrics instance.
 */

//Supporting class used to indicate element bounds.
function DrawMetrics()
{
	this._x = 0;
	this._y = 0;
	this._width = 0;
	this._height = 0;
}	

//DrawMetrics is base object, no inheritance.
DrawMetrics.prototype.constructor = DrawMetrics;

/**
 * @function equals
 * 
 * Checks if two instances of DrawMetrics contain the same values.
 * 
 * @param drawMetrics DrawMetrics
 * DrawMetrics instance to compare.
 * 
 * @returns bool
 * True when both instances contain the same values.
 */
DrawMetrics.prototype.equals = 
	function(drawMetrics)
	{
		if (this._x == drawMetrics._x && 
			this._y == drawMetrics._y &&
			this._width == drawMetrics._width && 
			this._height == drawMetrics._height)
		{
			return true;
		}
		
		return false;
	};

/**
 * @function clone
 * Duplicates an instance of DrawMetrics. 
 * 
 * @returns DrawMetrics
 * A new DrawMetrics instance identical to the cloned instance.
 */		
DrawMetrics.prototype.clone = 
	function ()
	{
		var clonedMetrics = new DrawMetrics();
		
		clonedMetrics._x = this._x;
		clonedMetrics._y = this._y;
		clonedMetrics._width = this._width;
		clonedMetrics._height = this._height;
		
		return clonedMetrics;
	};
	
//@private (for now)	
DrawMetrics.prototype.copyFrom = 
	function (copyFromMetrics)
	{
		this._x = copyFromMetrics._x;
		this._y = copyFromMetrics._y;
		this._width = copyFromMetrics._width;
		this._height = copyFromMetrics._height;
	};
	
//@private (for now)
DrawMetrics.prototype.mergeExpand = 
	function (mergeWithDrawMetrics)
	{
		if (mergeWithDrawMetrics._x < this._x)
		{
			this._width += (this._x - mergeWithDrawMetrics._x);
			this._x = mergeWithDrawMetrics._x;
		}
		if (mergeWithDrawMetrics._y < this._y)
		{
			this._height += (this._y - mergeWithDrawMetrics._y);
			this._y = mergeWithDrawMetrics._y;
		}
		if (mergeWithDrawMetrics._x + mergeWithDrawMetrics._width > this._x + this._width)
			this._width += ((mergeWithDrawMetrics._x + mergeWithDrawMetrics._width) - (this._x + this._width));
		if (mergeWithDrawMetrics._y + mergeWithDrawMetrics._height > this._y + this._height)
			this._height += ((mergeWithDrawMetrics._y + mergeWithDrawMetrics._height) - (this._y + this._height));
	};
	
//@private (for now)	
DrawMetrics.prototype.mergeReduce = 
	function (mergeWithDrawMetrics)
	{
		if (this._x < mergeWithDrawMetrics._x)
		{
			this._width -= (mergeWithDrawMetrics._x - this._x);
			this._x = mergeWithDrawMetrics._x;
		}
		if (this._y < mergeWithDrawMetrics._y)
		{
			this._height -= (mergeWithDrawMetrics._y - this._y);
			this._y = mergeWithDrawMetrics._y;
		}
		if (this._x + this._width > mergeWithDrawMetrics._x + mergeWithDrawMetrics._width)
			this._width -= ((this._x + this._width) - (mergeWithDrawMetrics._x + mergeWithDrawMetrics._width));
		if (this._y + this._height > mergeWithDrawMetrics._y + mergeWithDrawMetrics._height)
			this._height -= ((this._y + this._height) - (mergeWithDrawMetrics._y + mergeWithDrawMetrics._height));	
	};
	
DrawMetrics.prototype.roundToPrecision = 
	function (precision)
	{
		this._x = CanvasElement.roundToPrecision(this._x, precision);
		this._y = CanvasElement.roundToPrecision(this._y, precision);
		this._width = CanvasElement.roundToPrecision(this._width, precision);
		this._height = CanvasElement.roundToPrecision(this._height, precision);
	};
	
//@private (for now)	
DrawMetrics.prototype.roundUp = 
	function ()
	{
		var x1 = this._x;
		var x2 = this._x + this._width;
		var y1 = this._y;
		var y2 = this._y + this._height;
		
		x1 = Math.floor(x1);
		x2 = Math.ceil(x2);
		y1 = Math.floor(y1);
		y2 = Math.ceil(y2);
		
		this._x = x1;
		this._y = y1;
		this._width = x2 - x1;
		this._height = y2 - y1;
	};
	
/**
 * @function getX
 * 
 * Gets the X value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The X value.
 */
DrawMetrics.prototype.getX = 
	function()
	{
		return this._x;
	};
	
/**
 * @function getY
 * 
 * Gets the Y value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The Y value.
 */	
DrawMetrics.prototype.getY = 
	function()
	{
		return this._y;
	};
	
/**
 * @function getWidth
 * 
 * Gets the Width value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The Width value.
 */		
DrawMetrics.prototype.getWidth = 
	function()
	{
		return this._width;
	};
	
/**
 * @function getHeight
 * 
 * Gets the Height value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The Height value.
 */		
DrawMetrics.prototype.getHeight = 
	function()
	{
		return this._height;
	};
	
	


///////////////////////////////////////////////////////////////////////
///////////////////////DataListData////////////////////////////////////

/**
 * @class DataListData
 * 
 * Internal data storage class passed to CanvasElements when they are used as
 * DataRenderers for a DataListElement or subclass.
 * 
 * 
 * @constructor DataListData 
 * Creates new DataListData instance.
 * 
 * @param parentList DataListElement
 * The parent DataListElement or subclass.
 * 
 * @param itemIndex int
 * The Collection item index.
 */
function DataListData(parentList, itemIndex)
{
	/**
	 * @member _parentList DataListElement
	 * Read Only - The parent DataListElement or subclass. 
	 */
	this._parentList = parentList;
	
	/**
	 * @member _itemIndex int
	 * Read Only - The Collection item index.
	 */
	this._itemIndex = itemIndex;
};	


///////////////////////////////////////////////////////////////////////
///////////////////////DataGridItemData////////////////////////////////

/**
 * @class DataGridItemData
 * 
 * Internal data storage class passed to CanvasElements when they are used as
 * DataRenderers for a DataGrid.
 * 
 * 
 * @constructor DataGridItemData 
 * Creates new DataGridItemData instance.
 * 
 * @param parentGrid DataGridElement
 * The parent DataListElement or subclass.
 * 
 * @param itemIndex int
 * The Collection item index.
 * 
 * @param columnIndex int
 * The column index associated with the DataGrid renderer.
 */
function DataGridItemData(parentGrid, itemIndex, columnIndex)
{
	/**
	 * @member _parentGrid DataGridElement
	 * Read Only - The parent DataGridElement or subclass. 
	 */
	this._parentGrid = parentGrid;
	
	/**
	 * @member _itemIndex int
	 * Read Only - The Collection item index.
	 */
	this._itemIndex = itemIndex;
	
	/**
	 * @member _columnIndex int
	 * Read Only - Column index associated with the DataGrid renderer.
	 */
	this._columnIndex = columnIndex;
};	




/**
 * @depends StyleableBase.js
 */

////////////////////////////////////////////////////////
//////////////CursorDefinition//////////////////////////	

/**
 * @class CursorDefinition
 * @inherits StyleableBase
 * 
 * CursorDefintion stores styles necessary to render/animate custom cursors.
 * This is used for CanvasElement's Cursor style (roll-over cursor) and can
 * also be added directly to CanvasManager. 
 *  
 * 
 * @constructor CursorDefinition 
 * Creates new CursorDefinition instance.
 */
function CursorDefinition()
{
	CursorDefinition.base.prototype.constructor.call(this);
	
	this._cursorElement = null;
	this._addedCount = 0;
}

//Inherit from StyleableBase
CursorDefinition.prototype = Object.create(StyleableBase.prototype);
CursorDefinition.prototype.constructor = CursorDefinition;
CursorDefinition.base = StyleableBase;

/////////////Style Types///////////////////////////////

CursorDefinition._StyleTypes = Object.create(null);

/**
 * @style CursorClass CanvasElement
 * 
 * The CanvasElement constructor or browser string type to use for the cursor.
 */
CursorDefinition._StyleTypes.CursorClass = 						{inheritable:false};		// CanvasElement() constructor

/**
 * @style CursorStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the cursor class. (Including Width and Height, unless you've implemented
 * the doMeasure() function into a custom CanvasElement subclass).
 */
CursorDefinition._StyleTypes.CursorStyle = 						{inheritable:false};		// StyleDefinition

/**
 * @style CursorOffsetX Number
 * 
 * The X offset from the actual mouse position the cursor should be rendered.
 */
CursorDefinition._StyleTypes.CursorOffsetX = 					{inheritable:false};		// number

/**
 * @style CursorOffsetY Number
 * 
 * The Y offset from the actual mouse position the cursor should be rendered.
 */
CursorDefinition._StyleTypes.CursorOffsetY = 					{inheritable:false};		// number


///////////Default Styles/////////////////////////////

CursorDefinition.StyleDefault = new StyleDefinition();

CursorDefinition.StyleDefault.setStyle("CursorClass", 							"default"); 	// "browsertype" || CanvasElement() constructor
CursorDefinition.StyleDefault.setStyle("CursorStyle", 							null); 			// StyleDefinition
CursorDefinition.StyleDefault.setStyle("CursorOffsetX", 						0); 			// number
CursorDefinition.StyleDefault.setStyle("CursorOffsetY", 						0); 			// number




///////////////////////////////////////////////////////////////////
///////////////////////CollectionSort//////////////////////////////	

/**
 * @class CollectionSort
 * 
 * CollectionSort is a helper class that stores a comparatorFunction
 * and a isDecending flag used to invert the sort.
 * 
 * 
 * @constructor CollectionSort 
 * Creates new CollectionSort instance.
 * 
 * @param comparatorFunction Function
 * The sort comparator function to use when sorting an array.
 * 
 * @param isDecending boolean
 * When true invert the sort.
 */
function CollectionSort(comparatorFunction, isDecending)
{
	this._comparatorFunction = comparatorFunction;
	this._isDecending = isDecending;
	
	var _self = this;
	
	//Private function to invert the comparator (decending sort). 
	//This gets passed to Array as function pointer so there's no point in using prototype.
	this._collectionSortDecendingComparator = 
		function (objA, objB)
		{
			return _self._comparatorFunction(objB, objA);
		};
}

//No inheritance (base object)
CollectionSort.prototype.constructor = CollectionSort;

/**
 * @function setComparatorFunction
 * Sets the comparator function to be used when sorting. Comparators accept 2 parameters and return -1, 0, or +1 
 * depending on the sort relation between the 2 parameters.
 * 
 * function (objA, objB) { return objA - objB; };
 * 
 *  @param comparatorFunction Function
 *  The function to be used as the comparator.
 */
CollectionSort.prototype.setComparatorFunction = 
	function (comparatorFunction)
	{
		this._comparatorFunction = comparatorFunction;
	};
	
/**
 * @function getComparatorFunction
 * Gets the comparator function used when sorting.
 * 
 * @returns Function
 * The comparator function used when sorting.
 */	
CollectionSort.prototype.getComparatorFunction = 
	function ()
	{
		return this._comparatorFunction;
	};

/**
 * @function sort
 * Sorts an array using the comparator function and isDecending flag.
 * 
 * @param array Array
 * Array to be sorted.
 */	
CollectionSort.prototype.sort = 
	function (array)
	{
		if (this._isDecending == true)
			array.sort(this._collectionSortDecendingComparator);
		else
			array.sort(this._comparatorFunction);
	};
	
/**
 * @function setIsDecending
 * Sets the isDecending flag. True to invert the sort.
 * 
 * @param isDecending bool
 * When true, invert the sort comparator function.
 */	
CollectionSort.prototype.setIsDecending = 
	function (isDecending)
	{
		this._isDecending = isDecending;
	};
	
/**
 * @function getIsDecending
 * Gets the state of the isDecending flag.
 * 
 * @returns boolean
 * The state of the isDecending flag.
 */	
CollectionSort.prototype.getIsDecending = 
	function ()
	{
		return this._isDecending;
	};
	
	


/**
 * @depends StyleableBase.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////CanvasElement///////////////////////////////////////	
	
/**
 * @class CanvasElement
 * @inherits StyleableBase
 * 
 * Base class for all Elements to be rendered to the Canvas by CanvasManager. 
 * CanvasElement supports all basic system functions for render-able objects such 
 * as the display chain hierarchy, user interactivity and events, 
 * style management, vector based rendering, etc. 
 * 
 * CanvasElement is the most basic type that can be added to CanvasManager and can be
 * used to automatically draw shapes or any custom rendering to the canvas.
 * 
 * 
 * @constructor CanvasElement 
 * Creates new CanvasElement instance.
 */

function CanvasElement()
{
	CanvasElement.base.prototype.constructor.call(this);
	
	//Proxy styles from a different element.
	this._styleProxy = null;
	
	//This is *not* class based defaults. Its a default version of _styleDefinition.
	//Used when the framework wants to apply a default definition that override class 
	//based default styles but *not* user applied styles.
	this._styleDefinitionDefault = null; 
	
	//Assigned style definitions
	this._styleDefinitions = [];
	
	//Storage for the current background shape ShapeBase() per styling. We need to store a reference 
	//because we listen for style changed events and need to be able to remove the listener when
	//this is changed (via styles) or added/removed to display chain.
	this._backgroundShape = null;
	
	this._manager = null; //Canvas Manager reference
	this._displayDepth = 0; //Depth in display chain hierarchy
	
	//Event listeners for capture phase. (Only ElementEvent events support capture)
	this._captureListeners = Object.create(null);
	
	
	this._name = null;	//User defined identifier
	
	/**
	 * @member _x Number
	 * Read only - X position in pixels relative to this elements parent. This is not updated immediately, only
	 * after our parent has finished its layout phase.
	 */
	this._x = 0;
	
	/**
	 * @member _y Number
	 * Read only - Y position in pixels relative to this elements parent. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._y = 0;
	
	/**
	 * @member _width Number
	 * Read only - This element's actual width in pixels. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._width = 0;
	
	/**
	 * @member _height Number
	 * Read only - This element's actual height in pixels. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._height = 0;
	
	/**
	 * @member _measuredWidth Number
	 * Read only - This element's measured width in pixels. This is not updated immediately, only
	 * after this element has finished its measure phase will this be valid.
	 */
	this._measuredWidth = 0;
	
	/**
	 * @member _measuredHeight Number
	 * Read only - This element's measured height in pixels. This is not updated immediately, only
	 * after this element has finished its measure phase will this be valid.
	 */
	this._measuredHeight = 0;
	
	/**
	 * @member _mouseIsOver boolean
	 * Read only - true if the mouse is over this element, otherwise false.
	 */
	this._mouseIsOver = false;
	
	/**
	 * @member _mouseIsDown boolean
	 * Read only - true if the mouse is pressed on this element, otherwise false.
	 */
	this._mouseIsDown = false;
	
	/**
	 * @member _isFocused boolean
	 * Read only - true if this element currently has focus, otherwise false.
	 */
	this._isFocused = false;
	
	/**
	 * @member _rotateDegrees Number
	 * Read only - Degrees this element is rotated. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._rotateDegrees = 0;
	
	/**
	 * @member _rotateCenterX Number
	 * Read only - The X position relative to the element's parent this element is rotated around. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._rotateCenterX = 0;
	
	/**
	 * @member _rotateCenterY Number
	 * Read only - The Y position relative to the element's parent this element is rotated around. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._rotateCenterY = 0;
	
	/**
	 * @member _parent CanvasElement
	 * Read only - This elements parent element.
	 */
	this._parent = null; 	
	
	this._children = [];
	
	this._stylesInvalid = true;
	this._stylesInvalidMap = Object.create(null);	//Dirty map of changed styles for _doStylesChanged()
	this._stylesValidateNode = new CmLinkedNode();	//Reference to linked list iterator
	this._stylesValidateNode.data = this;
	
	//getStyle() can potentially be an expensive operation, we cache the value for performance and comparison when external styles change.
	this._stylesCache = Object.create(null);		
	
	this._measureInvalid = true;					//Dirty flag for _doMeasure()
	this._measureValidateNode = new CmLinkedNode();	//Reference to linked list iterator
	this._measureValidateNode.data = this;
	
	this._layoutInvalid = true;						//Dirty flag for _doLayout()
	this._layoutValidateNode = new CmLinkedNode(); 	//Reference to linked list iterator
	this._layoutValidateNode.data = this;
	
	this._renderInvalid = true;						//Dirty flag for _doRender()
	this._renderValidateNode = new CmLinkedNode();	//Reference to linked list iterator
	this._renderValidateNode.data = this;
	
	//Off screen canvas for rendering this element.
	this._graphicsCanvas = null;
	this._graphicsCtx = null;
	this._graphicsClear = true;					//Optimization, sometimes we may *have* a canvas, but its been cleared so no need to render.
	
	//Metrics used for redraw region relative to composite parents (and ourself if we're a composite layer).
	this._compositeMetrics = [];				//Array of {element:element, metrics:DrawMetrics, drawableMetrics:DrawMetrics}
	
	this._renderChanged = true;					//Dirty flag for redraw region set to true when _graphicsCanvas has been modified.
	this._renderVisible = false; 				//False if any element in the composite parent chain is not visible.	
	
	/////////Composite Rendering////////////////
	
	//Composite rendering is used for effects like shadow, alpha, and transformations which
	//require aggregating child renderings, then re-rendering with the desired effect.
	//When an element requires composite rendering, it and its children are rendered to _compositeCanvas,
	//then _compositeCanvas is rendered to the parent composite (or root canvas) and appropriate effects are applied.
	//These values are only populated when this element requires composite rendering.
	
	this._compositeRenderInvalid = false;
	this._compositeRenderValidateNode = new CmLinkedNode();
	this._compositeRenderValidateNode.data = this;
	
	this._compositeEffectChanged = true;
	
	//Pre-effect / transform. Utilizes re-draw regions when rendering.
	this._compositeVisibleMetrics = null;			//Visible area of the composite layer.																			
	this._redrawRegionMetrics = null;				//Region to redraw																								
	
	this._compositeCtx = null;						//Graphics context																								
	this._compositeCanvas = null;					//Off screen canvas for aggregate rendering of this + child renderings.											
	this._compositeCanvasMetrics = null;			//Metrics of the composite canvas. 																				
	
	//Post-effect / transform. 
	this._transformVisibleMetrics = null;			//Transformed _compositeVisibleMetrics
	this._transformDrawableMetrics = null;			//Transformed _compositeVisibleMetrics region after clipping is applied															
	////////////////////////////////////////////
	
	
	this._rollOverCursorInstance = null; 			//Reference to cursor list iterator for roll-over cursor.
	
	this._renderFocusRing = false;
	
	var _self = this;
	
	//Private event handlers, need instance for each element, proxy to prototype.
	this._onExternalStyleChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onExternalStyleChanged(styleChangedEvent);
		};
	
	this._onBackgroundShapeStyleChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onBackgroundShapeStyleChanged(styleChangedEvent);
		};
		
	this._onCanvasElementAddedRemovedInstance = 
		function (addedRemovedEvent)
		{
			if (addedRemovedEvent.getType() == "added")
				_self._onCanvasElementAdded(addedRemovedEvent);
			else if (addedRemovedEvent.getType() == "removed")
				_self._onCanvasElementRemoved(addedRemovedEvent);
		};
		
	this._onCanvasElementCursorOverOutInstance = 
		function (elementEvent)
		{
			_self._updateRolloverCursorDefinition();
		};
		
		
	//Listen for added/removed to display chain. (Setup / Cleanup)	
	this.addEventListener("added", this._onCanvasElementAddedRemovedInstance);
	this.addEventListener("removed", this._onCanvasElementAddedRemovedInstance);
	
	
	//////////Dynamic Properties////////////////  //Added at runtime when required.
	
	///////DataRenderer/////////////
	
	/**
	 * @member _listData DataListData
	 * Read only - List data provided by parent DataList when acting as a DataRenderer
	 */
	//this._listData = any;
	
	/**
	 * @member _itemData Object
	 * Read only - Collection item associated with this DataRenderer
	 */
	//this._itemData = any;
	
	/**
	 * @member _listSelected Any
	 * Read only - DataRenderer selected state.
	 */
	//this._listSelected = any;
	
	////////////////////////////////
}

//Inherit from StyleableBase
CanvasElement.prototype = Object.create(StyleableBase.prototype);
CanvasElement.prototype.constructor = CanvasElement;
CanvasElement.base = StyleableBase;

//Style priority enum
CanvasElement.StylePriorities = 
{
	INSTANCE:0,
	DEFINITION:1,
	PROXY:2,
	INHERITED:3,
	DEFAULT_DEFINITION:4,
	DEFAULT_PROXY:5,
	CLASS:6
};

////////////Events/////////////////////////////////////

/**
 * @event localechanged DispatcherEvent
 * @broadcast
 * Dispatched when CanvasManager's locale selection changes.
 * 
 * @event enterframe DispatcherEvent
 * @broadcast
 * Dispatched at the beginning of the render frame before any life cycle processing begins.
 * 
 * @event mousemoveex ElementMouseEvent
 * @broadcast
 * Dispatched when the mouse moves anywhere, even outside of the browser window. Mouse coordinates are relative to CanvasManager.
 * 
 * @event resize DispatcherEvent
 * Dispatched when the element's size changes.
 * 
 * @event layoutcomplete DispatcherEvent
 * Typically an internal event. Dispatched when an element has completed its
 * layout phase. This is used when it is necessary to wait for an element to
 * finish its layout pass so things such as its PercentWidth calculation is complete.
 * This is very expensive and should only be used when absolutely necessary. Its usually
 * only needed when elements are not directly related via parent/child. 
 * For example, DropdownElement uses this to adjust the height of the dropdown popup
 * since we do not know how much height it will need until after it has finished layout.
 * 
 * @event measurecomplete DispatcherEvent
 * Typically an internal event. Dispatched when an element has completed its 
 * measure phase. This is used when it is necessary to wait for an element to
 * finish its measure pass so that its content size or _measuredSize calculation is complete.
 * This is very expensive and should only be used when absolutely necessary.  Its usually
 * only needed when elements are not directly related via parent/child.
 * For example, ViewportElement uses this to invoke a layout pass when its content child
 * changes _measuredSize. The Viewport uses an intermediate CanvasElement as a clipping container
 * for the content child, which does not measure children, so an event is needed to notify the Viewport.
 * 
 * @event keydown ElementKeyboardEvent
 * Dispatched when the element has focus and a key is pressed, repeatedly dispatched if the key is held down.
 * 
 * @event keyup ElementKeyboardEvent
 * Dispatched when the element has focus and a key is released.
 * 
 * @event mousedown ElementMouseEvent
 * Dispatched when the mouse is pressed over this element.
 * 
 * @event mouseup ElementMouseEvent
 * Dispatched when the mouse is released. Note that the mouse may not still be over the element.
 * 
 * @event click ElementMouseEvent
 * Dispatched when the mouse is pressed and released over the same element.
 * 
 * @event mousemove ElementMouseEvent
 * Dispatched when the mouse moves over this element.
 * 
 * @event wheel ElementMouseWheelEvent
 * Dispatched when the mouse wheel is rolled while over this element.
 * 
 * @event dragging ElementEvent
 * Dispatched when this element is moved due to it being dragged.
 * 
 * @event rollover ElementEvent
 * Dispatched when the mouse moves over this element.
 * 
 * @event rollout ElementEvent
 * Dispatched when the mouse moves outside of this element.
 * 
 * @event focusin ElementEvent
 * Dispatched when this element gains focus.
 * 
 * @event focusout ElementEvent
 * Dispatched when this element loses focus.
 * 
 * @event added AddedRemovedEvent
 * Dispatched when this element is added to the display hierarchy and becomes a descendant of CanvasManager. 
 * 
 * @event removed AddedRemovedEvent
 * Dispatched when this element is removed from the display hierarchy and is no longer a descendant of CanvasManager. 
 */


/////////////Style Types///////////////////////////////

CanvasElement._StyleTypes = Object.create(null);

//Rendering
/**
 * @style Visible boolean
 * 
 * When false the element will not be rendered.
 */
CanvasElement._StyleTypes.Visible = 				{inheritable:false};		// true || false

/**
 * @style BorderType String
 * 
 * Determines the border type the CanvasElement should render. Allowable values are
 * "none", "solid", "inset", or "outset". Note that borders are internal and drawn on the inside
 * of the elements bounding area.
 */
CanvasElement._StyleTypes.BorderType = 				{inheritable:false};		// "none" || "solid" || "inset" || "outset"

/**
 * @style BorderColor String
 * 
 * Hex color value to be used when drawing the border. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.BorderColor = 			{inheritable:false};		// "#FF0000" or null

/**
 * @style BorderThickness Number
 * 
 * Thickness in pixels to be used when drawing the border. 
 */
CanvasElement._StyleTypes.BorderThickness = 		{inheritable:false};		// number

/**
 * @style BackgroundColor String
 * 
 * Hex color value to be used when drawing the background. This may be set to null and no
 * background will be rendered. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.BackgroundColor = 		{inheritable:false};		// "#FF0000" or null

/**
 * @style ShadowSize Number
 * 
 * Size in pixels that the drop shadow should be rendered. Note that the drop shadow may be rendered
 * outside the elements bounding area. This will cause the element to be composite rendered.
 */
CanvasElement._StyleTypes.ShadowSize = 				{inheritable:false};		// number

/**
 * @style ShadowOffsetX Number
 * 
 * X offset that the drop shadow will be rendered.
 */
CanvasElement._StyleTypes.ShadowOffsetX = 			{inheritable:false};		// number

/**
 * @style ShadowOffsetY Number
 * 
 * Y offset that the drop shadow will be rendered.
 */
CanvasElement._StyleTypes.ShadowOffsetY = 			{inheritable:false};		// number

/**
 * @style ShadowColor String
 * 
 * Hex color value to be used when drawing the drop shadow. This may be set to null and no
 * shadow will be rendered. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.ShadowColor = 			{inheritable:false};		// "#FF0000" or null

/**
 * @style Alpha Number
 * 
 * Alpha value to use when rendering this component. Allowable values are between 0 and 1 with
 * 0 being transparent and 1 being opaque. This causes the element to perform composite rendering
 * when a value between 1 and 0 is used.
 */
CanvasElement._StyleTypes.Alpha = 					{inheritable:false};		// number

/**
 * @style AutoGradientType String
 * 
 * Determines the type of gradient to be used when rendering the element's background.
 * Allowable values are "none", "linear", or "radial". Auto gradients automatically lighten
 * and darken the associated color are always rendered in the same direction relative to the 
 * canvas itself regardless of rotation or transformation applied to the element. 
 * This is used to create effects like a consistent light source even if the element is rotating.
 */
CanvasElement._StyleTypes.AutoGradientType = 		{inheritable:false};		// "none" || "linear" || "radial"

/**
 * @style AutoGradientStart Number
 * 
 * Color offset to apply to the start of the gradient. Allowable values are numbers between 
 * -1 (white) and +1 (black). 
 */
CanvasElement._StyleTypes.AutoGradientStart = 		{inheritable:false};		// number (-1 to +1 values)

/**
 * @style AutoGradientStop Number
 * 
 * Color offset to apply to the end of the gradient. Allowable values are numbers between 
 * -1 (white) and +1 (black). 
 */
CanvasElement._StyleTypes.AutoGradientStop = 		{inheritable:false};		// number (-1 to +1 values)

/**
 * @style ClipContent boolean
 * 
 * Determines if out of bounds rendering is allowed. If true the element will clip all rendering
 * and children's rendering to the elements bounding box. 
 */
CanvasElement._StyleTypes.ClipContent = 			{inheritable:false};		// number (true || false)

/**
 * @style SkinState String
 * 
 * This is an internal style used to toggle an element's current skin for different states such
 * as normal, mouse-over, mouse-down, etc. Its also commonly used by skin classes to identify their skin state.
 */
CanvasElement._StyleTypes.SkinState = 				{inheritable:false};		// "state"

/**
 * @style BackgroundShape ShapeBase
 * 
 * Shape to be used when rendering the elements background. May be any ShapeBase subclass instance.
 */
CanvasElement._StyleTypes.BackgroundShape = 		{inheritable:false};		// ShapeBase()

/**
 * @style FocusColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing the elements focus indicator. Format "#FF0000" (Red). 
 * The focus indicator is only rendered when the element gains focus due to a tab stop.
 */
CanvasElement._StyleTypes.FocusColor = 				{inheritable:true};			// color ("#000000")

/**
 * @style FocusThickness Number
 * @inheritable
 * 
 * Size in pixels that the focus ring should be rendered. Note that the focus ring is rendered
 * outside the elements bounding area.
 */
CanvasElement._StyleTypes.FocusThickness =			{inheritable:true};			// number


//Layout
/**
 * @style Padding Number
 * 
 * Size in pixels that inner content should be spaced from the outer bounds of the element. 
 * Padding effects all sides of the element. Padding may be negative under certain circumstances like
 * expanding an inner child to allow border collapsing with its parent.
 */
CanvasElement._StyleTypes.Padding = 				{inheritable:false};		// number

/**
 * @style PaddingTop Number
 * 
 * Size in pixels that inner content should be spaced from the upper bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingTop = 				{inheritable:false};		// number or null

/**
 * @style PaddingBottom Number
 * 
 * Size in pixels that inner content should be spaced from the lower bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingBottom = 			{inheritable:false};		// number or null

/**
 * @style PaddingLeft Number
 * 
 * Size in pixels that inner content should be spaced from the left most bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingLeft = 			{inheritable:false};		// number or null

/**
 * @style PaddingRight Number
 * 
 * Size in pixels that inner content should be spaced from the right most bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingRight = 			{inheritable:false};		// number or null


//Functional

/**
 * @style Enabled boolean
 * 
 * When false disables user interaction with the element.
 */
CanvasElement._StyleTypes.Enabled = 				{inheritable:false};		// true || false

/**
 * @style MouseEnabled boolean
 * 
 * When false disables mouse events for the element.
 */
CanvasElement._StyleTypes.MouseEnabled = 			{inheritable:false};		// true || false

/**
 * @style Draggable boolean
 * 
 * When true allows the element to be dragged by the user. This does not work for containers
 * that do not allow absolute positioning such as a ListContainer.
 */
CanvasElement._StyleTypes.Draggable = 				{inheritable:false};		// true || false

/**
 * @style Cursor CursorDefinition
 * 
 * Specifies the cursor to be displayed when the mouse is over the element. A custom CursorDefinition
 * may be used or a browser type String ("text", "none", etc) may be used.
 */
CanvasElement._StyleTypes.Cursor = 					{inheritable:false};		// CursorDefinition()

/**
 * @style TabStop int
 * 
 * Determines if an element can be focused using tab stops. -1 indicates the element cannot
 * take focus, 0 is default and the element will be focused in the order it appears in the display chain.
 * Numbers higher than 0 indicate a specific order to be used (not yet implemented).
 */
CanvasElement._StyleTypes.TabStop = 				{inheritable:false};		// number


//Container Placement
/**
 * @style X Number
 * 
 * The X position the element should be rendered relative to its parent container. This only
 * works if the element is a child of an AnchorContainer.
 */
CanvasElement._StyleTypes.X =						{inheritable:false};		// number || null

/**
 * @style Y Number
 * 
 * The Y position the element should be rendered relative to its parent container. This only
 * works if the element is a child of an AnchorContainer.
 */
CanvasElement._StyleTypes.Y =						{inheritable:false};		// number || null

/**
 * @style Width Number
 * 
 * The Width the element should be rendered relative to its parent container. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.Width =					{inheritable:false};		// number || null

/**
 * @style Height Number
 * 
 * The Height the element should be rendered relative to its parent container. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.Height =					{inheritable:false};		// number || null

/**
 * @style Top Number
 * 
 * The distance the element should be positioned from the upper bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Top =						{inheritable:false};		// number || null

/**
 * @style Left Number
 * 
 * The distance the element should be positioned from the left most bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Left =					{inheritable:false};		// number || null

/**
 * @style Bottom Number
 * 
 * The distance the element should be positioned from the lower bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Bottom =					{inheritable:false};		// number || null

/**
 * @style Right Number
 * 
 * The distance the element should be positioned from the right most bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Right =					{inheritable:false};		// number || null

/**
 * @style PercentWidth Number
 * 
 * The percentage of available width the element should consume relative to its parent container. This only
 * works if the element is a child of a Container element. Note that percentage width is calculated
 * based on the available space left over *after* static sized elements considered. Percentages
 * are allowed to add to more than 100 and will consume all of the available space. For containers
 * like ListContainers, when percents add to more than 100 the elements will share the available space
 * per the ratio of percent vs total percent used so it is perfectly reasonable to set 3 elements all
 * to 100 and allow them to split the real-estate by 3.
 */
CanvasElement._StyleTypes.PercentWidth =			{inheritable:false};		// number || null

/**
 * @style PercentHeight Number
 * 
 * The percentage of available height the element should consume relative to its parent container. This only
 * works if the element is a child of a Container element. Note that percentage height is calculated
 * based on the available space left over *after* static sized elements considered. Percentages
 * are allowed to add to more than 100 and will consume all of the available space. For containers
 * like ListContainers, when percents add to more than 100 the elements will share the available space
 * per the ratio of percent vs total percent used so it is perfectly reasonable to set 3 elements all
 * to 100 and allow them to split the real-estate by 3.
 */
CanvasElement._StyleTypes.PercentHeight =			{inheritable:false};		// number || null

/**
 * @style MinWidth Number
 * 
 * The minimum width in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MinWidth =				{inheritable:false};		// number || null

/**
 * @style MinHeight Number
 * 
 * The minimum height in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MinHeight =				{inheritable:false};		// number || null

/**
 * @style MaxWidth Number
 * 
 * The maximum width in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MaxWidth =				{inheritable:false};		// number || null

/**
 * @style MaxHeight Number
 * 
 * The maximum height in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MaxHeight =				{inheritable:false};		// number || null

/**
 * @style HorizontalCenter Number
 * 
 * The distance in pixels from the horizontal center of the parent the element should be positioned.
 * Negative numbers indicate left of center, positive right of center. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.HorizontalCenter =		{inheritable:false};		// number || null

/**
 * @style VerticalCenter Number
 * 
 * The distance in pixels from the vertical center of the parent the element should be positioned.
 * Negative numbers indicate left of center, positive right of center. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.VerticalCenter =			{inheritable:false};		// number || null

/**
 * @style RotateDegrees Number
 * 
 * The number of degrees the element should be rotated (clockwise). When no RotateCenterX or
 * RotateCenterY is set, the element is rotated via its center point and rotated objects are
 * still positioned relative to their parent's coordinate plane after the transform has occurred.
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.RotateDegrees = 			{inheritable:false};		// number

/**
 * @style RotateCenterX Number
 * 
 * The X position of the parent container the element should be rotated around. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.RotateCenterX = 			{inheritable:false};		// number || null

/**
 * @style RotateCenterY Number
 * 
 * The Y position of the parent container the element should be rotated around. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.RotateCenterY = 			{inheritable:false};		// number || null

/**
 * @style IncludeInLayout boolean
 * 
 * When false, the element is no longer considered in the parent container's layout. 
 * Typically this is used in conjunction with Visible, however sometimes you may want to
 * hide an element, but still have it consume container space.
 */
CanvasElement._StyleTypes.IncludeInLayout = 		{inheritable:false};		// true || false

/**
 * @style CompositeLayer boolean
 * 
 * When true, this element renders itself and all children to a single layer and is treated
 * by its parent as a single element when rendering.  This is necessary and automatically enabled
 * for styles like alpha where the component and all its children must be pre-rendered, and then 
 * re-rendered with the appropriate effect.  
 * 
 * This is very expensive but can also be very beneficial when used appropriately.  
 * For example, if you have an application with a scrolling or constantly changing background
 * thereby always causing a full screen redraw, its beneficial to make the layer on top of the
 * background a composite layer.  This effectively buffers the layer. Only the delta changes
 * will be drawn to the composite. Otherwise the entire display chain would have to be re-drawn 
 * when the background moves. This is memory intensive as it effectively duplicates the rendering
 * area. Composite elements/children changing will update the composite layer, then that region of the 
 * composite layer needs to be copied up to the parent, resulting in an additional buffer copy.
 */
CanvasElement._StyleTypes.CompositeLayer = 					{inheritable:false};		//true || false

//Text
/**
 * @style TextStyle String
 * @inheritable
 * 
 * Determines the style to render text. Available values are "normal", "bold", "italic", and "bold italic".
 */
CanvasElement._StyleTypes.TextStyle =						{inheritable:true};		// "normal" || "bold" || "italic" || "bold italic"

/**
 * @style TextFont String
 * @inheritable
 * 
 * Determines the font family to use when rendering text such as "Arial".
 */
CanvasElement._StyleTypes.TextFont =						{inheritable:true};		// "Arial"

/**
 * @style TextSize int
 * @inheritable
 * 
 * Determines the size in pixels to render text.
 */
CanvasElement._StyleTypes.TextSize =						{inheritable:true};		// number

/**
 * @style TextAlign String
 * @inheritable
 * 
 * Determines alignment when rendering text. Available values are "left", "center", and "right".
 */
CanvasElement._StyleTypes.TextAlign =						{inheritable:true};		// "left" || "center" || "right"

/**
 * @style TextBaseline String
 * @inheritable
 * 
 * Determines the baseline when rendering text. Available values are "top", "middle", or "bottom".
 */
CanvasElement._StyleTypes.TextBaseline =					{inheritable:true};  	// "top" || "middle" || "bottom"

/**
 * @style LinePaddingTop Number
 * @inheritable
 * 
 * Padding to apply to the top of each line of text. This also impacts the size of the highlight background.
 * This is useful when using strange fonts that exceed their typical vertical bounds.
 */
CanvasElement._StyleTypes.TextLinePaddingTop = 				{inheritable:true};		// number

/**
 * @style LinePaddingBottom Number
 * @inheritable
 * 
 * Padding to apply to the bottom of each line of text. This also impacts the size of the highlight background.
 * This is useful when using strange fonts that exceed their typical vertical bounds.
 */
CanvasElement._StyleTypes.TextLinePaddingBottom = 			{inheritable:true};		// number

/**
 * @style TextLineSpacing Number
 * @inheritable
 * 
 * Vertical line spacing in pixels.
 */
CanvasElement._StyleTypes.TextLineSpacing = 				{inheritable:true};		// number

/**
 * @style TextColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing text. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextColor =						{inheritable:true};		// "#000000"

/**
 * @style TextFillType String
 * @inheritable
 * 
 * Determines the fill type when rendering text. Available values are "fill" and "stroke".
 * Stroke draws a border around characters, while fill completely fills them.
 */
CanvasElement._StyleTypes.TextFillType =					{inheritable:true};		// "fill" || "stroke"

/**
 * @style TextHighlightedColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing highlighted text. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextHighlightedColor = 			{inheritable:true};		// color "#000000"

/**
 * @style TextHighlightedColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing highlighted text background. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextHighlightedBackgroundColor = 	{inheritable:true};		// color "#000000"

/**
 * @style TextCaretColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing blinking text caret. "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextCaretColor = 					{inheritable:true};		// color "#000000"


/////////////Default Styles///////////////////////////////

CanvasElement.StyleDefault = new StyleDefinition();
//CanvasElement specific styles.
CanvasElement.StyleDefault.setStyle("Visible", 							true);
CanvasElement.StyleDefault.setStyle("BorderType", 						"none");
CanvasElement.StyleDefault.setStyle("BorderColor", 						"#000000");
CanvasElement.StyleDefault.setStyle("BorderThickness", 					1);
CanvasElement.StyleDefault.setStyle("BackgroundColor", 					null); 
CanvasElement.StyleDefault.setStyle("ShadowSize", 						0);
CanvasElement.StyleDefault.setStyle("ShadowOffsetX",					0);
CanvasElement.StyleDefault.setStyle("ShadowOffsetY",					0);
CanvasElement.StyleDefault.setStyle("ShadowColor",						"#000000");
CanvasElement.StyleDefault.setStyle("Alpha", 							1);
CanvasElement.StyleDefault.setStyle("AutoGradientType",					"none");
CanvasElement.StyleDefault.setStyle("AutoGradientStart",				(0.15));
CanvasElement.StyleDefault.setStyle("AutoGradientStop",					(-0.15));
CanvasElement.StyleDefault.setStyle("ClipContent",						false);
CanvasElement.StyleDefault.setStyle("SkinState", 						"");
CanvasElement.StyleDefault.setStyle("BackgroundShape", 					null); 		//ShapeBase
CanvasElement.StyleDefault.setStyle("FocusColor", 						"#3333FF");	// color ("#000000")
CanvasElement.StyleDefault.setStyle("FocusThickness", 					1);			// number

CanvasElement.StyleDefault.setStyle("Padding", 							0); 		//Not necessary, just for completeness
CanvasElement.StyleDefault.setStyle("PaddingTop", 						0);
CanvasElement.StyleDefault.setStyle("PaddingBottom",					0);
CanvasElement.StyleDefault.setStyle("PaddingLeft", 						0);
CanvasElement.StyleDefault.setStyle("PaddingRight", 					0);

CanvasElement.StyleDefault.setStyle("Enabled", 							true);
CanvasElement.StyleDefault.setStyle("MouseEnabled", 					true);
CanvasElement.StyleDefault.setStyle("Draggable", 						false);
CanvasElement.StyleDefault.setStyle("Cursor", 							null);		// "browsertype" || CursorDefinition
CanvasElement.StyleDefault.setStyle("TabStop", 							-1);		// number

CanvasElement.StyleDefault.setStyle("X", 								null);
CanvasElement.StyleDefault.setStyle("Y", 								null);
CanvasElement.StyleDefault.setStyle("Width", 							null);
CanvasElement.StyleDefault.setStyle("Height", 							null);
CanvasElement.StyleDefault.setStyle("Top", 								null);
CanvasElement.StyleDefault.setStyle("Left", 							null);
CanvasElement.StyleDefault.setStyle("Bottom", 							null);
CanvasElement.StyleDefault.setStyle("Right", 							null);
CanvasElement.StyleDefault.setStyle("PercentWidth", 					null);
CanvasElement.StyleDefault.setStyle("PercentHeight", 					null);
CanvasElement.StyleDefault.setStyle("MinWidth", 						5);		
CanvasElement.StyleDefault.setStyle("MinHeight", 						5);
CanvasElement.StyleDefault.setStyle("MaxWidth", 						null);
CanvasElement.StyleDefault.setStyle("MaxHeight", 						null);
CanvasElement.StyleDefault.setStyle("HorizontalCenter", 				null);
CanvasElement.StyleDefault.setStyle("VerticalCenter", 					null);
CanvasElement.StyleDefault.setStyle("RotateDegrees", 					0);
CanvasElement.StyleDefault.setStyle("RotateCenterX", 					null);
CanvasElement.StyleDefault.setStyle("RotateCenterY", 					null);
CanvasElement.StyleDefault.setStyle("IncludeInLayout", 					true);
CanvasElement.StyleDefault.setStyle("CompositeLayer",					false);

CanvasElement.StyleDefault.setStyle("TextStyle", 						"normal");
CanvasElement.StyleDefault.setStyle("TextFont", 						"Arial");
CanvasElement.StyleDefault.setStyle("TextSize", 						12);
CanvasElement.StyleDefault.setStyle("TextAlign",						"left");
CanvasElement.StyleDefault.setStyle("TextBaseline", 					"middle");
CanvasElement.StyleDefault.setStyle("TextLinePaddingTop", 				1);
CanvasElement.StyleDefault.setStyle("TextLinePaddingBottom", 			1);
CanvasElement.StyleDefault.setStyle("TextLineSpacing", 					0);
CanvasElement.StyleDefault.setStyle("TextColor", 						"#000000");
CanvasElement.StyleDefault.setStyle("TextFillType", 					"fill");
CanvasElement.StyleDefault.setStyle("TextHighlightedColor", 			"#FFFFFF");
CanvasElement.StyleDefault.setStyle("TextHighlightedBackgroundColor", 	"#000000");
CanvasElement.StyleDefault.setStyle("TextCaretColor", 					"#000000");


///////////CanvasElement Public Functions///////////////////////////////

/**
 * @function addStyleDefinition
 * Adds a style definition to the end element's definition list. Styles in this definition
 * will override styles in previously added definitions (lower index). Instance styles, set 
 * using setStyle() will override all definition styles.
 * Adding style definitions to elements already attached to the display chain is expensive, 
 * for better performance add definitions before attaching the element via addElement()
 * 
 * @param styleDefinition StyleDefinition
 * The StyleDefinition to add and associate with the element.
 * 
 * @returns StyleDefinition
 * The style definition just added.
 */
CanvasElement.prototype.addStyleDefinition = 
	function (styleDefinition)
	{
		return this.addStyleDefinitionAt(styleDefinition, this._styleDefinitions.length);
	};
	
/**
 * @function addStyleDefinitionAt
 * Inserts a style definition to this elements definition list at the specified index.
 * Definitions with higher indexes (added later) are higher priority. Instance styles, set 
 * using setStyle() will override all definition styles. 
 * Adding style definitions to elements already attached to the display chain is expensive, 
 * for better performance add definitions before attaching the element via addElement()
 * 
 * @param styleDefinition StyleDefinition
 * StyleDefinition to be added to this elements definition list.
 * 
 * @param index int
 * The index to insert the style definition within the elements definition list.
 * 
 * @returns StyleDefinition
 * Returns StyleDefinition just added when successfull, null if the StyleDefinition could not
 * be added due to the index being out of range or other error.
 */	
CanvasElement.prototype.addStyleDefinitionAt = 
	function (styleDefinition, index)
	{
		if (!(styleDefinition instanceof StyleDefinition))
			return null;
	
		if (index < 0 || index > this._styleDefinitions.length)
			return null;
		
		//Make sure this style definition is not already in the list (no adding duplicates)
		if (this._styleDefinitions.indexOf(styleDefinition) != -1 || styleDefinition == this._styleDefinitionDefault)
			return null;
		
		this._styleDefinitions.splice(index, 0, styleDefinition);
		
		if (this._manager != null) //Attached to display chain
		{
			styleDefinition.addEventListener("stylechanged", this._onExternalStyleChangedInstance);
			
			//_onExternalStyleChanged() is expensive! We use the map to make sure we only do each style once.
			var styleNamesMap = Object.create(null);
			var styleName = null;
			
			//We're shifting the priority of all existing style definitions with a lower index (previously added) 
			//when we add a new one, so we need to invoke a style change on all associated styles.
			
			//Record relevant style names
			for (var i = index; i >= 0; i--)
			{
				for (styleName in this._styleDefinitions[i]._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Spoof style changed events for normal handling.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		
		return styleDefinition;
	};
	
/**
 * @function removeStyleDefinition
 * Removes the supplied style definition from the element's style chain.
 * 
 * @param styleDefinition StyleDefinition
 * The StyleDefinition to remove from the element.
 * 
 * @returns StyleDefinition
 * The style definition just removed, or null if the supplied style 
 * definition is not associated with this element.
 */	
CanvasElement.prototype.removeStyleDefinition = 
	function (styleDefinition)
	{
		var index = this._styleDefinitions.indexOf(styleDefinition);
		if (index == -1)
			return null;
	
		return this.removeStyleDefinitionAt(index);
	};
	
/**
 * @function removeStyleDefinitionAt
 * Removes the style definition from the elements definition list at the supplied index.
 * 
 * @param index int
 * Index to be removed.
 * 
 * @returns StyleDefinition
 * Returns the StyleDefinition just removed if successfull, null if the definition could
 * not be removed due it it not being in this elements definition list, or index out of range.
 */		
CanvasElement.prototype.removeStyleDefinitionAt = 
	function (index)
	{
		if (index < 0 || index > this._styleDefinitions.length - 1)
			return null;
		
		if (this._manager != null) //Attached to display chain
		{
			//_onExternalStyleChanged() is expensive! We use the map to make sure we only do each style once.
			var styleNamesMap = Object.create(null);
			var styleName = null;
			
			//We're shifting the priority of all existing style definitions with a lower index (previously added) 
			//when we add a new one, so we need to invoke a style change on all associated styles.
			
			//Record relevant styles
			for (var i = index; i >= 0; i--)
			{
				for (styleName in this._styleDefinitions[i]._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Remove definition
			var styleDefinition = this._styleDefinitions.splice(index, 1)[0]; //Returns array of removed items.
			styleDefinition.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
			
			//Spoof style changed event for relevant styles.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		else //Not attached, just remove the definition
			this._styleDefinitions.splice(index, 1)
		
		return styleDefinition;
	};
	
/**
 * @function clearStyleDefinitions
 * Removes all style definitions from the element. This is more efficient than
 * removing definitions one at a time.
 */		
CanvasElement.prototype.clearStyleDefinitions = 
	function ()
	{
		if (this._manager != null) //Attached to display chain
		{
			//_onExternalStyleChanged() is expensive! We use the map to make sure we only do each style once.
			var styleNamesMap = Object.create(null);
			var styleDefinition = null;
			var styleName = null;
			
			for (var i = 0; i < this._styleDefinitions.length; i++)
			{
				styleDefinition = this._styleDefinitions[i];
				
				styleDefinition.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
				
				//Record removed style names
				for (styleName in styleDefinition._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Clear definitions
			this._styleDefinitions.splice(0, this._styleDefinitions.length);
			
			//Spoof a style changed event on all the styles we removed.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		else //Not attached, just clear the definition list.
			this._styleDefinitions.splice(0, this._styleDefinitions.length);
	};
	
/**
 * @function setStyleDefinitions
 * Replaces the elements current style definition list. This is more effecient than removing or 
 * adding style definitions one at a time.
 * 
 * @param styleDefinitions StyleDefinition
 * May be a StyleDefinition, or an Array of StyleDefinition
 */
CanvasElement.prototype.setStyleDefinitions = 
	function (styleDefinitions)
	{
		if (styleDefinitions == null)
			styleDefinitions = [];
		
		if (Array.isArray(styleDefinitions) == false)
			styleDefinitions = [styleDefinitions];
		
		var i = 0;
		
		//trim the definitions for duplicates
		for (i = styleDefinitions.length - 1; i >= 0; i--)
		{
			//Make sure this style definition is not already in the list (no adding duplicates)
			if (styleDefinitions.indexOf(styleDefinitions[i]) < i || styleDefinitions[i] == this._styleDefinitionDefault)
				styleDefinitions.splice(i, 1);
		}
		
		if (this._manager != null) //Attached to display chain
		{
			//Check if nothing changed before we do a bunch of work.
			if (styleDefinitions.length == this._styleDefinitions.length)
			{
				var changed = false;
				for (i = 0; i < styleDefinitions.length; i++)
				{
					if (styleDefinitions[i] != this._styleDefinitions[i])
					{
						changed = true;
						break;
					}
				}
				
				//No changes.
				if (changed == false)
					return;
			}
			
			var styleName = null;
			var styleNamesMap = Object.create(null);
			var styleDefinition = null;
			
			//Remove old
			while (this._styleDefinitions.length > 0)
			{
				styleDefinition = this._styleDefinitions[this._styleDefinitions.length - 1];
				this._styleDefinitions.splice(this._styleDefinitions.length - 1, 1);
				styleDefinition.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
				
				//Record removed style names
				for (styleName in styleDefinition._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Add new
			for (i = 0; i < styleDefinitions.length; i++)
			{
				styleDefinition = styleDefinitions[i];
				this._styleDefinitions.push(styleDefinition);
				styleDefinition.addEventListener("stylechanged", this._onExternalStyleChangedInstance);
				
				//Record added style names
				for (styleName in styleDefinition._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Spoof style changed events for normal style changed handling.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		else //Not attached to display chain, just swap the definitions
		{
			//Clear the definition list
			this._styleDefinitions.splice(0, this._styleDefinitions.length);
			
			//Add the new definitions.
			for (i = 0; i < styleDefinitions.length; i++)
				this._styleDefinitions.push(styleDefinitions[i]);
		}
	};
	
/**
 * @function getNumStyleDefinitions
 * Gets the number of style definitions associated with this element.
 * 
 * @returns int
 * The number of style definitions.
 */		
CanvasElement.prototype.getNumStyleDefinitions = 
	function ()
	{
		return this._styleDefinitions.length;
	};
	
/**
 * @function getStyleDefinitionAt
 * Gets the style definition at the supplied zero base index.
 * 
 * @param index int
 * Index of the style definition to return;
 * 
 * @returns StyleDefinition
 * The style defenition at the supplied index, or null if index is out of range. 
 */		
CanvasElement.prototype.getStyleDefinitionAt = 
	function (index)
	{
		if (index < 0 || index >= this._styleDefinitions.length)
			return null;
		
		return this._styleDefinitions[index];
	};
	
/**
 * @function getStyle
 * @override
 * 
 * Gets the style value for this element. When retrieving a style, CanvasElements look
 * through their associated style chain, at each step if undefined is returned, they look
 * at the next step until a non-undefined value is found.
 * 
 * 1) Instance - Styles set directly to the element via setStyle()
 * 2) StyleDefinitions - Styles associated via its assigned StyleDefinitions
 * 3) StyleProxy - If proxy element is assigned, move to proxy element and repeat steps 1-3
 * 4) Inheritable - If style is inheritable, move up to parent element and repeat steps 1-4
 * 5) Default styles
 * 
 * @seealso StyleProxy
 * @seealso StyleableBase
 * 
 * @param styleName String
 * String representing the style value to be returned.
 * 
 * @returns Any
 * Returns the associated style value if found, otherwise undefined.
 * 
 */
CanvasElement.prototype.getStyle = 
	function (styleName)
	{
		return CanvasElement.base.prototype.getStyle.call(this, styleName);
	};	
	
//@override
CanvasElement.prototype.getStyleData = 
	function (styleName)
	{
		//Create cache if does not exist.
		var styleCache = this._stylesCache[styleName];
		if (styleCache == null)
		{
			styleCache = {styleData:new StyleData(styleName), cacheInvalid:true};
			this._stylesCache[styleName] = styleCache;
		}
		
		//Check cache
		if (styleCache.cacheInvalid == false)
			return styleCache.styleData.clone();
		
		styleCache.cacheInvalid = false;
		var styleData = styleCache.styleData;
		
		//Reset the cache data.
		styleData.priority = [];
		styleData.value = undefined;
		
		//Check instance
		if (styleName in this._styleMap)
			styleData.value = this._styleMap[styleName];
		
		if (styleData.value !== undefined)
		{
			styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);
			return styleData.clone();
		}
		
		//Counters (priority depth)
		var ctr = 0;
		var ctr2 = 0;
		
		//Check definitions
		for (ctr = this._styleDefinitions.length - 1; ctr >= 0; ctr--)
		{
			styleData.value = this._styleDefinitions[ctr].getStyle(styleName);
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);
				styleData.priority.push((this._styleDefinitions.length - 1) - ctr); //StyleDefinition depth
				
				return styleData.clone();
			}
		}
		
		var proxy = null;
		var styleType = null;
		
		//Check proxy
		proxy = this._styleProxy;
		while (proxy != null)
		{
			styleType = proxy._proxyElement._getStyleType(styleName);
			
			if ((styleType != null && styleName in proxy._proxyMap == false) ||		//Defined & not in proxy map
				(styleType == null && "_Arbitrary" in proxy._proxyMap == false)) 	//Not defined and no _Arbitrary flag
				break;
			
			//Check proxy instance
			if (styleName in proxy._proxyElement._styleMap)
				styleData.value = proxy._proxyElement._styleMap[styleName];
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.PROXY);		
				styleData.priority.push(ctr);	//Proxy depth (chained proxies)
				styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);	
				
				return styleData.clone();
			}
			
			//Check proxy definitions
			for (ctr2 = proxy._proxyElement._styleDefinitions.length - 1; ctr2 >= 0; ctr2--)
			{
				styleData.value = proxy._proxyElement._styleDefinitions[ctr2].getStyle(styleName);
				
				if (styleData.value !== undefined)
				{
					styleData.priority.push(CanvasElement.StylePriorities.PROXY);
					styleData.priority.push(ctr);	//Proxy depth (chained proxies)
					styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);	
					styleData.priority.push((proxy._proxyElement._styleDefinitions.length - 1) - ctr2); //definition depth	
					
					return styleData.clone();
				}
			}
			
			ctr++;
			proxy = proxy._proxyElement._styleProxy;
		}
		
		//Check inherited
		proxy = null;
		styleType = null;
		ctr = 0;
		ctr2 = 0;
		
		var parent = this;
		var ctr3 = 0;
		
		while (true)
		{
			styleType = parent._getStyleType(styleName);
			if (styleType == null || styleType.inheritable == false)
				break;
			
			parent = parent._parent;
			
			if (parent == null)
				break;
			
			//Check parent instance
			if (styleName in parent._styleMap)
				styleData.value = parent._styleMap[styleName];
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.INHERITED);	
				styleData.priority.push(ctr);	//Parent depth
				styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);
				
				return styleData.clone();
			}
			
			//Check style definitions
			for (ctr2 = parent._styleDefinitions.length - 1; ctr2 >= 0; ctr2--)
			{
				styleData.value = parent._styleDefinitions[ctr2].getStyle(styleName);
				
				if (styleData.value !== undefined)
				{
					styleData.priority.push(CanvasElement.StylePriorities.INHERITED);	
					styleData.priority.push(ctr);	//Parent depth
					styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);
					styleData.priority.push((parent._styleDefinitions.length - 1) - ctr2); //Definition depth	
					
					return styleData.clone();
				}
			}
			
			//Check parent proxy
			proxy = parent._styleProxy;
			ctr2 = 0;
			while (proxy != null)
			{
				styleType = proxy._proxyElement._getStyleType(styleName);
				
				if ((styleType != null && styleName in proxy._proxyMap == false) ||		//Defined & not in proxy map
					(styleType == null && "_Arbitrary" in proxy._proxyMap == false)) 	//Not defined and no _Arbitrary flag
					break;
				
				//Check proxy instance
				if (styleName in proxy._proxyElement._styleMap)
					styleData.value = proxy._proxyElement._styleMap[styleName];
				
				if (styleData.value !== undefined)
				{
					styleData.priority.push(CanvasElement.StylePriorities.INHERITED);		
					styleData.priority.push(ctr);	//Parent depth
					styleData.priority.push(CanvasElement.StylePriorities.PROXY);		
					styleData.priority.push(ctr2);	//Proxy depth (chained proxies)
					styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);		
					
					return styleData.clone();
				}
				
				//Check proxy definition
				for (ctr3 = proxy._proxyElement._styleDefinitions.length - 1; ctr3 >= 0; ctr3--)
				{
					styleData.value = proxy._proxyElement._styleDefinitions[ctr3].getStyle(styleName);
					
					if (styleData.value !== undefined)
					{
						styleData.priority.push(CanvasElement.StylePriorities.INHERITED);	
						styleData.priority.push(ctr);	//Parent depth
						styleData.priority.push(CanvasElement.StylePriorities.PROXY);	
						styleData.priority.push(ctr2);	//Proxy depth (chained proxies)
						styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);
						styleData.priority.push((parent._styleDefinitions.length - 1) - ctr3); //Definition depth	
						
						return styleData.clone();
					}
				}

				ctr2++;
				proxy = proxy._proxyElement._styleProxy;
			}
			
			ctr++;
		}
		
		//Check default definition
		if (this._styleDefinitionDefault != null)
			styleData.value = this._styleDefinitionDefault.getStyle(styleName);
			
		if (styleData.value !== undefined)
		{
			styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_DEFINITION);
			return styleData.clone();
		}	
		
		//Check default proxy
		proxy = this._styleProxy;
		ctr = 0;
		while (proxy != null)
		{
			styleType = proxy._proxyElement._getStyleType(styleName);
			
			if ((styleType != null && styleName in proxy._proxyMap == false) ||		//Defined & not in proxy map
				(styleType == null && "_Arbitrary" in proxy._proxyMap == false)) 	//Not defined and no _Arbitrary flag
				break;
			
			if (proxy._proxyElement._styleDefinitionDefault != null)
				styleData.value = proxy._proxyElement._styleDefinitionDefault.getStyle(styleName);
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_PROXY);
				styleData.priority.push(ctr);	//Proxy depth (chained proxies)
				
				return styleData.clone();
			}
			
			ctr++;
			proxy = proxy._proxyElement._styleProxy;
		}
			
		//Check class
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(CanvasElement.StylePriorities.CLASS);
		
		return styleData.clone();		
	};
	
//@override	
CanvasElement.prototype.setStyle = 
	function (styleName, value)
	{
		var oldValue = undefined;
		if (styleName in this._styleMap)
			oldValue = this._styleMap[styleName];

		//No change
		if (oldValue === value)
			return;
		
		if (value === undefined)
			delete this._styleMap[styleName];
		else
			this._styleMap[styleName] = value;
		
		//Spoof a style changed event and pass it to _onExternalStyleChanged for normal handling
		this._onExternalStyleChanged(new StyleChangedEvent(styleName));
	};			

/**
 * @function getManager
 * Gets the CanvasManager currently associated with this element.
 * 
 * @returns CanvasManager
 * The CanvasManager currently associated with this element.
 */	
CanvasElement.prototype.getManager = 
	function ()
	{
		return this._manager;
	};

/**
 * @function setName
 * Sets an arbitrary name to this element. The system does not use this value,
 * it is for use by implementors if a way to differentiate elements is needed.
 * 
 * @param name String
 * A String to use as the element's name.
 */	
CanvasElement.prototype.setName = 
	function (name)
	{
		if (this._name == name)
			return false;
		
		this._name = name;
		return true;
	};
	
/**
 * @function getName
 * Gets the name associated with this element.
 * 
 * @returns String
 * The name associated with this element.
 */		
CanvasElement.prototype.getName = 
	function ()
	{
		return this._name;
	};
	
/**
 * @function getMouseIsDown
 * Gets the state of the mouse for this element.
 * 
 * @returns boolean
 * Returns true if the mouse is currently pressed, false otherwise.
 */		
CanvasElement.prototype.getMouseIsDown = 
	function()
	{
		return this._mouseIsDown;
	};	

/**
 * @function getParent
 * Gets this element's parent element.
 * 
 * @returns CanvasElement
 * This element's parent element.
 */		
CanvasElement.prototype.getParent = 
	function ()
	{
		return this._parent;
	};
	
/**
 * @function rotatePoint
 * Rotates a point point on this element's parent relative to this element's rotation transformation.
 * This is used to transform a point from the parent's coordinate plane to a child's coordinate plane or vice versa.
 * Typically you should use translatePointFrom() or translatePointTo() rather than rotatePoint().
 * 
 * @param point Object
 * Point object {x:0, y:0};
 * 
 * @param reverse boolean
 * When true, rotates a point on the parent's plane, to the childs plane. 
 * When false, rotates a point on the childs plane, to the parents plane.
 */	
CanvasElement.prototype.rotatePoint = 
	function (point, reverse)
	{
		if (this._rotateDegrees == 0)
			return;
		
		var radius = 
			Math.sqrt(
					(Math.abs(point.x - this._rotateCenterX) * Math.abs(point.x - this._rotateCenterX)) +
					(Math.abs(point.y - this._rotateCenterY) * Math.abs(point.y - this._rotateCenterY))
					);
		
		var degrees;
		if (reverse == false)
			degrees = 360 - this._rotateDegrees + CanvasElement.radiansToDegrees(Math.atan2(point.x - this._rotateCenterX, point.y - this._rotateCenterY));
		else
			degrees = 360 + this._rotateDegrees + CanvasElement.radiansToDegrees(Math.atan2(point.x - this._rotateCenterX, point.y - this._rotateCenterY));
			
		point.x = Math.sin(CanvasElement.degreesToRadians(degrees)) * radius + this._rotateCenterX;
		point.y = Math.cos(CanvasElement.degreesToRadians(degrees)) * radius + this._rotateCenterY;
	};

/**
 * @function translatePointFrom
 * Translates a point from an element to this element regardless of this element's transformation,
 * depth, or position in the display hierarchy. For example, you can call this to translate a point on
 * the canvas to the relative point on this element.
 * 
 * @param point Object
 * Point - object containing {x:0, y:0}.
 * 
 * @param relativeFromElement CanvasElement
 * The element that the supplied point is relative too.
 */	
CanvasElement.prototype.translatePointFrom = 
	function (point, relativeFromElement)
	{
		return relativeFromElement.translatePointTo(point, this);
	};

/**
 * @function translatePointTo
 * Translates a point from this element to another element regardless of this element's transformation,
 * depth, or position in the display hierarchy. For example, you can call this to translate a point on
 * this element to a point on the canvas.
 * 
 * @param point Object
 * Point - object containing {x:0, y:0}.
 * 
 * @param relativeToElement CanvasElement
 * The element to translate this element's point too.
 */		
CanvasElement.prototype.translatePointTo = 
	function (point, relativeToElement)
	{
		if (relativeToElement == null || relativeToElement == this)
			return false;
		
		if (this._manager == null || this._manager != relativeToElement._manager)
			return false;
		
		//Build up both parent chains so we can find common parent//
		////////////////////////////////////////////////////////////
		
		var commonParent = null;
		
		//We are a child of relativeElement
		var thisChain = [];
		thisChain.push(this);
		while (commonParent == null && thisChain[thisChain.length - 1]._parent != null)
		{
			if (thisChain[thisChain.length - 1]._parent == relativeToElement)
				commonParent = relativeToElement;
			else
				thisChain.push(thisChain[thisChain.length - 1]._parent);
		}
		
		//Relative element is a child of us.
		var relativeChain = [];
		if (commonParent == null)
		{
			relativeChain.push(relativeToElement);
			while (commonParent == null && relativeChain[thisChain.length - 1]._parent != null)
			{
				if (relativeChain[relativeChain.length - 1]._parent == this)
					commonParent = this;
				else
					relativeChain.push(relativeChain[relativeChain.length - 1]._parent);
			}
		}
		
		//Someone is doing something weird and we're not in each others direct chains so we have to translate up AND down.
		if (commonParent == null)
		{
			//We know we have the same canvas manager, so just keep popping both arrays till we find something different.
			while (thisChain[thisChain.length - 1] == relativeChain[relativeChain.length - 1])
			{
				commonParent = thisChain[thisChain.length - 1];
				
				thisChain.pop();
				relativeChain.pop();
			}
		}
		
		//Translate up to common parent.
		var currentParent = this;
		while (currentParent != null && currentParent != commonParent)
		{
			point.x += currentParent._x;
			point.y += currentParent._y;
			
			currentParent.rotatePoint(point, false);
			
			currentParent = currentParent._parent;
		}
		
		//Translate down to relativeElement
		for (var i = relativeChain.length - 1; i >= 0; i--)
		{
			//Rotate the point backwards so we can translate the point to the element's rotated plane.
			relativeChain[i].rotatePoint(point, true);
			
			//Adjust the mouse point to within this element rather than its position in parent.
			point.x -= relativeChain[i]._x;
			point.y -= relativeChain[i]._y;
		}
		
		return true;
	};
	
/**
 * @function translateMetricsFrom
 * Translates a DrawMetrics from another element's to this element regardless of this element's transformation,
 * depth, or position in the display hierarchy. 
 * 
 * @param metrics DrawMetrics
 * Metrics to transform from the relative to this element.
 * 
 * @param relativeFromElement CanvasElement
 * The element to translate the supplied metrics too. If relativeToElement equals
 * null or this, will return metrics the same as the supplied metrics.
 * 
 * @returns DrawMetrics
 * Translated DrawMetrics relative to the supplied element.
 */	
CanvasElement.prototype.translateMetricsFrom = 	
	function (metrics, relativeFromElement)
	{
		return relativeFromElement.translateMetricsTo(metrics, this);
	};
	
/**
 * @function translateMetricsTo
 * Translates a DrawMetrics from this element's to another element regardless of this element's transformation,
 * depth, or position in the display hierarchy. 
 * 
 * @param metrics DrawMetrics
 * Metrics to transform to from this element to the supplied relative element.
 * 
 * @param relativeToElement CanvasElement
 * The element to translate the supplied metrics too. If relativeToElement equals
 * null or this, will return metrics the same as the supplied metrics.
 * 
 * @returns DrawMetrics
 * Translated DrawMetrics relative to the supplied element.
 */	
CanvasElement.prototype.translateMetricsTo = 
	function (metrics, relativeToElement)
	{
		var translatedMetrics = new DrawMetrics();
		if (relativeToElement == null || relativeToElement == this)
		{
			translatedMetrics._x = metrics._x;
			translatedMetrics._y = metrics._y;
			translatedMetrics._width = metrics._width;
			translatedMetrics._height = metrics._height;
			
			return translatedMetrics;
		}

		if (this._manager == null || this._manager != relativeToElement._manager)
			return null;
		
		//Build up both parent chains so we can find common parent.
		var commonParent = null;
		
		//We are a child of relativeElement
		var thisChain = [];
		thisChain.push(this);
		while (commonParent == null && thisChain[thisChain.length - 1]._parent != null)
		{
			if (thisChain[thisChain.length - 1]._parent == relativeToElement)
				commonParent = relativeToElement;
			else
				thisChain.push(thisChain[thisChain.length - 1]._parent);
		}
		
		//Relative element is a child of us.
		var relativeChain = [];
		if (commonParent == null)
		{
			relativeChain.push(relativeToElement);
			while (commonParent == null && relativeChain[thisChain.length - 1]._parent != null)
			{
				if (relativeChain[relativeChain.length - 1]._parent == this)
					commonParent = this;
				else
					relativeChain.push(relativeChain[relativeChain.length - 1]._parent);
			}
		}
		
		//Someone is doing something weird and we're not in each others direct chains so we have to translate up AND down.
		if (commonParent == null)
		{
			//We know we have the same canvas manager, so just keep popping both arrays till we find something different.
			while (thisChain[thisChain.length - 1] == relativeChain[relativeChain.length - 1])
			{
				commonParent = thisChain[thisChain.length - 1];
				
				thisChain.pop();
				relativeChain.pop();
			}
		}
		
		var pointTl = {x:metrics._x, y:metrics._y};
		var pointTr = {x:metrics._x + metrics._width, y:metrics._y};
		var pointBr = {x:metrics._x + metrics._width, y:metrics._y + metrics._height};
		var pointBl = {x:metrics._x, y:metrics._y + metrics._height};
		
		//Translate up to common parent.
		var currentParent = this;
		while (currentParent != null && currentParent != commonParent)
		{
			pointTl.x += currentParent._x;
			pointTl.y += currentParent._y;
			
			pointTr.x += currentParent._x;
			pointTr.y += currentParent._y;
			
			pointBr.x += currentParent._x;
			pointBr.y += currentParent._y;
			
			pointBl.x += currentParent._x;
			pointBl.y += currentParent._y;
			
			currentParent.rotatePoint(pointTl, false);
			currentParent.rotatePoint(pointTr, false);
			currentParent.rotatePoint(pointBl, false);
			currentParent.rotatePoint(pointBr, false);
			
			currentParent = currentParent._parent;
		}
		
		//Translate down to relativeElement
		for (var i = relativeChain.length - 1; i >= 0; i--) 
		{
			//Rotate the point backwards so we can translate the point to the element's rotated plane.
			relativeChain[i].rotatePoint(pointTl, true);
			relativeChain[i].rotatePoint(pointTr, true);
			relativeChain[i].rotatePoint(pointBl, true);
			relativeChain[i].rotatePoint(pointBr, true);
			
			//Adjust the mouse point to within this element rather than its position in parent.
			pointTl.x -= relativeChain[i]._x;
			pointTl.y -= relativeChain[i]._y;
			
			pointTr.x -= relativeChain[i]._x;
			pointTr.y -= relativeChain[i]._y;
			
			pointBr.x -= relativeChain[i]._x;
			pointBr.y -= relativeChain[i]._y;
			
			pointBl.x -= relativeChain[i]._x;
			pointBl.y -= relativeChain[i]._y;
		}
		
		var minX = Math.min(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
		var maxX = Math.max(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
		var minY = Math.min(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
		var maxY = Math.max(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
		
		translatedMetrics._x = minX;
		translatedMetrics._y = minY;
		translatedMetrics._width = maxX - minX;
		translatedMetrics._height = maxY - minY;
		
		return translatedMetrics;
	};	
	
/**
 * @function getMetrics
 * Gets a DrawMetrics object containing the elements bounding box information
 * x, y, width, height, relative to the supplied element regardless of this element's transformation,
 * depth, or position in the display hierarchy. For example, you can call this get the elements width and height,
 * or to get this element's bounding box relative to the canvas or any other element.
 * 
 * @param relativeToElement CanvasElement
 * The element to translate this elements bounding box too. If relativeToElement equals
 * null or this, will return metrics relative to this element: {x:0, y:0, width:thisWidth, height:thisHeight}.
 * 
 * @returns DrawMetrics
 * DrawMetrics of this element relative to the supplied element.
 */	
CanvasElement.prototype.getMetrics = 
	function (relativeToElement)
	{
		if (relativeToElement == null)
			relativeToElement = this;
	
		if (this._manager == null || this._manager != relativeToElement._manager)
			return null;
	
		var metrics = new DrawMetrics();
		metrics._x = 0;
		metrics._y = 0;
		metrics._width = this._width;
		metrics._height = this._height;
		
		if (relativeToElement == this)
			return metrics;
		
		return this.translateMetricsTo(metrics, relativeToElement);
	};

//@Override
CanvasElement.prototype.addEventListener = 	
	function (type, callback)
	{
		CanvasElement.base.prototype.addEventListener.call(this, type, callback);
	
		//Broadcast events (dispatched only by manager)
		if ((type == "enterframe" || 
			type == "localechanged" || 
			type == "mousemoveex") &&
			this._manager != null)
		{
			this._manager._broadcastDispatcher.addEventListener(type, callback);
		}
		
		return true;
	};

//@Override	
CanvasElement.prototype.removeEventListener = 
	function (type, callback)
	{
		if (CanvasElement.base.prototype.removeEventListener.call(this, type, callback) == true)
		{
			//Broadcast events (dispatched only by manager)
			if ((type == "enterframe" || 
				type == "localechanged" || 
				type == "mousemoveex") &&
				this._manager != null)
			{
				this._manager._broadcastDispatcher.removeEventListener(type, callback);
			}
			
			return true;
		}
		
		return false;
	};	

	
////////////Capture Phase Event Listeners///////////////////////	
	
/**
 * @function addCaptureListener
 * Registers an event listener function to be called during capture phase.
 * 
 * @seealso ElementEvent
 * 
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function to be called when the event occurs.
 */	
CanvasElement.prototype.addCaptureListener = 
	function (type, callback)
	{
		if (this._captureListeners[type] == null)
			this._captureListeners[type] = [];
		
		this._captureListeners[type].push(callback);
		
		return true;
	};

/**
 * @function removeCaptureListener
 * Removes a capture event listener.
 * 
 * @seealso ElementEvent
 * 
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be removed.
 * 
 * @returns boolean
 * Returns true if the callback was successfully removed, otherwise false
 * such as if the function callback was not previously registered.
 */		
CanvasElement.prototype.removeCaptureListener = 
	function (type, callback)
	{
		if (!(type in this._captureListeners))
			return false;
	
		for (var i = 0; i < this._captureListeners[type].length; i++)
		{
			if (this._captureListeners[type][i] == callback)
			{
				this._captureListeners[type].splice(i, 1);
				return true;
			}
		}
		
		return false;
	};

/**
 * @function hasCaptureListener
 * Checks if an event capture listener has been registered with this CanvasElement
 * 
 * @seealso ElementEvent
 * 
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be called when the event occurs. This may be null to check
 * if the CanvasElement has any capture events registered for the provided type.
 * 
 * @returns boolean
 * Returns true if the CanvasElement has the provided capture callback registered for the 
 * provided type, or any capture callback for the provided type if the callback parameter is null.
 * Otherwise, returns false.
 */		
CanvasElement.prototype.hasCaptureListener = 
	function (type, callback)
	{
		if (!(type in this._captureListeners))
			return false;
	
		if (callback == null && this._captureListeners[type].length > 0)
			return true;
		
		for (var i = 0; i < this._captureListeners[type].length; i++)
		{
			if (this._captureListeners[type][i] == callback)
				return true;
		}
		
		return false;
	};	
	
/////////////CanvasElement Public Static Functions//////////////////

/**
 * @function adjustColorLight
 * @static
 * Adjusts supplied color brightness.
 * 
 * @param color String
 * Hex color value be adjusted. Format like "#FF0000" (red)
 * 
 * @param percent Number
 * Value between -1 and +1. -1 will return white. +1 will return black.
 * 
 * @returns String
 * Adjusted Hex color value.
 */
//Looks complicated... not really. Its using a percentage of the distance between black(neg) or white(pos) on all 3 channels independently.
CanvasElement.adjustColorLight = 
	function (color, percent) 
	{   
	    var f = parseInt(color.slice(1), 16);
	    var t = percent < 0 ? 0 : 255;
	    var p = percent < 0 ? percent * -1 : percent;
	    var R = f >> 16;
	    var G = f >> 8 & 0x00FF;
	    var B = f & 0x0000FF;
	    
	    return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
	};
	
/**
 * @function radiansToDegrees
 * @static
 * Calculates radians to degrees.
 * 
 * @param radians Number
 * Radians to be calculated to degrees.
 * 
 * @returns Number
 * Resulting degrees from supplied radians.
 */	
CanvasElement.radiansToDegrees = 
	function (radians)
	{
		return radians * (180 / Math.PI);
	};
	
/**
 * @function degreesToRadians
 * @static
 * Calculates degrees to radians.
 * 
 * @param degrees Number
 * Degrees to be calculated to degrees.
 * 
 * @returns Number
 * Resulting radians from supplied degrees.
 */		
CanvasElement.degreesToRadians = 
	function (degrees)
	{
		return degrees * (Math.PI / 180);
	};

/**
 * @function normalizeDegrees
 * @static
 * Adjusts degrees less than 0 or greater than 360 to corresponding degrees between 0 and 360. 
 * This is useful when rotating an element by increments.
 * 
 * @param value Number
 * Degrees to normalize.
 * 
 * @returns Number
 * Degrees between 0 and 360.
 */	
CanvasElement.normalizeDegrees = 
	function (value)
	{
		while (value >= 360)
			value = value - 360;
		while (value < 0)
			value = value + 360;
		
		return value;
	};	

/**
 * @function roundToPrecision
 * @static
 * Rounds a number to specified precision (decimal points).
 * 
 * @param value Number
 * Number to round.
 * 
 * @param precision int
 * Number of decimal points.
 * 
 * @returns Number
 * Rounded value.
 */	
CanvasElement.roundToPrecision = 
	function (value, precision)
	{
		if (precision == 0)
			return Math.round(value);
		
		var multiplier = Math.pow(10, precision);
		
		value = value * multiplier;
		value = Math.round(value);
		return value / multiplier;
	};
	
/////////////CanvasElement Internal Static Functions//////////////////	
	
CanvasElement._browserType = "";	
	
//Map of maps for character widths by font size/style. Some browsers render canvas text by pixel rather 
//than character width. For example, an uppercase "T" with a lowercase "e" next to it ("Te"), 
//the "e" will actually render overlapping the "T" since the "e" is not tall enough to collide with the top of the "T". 
//This doesnt work for word processing, we need to be able to identify each character so we measure and 
//store character widths here, and render all text on a character by character basis for consistency.
CanvasElement._characterWidthMap = Object.create(null); 

CanvasElement._characterFillBitmapMap = Object.create(null);
CanvasElement._characterStrokeBitmapMap = Object.create(null);

CanvasElement._measureCharBitmap = null;
CanvasElement._measureCharContext = null;
(	function () 
	{
		CanvasElement._measureCharBitmap = document.createElement("canvas");
		CanvasElement._measureCharBitmap.width = 1;
		CanvasElement._measureCharBitmap.height = 1;
		
		CanvasElement._measureCharContext = CanvasElement._measureCharBitmap.getContext("2d");
	}
)();

/**
 * @function _measureText
 * @static
 * Measures text on a character by character basis. Unfortunately, browsers will give
 * different widths for strings of text, than text measured character by character. It appears
 * text width changes depending on which characters are next to which characters. This behavior
 * cannot be used for text that requires highlighting or editing. This function records the character
 * width per font in a map, and then uses that map to measure text widths. This surprisingly turns out to be 
 * just as fast as measuring full text via the canvas context (since canvas sucks so bad at text rendering).
 * 
 * @param text String
 * The text string to measure.
 * 
 * @param fontString String
 * Font styling to use when measuring. Use _getFontString()
 * 
 * @returns Number
 * Width of the text as measured via characters.
 */
CanvasElement._measureText = 
	function (text, fontString)
	{
		var charMap = CanvasElement._characterWidthMap[fontString];
		if (charMap == null)
		{
			charMap = Object.create(null);
			CanvasElement._characterWidthMap[fontString] = charMap;
		}
		
		var result = 0;
		var charWidth = 0;
		var fontSet = false;
		
		for (var i = 0; i < text.length; i++)
		{
			charWidth = charMap[text[i]];
			if (charWidth == null)
			{
				if (fontSet == false) 
				{
					CanvasElement._measureCharContext.font = fontString;
					fontSet = true;
				}
				
				charWidth = Math.ceil(CanvasElement._measureCharContext.measureText(text[i]).width);
				charMap[text[i]] = charWidth;
			}
			
			result += charWidth;
		}
		
		return result;
	};

/**
 * @function _fillText
 * @static
 * Renders text on a character by character basis. Unfortunately, browsers will give
 * different widths for strings of text, than text measured character by character. It appears
 * text width changes depending on which characters are next to which characters. This behavior
 * cannot be used for text that requires highlighting or editing. This function records character
 * bitmaps per font in a map, and then uses that map to render characters. This surprisingly turns out to be 
 * just as fast as rendering full text via the canvas context (since canvas sucks so bad at text rendering).
 * 
 * @param ctx Canvas2DContext
 * The canvas context to render the text. 
 * 
 * @param text String
 * The text string to render.
 * 
 * @param x Number
 * The X coordinate to render the text.
 * 
 * @param y Number
 * The Y coordinate to render the text.
 * 
 * @param fontString String
 * Font styling to use when measuring. Use _getFontString()
 * 
 * @param color String
 * Hex color value to be used to render the text. Format like "#FF0000" (red).
 * 
 * @param baseline String
 * Text Y position relative to Y coordinate. ("top", "middle", or "bottom")
 */	
CanvasElement._fillText = 
	function (ctx, text, x, y, fontString, color, baseline)
	{
		var bitmapMap = CanvasElement._characterFillBitmapMap[fontString];
		if (bitmapMap == null)
		{
			bitmapMap = Object.create(null);
			CanvasElement._characterFillBitmapMap[fontString] = bitmapMap;
		}
		
		for (var i = 0; i < text.length; i++)
		{
			var bitmapAndContext = bitmapMap[text[i]];
			
			if (bitmapAndContext == null)
			{
				bitmapAndContext = {canvas:null, context:null, fontSize:0};
				bitmapMap[text[i]] = bitmapAndContext;
				
				bitmapAndContext.canvas = document.createElement("canvas");
				
				var fontSplit = fontString.split(" ");
				var fontSize = 0;
				for (var i2 = 0; i2 < fontSplit.length; i2++)
				{
					if (fontSplit[i2].length >= 3)
					{
						var pxString = fontSplit[i2].substr(fontSplit[i2].length - 2, 2);
						if (pxString == "px")
						{
							fontSize = Number(fontSplit[i2].substr(0, fontSplit[i2].length - 2));
							break;
						}
					}
				}
				
				bitmapAndContext.fontSize = fontSize;
				
				bitmapAndContext.canvas.height = fontSize + 4;
				bitmapAndContext.canvas.width = CanvasElement._measureText(text[i], fontString);
				
				bitmapAndContext.context = bitmapAndContext.canvas.getContext("2d");
				bitmapAndContext.context.font = fontString;
				bitmapAndContext.context.textBaseline = "middle";
				bitmapAndContext.context.textAlign = "left";
				bitmapAndContext.context.strokeStyle = "#000000";
				bitmapAndContext.context.fillStyle = "#000000";
				bitmapAndContext.context.fillText(text[i], 0, bitmapAndContext.canvas.height / 2);
				
				bitmapAndContext.context.globalCompositeOperation = "source-atop";
			}
			
			if (bitmapAndContext.context.fillStyle != color) 
			{
				bitmapAndContext.context.fillStyle = color;
				
				bitmapAndContext.context.beginPath();
				bitmapAndContext.context.moveTo(0, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, bitmapAndContext.canvas.height);
				bitmapAndContext.context.lineTo(0, bitmapAndContext.canvas.height);
				bitmapAndContext.context.closePath();
				
				bitmapAndContext.context.fill();
			}
			
			if (baseline == "top")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - ((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2)));
			else if (baseline == "bottom")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2) + bitmapAndContext.fontSize)));
			else //	"middle"
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (bitmapAndContext.canvas.height / 2)));
			
			if (text.length == 1)
				return;
			
			x += CanvasElement._measureText(text[i], fontString);
		}
	};	
	
/**
 * @function _strokeText
 * @static
 * Renders text on a character by character basis. Unfortunately, browsers will give
 * different widths for strings of text, than text measured character by character. It appears
 * text width changes depending on which characters are next to which characters. This behavior
 * cannot be used for text that requires highlighting or editing. This function records character
 * bitmaps per font in a map, and then uses that map to render characters. This surprisingly turns out to be 
 * just as fast as rendering full text via the canvas context (since canvas sucks so bad at text rendering).
 * 
 * @param ctx Canvas2DContext
 * The canvas context to render the text. 
 * 
 * @param text String
 * The text string to render.
 * 
 * @param x Number
 * The X coordinate to render the text (Upper left).
 * 
 * @param y Number
 * The Y coordinate to render the text (Uppder left).
 * 
 * @param fontString String
 * Font styling to use when measuring. Use _getFontString()
 * 
 * @param color String
 * Hex color value to be used to render the text. Format like "#FF0000" (red).
 * 
 * @param baseline String
 * Text Y position relative to Y coordinate. ("top", "middle", or "bottom")
 */	
CanvasElement._strokeText = 
	function (ctx, text, x, y, fontString, color, baseline)
	{
		var bitmapMap = CanvasElement._characterStrokeBitmapMap[fontString];
		if (bitmapMap == null)
		{
			bitmapMap = Object.create(null);
			CanvasElement._characterStrokeBitmapMap[fontString] = bitmapMap;
		}
		
		for (var i = 0; i < text.length; i++)
		{
			var bitmapAndContext = bitmapMap[text[i]];
			
			if (bitmapAndContext == null)
			{
				bitmapAndContext = {canvas:null, context:null};
				bitmapMap[text[i]] = bitmapAndContext;
				
				bitmapAndContext.canvas = document.createElement("canvas");
				
				var fontSplit = fontString.split(" ");
				var fontSize = 0;
				for (var i2 = 0; i2 < fontSplit.length; i2++)
				{
					if (fontSplit[i2].length >= 3)
					{
						var pxString = fontSplit[i2].substr(fontSplit[i2].length - 2, 2);
						if (pxString == "px")
						{
							fontSize = Number(fontSplit[i2].substr(0, fontSplit[i2].length - 2));
							break;
						}
					}
						
				}
				
				bitmapAndContext.fontSize = fontSize;
				
				bitmapAndContext.canvas.height = fontSize + 4;
				bitmapAndContext.canvas.width = CanvasElement._measureText(text[i], fontString);
				
				bitmapAndContext.context = bitmapAndContext.canvas.getContext("2d");
				bitmapAndContext.context.font = fontString;
				bitmapAndContext.context.textBaseline = "middle";
				bitmapAndContext.context.textAlign = "left";
				bitmapAndContext.context.strokeStyle = "#000000";
				bitmapAndContext.context.fillStyle = "#000000";
				bitmapAndContext.context.strokeText(text[i], 0, bitmapAndContext.canvas.height / 2);
				
				bitmapAndContext.context.globalCompositeOperation = "source-atop";
			}
			
			if (bitmapAndContext.context.fillStyle != color) 
			{
				bitmapAndContext.context.fillStyle = color;
				
				bitmapAndContext.context.beginPath();
				bitmapAndContext.context.moveTo(0, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, bitmapAndContext.canvas.height);
				bitmapAndContext.context.lineTo(0, bitmapAndContext.canvas.height);
				bitmapAndContext.context.closePath();
				
				bitmapAndContext.context.fill();
			}
			
			if (baseline == "top")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - ((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2)));
			else if (baseline == "bottom")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2) + bitmapAndContext.fontSize)));
			else //	"middle"
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (bitmapAndContext.canvas.height / 2)));
			
			if (text.length == 1)
				return;
			
			x += CanvasElement._measureText(text[i], fontString);
		}
	};		
	
/**
 * @function _calculateMinMaxPercentSizes
 * @static
 * Used to calculate size in pixels that percent sized elements should consume given
 * a supplied size in pixels. Populates .actualSize field on objects in supplied 
 * percentSizedObjects array. This function automatically rounds all sizes to the
 * nearest pixel to prevent anti-aliasing and fuzzy lines.
 * 
 * @param percentSizedObjects Array
 * Array of objects containing size data: {minSize:Number, maxSize:Number, percentSize:Number}
 * 
 * @param size Number
 * Available size in pixels.
 */
CanvasElement._calculateMinMaxPercentSizes = 
	function (percentSizedObjects, size)
	{
		if (percentSizedObjects.length == 0)
			return;
	
		var percentObjects = percentSizedObjects.slice();
		var availableSize = size;
		var totalPercentUsed = 0;
		var i;
		
		//Fix values, record total percent used.
		for (i = 0; i < percentObjects.length; i++)
		{
			if (percentObjects[i].minSize == null)
				percentObjects[i].minSize = 0;
			if (percentObjects[i].maxSize == null)
				percentObjects[i].maxSize = Number.MAX_VALUE;
			if (percentObjects[i].percentSize == null)
				percentObjects[i].percentSize = 100;
			
			totalPercentUsed += percentObjects[i].percentSize;
		}
		
		//Size all percent sized elements.
		var done = false;
		while (done == false)
		{
			var size = 0;
			done = true;
			
			for (i = 0; i < percentObjects.length; i++)
			{
				size = availableSize * (percentObjects[i].percentSize / totalPercentUsed);
				if (size > percentObjects[i].maxSize)
				{
					percentObjects[i].actualSize = percentObjects[i].maxSize;
					totalPercentUsed -= percentObjects[i].percentSize;
					availableSize -= percentObjects[i].maxSize;
					
					percentObjects.splice(i, 1);
					done = false;
					break;
				}
				else if (size < percentObjects[i].minSize)
				{
					percentObjects[i].actualSize = percentObjects[i].minSize;
					totalPercentUsed -= percentObjects[i].percentSize;
					availableSize -= percentObjects[i].minSize;
					
					percentObjects.splice(i, 1);
					done = false;
					break;
				}
				else
					percentObjects[i].actualSize = Math.floor(size);
			}
		}
		
		for (i = 0; i < percentObjects.length; i++)
			availableSize -= percentObjects[i].actualSize;
		
		//Distribute excess pixels (rounding error)
		while (availableSize >= 1 && percentObjects.length > 0)
		{
			for (i = 0; i < percentObjects.length; i++)
			{
				while (percentObjects[i].actualSize + 1 > percentObjects[i].maxSize)
				{
					percentObjects.splice(i, 1);
					if (i == percentObjects.length)
						break;
				}
				
				if (i == percentObjects.length)
					break;
				
				percentObjects[i].actualSize++;
				availableSize--;
				
				if (availableSize <= 0)
					break;
			}
		}
	};
	
///////////////CanvasElement Internal Functions////////////////////////////////////

//@private	
CanvasElement.prototype._onBackgroundShapeStyleChanged = 
	function (styleChangedEvent)
	{
		this._invalidateRender();
	};
	
//@private	
CanvasElement.prototype._onExternalStyleChanged = 
	function (styleChangedEvent)
	{
		//Not attached to display chain, bail.
		if (this._manager == null)
			return;
		
		var isProxy = false;
		var isParent = false;
		var validStyle = false;
		var styleName = styleChangedEvent.getStyleName();	
		var styleType = this._getStyleType(styleName);
		
		if (this._styleProxy != null &&  styleChangedEvent.getTarget() == this._styleProxy._proxyElement)
			isProxy = true;
		if (this._parent != null && styleChangedEvent.getTarget() == this._parent)
			isParent = true;
		
		if (isProxy == true || isParent == true)
		{
			if ((isProxy == true && (styleName in this._styleProxy._proxyMap == true || this._styleProxy._proxyElement._getStyleType(styleName) == null)) ||
				(isParent == true && styleType != null && styleType.inheritable == true))
			{
				validStyle = true;
			}
			else
				validStyle = false;
		}
		else
			validStyle = true;
		
		//Style we dont care about, bail.
		if (validStyle == false)
			return;
		
		var oldStyleData = null;
		var newStyleData = null;
		
		//Get the cache for this style.
		var styleCache = this._stylesCache[styleName];
		
		//Create cache if doesnt exist.
		if (styleCache == null)
		{
			styleCache = {styleData:new StyleData(styleName), cacheInvalid:true};
			this._stylesCache[styleName] = styleCache;
		}
		
		//Cache valid, copy it for later compare.
		if (styleCache.cacheInvalid == false)
			oldStyleData = styleCache.styleData.clone();
		
		//Invalidate the cache
		styleCache.cacheInvalid = true;
		
		//Get updated data.
		newStyleData = this.getStyleData(styleName);
		
		//No change, bail.
		if (oldStyleData != null && oldStyleData.equals(newStyleData) == true)
			return;
		
		if (styleType != null)
			this._invalidateStyle(styleName);
		
		//Re-dispatch from ourself.
		this._dispatchEvent(styleChangedEvent); 
	};
	
//@override
CanvasElement.prototype._getDefaultStyleData = 
	function (styleName)
	{
		var styleData = new StyleData(styleName);
		
		//Check default definition
		if (this._styleDefinitionDefault != null)
			styleData.value = this._styleDefinitionDefault.getStyle(styleName);
			
		if (styleData.value !== undefined)
		{
			styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_DEFINITION);
			return styleData;
		}	
		
		//Check default proxy
		var proxy = this._styleProxy;
		var ctr = 0;
		while (proxy != null)
		{
			if (styleName in proxy._proxyMap == false && proxy._proxyElement._getStyleType(styleName) != null)
				break;
			
			if (proxy._proxyElement._styleDefinitionDefault != null)
				styleData.value = proxy._proxyElement._styleDefinitionDefault.getStyle(styleName);
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_PROXY);
				styleData.priority.push(ctr);	//Proxy level (chained proxies)
				
				return styleData;
			}
			
			ctr++;
			proxy = proxy._proxyElement._styleProxy;
		}
			
		//Check class
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(CanvasElement.StylePriorities.CLASS);
		
		return styleData;			
	};	

/**
 * @function _setStyleDefinitionDefault
 * 
 * Sets the default style definition. Use this when you need to supply a default definition 
 * that differs from the class based definition. For example, you're component uses a Button, 
 * but you need to supply styles to the button (or its skins) that differ from a Button's 
 * class defaults. Default styles do not track changes at runtime so this should always be 
 * called *before* the element is added to its parent and is included in the display chain.
 * 
 * @param styleDefinition StyleDefintion
 * The default style definiton to apply to the element.
 */
CanvasElement.prototype._setStyleDefinitionDefault = 
	function (styleDefinition)
	{
		this._styleDefinitionDefault = styleDefinition;
	};
	
/**
 * @function _setStyleProxy
 * 
 * Sets the element which is to proxy styles to this element. See getStyle() and StyleProxy.
 * 
 * @param styleProxy StyleProxy
 * The StyleProxy element wrapper to use to proxy styles from the proxy element to this element.
 * 
 * @seealso StyleProxy
 */	
CanvasElement.prototype._setStyleProxy = 
	function (styleProxy)
	{
		this._styleProxy = styleProxy;
	};
	
/**
 * @function _onCanvasElementAdded
 * Invoked when the element is added to the canvas. Every CanvasElement already adds its own
 * "added" event listener so overriding this is identical but more efficient than adding your own "added" event listener.
 * You should *always* call the base class function.
 * 
 * @param addedRemovedEvent AddedRemovedEvent
 * The AddedRemovedEvent to process.
 */	
CanvasElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		/////////Added to the Display Chain/////////////
	
		for (var i = 0; i < this._styleDefinitions.length; i++)
		{
			if (this._styleDefinitions[i].hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == false)
				this._styleDefinitions[i].addEventListener("stylechanged", this._onExternalStyleChangedInstance);
		}

		//If proxy is our parent, we dont want duplicate listeners.
		if (this._styleProxy != null && this._styleProxy._proxyElement.hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == false)
			this._styleProxy._proxyElement.addEventListener("stylechanged", this._onExternalStyleChangedInstance);
		
		if (this._backgroundShape != null && this._backgroundShape.hasEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance) == false)
			this._backgroundShape.addEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
		
		//Add broadcast events to manager//
		if ("enterframe" in this._eventListeners && this._eventListeners["enterframe"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["enterframe"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.addEventListener("enterframe", this._eventListeners["enterframe"][i]);
		}
		if ("localechanged" in this._eventListeners && this._eventListeners["localechanged"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["localechanged"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.addEventListener("localechanged", this._eventListeners["localechanged"][i]);
		}
		if ("mousemoveex" in this._eventListeners && this._eventListeners["mousemoveex"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["mousemoveex"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.addEventListener("mousemoveex", this._eventListeners["mousemoveex"][i]);
		}
		
		//Invalidate redraw and composite render
		this._invalidateRedrawRegion();
		this._invalidateCompositeRender();
		
		///////////Invalidate All Styles////////////////
		
		//Invalidate all cache
		for (var prop in this._stylesCache)
			this._stylesCache[prop].cacheInvalid = true;
		
		//Invalidate *all* styles, don't need to propagate, display propagates when attaching.
		var thisProto = Object.getPrototypeOf(this);
		var thisClass = null;
		
		if (thisProto == null || thisProto.hasOwnProperty("constructor") == true)
			thisClass = thisProto.constructor;
		
		while (thisClass != null)
		{
			if ("_StyleTypes" in thisClass)
			{
				for (var styleName in thisClass._StyleTypes)
					this._invalidateStyle(styleName);
			}
			
			thisProto = Object.getPrototypeOf(thisProto);
			if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
				thisClass = null;
			else
				thisClass = thisProto.constructor;			
		}
		
		//Always dispatch when added.
		if (this.hasEventListener("localechanged", null) == true)
			this._dispatchEvent(new DispatcherEvent("localechanged"));
	};

/**
 * @function _onCanvasElementRemoved
 * Invoked when the element is removed to the canvas. Every CanvasElement already adds its own
 * "removed" event listener so overriding this is identical but more efficient than adding your own "removed" event listener.
 * You should *always* call the base class function.
 * 
 * @param addedRemovedEvent AddedRemovedEvent
 * The AddedRemovedEvent to process.
 */		
CanvasElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		///////Removed from display chain///////////////////
	
		var i = 0;
	
		for (i = 0; i < this._styleDefinitions.length; i++)
		{
			if (this._styleDefinitions[i].hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == false)
				this._styleDefinitions[i].removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
		}
		
		if (this._styleProxy != null && this._styleProxy._proxyElement.hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == true)
			this._styleProxy._proxyElement.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
		
		if (this._backgroundShape != null && this._backgroundShape.hasEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance) == false)
			this._backgroundShape.removeEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
		
		if (this._rollOverCursorInstance != null)
		{
			addedRemovedEvent.getManager().removeCursor(this._rollOverCursorInstance);
			this._rollOverCursorInstance = null;
		}
		
		//Update the redraw region of any composite parents still attached to the display chain.
		for (i = 0; i < this._compositeMetrics.length; i++)
		{
			if (this._compositeMetrics[i].element._manager != null)
				this._compositeMetrics[i].element._updateRedrawRegion(this._compositeMetrics[i].drawableMetrics);
		}
		
		//Reset cycle flags
		this._stylesInvalid = true;
		this._measureInvalid = true;
		this._layoutInvalid = true;
		this._renderInvalid = true;
		
		//Nuke graphics canvas
		this._graphicsCanvas = null;
		this._graphicsCtx = null;
		this._graphicsClear = true;					
		
		//Nuke composite canvas
		this._compositeCtx = null;																														
		this._compositeCanvas = null;																
		this._compositeCanvasMetrics = null;			 
		
		//Reset redraw flags
		this._renderChanged = true;					
		this._renderVisible = false; 					
		this._compositeEffectChanged = true;
		
		//Nuke composite data
		this._compositeMetrics = [];
		this._compositeVisibleMetrics = null;																						
		this._redrawRegionMetrics = null;																												
		this._transformVisibleMetrics = null;			
		this._transformDrawableMetrics = null;				
		
		//Remove broadcast events from manager//
		if ("enterframe" in this._eventListeners && this._eventListeners["enterframe"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["enterframe"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.removeEventListener("enterframe", this._eventListeners["enterframe"][i]);
		}
		if ("localechanged" in this._eventListeners && this._eventListeners["localechanged"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["localechanged"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.removeEventListener("localechanged", this._eventListeners["localechanged"][i]);
		}
		if ("mousemoveex" in this._eventListeners && this._eventListeners["mousemoveex"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["mousemoveex"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.removeEventListener("mousemoveex", this._eventListeners["mousemoveex"][i]);
		}
	};	
	
/**
 * @function _getFontString
 * Gets a font string that can be applied to the canvas's Context2D via the element's text styles.
 * This is just a helper to gather and format the styles for the canvas context.
 * 
 * @returns String
 * String to be applied to the canvas contex's font. "bold 14px Arial".
 */	
CanvasElement.prototype._getFontString = 
	function ()
	{
		return this.getStyle("TextStyle") + " " + this.getStyle("TextSize") + "px " + this.getStyle("TextFont");
	};		
	
//@Override
CanvasElement.prototype._dispatchEvent = 
	function (dispatchEvent)
	{
		if (!(dispatchEvent instanceof ElementEvent))
		{
			CanvasElement.base.prototype._dispatchEvent.call(this, dispatchEvent);
			return;
		}
	
		dispatchEvent._canceled = false;
		dispatchEvent._defaultPrevented = false;
		
		//We're transforming the event as we bubble. We shouldn't change the instance given to the dispatcher. 
		var event = dispatchEvent.clone();
	
		event._target = this;
		
		//Clone the event when calling the handlers so they cannot fudge the event data.
		var handlerEvent = null;
		
		if (event._bubbles == true)
		{
			var currentElement = this;
			var currentMousePoint = {x:0, y:0};
			if (event instanceof ElementMouseEvent)
			{
				currentMousePoint.x = event._x;
				currentMousePoint.y = event._y;
			}
			
			//Get parent chain.
			var parentChain = [];
			while (currentElement != null)
			{
				parentChain.push({element:currentElement, 
								x:currentMousePoint.x, 
								y:currentMousePoint.y});
				
				//Adjust mouse point for parent.
				if (event instanceof ElementMouseEvent)
				{
					currentMousePoint.x += currentElement._x;
					currentMousePoint.y += currentElement._y;
					
					currentElement.rotatePoint(currentMousePoint, false);
				}
				
				currentElement = currentElement._parent;
			}
			
			//Dispatch Capture Events.
			event._phase = "capture";
			for (var i = parentChain.length -1; i >= 0; i--)
			{
				currentElement = parentChain[i].element;
				
				if (event._type in currentElement._captureListeners && currentElement._captureListeners[event._type].length > 0)
				{
					event._currentTarget = currentElement;
					if (event instanceof ElementMouseEvent)
					{
						event._x = parentChain[i].x;
						event._y = parentChain[i].y;
					}
					
					//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
					//we dont want to miss an event, or inconsistently dispatch newly added events.
					var listeners = currentElement._captureListeners[event._type].slice();
					
					//TODO: Sort by priority (no priority available yet).
					
					for (var i2 = 0; i2 < listeners.length; i2++)
					{
						handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
						listeners[i2](handlerEvent);
						
						if (handlerEvent._defaultPrevented == true)
							dispatchEvent._defaultPrevented = true;
						
						if (handlerEvent._canceled == true)
						{
							dispatchEvent._canceled = true;
							return;
						}
					}
				}
			}
			
			//Dispatch Bubble Events.
			event._phase = "bubble";
			for (var i = 0; i < parentChain.length; i++)
			{
				currentElement = parentChain[i].element;
				
				if (event._type in currentElement._eventListeners && currentElement._eventListeners[event._type].length > 0)
				{
					event._currentTarget = currentElement;
					if (event instanceof ElementMouseEvent)
					{
						event._x = parentChain[i].x;
						event._y = parentChain[i].y;
					}
					
					//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
					//we dont want to miss an event, or inconsistently dispatch newly added events.
					var listeners = currentElement._eventListeners[event._type].slice();
					
					//TODO: Sort by priority (no priority available yet).
					
					for (var i2 = 0; i2 < listeners.length; i2++)
					{
						handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
						listeners[i2](handlerEvent);
						
						if (handlerEvent._defaultPrevented == true)
							dispatchEvent._defaultPrevented = true;
						
						if (handlerEvent._canceled == true)
						{
							dispatchEvent._canceled = true;
							return;
						}
					}
				}
			}
			
		}
		else //Dispatch only target events.
		{ 
			event._currentTarget = this;

			event._phase = "capture";
			if (event._type in this._captureListeners && this._captureListeners[event._type].length > 0)
			{
				//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
				//we dont want to miss an event, or inconsistently dispatch newly added events.
				var listeners = this._captureListeners[event._type].slice();
				
				//TODO: Sort by priority (no priority available yet).
				
				for (var i2 = 0; i2 < listeners.length; i2++)
				{
					handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
					listeners[i2](handlerEvent);
					
					if (handlerEvent._defaultPrevented == true)
						dispatchEvent._defaultPrevented = true;
					
					if (handlerEvent._canceled == true)
					{
						dispatchEvent._canceled = true;
						return;
					}
				}
			}
			
			event._phase = "bubble";
			if (event._type in this._eventListeners && this._eventListeners[event._type].length > 0)
			{
				//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
				//we dont want to miss an event, or inconsistently dispatch newly added events.
				var listeners = this._eventListeners[event._type].slice();
				
				//TODO: Sort by priority (no priority available yet).
				
				for (var i2 = 0; i2 < listeners.length; i2++)
				{
					handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
					listeners[i2](handlerEvent);
					
					if (handlerEvent._defaultPrevented == true)
						dispatchEvent._defaultPrevented = true;
					
					if (handlerEvent._canceled == true)
					{
						dispatchEvent._canceled = true;
						return;
					}
				}
			}
		}
	};

/**
 * @function _addChild
 * Adds a child element to the end of this element's child list.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added.
 */	
CanvasElement.prototype._addChild = 
	function (element)
	{
		return this._addChildAt(element, this._children.length);
	};

/**
 * @function _addChildAt
 * Inserts a child element to this elements child list at the specified index.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a child of this element.
 * 
 * @param index int
 * The index position to insert the child in the elements child list.
 * 
 * @returns CanvasElement
 * Returns the element just added when successfull, null if the element could not
 * be added due to the index being out of range.
 */		
CanvasElement.prototype._addChildAt = 
	function (element, index)
	{
		if (!(element instanceof CanvasElement))
			return null;
		
		if (index < 0 || index > this._children.length)
			return null;
		
		//Elements may only have 1 parent.
		if (element._parent != null)
			element._parent._removeChild(element);
		
		element._parent = this;
		this._children.splice(index, 0, element);
		this.addEventListener("stylechanged", element._onExternalStyleChangedInstance);
		
		element._propagateChildData();
		
		this._invalidateMeasure();
		this._invalidateLayout();
		
		if (this._manager != null)
		{
			this._manager._rollOverInvalid = true;
			this._manager._processAddRemoveDisplayChainQueue();
		}
		
		return element;
	};
	
/**
 * @function _removeChild
 * Removes a child element from this elements child list.
 * 
 * @param element CanvasElement
 * Child to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successfull, null if the
 * element could not be removed due to it not being a child of this element.
 */	
CanvasElement.prototype._removeChild = 
	function (element)
	{
		var childIndex = this._children.indexOf(element);
		if (childIndex == -1)
			return null;
	
		return this._removeChildAt(childIndex);
	};

/**
 * @function _removeChildAt
 * Removes a child element at specified index.
 * 
 * @param index int
 * Index to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successfull, null if the element could
 * not be removed due it it not being a child of this element, or index out of range.
 */		
CanvasElement.prototype._removeChildAt = 
	function (index)
	{
		if (index < 0 || index > this._children.length - 1)
			return null;
		
		var element = this._children.splice(index, 1)[0]; //Returns array of removed items.
		
		//We removed an element that is in mouse-down state. 
		//Change the mouseup target to the parent of this element.
		if (element._mouseIsDown == true)
			element._manager._mouseDownElement = element._parent;
		
		if (element._mouseIsOver == true)
			element._manager._rollOverElement = element._parent;
		
		element._parent = null;
		this.removeEventListener("stylechanged", element._onExternalStyleChangedInstance);
		
		element._propagateChildData();
		
		this._invalidateMeasure();
		this._invalidateLayout();
		
		if (this._manager != null)
		{
			this._manager._rollOverInvalid = true;
			this._manager._processAddRemoveDisplayChainQueue();
		}
		
		return element;
	};	

/**
 * @function _getChildAt
 * Gets the child element at the supplied index.
 * 
 * @param index int
 * Index of child element to return;
 * 
 * @returns CanvasElement
 * The element at the supplied index, or null if index is out of range. 
 */	
CanvasElement.prototype._getChildAt = 
	function (index)
	{
		if (index < 0 || index > this._children.length - 1)
			return null;
		
		return this._children[index];
	};
	
/**
 * @function _getChildIndex
 * Returns the index of the supplied child element.
 * 
 * @param element CanvasElement
 * Child element to return the index.
 * 
 * @returns int
 * Returns the child index or -1 if the element is not
 * a child of this element.
 */	
CanvasElement.prototype._getChildIndex = 
	function (element)
	{
		return this._children.indexOf(element);
	};
	
/**
 * @function _setChildIndex
 * Changes a child element's index. 
 * 
 * @param element CanvasElement
 * Child element to change index.
 * 
 * @param index int
 * New index of the child element.
 * 
 * @returns boolean
 * Returns true if the child's index is successfully changed, false if the element
 * is not a child of this element or the index is out of range.
 */	
CanvasElement.prototype._setChildIndex = 
	function (element, index)
	{
		if (index < 0 || index > this._children.length - 1)
			return false;
		
		var currentIndex = this._getChildIndex(element);
		if (currentIndex == -1 || currentIndex == index)
			return false;
		
		this._children.splice(index, 0, this._children.splice(currentIndex, 1)[0]);
		
		this._invalidateMeasure();
		this._invalidateLayout();
		
		return true;
	};
	
/**
 * @function _getNumChildren
 * Gets this elements number of children.
 * 
 * @returns int
 * The number of child elements.
 */	
CanvasElement.prototype._getNumChildren = 
	function ()
	{
		return this._children.length;
	};
	
//@private	
CanvasElement.prototype._propagateChildData = 
	function ()
	{
		var isManager = (this instanceof CanvasManager);
	
		if ((isManager == false && (this._parent == null || this._parent._displayDepth == 0)) || 
			isManager == true && this._manager != null)
		{//Removed from display chain
			
			//Purge manager data.
			if (this._manager != null)
			{
				if (this._stylesInvalid == true)
					this._manager._updateStylesQueue.removeNode(this._stylesValidateNode, this._displayDepth);
				
				if (this._measureInvalid == true)
					this._manager._updateMeasureQueue.removeNode(this._measureValidateNode, this._displayDepth);
				
				if (this._layoutInvalid == true)
					this._manager._updateLayoutQueue.removeNode(this._layoutValidateNode, this._displayDepth);
				
				if (this._renderInvalid == true)
					this._manager._updateRenderQueue.removeNode(this._renderValidateNode, this._displayDepth);
				
				if (this._compositeRenderInvalid == true)
					this._manager._compositeRenderQueue.removeNode(this._compositeRenderValidateNode, this._displayDepth);
				
				if (this == this._manager._draggingElement)
					this._manager._clearDraggingElement();
				
				if (this == this._manager._focusElement)
					this._manager._focusElement = null;
				
				this._manager._pushAddRemoveDisplayChainQueue(this, "removed");
			}
			
			this._renderFocusRing = false;
			this._isFocused = false;
			this._mouseIsOver = false;
			this._mouseIsDown = false;
			this._displayDepth = 0;
			this._manager = null;
		}
		else
		{//Added to display chain
			
			if (isManager == true)
			{
				this._displayDepth = 1;
				this._manager = this;
			}
			else
			{
				this._displayDepth = this._parent._displayDepth + 1;
				this._manager = this._parent._manager;
			}
			
			//Add manager data.
			if (this._manager != null)
			{
				if (this._stylesInvalid == true)
					this._manager._updateStylesQueue.addNode(this._stylesValidateNode, this._displayDepth);
				
				if (this._measureInvalid == true)
					this._manager._updateMeasureQueue.addNode(this._measureValidateNode, this._displayDepth);
				
				if (this._layoutInvalid == true)
					this._manager._updateLayoutQueue.addNode(this._layoutValidateNode, this._displayDepth);
				
				if (this._renderInvalid == true)
					this._manager._updateRenderQueue.addNode(this._renderValidateNode, this._displayDepth);
				
				if (this._compositeRenderInvalid == true)
					this._manager._compositeRenderQueue.addNode(this._compositeRenderValidateNode, this._displayDepth);
				
				this._manager._pushAddRemoveDisplayChainQueue(this, "added");
			}
		}
		
		for (var i = 0; i < this._children.length; i++)
			this._children[i]._propagateChildData();
	};	

/**
 * @function _setRelativePosition
 * Sets the elements position relative to a supplied element regardless of this element's transformation,
 * depth, or position in the display hierarchy or relation to the supplied relativeToElement. This should typically
 * only be called during the parent element's layout phase. Setting relativeToElement to null has an identical
 * effect to calling _setActualPosition(). This is used by some containers to position the element relative
 * to a parent's coordinate plane rather than the child's transformed plane.
 * 
 * @param x Number
 * The relative X position to move this element's position.
 * 
 * @param y Number
 * The relative Y position to move this element's position.
 * 
 * @param relativeToElement CanvasElement
 * The CanvasElement to move this element relative too.
 */	
CanvasElement.prototype._setRelativePosition = 
	function (x, y, relativeToElement)
	{
		if (relativeToElement == null || relativeToElement == this)
		{
			if (this._x == x && this._y == y)
				return;
			
			this._x = x;
			this._y = y;
			
			if (this._manager != null)
				this._manager._rollOverInvalid = true;
			
			this._invalidateRedrawRegion();
		}
		
		if (this._manager == null || this._manager != relativeToElement._manager)
			return;
		
		//Use relative parent metrics. We want to shift this elements entire plane if its
		//transformed (rotated), we dont want to slide the element around on its transformed plane.
		var parentMetrics = this.getMetrics(this._parent);
		
		//Get the move-to position within our parent element.
		var newPosition = {x:x, y:y};
		relativeToElement.translatePointTo(newPosition, this._parent);
		
		//We haven't moved.
		if (newPosition.x == parentMetrics.getX() && newPosition.y == parentMetrics.getY())
			return;
		
		//Get the delta in its position.
		var deltaX = newPosition.x - parentMetrics.getX();
		var deltaY = newPosition.y - parentMetrics.getY();
		
		this._x = this._x + deltaX;
		this._y = this._y + deltaY;
		
		if (this._rotateDegrees != 0)
		{
			this._rotateCenterX += deltaX;
			this._rotateCenterY += deltaY;
		}
		
		if (this._manager != null)
			this._manager._rollOverInvalid = true;
		
		this._invalidateRedrawRegion();
	};	
		
/**
 * @function _setActualPosition
 * Sets the elements position within its parent. Note that if the element is transformed or rotated,
 * this sets the elements position within its transformed plane. If you wish to position a transformed
 * element relative to its parents coordinate plane, use _setRelativePosition(). This should typically
 * only be called from within the parents layout phase.
 * 
 * @param x int
 * The X position to move the element.
 * 
 * @param y int
 * The Y position to move the element.
 */	
CanvasElement.prototype._setActualPosition = 
	function (x, y)
	{
		x = Math.round(x);
		y = Math.round(y);
		
		if (this._x == x && this._y == y)
			return;
		
		this._x = x;
		this._y = y;
		
		if (this._manager != null)
			this._manager._rollOverInvalid = true;
		
		this._invalidateRedrawRegion();
	};	
	
/**
 * @function _setActualSize
 * Sets this element's size in pixels prior to any transformation or rotation. 
 * This should typically only be called from within the parents layout phase.
 * 
 * @param width Number
 * The width in pixels to size this element.
 * 
 * @param height Number
 * The height in pixels to size this element.
 */	
CanvasElement.prototype._setActualSize = 
	function (width, height)
	{
		//if (typeof width !== "number" || typeof height !== "number" || isNaN(width) || isNaN(height))
		//	throw "Invalid Size";
	
		//TODO: This is BAD!!!  This is effectively a fix for components that arent rounding / drawing on
		//		on even pixel lines causing anti-aliasing fuzz. This *needs* to be removed, and offending components fixed.
		width = Math.round(width);
		height = Math.round(height);
		
		if (this._width == width && this._height == height)
			return false;
		
		this._width = width;
		this._height = height;
		
		this._invalidateLayout();
		this._invalidateRender();
		
		if (this.hasEventListener("resize", null) == true)
			this._dispatchEvent(new DispatcherEvent("resize"), false);
		
		if (this._manager != null)
			this._manager._rollOverInvalid = true;
		
		return true;
	};
	
/**
 * @function _setActualRotation
 * Sets this elements rotation degrees and rotation point relative to its parent. This should typically
 * only be called from within the parent's layout phase.
 * 
 * @param degrees Number
 * Degrees to rotate the element (clockwise).
 * 
 * @param centerX Number
 * The X position relative to the elements parent to rotate around.
 * 
 * @param centerY Number
 * The Y position relative to the elements parent to rotate around.
 */	
CanvasElement.prototype._setActualRotation = 
	function (degrees, centerX, centerY)
	{
		if (centerX == null || centerY == null)
		{
			centerX = 0;
			centerY = 0;
		}
	
		if (this._rotateDegrees != degrees || this._rotateCenterX != centerX || this._rotateCenterY != centerY)
		{
			this._invalidateRedrawRegion();
			
			if (this._rotateDegrees != degrees)
			{
				this._compositeEffectChanged = true;
				this._invalidateCompositeRender();
				
				//Check if we need to re-render due to auto gradient
				var autoGradientType = this.getStyle("AutoGradientType");
				var backgroundColor = this.getStyle("BackgroundColor");
				var borderType = this.getStyle("BorderType");
				
				if (autoGradientType != null && autoGradientType != "none" && 
					(backgroundColor != null || (borderType != null && borderType != "none")))
				{
					this._invalidateRender();
				}
			}
		}
		
		this._rotateDegrees = degrees;
		this._rotateCenterX = centerX;
		this._rotateCenterY = centerY;
	};
	
//@private
CanvasElement.prototype._setMeasuredSize = 
	function (width, height)
	{
		if (this._measuredWidth == width && this._measuredHeight == height)
			return;
		
		this._measuredWidth = width;
		this._measuredHeight = height;
		
		if (this._parent != null)
		{
			this._parent._invalidateMeasure();
			this._parent._invalidateLayout();
		}
		
		if (this.hasEventListener("measurecomplete", null) == true)
			this._dispatchEvent(new DispatcherEvent("measurecomplete"));
	};
	
//@private	
CanvasElement.prototype._setRenderFocusRing = 
	function (shouldRender)
	{
		if (this._renderFocusRing == shouldRender)
			return;
		
		this._renderFocusRing = shouldRender;
		this._invalidateRender();
	};

//@private	
CanvasElement.prototype._createMetrics = 
	function ()
	{
		return new DrawMetrics();
	};
	
	
/**
 * @function _getGraphicsCtx
 * Returns the canvas context used when rendering this element. This should typically
 * only be called from within the element's _doRender() phase, and only if you intend
 * to actually draw. Calling this will impact the canvas redraw regions.
 *  
 * @returns Canvas2DContext
 * Canvas context used when rendering this element.
 */	
CanvasElement.prototype._getGraphicsCtx = 
	function ()
	{
		if (this._graphicsCanvas == null)
		{
			this._graphicsCanvas = document.createElement("canvas");
			this._graphicsCtx = this._graphicsCanvas.getContext("2d");
			
			this._graphicsCanvas.width = this._width;
			this._graphicsCanvas.height = this._height;
		}
		
		this._renderChanged = true;
		this._graphicsClear = false;
		
		this._invalidateRedrawRegion();
		
		return this._graphicsCtx;
	};
	
	
/**
 * @function _getPaddingSize
 * Helper function that returns the elements total padding width and height per its applied styles.
 * 
 * @returns Object
 * Returns an object containing 
 * {width:paddingWidth, height:paddingHeight,
 * paddingBottom:paddingBottom, paddingTop:paddingTop,
 * paddingLeft:paddingLeft, paddingRight:paddingRight}.
 */	
CanvasElement.prototype._getPaddingSize = 
	function ()
	{
		var paddingData = this.getStyleData("Padding");
		var paddingTopData = this.getStyleData("PaddingTop");
		var paddingBottomData = this.getStyleData("PaddingBottom");
		var paddingLeftData = this.getStyleData("PaddingLeft");
		var paddingRightData = this.getStyleData("PaddingRight");
		
		var paddingTop = paddingTopData.value;
		if (paddingData.comparePriority(paddingTopData) > 0) //Use Padding if higher priority
			paddingTop = paddingData.value;
		
		var paddingBottom = paddingBottomData.value;
		if (paddingData.comparePriority(paddingBottomData) > 0) //Use Padding if higher priority
			paddingBottom = paddingData.value;
		
		var paddingLeft = paddingLeftData.value;
		if (paddingData.comparePriority(paddingLeftData) > 0) //Use Padding if higher priority
			paddingLeft = paddingData.value;
		
		var paddingRight = paddingRightData.value;
		if (paddingData.comparePriority(paddingRightData) > 0) //Use Padding if higher priority
			paddingRight = paddingData.value;
		
		return { width: paddingLeft + paddingRight, 
				height: paddingTop + paddingBottom, 
				paddingBottom:paddingBottom, 
				paddingTop:paddingTop, 
				paddingLeft:paddingLeft, 
				paddingRight:paddingRight};
	};

/**
 * @function _getBorderThickness
 * Helper function that returns the elements border thickness per its applied styles.
 * 
 * @returns Number
 * The elements border thickness.
 */	
CanvasElement.prototype._getBorderThickness = 
	function ()
	{
		var borderThickness = 0;
		var borderType = this.getStyle("BorderType");
		var borderColor = this.getStyle("BorderColor");
		if ((borderType == "solid" || borderType == "inset" || borderType == "outset") && borderColor != null)
		{
			borderThickness = this.getStyle("BorderThickness");
			if (borderThickness < 0)
				borderThickness = 0;
		}
		
		return borderThickness;
	};

/**
 * @function _getStyledOrMeasuredWidth
 * Helper function that returns this elements styled width, or measured width if no style is set. Typically
 * called from within a parent containers layout phase.
 * 
 * @returns Number
 * The elements width.
 */	
CanvasElement.prototype._getStyledOrMeasuredWidth = 
	function ()
	{
		var width = this.getStyle("Width");
		
		if (width == null)
		{
			var maxWidth = this.getStyle("MaxWidth");
			var minWidth = this.getStyle("MinWidth");
			
			if (minWidth == null)
				minWidth = 0;
			if (maxWidth == null)
				maxWidth = Number.MAX_VALUE;
			
			width = this._measuredWidth;
			width = Math.min(width, maxWidth);
			width = Math.max(width, minWidth);
		}
		
		return width;
	};

/**
 * @function _getStyledOrMeasuredHeight
 * Helper function that returns this elements styled height, or measured height if no style is set. Typically
 * called from within a parent containers layout phase.
 * 
 * @returns Number
 * The elements height.
 */		
CanvasElement.prototype._getStyledOrMeasuredHeight = 
	function ()
	{
		var height = this.getStyle("Height");
		
		if (height == null)
		{
			var maxHeight = this.getStyle("MaxHeight");
			var minHeight = this.getStyle("MinHeight");			
			
			if (minHeight == null)
				minHeight = 0;
			if (maxHeight == null)
				maxHeight = Number.MAX_VALUE;	
			
			height = this._measuredHeight;
			height = Math.min(height, maxHeight);
			height = Math.max(height, minHeight);
		}
		
		return height;
	};
	
/**
 * @function _getBorderMetrics
 * Helper function that returns a DrawMetrics object whose bounding area is inside this elements border.
 * 
 * @returns DrawMetrics
 * Returns DrawMetrics that define a bounding area inside this elements border.
 */	
CanvasElement.prototype._getBorderMetrics = 
	function ()
	{
		var metrics = this._createMetrics();
		
		var borderThickness = this._getBorderThickness();
		
		metrics._x = borderThickness / 2;
		metrics._y = borderThickness / 2;
		
		metrics._width = this._width - borderThickness;
		metrics._height = this._height - borderThickness;
		
		return metrics;
	};
	
/**
 * @function _getPaddingMetrics
 * Helper function that returns a DrawMetrics object whose bounding area is inside this elements padding area.
 * 
 * @returns DrawMetrics
 * Returns DrawMetrics that define a bounding area inside this elements padding area.
 */		
CanvasElement.prototype._getPaddingMetrics = 
	function()
	{
		var metrics = this._createMetrics();
		var paddingSize = this._getPaddingSize();
		
		metrics._x = paddingSize.paddingLeft;
		metrics._y = paddingSize.paddingTop;
		metrics._width = this._width -  paddingSize.paddingLeft - paddingSize.paddingRight;
		metrics._height = this._height - paddingSize.paddingTop - paddingSize.paddingBottom;
		
		return metrics;
	};

/**
 * @function _getAutoGradientFill
 * Helper function that returns a Context2D linear or radial CanvasGradient depending on this elements
 * auto gradient styles. This gradient uses 1 color and lightens and darkens the supplied color. 
 * The gradient is always oriented in the same direction regardless of the elements rotation or transformation. 
 * This is used for a consistent light source. 
 * 
 * @param color String
 * Hex color to lighten and darken for gradient. Format "#FF0000" (red).
 * 
 * @param context Canvas2DContext
 * Canvas2DContext to use to generate the gradient.
 * 
 * @returns CanvasGradient
 * Returns CanvasGradient to be applied to canvas Context2D.
 */		
CanvasElement.prototype._getAutoGradientFill = 
	function (color, context)
	{
		var gradientType = this.getStyle("AutoGradientType");
		
		if (gradientType == "radial")
			return this._getAutoGradientRadial(color, context);
		else if (gradientType == "linear")
			return this._getAutoGradientLinear(color, context);
		
		return null;
	};

/**
 * @function _getAutoGradientMetrics
 * Helper function that returns a metrics object to be used for generating a consistent gradient
 * relative to the canvas regardless of the elements rotation, transformation or position in the
 * display hierarchy. Currently this always generates a gradient at 10 degrees from the upper left
 * to the lower right for consistency with inset/outset borders. This is used by the auto-gradient
 * to create a consistent light source. More styles should be added to allow changing the degrees
 * for more flexibility.
 * 
 * @returns Object
 * Gradient metrics object containing {startPoint:{x,y}, endPoint:{x, y}, width, height}
 */	
CanvasElement.prototype._getAutoGradientMetrics = 
	function ()
	{
		//Get metrics relative to the canvas. Regardless of transform, 
		//light source should always be consistent.
		var metrics = this.getMetrics(this._manager);
	
		//For convienience
		var canvasX = metrics.getX();
		var canvasY = metrics.getY();
		var canvasWidth = metrics.getWidth();
		var canvasHeight = metrics.getHeight();
		
		//Calculate the gradient line based on the element's canvas metrics.
		var gradientWidth = canvasHeight * Math.tan(CanvasElement.degreesToRadians(8));
		
		var gradientStart = {x:0, y:canvasY};
		if (gradientWidth <= canvasWidth)
			gradientStart.x = canvasX + (canvasWidth / 2) - (gradientWidth / 2);
		else
			gradientStart.x = canvasX - ((gradientWidth - canvasWidth) / 2);
		
		var gradientEnd = {x:0, y:canvasY + canvasHeight};
		if (gradientWidth <= canvasWidth)
			gradientEnd.x = canvasX + (canvasWidth / 2) + (gradientWidth / 2);
		else
			gradientEnd.x = canvasX + canvasWidth + ((gradientWidth - canvasWidth) / 2);
		
		//Translate the gradient line start/stop back down to the element's coordinate plane.
		this._manager.translatePointTo(gradientStart, this);
		this._manager.translatePointTo(gradientEnd, this);
		
		return {startPoint:gradientStart, endPoint:gradientEnd, width:canvasWidth, height:canvasHeight};
	};

/**
 * @function _getAutoGradientLinear
 * Helper function that returns a Context2D linear CanvasGradient depending on this elements
 * auto gradient styles. See _getAutoGradientFill().
 * 
 * @param color String
 * Hex color to lighten and darken for gradient. Format "#FF0000" (red).
 * 
 * @param context Canvas2DContext
 * Canvas2DContext to use to generate the gradient.
 * 
 * @returns CanvasGradient
 * Returns CanvasGradient to be applied to canvas Context2D.
 */		
CanvasElement.prototype._getAutoGradientLinear = 
	function (color, context)
	{
		var lighterFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStart"));
		var darkerFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStop"));
		
		var gradientMetrics = this._getAutoGradientMetrics();
		
		var fillGradient = context.createLinearGradient(
									gradientMetrics.startPoint.x, gradientMetrics.startPoint.y, 
									gradientMetrics.endPoint.x, gradientMetrics.endPoint.y);
		try
		{
			fillGradient.addColorStop(0, lighterFill);
			fillGradient.addColorStop(1, darkerFill);
		}
		catch (ex)
		{
			//Swallow, invalid color
			return null;
		}
		
		return fillGradient;
	};	
	
/**
 * @function _getAutoGradientRadial
 * Helper function that returns a Context2D linear CanvasGradient depending on this elements
 * auto gradient styles. See _getAutoGradientFill().
 * 
 * @param color String
 * Hex color to lighten and darken for gradient. Format "#FF0000" (red).
 * 
 * @param context Canvas2DContext
 * Canvas2DContext to use to generate the gradient.
 * 
 * @returns CanvasGradient
 * Returns CanvasGradient to be applied to canvas Context2D.
 */		
CanvasElement.prototype._getAutoGradientRadial = 
	function (color, context)
	{
		var lighterFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStart"));
		var darkerFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStop"));
		
		var gradientMetrics = this._getAutoGradientMetrics();
		
		var xSpan = gradientMetrics.endPoint.x - gradientMetrics.startPoint.x;
		var ySpan = gradientMetrics.endPoint.y - gradientMetrics.startPoint.y;
		
		var gradientPoint = {x:gradientMetrics.startPoint.x + (xSpan * .42), 
							y:gradientMetrics.startPoint.y + (ySpan * .42)};
		
		var fillGradient = context.createRadialGradient(
				gradientPoint.x, gradientPoint.y, 
				(Math.max(gradientMetrics.width, gradientMetrics.height) / 2) + (Math.max(xSpan, ySpan) * .08), 
				gradientPoint.x, gradientPoint.y, 
				0);
		
		fillGradient.addColorStop(0, darkerFill);
		fillGradient.addColorStop(1, lighterFill);
		
		return fillGradient;
	};	

/**
 * @function _drawBackgroundShape
 * Used to draw the path to the Canvas2DContext that is to be used to render the focus ring,
 * fill the background, and draw the border. You should never need to explicitly call this. 
 * The system calls this during render phase.
 * Typically you should use the BackgroundShape style
 * for this, but may override it under more complex scenarios.
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to draw the background shape path.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */	
CanvasElement.prototype._drawBackgroundShape = 
	function (ctx, borderMetrics)
	{
		if (this._backgroundShape == null)
		{
			//Full rectangle
			var x = borderMetrics.getX();
			var y = borderMetrics.getY();
			var w = borderMetrics.getWidth();
			var h = borderMetrics.getHeight();
			
			ctx.moveTo(x, y);
			ctx.lineTo(x + w, y);
			ctx.lineTo(x + w, y + h);
			ctx.lineTo(x, y + h);
			ctx.closePath();
		}
		else
		{
			this._backgroundShape.drawShape(ctx, borderMetrics);
		}
	};

/**
 * @function _drawFocusRing
 * Used to draw the focus ring when a tab-able element gains focus due to a tab stop per the elements styles.
 * You should never need to explicitly call this. The system calls this during
 * the render phase. You may override if you wish to draw a more complex focus indicator.
 * Focus ring is drawn *outside* the elements bounding box. Focus ring is rendered
 * before the background and border. 
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to render the focus ring.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */		
CanvasElement.prototype._drawFocusRing = 
	function (ctx, borderMetrics)
	{
		var focusRingThickness = this.getStyle("FocusThickness");
		if (focusRingThickness <= 0)
			return;
		
		var focusRingColor = this.getStyle("FocusColor");
		if (focusRingColor == null)
			return;		
		
		var metrics = this.getMetrics(this);
		
		var x = metrics.getX() - focusRingThickness;
		var y = metrics.getY() - focusRingThickness;
		var w = metrics.getWidth() + (focusRingThickness * 2);
		var h = metrics.getHeight() + (focusRingThickness * 2);
		
		ctx.beginPath();
		
		//Draw anticlockwise
		ctx.moveTo(x, y);
		ctx.lineTo(x, y + h);
		ctx.lineTo(x + w, y + h);
		ctx.lineTo(x + w, y);
		ctx.closePath();
		
		//Draws clockwise (shape inside shape)
		this._drawBackgroundShape(ctx, borderMetrics);
		
		//Clip the *inside* of the background shape
		ctx.clip();

		//Draw border
		ctx.beginPath();
		this._drawBackgroundShape(ctx, borderMetrics);
		
		ctx.strokeStyle = focusRingColor;

		//Increase thickness
		ctx.lineWidth = this._getBorderThickness() + (focusRingThickness * 2);
		ctx.stroke();
	};
	
/**
 * @function _fillBackground
 * Used to fill the elements background shape according to the elements background color and gradient settings.
 * You should never need to explicitly call this. The system calls this during
 * the render phase. You may override if you need to do a more complex background fill. The background fill
 * is rendered after the focus ring and before the border. 
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to fill the background shape.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */	
CanvasElement.prototype._fillBackground = 
	function (borderMetrics)
	{
		var backgroundColor = this.getStyle("BackgroundColor");
		if (backgroundColor == null)
			return;
	
		var ctx = this._getGraphicsCtx();
		var gradientFill = this._getAutoGradientFill(backgroundColor, ctx);
		
		if (gradientFill != null)
			ctx.fillStyle = gradientFill;
		else
			ctx.fillStyle = backgroundColor;
		
		ctx.beginPath();
		this._drawBackgroundShape(ctx, borderMetrics);

		ctx.fill();
	};

//@private	
CanvasElement.prototype._drawSolidBorder = 
	function (ctx, borderMetrics)
	{
		var borderColor = this.getStyle("BorderColor");
		if (borderColor == null)
			return;
		
		var borderThickness = this.getStyle("BorderThickness");
		if (borderThickness < 0)
			return;
	
		ctx.beginPath();
		this._drawBackgroundShape(ctx, borderMetrics);
		ctx.strokeStyle = borderColor;

		ctx.lineWidth = borderThickness;
		ctx.stroke();
	};
	
/**
 * @function _drawBorder
 * Used to render the elements border according to the element's style settings.
 * You should never need to explicitly call this. The system calls this during
 * the render phase. You may override if you need to do a more complex border. The border
 * is rendered last, on top of the focus ring and background fill.
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to render the border.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */		
CanvasElement.prototype._drawBorder = 
	function (borderMetrics)
	{
		var borderType = this.getStyle("BorderType");
	
		if (borderType != "solid" && borderType != "inset" && borderType != "outset")
			return;			
	
		var ctx = this._getGraphicsCtx();
		
		if (borderType == "solid")
		{
			this._drawSolidBorder(ctx, borderMetrics);
		}
		else //inset || outset
		{
			var borderColor = this.getStyle("BorderColor");
			var borderThickness = this.getStyle("BorderThickness");
			
			if (borderColor == null || borderThickness <= 0)
				return;
			
			var x = 0;
			var y = 0;
			var w = this._width;
			var h = this._height;
			
			var lighterColor = CanvasElement.adjustColorLight(borderColor, .3);
			var darkerColor = CanvasElement.adjustColorLight(borderColor, .3 * -1);
			
			var tlColor = borderType == "inset" ? darkerColor : lighterColor;
			var brColor = borderType == "inset" ? lighterColor : darkerColor;
			
			ctx.beginPath();
			ctx.moveTo(x, y + h);
			ctx.lineTo(x, y);
			ctx.lineTo(x + w, y);
			
			ctx.lineTo(x + w - borderThickness, y + borderThickness);
			ctx.lineTo(x + borderThickness, y + borderThickness);
			ctx.lineTo(x + borderThickness, y + h - borderThickness);
			ctx.closePath();
			
			ctx.fillStyle = tlColor;
			ctx.fill();
			
			ctx.beginPath();
			ctx.moveTo(x, y + h);
			ctx.lineTo(x + w, y + h);
			ctx.lineTo(x + w, y);
			
			ctx.lineTo(x + w - borderThickness, y + borderThickness);
			ctx.lineTo(x + w - borderThickness, y + h - borderThickness);
			ctx.lineTo(x + borderThickness, y + h - borderThickness);
			ctx.closePath();
			
			ctx.fillStyle = brColor;
			ctx.fill();
			
			ctx.lineWidth = 1;
			ctx.globalAlpha= .15;
			ctx.strokeStyle = "#000000";
			
			ctx.beginPath();
			ctx.moveTo(x, y);
			ctx.lineTo(x + borderThickness, y + borderThickness);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.moveTo(x + w, y + h);
			ctx.lineTo(x + w - borderThickness, y + h - borderThickness);
			ctx.stroke();
		}
	};

//@private	
CanvasElement.prototype._validateStyles = 
	function ()
	{
		this._stylesInvalid = false;
	
		//Reset and record the current set of invalid styles
		var stylesInvalidMap = Object.create(null);
		
		for (var prop in this._stylesInvalidMap)
		{
			if (this._stylesInvalidMap[prop] == true)
			{
				stylesInvalidMap[prop] = true; //Record
				this._stylesInvalidMap[prop] = false; //Reset
			}
		}
		
		this._doStylesUpdated(stylesInvalidMap);
	};
	
//@private	
CanvasElement.prototype._validateMeasure = 
	function ()
	{
		this._measureInvalid = false;
	
		var paddingSize = this._getPaddingSize();
		var measuredSize = this._doMeasure(paddingSize.width, paddingSize.height);
			
		this._setMeasuredSize(measuredSize.width, measuredSize.height);
	};
	
//@private	
CanvasElement.prototype._validateLayout = 
	function ()
	{
		this._layoutInvalid = false;
		this._doLayout(this._getPaddingMetrics());
		
		if (this._layoutInvalid == false && this.hasEventListener("layoutcomplete", null) == true)
			this._dispatchEvent(new DispatcherEvent("layoutcomplete"));
	};	
	
//@private
CanvasElement.prototype._validateRender = 
	function ()
	{
		this._renderInvalid = false;
		
		if (this._graphicsCanvas != null)
		{
			this._graphicsCanvas.width = this._width;
			this._graphicsCanvas.height = this._height;
			this._graphicsCtx.clearRect(0, 0, this._graphicsCanvas.width, this._graphicsCanvas.height);
		}
		
		if (this._graphicsClear == false)
		{
			this._renderChanged = true;
			this._graphicsClear = true;
			
			this._invalidateRedrawRegion();
		}
		
		this._doRender();
	};

//@private
CanvasElement.prototype._getCompositeMetrics = 
	function (compositeParent)
	{
		for (var i = 0; i < this._compositeMetrics.length; i++)
		{
			if (this._compositeMetrics[i].element == compositeParent)
				return this._compositeMetrics[i];
		}
		
		return null;
	};
	
//@private
CanvasElement.prototype._validateCompositeRender = 
	function ()
	{
		if (this._isCompositeElement() == true)
		{
			this._updateCompositeCanvas();
			
			if (this._redrawRegionMetrics != null && this._compositeCanvasMetrics != null)
			{
				//Add a 1 pixel buffer to the redraw region. 
				//This accounts for rounding errors considering redraw regions are calculated per element
				//and composite layers calculated are rendered as an aggregate.
				this._redrawRegionMetrics._x -= 1;
				this._redrawRegionMetrics._y -= 1;
				this._redrawRegionMetrics._width += 2;
				this._redrawRegionMetrics._height += 2;
				this._redrawRegionMetrics.roundUp();
				
				//Composite canvas may have shrunk to smaller than the redraw region, adjust the redraw region
				this._redrawRegionMetrics.mergeReduce(this._compositeCanvasMetrics);
				
				if (this._redrawRegionMetrics._width > 0 && this._redrawRegionMetrics._height > 0)
				{
					this._compositeCtx.clearRect(this._redrawRegionMetrics._x, this._redrawRegionMetrics._y, this._redrawRegionMetrics._width, this._redrawRegionMetrics._height);
					this._renderRedrawRegion(this);
				}
			}
		}
		else //No longer a composite element, nuke the compositing canvases
		{
			this._compositeCanvas = null;				
			this._compositeCtx = null;				
			this._compositeCanvasMetrics = null;		
		}
		
		this._compositeRenderInvalid = false;
		this._compositeEffectChanged = false;
		this._redrawRegionMetrics = null;
	};	
	
//@private	
CanvasElement.prototype._updateCompositeCanvas = 
	function ()
	{
		if (this._compositeVisibleMetrics == null)
		{
			this._compositeCanvas = null;
			this._compositeCtx = null;
			this._compositeCanvasMetrics = null;
		}
		else 
		{
			var newMetrics = this._compositeVisibleMetrics.clone();
			newMetrics.roundUp();
			
			if (this._compositeCanvas == null || this._compositeCanvasMetrics.equals(newMetrics) == false)
			{
				if (this._compositeCanvas == null)
				{
					this._compositeCanvas = document.createElement("canvas");
					this._compositeCtx = this._compositeCanvas.getContext("2d");
				}
				
				if (this._compositeCanvasMetrics == null)
					this._compositeCanvasMetrics = newMetrics;
				else
					this._compositeCanvasMetrics.copyFrom(newMetrics);
				
				this._compositeCanvas.width = this._compositeCanvasMetrics._width;
				this._compositeCanvas.height = this._compositeCanvasMetrics._height;
				
				//Translate x / y
				this._compositeCtx.setTransform(1, 0, 0, 1, this._compositeCanvasMetrics._x * -1, this._compositeCanvasMetrics._y * -1);
				
				//Expand the redraw region to this whole canvas.
				if (this._redrawRegionMetrics == null)
					this._redrawRegionMetrics = this._compositeCanvasMetrics.clone();
				else
					this._redrawRegionMetrics.mergeExpand(this._compositeCanvasMetrics);
			}
		}
	};
	
//@private	
CanvasElement.prototype._isCompositeElement = 
	function ()
	{
		if (this == this._manager)
			return true;
		
		var alpha = this.getStyle("Alpha");
		if (alpha > 0 && alpha < 1)
			return true;
		
		var rotateDegrees = CanvasElement.normalizeDegrees(this._rotateDegrees);
		if (rotateDegrees != 0)
			return true;
		
		if (this.getStyle("ShadowSize") > 0 && this.getStyle("ShadowColor") != null)
			return true;
		
		if (this.getStyle("CompositeLayer") == true)
			return true;
		
		return false;
	};
	
//@private	
CanvasElement.prototype._updateRedrawRegion = 
	function (changedMetrics)
	{
		if (changedMetrics == null || changedMetrics._width <= 0 || changedMetrics._height <= 0)
			return;
	
		if (this._redrawRegionMetrics == null)
			this._redrawRegionMetrics = changedMetrics.clone();
		else
			this._redrawRegionMetrics.mergeExpand(changedMetrics);
		
		this._invalidateCompositeRender();
	};	
	
//@private - This is here to handle a firefox bug. FF ignores clipping if shadow is applied prior to any other
//			 rendering. We draw one pixel outside the canvas bounds to make sure the clipping region gets applied.
CanvasElement.prototype._primeShadow = 
	function ()
	{
		this._compositeCtx.beginPath();
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x - 1, this._compositeCanvasMetrics._y - 1);
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x, this._compositeCanvasMetrics._y - 1);
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x, this._compositeCanvasMetrics._y);
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x - 1, this._compositeCanvasMetrics._y);
		this._compositeCtx.closePath();
		
		this._compositeCtx.fillStyle = "#000000";
		this._compositeCtx.fill();
	};
	
//@private	
CanvasElement.prototype._renderRedrawRegion = 
	function (element)
	{
		if (element._renderVisible == false)
			return;
	
		var isCompositeChildElement = false;
		if (this != element && element._isCompositeElement() == true)
			isCompositeChildElement = true;
		
		var elementGraphics = null;
		var drawableMetrics = null;
		var compositeMetrics = null;
		
		if (isCompositeChildElement == true && element._transformDrawableMetrics != null)
		{
			compositeMetrics = element._transformVisibleMetrics;
			drawableMetrics = element._transformDrawableMetrics;
			elementGraphics = element._compositeCanvas;
			
			this._compositeCtx.globalAlpha = element.getStyle("Alpha");
		}
		else if (isCompositeChildElement == false && element._compositeMetrics.length > 0 && element._graphicsClear == false)
		{
			compositeMetrics = element._compositeMetrics[0].metrics;
			drawableMetrics = element._compositeMetrics[0].drawableMetrics;
			elementGraphics = element._graphicsCanvas;
			
			this._compositeCtx.globalAlpha = 1;
		}
		
		if (elementGraphics != null &&
			drawableMetrics._width > 0 && drawableMetrics._height > 0 &&
			drawableMetrics._x < this._redrawRegionMetrics._x + this._redrawRegionMetrics._width && 
			drawableMetrics._x + drawableMetrics._width > this._redrawRegionMetrics._x && 
			drawableMetrics._y < this._redrawRegionMetrics._y + this._redrawRegionMetrics._height && 
			drawableMetrics._y + drawableMetrics._height > this._redrawRegionMetrics._y)
		{
			if (isCompositeChildElement == true && CanvasElement.normalizeDegrees(element._rotateDegrees) != 0)
			{
				var clipMetrics = drawableMetrics.clone();
				clipMetrics.mergeReduce(this._redrawRegionMetrics);
				
				this._compositeCtx.save();
				
				//Clip the region we need to re-draw
				this._compositeCtx.beginPath();
				this._compositeCtx.moveTo(clipMetrics._x, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.lineTo(clipMetrics._x, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.closePath();
				this._compositeCtx.clip();
				
				//Translate canvas to actual position
				var parent = element._parent;
				while (parent._isCompositeElement() == false)
				{
					this._compositeCtx.translate(parent._x, parent._y);
					parent = parent._parent;
				} 
				
				//Do rotation
				this._compositeCtx.translate(element._rotateCenterX, element._rotateCenterY);
				this._compositeCtx.rotate(CanvasElement.degreesToRadians(element._rotateDegrees));
				this._compositeCtx.translate(-element._rotateCenterX, -element._rotateCenterY);
			
				//Account for composite canvas translation.
				this._compositeCtx.translate(element._compositeCanvasMetrics._x, element._compositeCanvasMetrics._y);
				
				//Handle shadow
				if (element.getStyle("ShadowSize") > 0 && element.getStyle("ShadowColor") != null)
				{
					//Handle firefox bug.
					this._primeShadow();
					
					this._compositeCtx.shadowBlur = element.getStyle("ShadowSize");
					this._compositeCtx.shadowColor = element.getStyle("ShadowColor");
					
					//We need to rotate the shadow to match the element's rotation
					var shadowOffsetX = element.getStyle("ShadowOffsetX");
					var shadowOffsetY = element.getStyle("ShadowOffsetY");
					var radius = Math.sqrt((shadowOffsetX * shadowOffsetX) + (shadowOffsetY * shadowOffsetY));
					var degrees = 360 - element._rotateDegrees + CanvasElement.radiansToDegrees(Math.atan2(shadowOffsetX, shadowOffsetY));
					
					this._compositeCtx.shadowOffsetX = Math.sin(CanvasElement.degreesToRadians(degrees)) * radius;
					this._compositeCtx.shadowOffsetY = Math.cos(CanvasElement.degreesToRadians(degrees)) * radius;
				}
				
				this._compositeCtx.drawImage(
					elementGraphics, 
					0, 0, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height, 
					element._x, element._y, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height);
				
				this._compositeCtx.restore();
			}
			else if (isCompositeChildElement == true && element.getStyle("ShadowSize") > 0 && element.getStyle("ShadowColor") != null)
			{
				this._compositeCtx.save();
				
				var clipMetrics = drawableMetrics.clone();
				clipMetrics.mergeReduce(this._redrawRegionMetrics);
				
				//Clip the region we need to re-draw
				this._compositeCtx.beginPath();
				this._compositeCtx.moveTo(clipMetrics._x, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.lineTo(clipMetrics._x, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.closePath();
				this._compositeCtx.clip();
				
				//Handle firefox bug.
				this._primeShadow();
				
				this._compositeCtx.shadowBlur = element.getStyle("ShadowSize");
				this._compositeCtx.shadowColor = element.getStyle("ShadowColor");
				this._compositeCtx.shadowOffsetX = element.getStyle("ShadowOffsetX");
				this._compositeCtx.shadowOffsetY = element.getStyle("ShadowOffsetY");
				
				//Account for canvas edge buffer (visible - canvas)
				var destX = compositeMetrics._x - (element._compositeVisibleMetrics._x - element._compositeCanvasMetrics._x);
				var destY = compositeMetrics._y - (element._compositeVisibleMetrics._y - element._compositeCanvasMetrics._y);
				
				this._compositeCtx.drawImage(
						elementGraphics, 
						0, 0, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height, 
						destX, destY, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height);
				
				this._compositeCtx.restore();
			}
			else
			{
				var sourceX = 0;
				var sourceY = 0;
				
				var destX = 0;
				var destY = 0;

				var width = 0;
				var height = 0;
				
				if (drawableMetrics._x >= this._redrawRegionMetrics._x)
				{
					sourceX = drawableMetrics._x - compositeMetrics._x;
					destX = drawableMetrics._x;
					
					width = Math.min(drawableMetrics._width,  this._redrawRegionMetrics._width - (drawableMetrics._x - this._redrawRegionMetrics._x));
				}
				else
				{
					sourceX = this._redrawRegionMetrics._x - compositeMetrics._x;
					destX = this._redrawRegionMetrics._x;
					
					width = Math.min(this._redrawRegionMetrics._width,  drawableMetrics._width - (this._redrawRegionMetrics._x - drawableMetrics._x));
				}
				
				if (drawableMetrics._y >= this._redrawRegionMetrics._y)
				{
					sourceY = drawableMetrics._y - compositeMetrics._y;
					destY = drawableMetrics._y;
					
					height = Math.min(drawableMetrics._height,  this._redrawRegionMetrics._height - (drawableMetrics._y - this._redrawRegionMetrics._y));
				}
				else
				{
					sourceY = this._redrawRegionMetrics._y - compositeMetrics._y;
					destY = this._redrawRegionMetrics._y;
					
					height = Math.min(this._redrawRegionMetrics._height,  drawableMetrics._height - (this._redrawRegionMetrics._y - drawableMetrics._y));
				}
				
				this._compositeCtx.drawImage(
					elementGraphics, 
					sourceX, sourceY, width, height, 
					destX, destY, width, height);
			}
		}
		
		if (isCompositeChildElement == false)
		{
			for (var i = 0; i < element._children.length; i++)
				this._renderRedrawRegion(element._children[i]);
		}
	};			
	
/**
 * @function _invalidateStyle
 * Invalidates the supplied style and causes the system to invoke the _doStylesChanged() function.
 * This should never concievably be called and is exclusively handled by the system. 
 * This is the starting point for the element lifecycle. If you're program is dependent on 
 * _doStylesChanged() when no styles have actually changed, you might have a design issue. 
 * Do not override this function.
 * 
 * @param styleName String
 * String representing the style to be invalidated.
 */	
CanvasElement.prototype._invalidateStyle = 
	function (styleName)
	{
		if (this._stylesInvalid == false)
		{
			this._stylesInvalid = true;
			
			if (this._manager != null)
				this._manager._updateStylesQueue.addNode(this._stylesValidateNode, this._displayDepth);
		}
		
		this._stylesInvalidMap[styleName] = true;
	};	
	
/**
 * @function _invalidateMeasure
 * Invalidates the element's measured sizes and causes the system to invoke 
 * doMeasure() on the next measure phase. The system calls this automatically for all
 * existing components, this is only necessary for custom component development. 
 * This should only be called when a change is made
 * to the element that will impact its measurement. Such as property changes or from within the elements doStylesUpdated() 
 * when a style change impacts the elements measurement (such as Padding).  On rare occasions
 * you may need to re-invalidate measurement from within the doMeasure() function (such as wrapping text).
 * This will cause a 2nd measurement pass for that element which is valid (but expensive).
 * Do not override this function.
 */	
CanvasElement.prototype._invalidateMeasure = 
	function()
	{
		//Only invalidate once.
		if (this._measureInvalid == false)
		{
			this._measureInvalid = true;
			
			if (this._manager != null)
				this._manager._updateMeasureQueue.addNode(this._measureValidateNode, this._displayDepth);
		}
	};
	
/**
 * @function _invalidateLayout
 * Invalidates the elements child layout and causes the system to invoke doLayout() on
 * the next layout phase. The system calls this automatically for all existing components,
 * this is only necessary for custom component development.
 * This should only be called when a change is made to the element that will impact its layout.
 * Such as property changes or from within the elements doStylesUpdated() when a style change impacts
 * the element's layout (such as Padding). On rare occasions you may need to re-invalidate layout
 * from within the doLayout() function. An example is when a DataList adds a new DataRenderer it
 * re-invalidates layout to allow the renderer to measure before continuing layout.
 * Do not override this function.
 */	
CanvasElement.prototype._invalidateLayout = 
	function()
	{
		//Only invalidate once.
		if (this._layoutInvalid == false)
		{
			this._layoutInvalid = true;
			
			if (this._manager != null)
				this._manager._updateLayoutQueue.addNode(this._layoutValidateNode, this._displayDepth);
		}
	};	
	
/**
 * @function _invalidateRender
 * Invalidates the elements child render and causes the system to invoke doRender() on
 * the next render phase. The system calls this automatically for all existing components,
 * this is only necessary for custom component development.
 * This should only be called when a change is made to the element that will impact its rendering.
 * Such as property changes or from within the elements doStylesUpdated() when a style change impacts
 * the element's rendering (such as BackgroundColor). 
 * Do not override this function.
 */	
CanvasElement.prototype._invalidateRender =
	function ()
	{
		//Only invalidate once.
		if (this._renderInvalid == false)
		{
			this._renderInvalid = true;
			
			if (this._manager != null)
				this._manager._updateRenderQueue.addNode(this._renderValidateNode, this._displayDepth);
		}
	};	
	
//@private	
CanvasElement.prototype._invalidateRedrawRegion = 
	function ()
	{
		if (this._manager != null)
			this._manager._redrawRegionInvalid = true;
	};	
	
//@private
CanvasElement.prototype._invalidateCompositeRender = 
	function ()
	{
		if (this._compositeRenderInvalid == false)
		{
			this._compositeRenderInvalid = true;
			
			if (this._manager != null)
				this._manager._compositeRenderQueue.addNode(this._compositeRenderValidateNode, this._displayDepth);
		}
	};
	
/**
 * @function _doStylesUpdated
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to style changes or elements being added to the display hierarchy.
 * Override this function to handle style changes to the element. Style changes may impact other styles,
 * event listeners, layout, measurement, rendering, etc. You should call appropriate _invalidate() method per style.
 * Note that style handling should not be dependent on the *current* state of a style. This function
 * should be able to run repeatedly with the same values. An example of when this may happen is if
 * an element is temporarily removed from the display hierarchy then added back. Whenever an element is added
 * all of its styles are invalidated. This is necessary as when an element is *not* part of the display chain
 * style changes are not tracked. So when an element is added there is no way to know which styles may have changed
 * hence all of them are invalidated. 
 * 
 * @param stylesMap Object
 * An Object map containing all the style names that have been updated. Map contains entries {styleName:true}.
 * Elements should typically check this map before assuming a style has changed for performance reasons. 
 * You should always call the base method. If you wish to override the style handling behavior of a specific style, 
 * you can simply delete it from the map before passing it to the base function.
 */	
CanvasElement.prototype._doStylesUpdated = 
	function (stylesMap)
	{
		if (this._parent != null && 
			(this._parent._measureInvalid == false || this._parent._layoutInvalid == false))
		{
			if ("X" in stylesMap ||
				"Y" in stylesMap ||
				"Width" in stylesMap ||
				"Height" in stylesMap ||
				"PercentWidth" in stylesMap ||
				"PercentHeight" in stylesMap ||
				"MinWidth" in stylesMap ||
				"MinHeight" in stylesMap ||
				"MaxWidth" in stylesMap ||
				"MaxHeight" in stylesMap ||
				"Top" in stylesMap ||
				"Left" in stylesMap ||
				"Bottom" in stylesMap ||
				"Right" in stylesMap ||
				"HorizontalCenter" in stylesMap ||
				"VerticalCenter" in stylesMap ||
				"IncludeInLayout" in stylesMap ||
				"RotateDegrees" in stylesMap ||
				"RotateCenterX" in stylesMap ||
				"RotateCenterY" in stylesMap)
			{
				this._parent._invalidateMeasure();
				this._parent._invalidateLayout();
			}
		}
		
		if (this._measureInvalid == false || this._layoutInvalid == false)
		{
			if ("Padding" in stylesMap ||
				"PaddingTop" in stylesMap ||
				"PaddingBottom" in stylesMap ||
				"PaddingLeft" in stylesMap ||
				"PaddingRight" in stylesMap)
			{
				this._invalidateMeasure();
				this._invalidateLayout();
			}
		}
		
		if ("BorderThickness" in stylesMap || 
			"BorderType" in stylesMap || 
			"BorderColor" in stylesMap || 
			"BackgroundColor" in stylesMap || 
			"AutoGradientType" in stylesMap || 
			"AutoGradientStart" in stylesMap || 
			"AutoGradientStop" in stylesMap ||
			(this._renderFocusRing == true && ("FocusColor" in stylesMap || "FocusThickness" in stylesMap)))
		{
			this._invalidateRender();
		}
		
		if ("Visible" in stylesMap ||
			"ClipContent" in stylesMap)
		{
			this._invalidateRedrawRegion();
		}
		
		if ("Alpha" in stylesMap ||
			"ShadowSize" in stylesMap)
		{
			this._compositeEffectChanged = true;
			this._invalidateRedrawRegion();
			this._invalidateCompositeRender();
		}
		
		if ("BackgroundShape" in stylesMap)
		{
			var bgShape = this.getStyle("BackgroundShape");
			
			//Only handle if changed, attached/detached handles initial add/remove listener.
			if (bgShape != this._backgroundShape)
			{
				if (this._backgroundShape != null)
					this._backgroundShape.removeEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
				
				this._backgroundShape = bgShape;
				
				if (this._backgroundShape != null)
					this._backgroundShape.addEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
				
				this._invalidateRender();
			}
		}
		
		if ("Cursor" in stylesMap)
		{
			var cursorDef = this.getStyle("Cursor");
			
			if (cursorDef == null && this.hasEventListener("rollover", this._onCanvasElementCursorOverOutInstance) == true)
			{
				this.removeEventListener("rollover", this._onCanvasElementCursorOverOutInstance);
				this.removeEventListener("rollout", this._onCanvasElementCursorOverOutInstance);
			}
			else if (cursorDef != null && this.hasEventListener("rollover", this._onCanvasElementCursorOverOutInstance) == false)
			{
				this.addEventListener("rollover", this._onCanvasElementCursorOverOutInstance);
				this.addEventListener("rollout", this._onCanvasElementCursorOverOutInstance);
			}
			
			this._updateRolloverCursorDefinition();
		}
		
		//Kill focus ring if disabled.
		if ("Enabled" in stylesMap && this.getStyle("Enabled") == false)
			this._setRenderFocusRing(false);
		
		if ("Visible" in stylesMap || "MouseEnabled" in stylesMap)
			this._manager._rollOverInvalid = true;
	};

//@private	
CanvasElement.prototype._updateRolloverCursorDefinition = 
	function ()
	{
		var cursorDef = this.getStyle("Cursor");
		
		if (this._rollOverCursorInstance != null && 
			(cursorDef == null || this._mouseIsOver == false))
		{
			this._manager.removeCursor(this._rollOverCursorInstance);
			this._rollOverCursorInstance = null;
		}
		else if (this._mouseIsOver == true && cursorDef != null)
		{
			if (this._rollOverCursorInstance == null)
				this._rollOverCursorInstance = this._manager.addCursor(cursorDef, 0);
			else if (this._rollOverCursorInstance.data != cursorDef)
			{
				this._manager.removeCursor(this._rollOverCursorInstance);
				this._rollOverCursorInstance = this._manager.addCursor(cursorDef, 0);
			}
		}
	};

/**
 * @function _doMeasure
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to changes that effect measurement or elements being added to the display hierarchy.
 * Override this function to calculate the measured size of the element based on its styling, children, etc. 
 * Return a object containing {width, height}.
 * 
 * @param padWidth Number
 * Simply a convienence as padding typically effects measurement (but not always) depending on the component.
 * Use any supporting functions such as _getBorderThickness that are needed to measure the element.
 * 
 * @param padHeight Number
 * Simply a convienence as padding typically effects measurement (but not always) depending on the component.
 * Use any supporting functions such as _getBorderThickness that are needed to measure the element.
 * 
 * @returns Object
 * An object containing the elements measured size. {width, height}
 */		
CanvasElement.prototype._doMeasure = 
	function (padWidth, padHeight)
	{
		//Stub for override.
	
		//Always return a size... 
		return {width: padWidth, height: padHeight};
	};
	
/**
 * @function _doLayout
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to changes that effect layout or elements being added to the display hierarchy.
 * Override this function to layout its children. You should call layout functions such as _setActualPosition() and
 * _setActualSize() on child elements from within this function. Sometimes you may need to add/remove additional elements
 * during layout such as when a Datagrid or Viewport adds/removes scroll bars. Keep in mind that adding/removing elements
 * automatically re-invalidates layout, so its best to bail out and wait for the next layout pass for best performance
 * under this scenario.
 * 
 * @param paddingMetrics DrawMetrics
 * Contains metrics to use after considering the element's padding. Simply a convienence as padding typically 
 * effects layout (but not always) depending on the component. Use any supporting functions such as _getBorderMetrics()
 * that are needed to layout the element.
 */		
CanvasElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		//Stub for override.
	};	
	
/**
 * @function _doRender
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to changes that effect rendering or elements being added to the display hierarchy.
 * Override this function to render the element. Keep in mind that any child elements are rendered on top of this
 * element. This function is typically not needed unless rendering a very primitive object such as a custom skin or 
 * a display object that cannot be handled via a BackgroundShape class and/or _fillBackground() function.
 * Most advanced objects should use skins and other means to render themselves.
 * 
 * CanvasElement draws its background and border via supplied shape and gradient settings.
 */		
CanvasElement.prototype._doRender =
	function()
	{
		var borderMetrics = this._getBorderMetrics();
		
		if (this._renderFocusRing == true)
		{
			//ctx.save();
			//this._drawFocusRing(borderMetrics);
			//ctx.restore();
		}
		
		this._fillBackground(borderMetrics);
		
		this._drawBorder(borderMetrics);
	};
	
	
//////////DataRenderer Dynamic Properties/////////////////
	
/**
 * @function _setListData
 * This function is called when the element is being used as a DataRenderer for containers
 * like DataList and DataGrid. Override this function to make any changes to the DataRenderer
 * per the supplied DataListData and itemData objects. Update any styles, states, add/remove children, call any
 * necessary _invalidate() functions, etc.
 * 
 * @param listData DataListData
 * A DataListData or subclass object passed by the parent DataList or subclass with data necessary
 * to update the DataRender like the parent DataList reference and row/column index being rendered.
 * 
 * @param itemData Object
 * The data Object (such as row data) supplied by the implementor's ListCollection to render the row/column DataRenderer.
 */	
CanvasElement.prototype._setListData = 
	function (listData, itemData)
	{
		this._listData = listData;
		this._itemData = itemData;
	};

/**
 * @function _setListSelected
 * This function is called when the element is being used as a DataRenderer for containers
 * like DataList and DataGrid to change the DataRenderer's selection state. 
 * Override this function to make any changes to the DataRenderer per the selection state.
 * Update any styles, states, add/remove children, call any necessary _invalidate() functions, etc.
 * 
 * @param selected boolean
 * True if the DataRenderer is selected, otherwise false.
 */	
CanvasElement.prototype._setListSelected = 
	function (selected)
	{
		this._listSelected = selected;
	};	
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////ViewportElement/////////////////////////////////	
	
/**
 * @class ViewportElement
 * @inherits CanvasElement
 * 
 * Viewport is a container that only supports one child element (usually another container).
 * When the child's content size is too large for the view area, the Viewport will optionally 
 * pop up scroll bars, otherwise the child element will assume the size of the ViewportElement.
 * 
 * This class needs more work. More styles are needed for controlling tween behavior and allowing
 * scrolling even if scroll bars are disabled.
 *  
 * 
 * @constructor ViewportElement 
 * Creates new ViewportElement instance.
 */
function ViewportElement()
{
	ViewportElement.base.prototype.constructor.call(this);
	
	this._viewElement = null;
	
	this._horizontalScrollBar = null;
	this._verticalScrollBar = null;
	
	this._viewPortContainer = new CanvasElement();
	this._viewPortContainer.setStyle("ClipContent", true);
	this._addChild(this._viewPortContainer);
	
	var _self = this;
	
	//Private event handler, need different instance for each Viewport, proxy to prototype.
	this._onViewportScrollBarChangeInstance =
		function (elementEvent)
		{
			_self._onViewportScrollBarChange(elementEvent);
		};
		
	this._onViewportMouseWheelEventInstance = 
		function (elementMouseWheelEvent)
		{
			_self._onViewportMouseWheelEvent(elementMouseWheelEvent);
		};
		
	this._onViewElementMeasureCompleteInstance = 
		function (event)
		{
			_self._onViewElementMeasureComplete(event);
		};
		
		
	this.addEventListener("wheel", this._onViewportMouseWheelEventInstance);
}

//Inherit from CanvasElement
ViewportElement.prototype = Object.create(CanvasElement.prototype);
ViewportElement.prototype.constructor = ViewportElement;
ViewportElement.base = CanvasElement;

/////////////Style Types////////////////////////////////////////////

ViewportElement._StyleTypes = Object.create(null);

/**
 * @style HorizontalScrollBarDisplay String
 * Determines the behavior of the horizontal scroll bar. Allowable values are "on", "off", or "auto".
 */
ViewportElement._StyleTypes.HorizontalScrollBarDisplay = 		{inheritable:false};		// "on" || "off" || "auto"

/**
 * @style HorizontalScrollBarPlacement String
 * Determines the position of the horizontal scroll bar. Allowable values are "top" or "bottom".
 */
ViewportElement._StyleTypes.HorizontalScrollBarPlacement = 		{inheritable:false};		// "top" || "bottom"

/**
 * @style VerticalScrollBarDisplay String
 * Determines the behavior of the vertical scroll bar. Allowable values are "on", "off", or "auto".
 */
ViewportElement._StyleTypes.VerticalScrollBarDisplay = 			{inheritable:false};		// "on" || "off" || "auto"

/**
 * @style VerticalScrollBarPlacement String
 * Determines the position of the vertical scroll bar. Allowable values are "left" or "right".
 */
ViewportElement._StyleTypes.VerticalScrollBarPlacement = 		{inheritable:false};		// "left" || "right"

//ScrollBar styles.
/**
 * @style HorizontalScrollBarStyle StyleDefinition
 * The StyleDefinition to be applied to the horizontal scroll bar.
 */
ViewportElement._StyleTypes.HorizontalScrollBarStyle = 			{inheritable:false};		// StyleDefinition

/**
 * @style VerticalScrollBarStyle StyleDefinition
 * The StyleDefinition to be applied to the vertical scroll bar.
 */
ViewportElement._StyleTypes.VerticalScrollBarStyle = 			{inheritable:false};		// StyleDefinition


////////////Default Styles///////////////////////////////////////

ViewportElement.StyleDefault = new StyleDefinition();

ViewportElement.StyleDefault.setStyle("HorizontalScrollBarDisplay", 					"auto");
ViewportElement.StyleDefault.setStyle("HorizontalScrollBarPlacement", 					"bottom");

ViewportElement.StyleDefault.setStyle("VerticalScrollBarDisplay", 						"auto");
ViewportElement.StyleDefault.setStyle("VerticalScrollBarPlacement", 					"right");

ViewportElement.StyleDefault.setStyle("HorizontalScrollBarStyle", 						null);
ViewportElement.StyleDefault.setStyle("VerticalScrollBarStyle", 						null);



/////////////Public///////////////////////////////

/**
 * @function setElement
 * Sets the child element of the Viewport.
 * 
 * @param element CanvasElement
 * The child element of the Viewport (or null).
 */
ViewportElement.prototype.setElement = 
	function (element)
	{
		if (this._viewElement != null)
		{
			this._viewElement.removeEventListener("measurecomplete", this._onViewElementMeasureCompleteInstance);
			this._viewPortContainer._removeChild(this._viewElement);
		}
		
		this._viewElement = element;
		
		if (this._viewElement != null)
		{
			this._viewElement.addEventListener("measurecomplete", this._onViewElementMeasureCompleteInstance);
			this._viewPortContainer._addChild(this._viewElement);
		}
		
		this._invalidateLayout();
	};


////////////Internal//////////////////////////////
	
/**
 * @function _onViewportScrollBarChange
 * Event handler for the scroll bar "changed" event. Updates the child elements position within the Viewport.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ViewportElement.prototype._onViewportScrollBarChange = 
	function (elementEvent)
	{
		this._invalidateLayout();
	};

ViewportElement.prototype._onViewElementMeasureComplete = 
	function (event)
	{
		this._invalidateLayout();
	};
	
/**
 * @function _onViewportMouseWheelEvent
 * Event handler for the Viewport's "wheel" event. Starts the scroll bar tween.
 * 
 * @param elementMouseWheelEvent ElementMouseWheelEvent
 * The ElementMouseWheelEvent to process.
 */		
ViewportElement.prototype._onViewportMouseWheelEvent = 
	function (elementMouseWheelEvent)
	{
		if (elementMouseWheelEvent.getDefaultPrevented() == true)
			return;
	
		var consumeEvent = false;
		
		var scrollPageSize = null;
		var scrollViewSize = null;
		var scrollLineSize = null;
		var scrollValue = null;
		var maxScrollValue = null;
		
		var deltaX = elementMouseWheelEvent.getDeltaX();
		var deltaY = elementMouseWheelEvent.getDeltaY();
		
		if (deltaX != 0 && this._horizontalScrollBar != null)
		{
			scrollPageSize = this._horizontalScrollBar.getScrollPageSize();
			scrollViewSize = this._horizontalScrollBar.getScrollViewSize();
			scrollLineSize = this._horizontalScrollBar.getScrollLineSize();
			
			maxScrollValue = scrollPageSize - scrollViewSize;
			if (maxScrollValue > 0)
			{
				scrollValue = this._horizontalScrollBar.getTweenToValue();
				if (scrollValue == null)
					scrollValue = this._horizontalScrollBar.getScrollValue();
				
				if (deltaX < 0 && scrollValue > 0)
				{
					this._horizontalScrollBar.startScrollTween(Math.max(scrollValue + (deltaX * (scrollLineSize * 3)), 0));
					consumeEvent = true;
				}
				else if (deltaX > 0 && scrollValue < maxScrollValue)
				{
					this._horizontalScrollBar.startScrollTween(Math.min(scrollValue + (deltaX * (scrollLineSize * 3)), maxScrollValue));
					consumeEvent = true;
				}
			}
		}
		
		if (deltaY != 0 && this._verticalScrollBar != null)
		{
			scrollPageSize = this._verticalScrollBar.getScrollPageSize();
			scrollViewSize = this._verticalScrollBar.getScrollViewSize();
			scrollLineSize = this._verticalScrollBar.getScrollLineSize();
			
			maxScrollValue = scrollPageSize - scrollViewSize;
			if (maxScrollValue > 0)
			{
				scrollValue = this._verticalScrollBar.getTweenToValue();
				if (scrollValue == null)
					scrollValue = this._verticalScrollBar.getScrollValue();
				
				if (deltaY < 0 && scrollValue > 0)
				{
					this._verticalScrollBar.startScrollTween(Math.max(scrollValue + (deltaY * (scrollLineSize * 3)), 0));
					consumeEvent = true;
				}
				else if (deltaY > 0 && scrollValue < maxScrollValue)
				{
					this._verticalScrollBar.startScrollTween(Math.min(scrollValue + (deltaY * (scrollLineSize * 3)), maxScrollValue));
					consumeEvent = true;
				}
			}
		}
		
		//We've consumed the wheel event, don't want parents double scrolling.
		if (consumeEvent == true)
		{
			elementMouseWheelEvent.preventDefault();
			this._invalidateLayout();
		}
	};
	
//@Override
ViewportElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ViewportElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("HorizontalScrollBarDisplay" in stylesMap ||
			"VerticalScrollBarDisplay" in stylesMap)
		{
			this._invalidateLayout();
			this._invalidateMeasure();
		}
		else if ("HorizontalScrollBarPlacement" in stylesMap ||
				"VerticalScrollBarPlacement" in stylesMap)
		{
			this._invalidateLayout();
		}
		
		if ("HorizontalScrollBarStyle" && this._horizontalScrollBar != null)
			this._horizontalScrollBar.setStyleDefinitions(this.getStyle("HorizontalScrollBarStyle"));
		if ("VerticalScrollBarStyle" && this._verticalScrollBar != null)
			this._verticalScrollBar.setStyleDefinitions(this.getStyle("VerticalScrollBarStyle"));
	};

//@Override
ViewportElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var vBarWidth = 0;
		var vBarHeight = 0;
		
		var hBarWidth = 0;
		var hBarHeight = 0;
		
		if (this._verticalScrollBar != null)
		{
			vBarWidth = this._verticalScrollBar._getStyledOrMeasuredWidth();
			vBarHeight = this._verticalScrollBar._getStyledOrMeasuredHeight();
		}
		if (this._horizontalScrollBar != null)
		{
			hBarWidth = this._horizontalScrollBar._getStyledOrMeasuredWidth();
			hBarHeight = this._horizontalScrollBar._getStyledOrMeasuredHeight();
		}
	
		return {width: Math.max(vBarWidth, hBarWidth) + padWidth, height: Math.max(vBarHeight, hBarHeight) + padHeight};
	};
	
//@Override	
ViewportElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		var hDisplay = this.getStyle("HorizontalScrollBarDisplay");
		var vDisplay = this.getStyle("VerticalScrollBarDisplay");
		
		var paneWidth = paddingMetrics.getWidth();
		var paneHeight = paddingMetrics.getHeight();
		
		var contentWidth = 0;
		var contentHeight = 0;
		if (this._viewElement != null)
		{
			contentWidth = this._viewElement._getStyledOrMeasuredWidth();
			contentHeight = this._viewElement._getStyledOrMeasuredHeight();
		}
		
		var scrollBarsChanged = false;
		var needsHScroll = false;
		var needsVScroll = false;
		
		//We need the scroll bar.
		if (hDisplay == "on" || (hDisplay == "auto" && contentWidth > paneWidth))
			needsHScroll = true;
			
		if (vDisplay == "on" || (vDisplay == "auto" && contentHeight > paneHeight))
			needsVScroll = true;
		
		//2nd pass, we need the *other* scroll bar because the first took some of our content area.
		if (needsHScroll == true && needsVScroll == false && vDisplay == "auto" && this._horizontalScrollBar != null)
		{
			if (contentHeight > paneHeight - this._horizontalScrollBar._getStyledOrMeasuredHeight())
				needsVScroll = true;
		}

		if (needsVScroll == true && needsHScroll == false && hDisplay == "auto" && this._verticalScrollBar != null)
		{
			if (contentWidth > paneWidth - this._verticalScrollBar._getStyledOrMeasuredWidth())
				needsHScroll = true;
		}
		
		//Destroy
		if (needsHScroll == false)
		{
			if (this._horizontalScrollBar != null)
			{
				this._removeChild(this._horizontalScrollBar);
				this._horizontalScrollBar = null;
				scrollBarsChanged = true;
			}
		}
		else //Create
		{
			if (this._horizontalScrollBar == null)
			{
				this._horizontalScrollBar = new ScrollBarElement();
				this._horizontalScrollBar._setStyleDefinitionDefault(this._getDefaultStyle("HorizontalScrollBarStyle"));
				this._horizontalScrollBar.setStyleDefinitions(this.getStyle("HorizontalScrollBarStyle"));
				this._horizontalScrollBar.setStyle("ScrollBarDirection", "horizontal");
				this._horizontalScrollBar.setScrollLineSize(25);
				
				this._horizontalScrollBar.addEventListener("changed", this._onViewportScrollBarChangeInstance);
				this._addChild(this._horizontalScrollBar);
				scrollBarsChanged = true;
			}
		}
		
		//Destroy
		if (needsVScroll == false)
		{
			if (this._verticalScrollBar != null)
			{
				this._removeChild(this._verticalScrollBar);
				this._verticalScrollBar = null;
				scrollBarsChanged = true;
			}
		}
		else //Create
		{
			if (this._verticalScrollBar == null)
			{
				this._verticalScrollBar = new ScrollBarElement();
				this._verticalScrollBar._setStyleDefinitionDefault(this._getDefaultStyle("VerticalScrollBarStyle"));
				this._verticalScrollBar.setStyleDefinitions(this.getStyle("VerticalScrollBarStyle"));
				this._verticalScrollBar.setStyle("ScrollBarDirection", "vertical");
				this._verticalScrollBar.setScrollLineSize(25);
				
				this._verticalScrollBar.addEventListener("changed", this._onViewportScrollBarChangeInstance);
				this._addChild(this._verticalScrollBar);
				scrollBarsChanged = true;
			}
		}
		
		//Wait for next pass, adding / removing bars changes content size, need bars to measure.
		if (scrollBarsChanged == true)
			return;
		
		var horizontalBarHeight = 0;
		var verticalBarWidth = 0;
		
		var horizontalScrollValue = 0;
		var verticalScrollValue = 0;
		
		if (this._horizontalScrollBar != null)
		{
			horizontalScrollValue = this._horizontalScrollBar.getScrollValue();
			horizontalBarHeight = this._horizontalScrollBar._getStyledOrMeasuredHeight();
			paneHeight -= horizontalBarHeight;
		}
		
		if (this._verticalScrollBar != null)
		{
			verticalScrollValue = this._verticalScrollBar.getScrollValue();
			verticalBarWidth = this._verticalScrollBar._getStyledOrMeasuredWidth();
			paneWidth -= verticalBarWidth;
		}
		
		//Fix scroll values (size reduction forces us to scroll up)
		horizontalScrollValue = Math.min(horizontalScrollValue, contentWidth - paneWidth);
		horizontalScrollValue = Math.max(horizontalScrollValue, 0);
		
		verticalScrollValue = Math.min(verticalScrollValue, contentHeight - paneHeight);
		verticalScrollValue = Math.max(verticalScrollValue, 0);
		
		var horizontalBarPlacement = this.getStyle("HorizontalScrollBarPlacement");
		var verticalBarPlacement = this.getStyle("VerticalScrollBarPlacement");
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		
		if (this._horizontalScrollBar != null)
		{
			this._horizontalScrollBar.setScrollPageSize(contentWidth);
			this._horizontalScrollBar.setScrollViewSize(paneWidth);
			this._horizontalScrollBar.setScrollValue(horizontalScrollValue);
			
			this._horizontalScrollBar._setActualSize(paneWidth, horizontalBarHeight);
			
			if (horizontalBarPlacement == "top")
			{
				if (verticalBarPlacement == "left")
					this._horizontalScrollBar._setActualPosition(x + verticalBarWidth, y);
				else
					this._horizontalScrollBar._setActualPosition(x, y);
			}
			else
			{
				if (verticalBarPlacement == "left")
					this._horizontalScrollBar._setActualPosition(x + verticalBarWidth, y + paneHeight);
				else
					this._horizontalScrollBar._setActualPosition(x, y + paneHeight);
			}
		}
		
		if (this._verticalScrollBar != null)
		{
			this._verticalScrollBar.setScrollPageSize(contentHeight);
			this._verticalScrollBar.setScrollViewSize(paneHeight);
			this._verticalScrollBar.setScrollValue(verticalScrollValue);
			
			this._verticalScrollBar._setActualSize(verticalBarWidth, paneHeight);
			
			if (verticalBarPlacement == "left")
			{
				if (horizontalBarPlacement == "top")
					this._verticalScrollBar._setActualPosition(x, y + horizontalBarHeight);
				else
					this._verticalScrollBar._setActualPosition(x, y);
			}
			else
			{
				if (horizontalBarPlacement == "top")
					this._verticalScrollBar._setActualPosition(x + paneWidth, y + horizontalBarHeight);
				else
					this._verticalScrollBar._setActualPosition(x + paneWidth, y);
			}
		}
		
		var containerX = x;
		var containerY = y;
		
		if (horizontalBarPlacement == "top")
			containerY += horizontalBarHeight;
		if (verticalBarPlacement == "left")
			containerX += verticalBarWidth;		
		
		this._viewPortContainer._setActualSize(paneWidth, paneHeight);
		this._viewPortContainer._setActualPosition(containerX, containerY);
		
		if (this._viewElement != null)
		{
			this._viewElement._setActualSize(Math.max(paneWidth, contentWidth), Math.max(paneHeight, contentHeight));
			this._viewElement._setActualPosition(horizontalScrollValue * -1, verticalScrollValue * -1)
		}
	};
	
	


/**
 * @depends CanvasElement.js
 */

///////Internal class for rendering lines of text/////////////////

//This class is only used for rendering lines. 
//No measure() or layout() needed (handled by parent TextField).
function TextFieldLineElement()
{
	TextFieldLineElement.base.prototype.constructor.call(this);
	
	this._text = "";
	
	this._highlightMinIndex = 0;
	this._highlightMaxIndex = 0;
	
	this._parentTextField = null;
	this._charMetricsStartIndex = -1;
	this._charMetricsEndIndex = -1;	//Non-inclusive
}
	
//Inherit from CanvasElement
TextFieldLineElement.prototype = Object.create(CanvasElement.prototype);
TextFieldLineElement.prototype.constructor = TextFieldLineElement;
TextFieldLineElement.base = CanvasElement;	

TextFieldLineElement.prototype.setParentLineMetrics = 
	function (parentTextField, charStartIndex, charEndIndex)
	{
		this._parentTextField = parentTextField;
		this._charMetricsStartIndex = charStartIndex;
		this._charMetricsEndIndex = charEndIndex;
		
		var newText = parentTextField._text.substring(charStartIndex, charEndIndex);
		if (newText != this._text)
		{
			this._text = newText;
			this._invalidateRender();
		}
	};

TextFieldLineElement.prototype.setParentSelection = 
	function (startIndex, endIndex)
	{
		var minIndex = Math.min(startIndex, endIndex);
		var maxIndex = Math.max(startIndex, endIndex);
		
		if (minIndex < this._charMetricsStartIndex)
			minIndex = this._charMetricsStartIndex;
		if (maxIndex > this._charMetricsEndIndex)
			maxIndex = this._charMetricsEndIndex;
		
		//Highlight is outside of bounds, nuke it.
		if (minIndex > maxIndex || minIndex == maxIndex)
		{
			minIndex = 0;
			maxIndex = 0;
		}
		
		if (this._highlightMinIndex == minIndex && this._highlightMaxIndex == maxIndex)
			return;
		
		this._highlightMinIndex = minIndex;
		this._highlightMaxIndex = maxIndex;
		
		this._invalidateRender();
	};

TextFieldLineElement.prototype.getLineWidth = 
	function ()
	{
		if (this._charMetricsStartIndex > -1 && this._charMetricsEndIndex > -1)
			return this._parentTextField._charMetrics[this._charMetricsEndIndex].x - this._parentTextField._charMetrics[this._charMetricsStartIndex].x;
		
		return 0;
	};	
	
//@Override
TextFieldLineElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextFieldLineElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap ||
			"TextColor" in stylesMap ||
			"TextFillType" in stylesMap)
		{
			this._invalidateRender();
		}
		else if ("TextHighlightedColor" in stylesMap ||
				"TextHighlightedBackgroundColor" in stylesMap)
		{
			//Only re-render if in fact we have a highlighted selection.
			if (this._highlightMinIndex != this._highlightMaxIndex)
				this._invalidateRender();
		}
	};		
	
//@Override
TextFieldLineElement.prototype._doRender =
	function()
	{
		TextFieldLineElement.base.prototype._doRender.call(this);
		
		if (this._text.length == 0)
			return;
		
		var paddingMetrics = this._getPaddingMetrics();
		var ctx = this._getGraphicsCtx();
		
		//Get styles
		var textFillType = this.getStyle("TextFillType");
		var textColor = this.getStyle("TextColor");
		var highlightTextColor = this.getStyle("TextHighlightedColor");
		var backgroundHighlightTextColor = this.getStyle("TextHighlightedBackgroundColor");
		var fontString = this._getFontString();
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY() + (paddingMetrics.getHeight() / 2); 
		
		if (this._highlightMinIndex == this._highlightMaxIndex)
		{
			if (textFillType == "stroke")
				CanvasElement._strokeText(ctx, this._text, x, y, fontString, textColor, "middle");
			else
				CanvasElement._fillText(ctx, this._text, x, y, fontString, textColor, "middle");
		}
		else
		{
			for (var i = 0; i < this._text.length; i++)
			{
				var charWidth = CanvasElement._measureText(this._text[i], fontString);
				
				if (this._highlightMinIndex <= i && this._highlightMaxIndex > i)
				{
					ctx.fillStyle = backgroundHighlightTextColor;
					
					ctx.beginPath();
					ctx.moveTo(x, 0);
					ctx.lineTo(x + charWidth, 0);
					ctx.lineTo(x + charWidth, this._height);
					ctx.lineTo(x, this._height);
					ctx.closePath();
					ctx.fill();
					
					if (textFillType == "stroke")
						CanvasElement._strokeText(ctx, this._text[i], x, y, fontString, highlightTextColor, "middle");
					else
						CanvasElement._fillText(ctx, this._text[i], x, y, fontString, highlightTextColor, "middle");
				}
				else
				{
					if (textFillType == "stroke")
						CanvasElement._strokeText(ctx, this._text[i], x, y, fontString, textColor, "middle");
					else
						CanvasElement._fillText(ctx, this._text[i], x, y, fontString, textColor, "middle");
				}
				
				x += charWidth;
			}
		}
	};	

/////////////////////////////////////////////////////////
/////////////////TextFieldElement////////////////////////

/**
 * @class TextFieldElement
 * @inherits CanvasElement
 * 
 * Internal class used for consistently rendering text used by controls like TextElement and TextInput.
 * You typically should not use this class directly it is designed to be wrapped by a higher level control. 
 * This class allows text to be selected and edited, it renders a text position caret and watches
 * focus/mouse/keyboard events, maintains position of individual characters and allows copy/cut/paste.
 * 
 * TextField also normalizes text width. The canvas natively will give
 * different widths for strings than when measuring and adding character widths 
 * which will not work for highlighting or editing. 
 * 
 * 
 * @constructor TextFieldElement 
 * Creates new TextFieldElement instance.
 */
function TextFieldElement()
{
	TextFieldElement.base.prototype.constructor.call(this);
	
	//Element used as the blinky text caret when focused.
	this._textCaret = null;
	
	this._textHighlightStartIndex = 0;
	this._caretIndex = 0;
	this._caretEnabled = false;
	this._caretBlinkTime = 0;
	this._caretBlinkVisible = false;
	
	this._text = "";
	
	this._charMetrics = null; 	// array of {x, w}
	this._spaceSpans = null; 	// array of {start, end, type} _charMetric positions of spaces for wrapping text.
	
	this._dragHighlightScrollCharacterTime = 0;
	this._dragHighlightScrollCharacterDuration = 0;
	this._dragHighlightScrollCharacterDirection = 0;
	
	//Container for storing / clipping lines of text.
	this._textLinesContainer = new CanvasElement();
	this._textLinesContainer.setStyle("ClipContent", true);
	this._addChild(this._textLinesContainer);
	
	var _self = this;
	
	//Private event handlers, need different instance for each TextField. Proxy to prototype.
	this._onTextFieldFocusEventInstance = 
		function (event)
		{
			if (event.getType() == "focusin")
				_self._onTextFieldFocusIn(event);
			else
				_self._onTextFieldFocusOut(event);
		};
	
	this._onTextFieldKeyDownInstance = 
		function (keyboardEvent)
		{
			_self._onTextFieldKeyDown(keyboardEvent);
		};
		
	this._onTextFieldMouseEventInstance =
		function (mouseEvent)
		{
			if (mouseEvent.getType() == "mousedown")
				_self._onTextFieldMouseDown(mouseEvent);
			else if (mouseEvent.getType() == "mouseup")
				_self._onTextFieldMouseUp(mouseEvent);
			else if (mouseEvent.getType() == "mousemoveex")
				_self._onTextFieldCanvasMouseMoveEx(mouseEvent); 
		};
	
	this._onTextFieldEnterFrameInstance =
		function (event)
		{
			_self._onTextFieldEnterFrame(event);
		};
	
	this._onTextFieldCopyPasteInstance = 
		function (event)
		{
			window.removeEventListener(event.type, _self._onTextFieldCopyPasteInstance);
		
			try
			{
				if (event.clipboardData)
				{
					if (event.type == "copy")
						_self._onTextFieldCopy(event.clipboardData);
					else if (event.type == "paste")
						_self._onTextFieldPaste(event.clipboardData);
					else // "cut"
						_self._onTextFieldCut(event.clipboardData);
				}
				
				if (event.preventDefault)
					event.preventDefault();
				
				return false;
			}
			catch (ex)
			{
				
			}
		};
}

//Inherit from CanvasElement
TextFieldElement.prototype = Object.create(CanvasElement.prototype);
TextFieldElement.prototype.constructor = TextFieldElement;
TextFieldElement.base = CanvasElement;	


/////////////Events///////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the text is changed due to user interaction.
 */


/////////////Style Types///////////////////////////////

TextFieldElement._StyleTypes = Object.create(null);

/**
 * @style Selectable boolean
 * 
 * When true, the text can be highlighted and copied.
 */
TextFieldElement._StyleTypes.Selectable = 				{inheritable:false};		// true || false

/**
 * @style MaxChars int
 * 
 * The maximum number of characters allowed for this TextField. When 0 unlimited characters are allowed.
 */
TextFieldElement._StyleTypes.MaxChars = 				{inheritable:false};		// number

/**
 * @style Multiline boolean
 * 
 * When true, text will be rendered on multiple lines when width is constrained rather than horizontal scrolling.
 */
TextFieldElement._StyleTypes.Multiline = 				{inheritable:false};		// true || false



////////////Default Styles////////////////////////////

TextFieldElement.StyleDefault = new StyleDefinition();

TextFieldElement.StyleDefault.setStyle("Selectable", 					false);
TextFieldElement.StyleDefault.setStyle("MaxChars", 						0);
TextFieldElement.StyleDefault.setStyle("Multiline", 					false);

TextFieldElement.StyleDefault.setStyle("Enabled", 						false);
TextFieldElement.StyleDefault.setStyle("TabStop",						0);
TextFieldElement.StyleDefault.setStyle("Cursor", 						"text");			

TextFieldElement.StyleDefault.setStyle("BorderType", 					"none");
TextFieldElement.StyleDefault.setStyle("PaddingTop", 					0);
TextFieldElement.StyleDefault.setStyle("PaddingBottom",					0);
TextFieldElement.StyleDefault.setStyle("PaddingLeft", 					3);
TextFieldElement.StyleDefault.setStyle("PaddingRight", 					2);
TextFieldElement.StyleDefault.setStyle("BackgroundColor",				null);


////////Public///////////////////////

/**
 * @function setText
 * Sets the text string to be rendered.
 * 
 * @param text String
 * Text string to be rendered
 */
TextFieldElement.prototype.setText = 
	function (text)
	{
		if (text == null)
			text = "";
	
		//Make sure we have an actual string
		if (typeof text !== "string")
		{
			try
			{
				text = text.toString();
			}
			catch (ex)
			{
				text = "";
			}
		}
		
		var maxChars = this.getStyle("MaxChars");
		
		if (maxChars > 0 && text.length > maxChars)
			text = text.substring(0, maxChars);
		
		if (text != this._text)
		{
			this._text = text;
			
			this._charMetrics = null;
			
			this.setSelection(0, 0);
			
			//Reset scroll position
			if (this._textLinesContainer._getNumChildren() > 0 && this.getStyle("Multiline") == false)
				this._textLinesContainer._getChildAt(0)._setActualPosition(0, 0);
			
			this._invalidateMeasure();
			this._invalidateLayout();
		}
	};

/**
 * @function getText
 * Gets the current text string.
 * 
 * @returns String
 * Current text string.
 */	
TextFieldElement.prototype.getText = 
	function ()
	{
		return this._text;
	};

/**
 * @function setSelection
 * Sets the text selection or text caret position. When startIndex and endIndex are the same
 * it places the text caret at that position, when different, it selects / highlights that range of characters.
 * 
 * @param startIndex int
 * Character index to begin the selection.
 * 
 * @param endIndex int
 * Character index to end the selection.
 */	
TextFieldElement.prototype.setSelection = 
	function (startIndex, endIndex)
	{
		if (startIndex < 0)
			startIndex = 0;
		if (startIndex > this._text.length)
			startIndex = this._text.length;
		
		if (endIndex < 0)
			endIndex = 0;
		if (endIndex > this._text.length)
			endIndex = this._text.length;
		
		if (startIndex == this._textHighlightStartIndex && endIndex == this._caretIndex)
			return;
		
		this._textHighlightStartIndex = startIndex;
		this._caretIndex = endIndex;
		
		if (this._caretEnabled == true && startIndex == endIndex)
		{
			this._caretBlinkVisible = true;
			this._caretBlinkTime = Date.now() + 800;
		}
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
		
		this._invalidateLayout();
	};
	
/**
 * @function getSelection
 * Gets the current text selection or text caret position.
 * 
 * @returns Object
 * Object containing the start and end selection indexes. {startIndex, endIndex}
 */	
TextFieldElement.prototype.getSelection = 
	function ()
	{
		return {startIndex:this._textHighlightStartIndex, endIndex:this._caretIndex};
	};	
	
////////Internal/////////////////////	

/**
 * @function _createTextCaret
 * Generates a CanvasElement to be used as the text caret.
 * 
 * @returns CanvasElement
 * New CanvasElement instance to be used as the text caret.
 */
TextFieldElement.prototype._createTextCaret = 
	function ()
	{
		var textCaret = new CanvasElement();
		textCaret.setStyle("MouseEnabled", false);
		textCaret.setStyle("BackgroundColor", "TextCaretColor");
		textCaret.setStyle("AutoGradientStart", 0);
		textCaret.setStyle("AutoGradientStop", 0);
		
		return textCaret;
	};
	
//@private
TextFieldElement.prototype._updateCaretVisibility = 
	function ()
	{
		if (this._caretEnabled == true &&
			this._caretBlinkVisible == true && 
			this._caretIndex > -1 && this._caretIndex <= this._text.length && //Dont think this line is necessary
			this._caretIndex == this._textHighlightStartIndex)
		{
			if (this._textCaret == null)
			{
				this._textCaret = this._createTextCaret();
				this._addChild(this._textCaret);
			}
			
			this._textCaret.setStyle("Visible", true);
		}
		else if (this._textCaret != null)
			this._textCaret.setStyle("Visible", false);
	};
	
//@private - only active when caret is enabled or dragging highlight selection is scrolling.
TextFieldElement.prototype._onTextFieldEnterFrame = 
	function (event)
	{
		var currentTime = Date.now();
		
		if (currentTime > this._caretBlinkTime && 
			this._caretEnabled == true &&
			this._caretIndex > -1 && this._caretIndex <= this._text.length && //Dont think this line is necessary
			this._caretIndex == this._textHighlightStartIndex)
		{	
			if (this._caretBlinkVisible == true)
			{//Shutting off caret
				
				if (this._caretBlinkTime + 400 < currentTime)
					this._caretBlinkTime = currentTime + 400;
				else
					this._caretBlinkTime += 400; 
			}
			else
			{//Turning on caret
				
				if (this._caretBlinkTime + 800 < currentTime)
					this._caretBlinkTime = currentTime + 800;
				else
					this._caretBlinkTime += 800; 
			}
			
			this._caretBlinkVisible = !(this._caretBlinkVisible);
			this._updateCaretVisibility();
		}
		
		if (currentTime > this._dragHighlightScrollCharacterTime && 
			this._dragHighlightScrollCharacterDuration > 0)
		{
			this._dragHighlightScrollCharacterTime += this._dragHighlightScrollCharacterDuration;
			var caretIndexChanged = false;
				
			if (this._dragHighlightScrollCharacterDirection == "left" && this._caretIndex > 0)
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex - 1);
				caretIndexChanged = true;
			}
			else if (this._dragHighlightScrollCharacterDirection == "right" && this._caretIndex < this._text.length)
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex + 1);
				caretIndexChanged = true;
			}
			
			if (caretIndexChanged == true)
			{
				var w = this._textLinesContainer._width;
				var textFieldLine1 = this._textLinesContainer._getChildAt(0);
				
				//Adjust text scroll position if cursor is out of bounds.
				var scrollDistance = 3;
				var caretPosition = this._charMetrics[this._caretIndex].x + textFieldLine1._x;
						
				//Adjust scroll position.
				if (caretPosition < 1)
				{
					textFieldLine1._setActualPosition(
							Math.min(0, (this._charMetrics[this._caretIndex].x * -1) + scrollDistance), 
							textFieldLine1._y);
				}
				else if (caretPosition > w - 1)
				{
					textFieldLine1._setActualPosition(
							Math.max(w - textFieldLine1._width, (this._charMetrics[this._caretIndex].x * -1) + w - scrollDistance), 
							textFieldLine1._y);
				}
			}
		}
	};
	
//@private	
TextFieldElement.prototype._enableCaret = 
	function ()
	{
		if (this._caretEnabled == true)
			return;
	
		this._caretEnabled = true;
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
	};
	
//@private	
TextFieldElement.prototype._disableCaret = 
	function ()
	{
		if (this._caretEnabled == false)
			return;
	
		this._caretEnabled = false;
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
	};

//@private - Only active if TextField is Enabled or Selectable.
TextFieldElement.prototype._onTextFieldFocusIn = 
	function (elementEvent)
	{
		//Tab focus (mouse would have already set caret)
		if (this._caretEnabled == true || this.getStyle("Enabled") == false)
			return;
	
		this._enableCaret();
		this.setSelection(0, this._text.length);
	};
	
//@private - Only active if TextField is Enabled or Selectable.	
TextFieldElement.prototype._onTextFieldFocusOut = 
	function (event)
	{
		this._disableCaret();
		this.setSelection(0, 0);
	};

/**
 * @function _getCaretIndexFromMouse
 * Gets the position to place the text caret based on the position of the mouse.
 * 
 * @param mouseX Number
 * Current X position of the mouse.
 * 
 * @param mouseY Number
 * Current Y position of the mouse.
 * 
 * @returns int
 * Corresponding caret character index.
 */	
TextFieldElement.prototype._getCaretIndexFromMouse = 
	function (mouseX, mouseY)
	{
		if (this._charMetrics == null || this._charMetrics.length == 0)
			return 0;
	
		var x = this._textLinesContainer._x;
		var w = this._textLinesContainer._width;
		mouseX += 2; //Text cursor is slightly offset. TODO: make this a style
		
		var textFieldLine1 = this._textLinesContainer._getChildAt(0);
		
		var charX = 0;
		var charW = 0;
		
		var newCaretIndex = 0;
		for (var i = 0; i <= this._text.length; i++)
		{
			charX = this._charMetrics[i].x + x + textFieldLine1._x;
			charW = this._charMetrics[i].width;
			
			if (charX < x)
				continue;
			
			if (charX > x + w)
				break;
			
			newCaretIndex = i;
			
			if (mouseX <= charX + (charW / 2))
				break;
		}
		
		return newCaretIndex;
	};

	
//@private - Only active if TextField is Enabled or Selectable.		
TextFieldElement.prototype._onTextFieldMouseDown = 
	function (mouseEvent)
	{
		if (this.hasEventListener("mousemoveex", this._onTextFieldMouseEventInstance) == false)
			this.addEventListener("mousemoveex", this._onTextFieldMouseEventInstance);

		var caretIndex = this._getCaretIndexFromMouse(mouseEvent.getX(), mouseEvent.getY());
		
		if (this.getStyle("Enabled") == true)
			this._enableCaret();
		
		this.setSelection(caretIndex, caretIndex);
	};
	
//@private - Only active if TextField is Enabled or Selectable.		
TextFieldElement.prototype._onTextFieldMouseUp = 
	function (mouseEvent)
	{
		if (this.hasEventListener("mousemoveex", this._onTextFieldMouseEventInstance) == true)
			this.removeEventListener("mousemoveex", this._onTextFieldMouseEventInstance);
		
		this._dragHighlightScrollCharacterDuration = 0;
		this._updateEnterFrameListener();
	};	
	
//@private - Only active if selectable or enabled and mouse is down.	
TextFieldElement.prototype._onTextFieldCanvasMouseMoveEx = 
	function (mouseEvent)
	{
		var mousePoint = {x:mouseEvent.getX(), y:mouseEvent.getY()};
		this.translatePointFrom(mousePoint, this._manager);
		
		var x = this._textLinesContainer._x;
		var w = this._textLinesContainer._width;
		
		var scrollDuration = 0;
		
		var caretIndex = this._getCaretIndexFromMouse(mousePoint.x, mousePoint.y);
		if (caretIndex == this._caretIndex)
		{
			if (mousePoint.x <= x + 2 && this._caretIndex > 0)
			{
				var range = Math.abs(x + 2 - mousePoint.x) * 3;
				scrollDuration = Math.max(20, 120 - range);
				
				if (this._dragHighlightScrollCharacterDuration == 0)
					this._dragHighlightScrollCharacterTime = Date.now() + scrollDuration;
				
				this._dragHighlightScrollCharacterDirection = "left";
			}
			else if (mousePoint.x >= x + w - 2 && this._caretIndex < this._text.length)
			{
				var range = Math.abs(x + w - 2 - mousePoint.x) * 3;
				scrollDuration = Math.max(20, 120 - range);
				
				if (this._dragHighlightScrollCharacterDuration == 0)
					this._dragHighlightScrollCharacterTime = Date.now() + scrollDuration;
				
				this._dragHighlightScrollCharacterDirection = "right";
			}
		}
		else
			this.setSelection(this._textHighlightStartIndex, caretIndex);
		
		this._dragHighlightScrollCharacterDuration = scrollDuration;
		this._updateEnterFrameListener();
	};
	
//@private	
TextFieldElement.prototype._updateCharXPositions = 
	function (startAfterIndex)
	{
		if (this._charMetrics == null || this._charMetrics.length == 0)
			return;
		
		if (startAfterIndex > this._charMetrics.length - 2)
			return;
		
		if (startAfterIndex < 0)
		{
			startAfterIndex = 0;
			this._charMetrics[0].x = 0;
		}
			
		var currentPos = this._charMetrics[startAfterIndex].x + this._charMetrics[startAfterIndex].width;
		for (var i = startAfterIndex + 1; i < this._charMetrics.length; i++)
		{
			this._charMetrics[i].x = currentPos;
			currentPos += this._charMetrics[i].width;
		}
	};

//@private	
TextFieldElement.prototype._deleteHighlightChars = 
	function ()
	{
		if (this._textHighlightStartIndex == this._caretIndex)
			return;
	
		var highlightBegin = Math.min(this._caretIndex, this._textHighlightStartIndex);
		var highlightEnd = Math.max(this._caretIndex, this._textHighlightStartIndex);
	
		//Fix char metrics
		this._charMetrics.splice(highlightBegin, highlightEnd - highlightBegin);
		this._updateCharXPositions(highlightBegin - 1);
		
		//Update string
		var strLeft = this._text.substring(0, highlightBegin);
		var strRight = this._text.substring(highlightEnd);
		this._text = strLeft + strRight;
		
		//Move caret
		this.setSelection(highlightBegin, highlightBegin);
	};	
	
/**
 * @function _onTextFieldKeyDown
 * Event handler for "keydown" event. Only active when TextField is enabled and focused.
 * Handles editing and cursor navigation / selection.
 * 
 * @param keyboardEvent ElementKeyboardEvent
 * ElementKeyboardEvent to process.
 */	
TextFieldElement.prototype._onTextFieldKeyDown = 
	function (keyboardEvent)
	{
		if (keyboardEvent.getDefaultPrevented() == true)
			return;
	
		var enabled = this.getStyle("Enabled");
		var keyString = keyboardEvent.getKey();
		var dispatchChanged = false;
		
		if (keyString == "c" && keyboardEvent.getCtrl() == true)
		{
			if (this._textHighlightStartIndex == this._caretIndex)
			{
				keyboardEvent.preventDefault();
				return;
			}
			
			//IE
			if (window.clipboardData)
			{
				this._onTextFieldCopy(window.clipboardData);
				keyboardEvent.preventDefault();
			} 
			else //FF, Chrome, Webkit (Allow keyboard event to invoke the copy / paste listener)
			{
				window.addEventListener("copy", this._onTextFieldCopyPasteInstance);
				this._invalidateLayout(); //Purges the listener if something upstream cancels the keyboard event.
			}
			
			return;
		}
		else if (keyString == "ArrowLeft")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex - 1);
			}
			else if (enabled == true)
			{
				if (this._textHighlightStartIndex != this._caretIndex)
					this.setSelection(Math.min(this._caretIndex, this._textHighlightStartIndex), Math.min(this._caretIndex, this._textHighlightStartIndex));
				else
					this.setSelection(this._caretIndex - 1, this._caretIndex - 1);
			}
		}
		else if (keyString == "ArrowRight")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex + 1);
			}
			else if (enabled == true)
			{
				if (this._textHighlightStartIndex != this._caretIndex)
					this.setSelection(Math.max(this._caretIndex, this._textHighlightStartIndex), Math.max(this._caretIndex, this._textHighlightStartIndex));
				else
					this.setSelection(this._caretIndex + 1, this._caretIndex + 1);
			}
		}
		else if (keyString == "End")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, this._text.length);
			}
			else if (enabled == true)
				this.setSelection(this._text.length, this._text.length);
		}
		else if (keyString == "Home")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, 0);
			}
			else if (enabled == true)
				this.setSelection(0, 0);
		}
		else if (enabled == false) 
		{
			return;
		}
		else if (keyString == "Backspace")
		{
			if (this._textHighlightStartIndex != this._caretIndex)
				this._deleteHighlightChars();
			else
			{
				if (this._text.length == 0 || this._caretIndex == 0)
				{
					keyboardEvent.preventDefault();
					return;
				}
				
				//Fix char metrics
				this._charMetrics.splice(this._caretIndex - 1, 1);
				this._updateCharXPositions(this._caretIndex - 2);
				
				//Update string
				var strLeft = this._text.substring(0, this._caretIndex - 1);
				var strRight = this._text.substring(this._caretIndex);
				this._text = strLeft + strRight;
				
				//Move caret
				this.setSelection(this._caretIndex - 1, this._caretIndex - 1);
			}
			
			dispatchChanged = true;
		}
		else if (keyString == "Delete")
		{
			if (this._textHighlightStartIndex != this._caretIndex)
				this._deleteHighlightChars();
			else
			{
				if (this._text.length == 0 || this._caretIndex == this._text.length)
				{
					keyboardEvent.preventDefault();
					return;
				}
	
				//Fix char metrics
				this._charMetrics.splice(this._caretIndex, 1);
				this._updateCharXPositions(this._caretIndex - 1);
				
				//Update string
				var strLeft = this._text.substring(0, this._caretIndex);
				var strRight = this._text.substring(this._caretIndex + 1);
				this._text = strLeft + strRight;
			}
			
			dispatchChanged = true;
		}
		else if (keyString == "v" && keyboardEvent.getCtrl() == true)
		{
			//IE
			if (window.clipboardData)
			{
				this._onTextFieldPaste(window.clipboardData);
				keyboardEvent.preventDefault();
			} 
			else //FF, Chrome, Webkit (Allow keyboard event to invoke the copy / paste listener)
			{
				window.addEventListener("paste", this._onTextFieldCopyPasteInstance);
				this._invalidateLayout(); //Purges the listener if something upstream cancels the keyboard event.
			}
			
			return;
		}
		else if (keyString == "x" && keyboardEvent.getCtrl() == true)
		{
			if (this._textHighlightStartIndex == this._caretIndex)
			{
				keyboardEvent.preventDefault();
				return;
			}
			
			//IE
			if (window.clipboardData)
			{
				this._onTextFieldCut(window.clipboardData);
				keyboardEvent.preventDefault();
			} 
			else //FF, Chrome, Webkit (Allow keyboard event to invoke the copy / paste listener)
			{
				window.addEventListener("cut", this._onTextFieldCopyPasteInstance);
				this._invalidateLayout(); //Purges the listener if something upstream cancels the keyboard event.
			}
			
			return;
		}
		else if (keyString.length == 1)
		{
			this._deleteHighlightChars();
			
			var maxChars = this.getStyle("MaxChars");
			
			if (maxChars > 0 && maxChars <= this._text.length)
			{
				keyboardEvent.preventDefault();
				return;
			}
			
			//Measure new char
			var newCharMetrics = {x:0, width:CanvasElement._measureText(keyString, this._getFontString())};
			
			//Fix char metrics
			this._charMetrics.splice(this._caretIndex, 0, newCharMetrics);
			this._updateCharXPositions(this._caretIndex - 1);
			
			//Update string
			var strLeft = this._text.substring(0, this._caretIndex);
			var strRight = this._text.substring(this._caretIndex);
			this._text = strLeft + keyString + strRight;
			
			//Move caret
			this.setSelection(this._caretIndex + 1, this._caretIndex + 1);
			
			dispatchChanged = true;
		}
		else
			return;
		
		this._scrollIfCaretOutOfBounds();
		this._invalidateLayout();
		
		if (dispatchChanged == true)
			this._dispatchEvent(new ElementEvent("changed", false));
		
		keyboardEvent.preventDefault();
	};

//@private	
TextFieldElement.prototype._scrollIfCaretOutOfBounds = 
	function ()
	{
		var textFieldLine1 = this._textLinesContainer._getChildAt(0);
		var w = this._textLinesContainer._width;
		var scrollDistance = Math.min(Math.floor(w * 0.3), 35);
		
		//Adjust text scroll position if cursor is out of bounds.
		var caretPosition = this._charMetrics[this._caretIndex].x + textFieldLine1._x;
				
		//Adjust scroll position (we dont know the width of the text line yet...) layout will fix if we overshoot
		if (caretPosition < 2)
		{
			textFieldLine1._setActualPosition(
				(this._charMetrics[this._caretIndex].x * -1) + scrollDistance,
				textFieldLine1._y);
		}
		else if (caretPosition > w - 2)
		{
			textFieldLine1._setActualPosition(
				(this._charMetrics[this._caretIndex].x * -1) + w - scrollDistance, 
				textFieldLine1._y);
		}
	};
	
/**
 * @function _onTextFieldCopy
 * Event handler for native browser "copy" event. Copies selected text to clipboard.
 * 
 * @param clipboardData BrowserClipboard
 * The browser clipboard object to copy text too.
 */	
TextFieldElement.prototype._onTextFieldCopy = 
	function (clipboardData)
	{
		var highlightBegin = Math.min(this._caretIndex, this._textHighlightStartIndex);
		var highlightEnd = Math.max(this._caretIndex, this._textHighlightStartIndex);
		
		var copyText = this._text.substring(highlightBegin, highlightEnd);
		
		clipboardData.setData("Text", copyText);
	};
	
/**
 * @function _onTextFieldCopy
 * Event handler for native browser "paste" event. Pastes clipboard text into TextField.
 * 
 * @param clipboardData BrowserClipboard
 * The browser clipboard object to copy text from.
 */		
TextFieldElement.prototype._onTextFieldPaste = 
	function (clipboardData)
	{
		var pasteString = clipboardData.getData("Text");
		
		if (pasteString == null || pasteString.length == 0)
			return;
		
		var maxChars = this.getStyle("MaxChars");
		if (maxChars > 0 && this._text.length >= maxChars && this._caretIndex >= maxChars)
			return;
		
		this._deleteHighlightChars();
		
		//Measure new chars
		var fontString = this._getFontString();
		for (var i = 0; i < pasteString.length; i++)
		{
			this._charMetrics.splice(this._caretIndex + i, 0, 
					{x:0, width:CanvasElement._measureText(pasteString[i], fontString)});
		}

		//Fix char metrics
		this._updateCharXPositions(this._caretIndex - 1);
		
		//Update string
		var strLeft = this._text.substring(0, this._caretIndex);
		var strRight = this._text.substring(this._caretIndex);
		this._text = strLeft + pasteString + strRight;
		
		//Move caret
		this.setSelection(this._caretIndex + pasteString.length, this._caretIndex + pasteString.length);
		
		//Truncate if exceeding max characters
		if (maxChars > 0 && this._text.length > maxChars)
		{
			this._text = this._text.subString(0, maxChars);
			this._charMetrics.splice(0, this._text.length - maxChars);
			this.setSelection(this._text.length, this._text.length);
		}
		
		this._scrollIfCaretOutOfBounds();
		this._invalidateLayout();
		
		this._dispatchEvent(new ElementEvent("changed", false));
	};

/**
 * @function _onTextFieldCut
 * Event handler for native browser "cut" event. Copies selected text to clipboard and deletes from TextField.
 * 
 * @param clipboardData BrowserClipboard
 * The browser clipboard object to copy text too.
 */		
TextFieldElement.prototype._onTextFieldCut = 
	function (clipboardData)
	{
		var highlightBegin = Math.min(this._caretIndex, this._textHighlightStartIndex);
		var highlightEnd = Math.max(this._caretIndex, this._textHighlightStartIndex);
		
		var copyText = this._text.substring(highlightBegin, highlightEnd);
		
		clipboardData.setData("Text", copyText);
		
		this._deleteHighlightChars();
		
		this._scrollIfCaretOutOfBounds();
		this._invalidateLayout();
		
		this._dispatchEvent(new ElementEvent("changed", false));
	};
	
//@Override	
TextFieldElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		TextFieldElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		this._disableCaret();
		
		if (this.hasEventListener("mousemoveex", this._onTextFieldMouseEventInstance) == true)
			this.removeEventListener("mousemoveex", this._onTextFieldMouseEventInstance);
		
		if (this.hasEventListener("enterframe", this._onTextFieldEnterFrameInstance) == true)
			this.removeEventListener("enterframe", this._onTextFieldEnterFrameInstance);
	};		
	
//@private	
TextFieldElement.prototype._updateEnterFrameListener = 
	function ()
	{
		if (this._dragHighlightScrollCharacterDuration > 0 ||
			(this._caretEnabled == true && this._textHighlightStartIndex == this._caretIndex))
		{
			if (this.hasEventListener("enterframe", this._onTextFieldEnterFrameInstance) == false)
				this.addEventListener("enterframe", this._onTextFieldEnterFrameInstance);
		}
		else
		{
			if (this.hasEventListener("enterframe", this._onTextFieldEnterFrameInstance) == true)
				this.removeEventListener("enterframe", this._onTextFieldEnterFrameInstance);
		}
	};
	
/**
 * @function _updateEventListeners
 * Adds removes mouse, keyboard, and focus event listeners based on Enabled and Selectable styles.
 * Called in response to style changes.
 */	
TextFieldElement.prototype._updateEventListeners = 
	function ()
	{
		var enabled = this.getStyle("Enabled");
		var selectable = this.getStyle("Selectable");
		
		if (selectable == true || enabled == true)
		{
			if (this.hasEventListener("keydown", this._onTextFieldKeyDownInstance) == false)
				this.addEventListener("keydown", this._onTextFieldKeyDownInstance);
			
			if (this.hasEventListener("mousedown", this._onTextFieldMouseEventInstance) == false)
				this.addEventListener("mousedown", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("mouseup", this._onTextFieldMouseEventInstance) == false)
				this.addEventListener("mouseup", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("focusin", this._onTextFieldFocusEventInstance) == false)
				this.addEventListener("focusin", this._onTextFieldFocusEventInstance);
			
			if (this.hasEventListener("focusout", this._onTextFieldFocusEventInstance) == false)
				this.addEventListener("focusout", this._onTextFieldFocusEventInstance);
		}
		else
		{
			if (this.hasEventListener("keydown", this._onTextFieldKeyDownInstance) == true)
				this.removeEventListener("keydown", this._onTextFieldKeyDownInstance);
			
			if (this.hasEventListener("mousedown", this._onTextFieldMouseEventInstance) == true)
				this.removeEventListener("mousedown", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("mouseup", this._onTextFieldMouseEventInstance) == true)
				this.removeEventListener("mouseup", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("focusin", this._onTextFieldFocusEventInstance) == true)
				this.removeEventListener("focusin", this._onTextFieldFocusEventInstance);
			
			if (this.hasEventListener("focusout", this._onTextFieldFocusEventInstance) == true)
				this.removeEventListener("focusout", this._onTextFieldFocusEventInstance);
		}
		
		if (enabled == false)
			this._disableCaret();
	};

	
//@Override
TextFieldElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextFieldElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap)
		{
			this._charMetrics = null;
			
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("Multiline" in stylesMap ||
			"TextLinePaddingTop" in stylesMap ||
			"TextLinePaddingBottom" in stylesMap)
		{
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("TextAlign" in stylesMap ||
			"TextBaseline" in stylesMap || 
			"TextLineSpacing" in stylesMap)
		{
			this._invalidateLayout();
		}
		
		if ("MaxChars" in stylesMap)
			this.setText(this._text); //Will trim if needed.
		
		if ("TextCaretColor" in stylesMap && this._textCaret != null)
			this._textCaret.setStyle("BackgroundColor", this.getStyle("TextCaretColor"));
		
		if ("Enabled" in stylesMap || "Selectable" in stylesMap)
			this._updateEventListeners();
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
	};	
	
///**
// * @function _getCharMetrics
// * Gets a DrawMetrics object containing position and size data of character at supplied index.
// * 
// * @param charIndex int
// * Index of character to return metrics.
// * 
// * @returns DrawMetrics
// * DrawMetrics object containing position and size data of character at supplied index.
// */	
//TextFieldElement.prototype._getCharMetrics = 
//	function (charIndex)
//	{
//		if (this._charMetrics == null || 
//			charIndex < 0 ||
//			charIndex >= this._text.length)
//		{
//			return null;
//		}
//		
//		var metrics = new DrawMetrics();
//		metrics._height = this._textHeight;
//		metrics._width = this._charMetrics[charIndex].width;
//		metrics._x = this._charMetrics[charIndex].x + this._textXScrollPosition;
//		metrics._y = this._textYPosition;
//		
//		return metrics;
//	};
	
//@private	
TextFieldElement.prototype._createCharMetrics = 
	function ()
	{
		if (this._charMetrics != null)
			return;
	
		var currentX = 0;
		var currentWidth = 0;
		
		this._charMetrics = [];
		this._spaceSpans = [];
		
		var currentSpaceSpan = null;
		
		if (this._text.length > 0)
		{
			var fontString = this._getFontString();	
			
			for (var i = 0; i < this._text.length; i++)
			{
				currentWidth = CanvasElement._measureText(this._text[i], fontString);
				
				this._charMetrics.push(
					{
						x:		currentX,
						width: 	currentWidth
					});
				
				if (this._text[i] == " ")
				{
					if (currentSpaceSpan == null)
						currentSpaceSpan = {start:i, end:i, type:"space"};
					else
						currentSpaceSpan.end = i;
				}
				else if (currentSpaceSpan != null)
				{
					this._spaceSpans.push(currentSpaceSpan);
					currentSpaceSpan = null;
				}
				
				if (this._text[i] == '\n')
					this._spaceSpans.push({start:i, end:i, type:"nline"});
				
				currentX += currentWidth;
			}
		}
		
		if (currentSpaceSpan != null)
			this._spaceSpans.push(currentSpaceSpan);
		
		//Dummy for caret at end of string
		this._charMetrics.push( { x:currentX, width:0 }); 
		this._invalidateLayout();
	};
	
//@Override
TextFieldElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		this._createCharMetrics();
	
		var measuredSize = {width:0, height:0};
		var singleLineTextWidth = this._charMetrics[this._text.length].x;
		
		var linePadTop = this.getStyle("TextLinePaddingTop");
		var linePadBottom = this.getStyle("TextLinePaddingBottom");
		var textSize = this.getStyle("TextSize");
		
		//Always add 1 for text caret 
		//TODO: This should be the text caret's width only when editable
		measuredSize.width = 1 + singleLineTextWidth + padWidth;
		measuredSize.height = textSize + linePadTop + linePadBottom + padHeight;

		//If using multi-line, height is dependent on actual width so layout
		//must run and do the actual measurment...
		if (this.getStyle("Multiline") == true)
		{	
			measuredSize.width = this.getStyle("MinWidth"); //We need the parent to know it can contract us.
			this._invalidateLayout();
		}
		
		return measuredSize;
	};	
	
//@Override	
TextFieldElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		TextFieldElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		//Adjust text x position per scroll / align.
		var availableWidth = w - 1; // account for caret width - TODO: width should be width of caret element, always 1 for now.
		
		//Size / Position the line container.
		this._textLinesContainer._setActualPosition(x, y);
		this._textLinesContainer._setActualSize(availableWidth, h);
		
		var isMultiline = this.getStyle("Multiline");
		var textAlign = this.getStyle("TextAlign");
		var textBaseline = this.getStyle("TextBaseline");
		var textSize = this.getStyle("TextSize");
		var lineSpacing = this.getStyle("TextLineSpacing");
		var linePaddingTop = this.getStyle("TextLinePaddingTop");
		var linePaddingBottom = this.getStyle("TextLinePaddingBottom");
		var lineHeight = textSize + linePaddingTop + linePaddingBottom;
		
		var spaceSpanIndex = 0;
		var lineStartCharIndex = 0;
		var lineEndCharIndex = 0;
		
		var newLineData = null;
		var lines = [];
		
		var caretLineIndex = 0;
		var newlineFound = false;
		
		while (lineStartCharIndex < this._charMetrics.length)
		{
			newLineData = {charMetricsStartIndex:-1, charMetricsEndIndex:-1};
			
			if (isMultiline == false)
			{
				newLineData.charMetricsStartIndex = 0; 
				newLineData.charMetricsEndIndex = this._charMetrics.length - 1;
				caretLineIndex = 0;
				lineStartCharIndex = this._charMetrics.length;
			}
			else
			{
				newLineData.charMetricsStartIndex = lineStartCharIndex;
				newlineFound = false;
				
				for (var i = spaceSpanIndex; i < this._spaceSpans.length; i++)
				{
					if (textAlign == "left")
						lineEndCharIndex = this._spaceSpans[i].end;
					else
						lineEndCharIndex = this._spaceSpans[i].start;
					
					if (this._charMetrics[lineEndCharIndex].x - this._charMetrics[newLineData.charMetricsStartIndex].x <= availableWidth ||
						newLineData.charMetricsEndIndex == -1)
					{
						newLineData.charMetricsEndIndex = lineEndCharIndex;
						
						spaceSpanIndex++;
						lineStartCharIndex = lineEndCharIndex + 1;
						
						if (this._spaceSpans[i].type == "nline")
						{
							newlineFound = true;
							break;
						}
					}
					else
						break;
				}
				
				//Last line, no more spaces for breaks.
				if (newLineData.charMetricsEndIndex == -1 || 
					(this._charMetrics[ this._charMetrics.length - 1].x - this._charMetrics[newLineData.charMetricsStartIndex].x <= availableWidth && newlineFound == false))
				{
					newLineData.charMetricsEndIndex = this._charMetrics.length - 1;
					lineStartCharIndex = this._charMetrics.length;
				}
			}
			
			lines.push(newLineData);
		}
		
		var totalTextHeight = (lines.length * lineHeight) + ((lines.length - 1) * lineSpacing); 
		
		//Update the measured size now that we know the height. (May cause another layout pass)
		if (isMultiline == true)
			this._setMeasuredSize(this._measuredWidth, totalTextHeight + this._getPaddingSize().height);
			
		var textYPosition;
		if (textBaseline == "top")
			textYPosition = 0;
		else if (textBaseline == "bottom")
			textYPosition = h - totalTextHeight;
		else //middle
			textYPosition = Math.round((h / 2) - (totalTextHeight / 2));
		 
		//Update actual line data
		var totalNewOldLines = Math.max(lines.length, this._textLinesContainer._getNumChildren());
		var textFieldLine = null;
		var lineWidth = 0;
		var lineXPosition;
		for (var i = 0; i < totalNewOldLines; i++)
		{
			//Line removed
			if (lines[i] == null)
				this._textLinesContainer._removeChildAt(i);
			else
			{
				textFieldLine = this._textLinesContainer._getChildAt(i);
				if (textFieldLine == null) //Line added
				{
					textFieldLine = new TextFieldLineElement();
					this._textLinesContainer._addChild(textFieldLine);
				}
				
				//Update line
				textFieldLine.setParentLineMetrics(this, lines[i].charMetricsStartIndex, lines[i].charMetricsEndIndex);
				textFieldLine.setParentSelection(this._textHighlightStartIndex, this._caretIndex);
				
				textFieldLine.setStyle("PaddingTop", linePaddingTop);
				textFieldLine.setStyle("PaddingBottom", linePaddingBottom);
				
				lineWidth = textFieldLine.getLineWidth();
				textFieldLine._setActualSize(lineWidth, lineHeight);
				
				if (lineWidth < availableWidth || isMultiline == true) //align
				{
					if (textAlign == "right")
						lineXPosition = availableWidth - lineWidth;
					else if (textAlign == "center")
						lineXPosition = Math.round((availableWidth / 2) - (lineWidth / 2));
					else // "left"
						lineXPosition = 0;
				}
				else //fill excess (over-scroll or resize)
				{
					if (textFieldLine._x > 0)
						lineXPosition = 0;					
					else if (textFieldLine._x + lineWidth < availableWidth)
						lineXPosition = availableWidth - lineWidth;
					else
						lineXPosition = textFieldLine._x;
				}
				
				textFieldLine._setActualPosition(lineXPosition, textYPosition);
				
				textYPosition += (lineHeight + lineSpacing);
			}
		}
		
		
		if (this._textCaret != null)
		{
			if (this._caretIndex < 0 || this._caretIndex > this._text.length)
				this._textCaret._setActualSize(0, lineHeight);
			else
			{
				//Find the line the caret is on.
				textFieldLine = this._textLinesContainer._getChildAt(caretLineIndex);

				var caretXPosition = this._charMetrics[this._caretIndex].x + textFieldLine._x + x;
				
				if (caretXPosition >= x && caretXPosition <= x + w - 1) //account for caret width
				{		
					this._textCaret._setActualPosition(caretXPosition, textFieldLine._y + y);
					this._textCaret._setActualSize(1, lineHeight);
				}
				else
					this._textCaret._setActualSize(0, lineHeight);
			}
		}
		
		//If we added a global listener, but a parent canceled the keyboard event, we need to purge these.
		window.removeEventListener("copy", this._onTextFieldCopyPasteInstance);
		window.removeEventListener("paste", this._onTextFieldCopyPasteInstance);
		window.removeEventListener("cut", this._onTextFieldCopyPasteInstance);
	};		
	
	


/**
 * @depends CanvasElement.js
 */

/////////////////////////////////////////////////////////
/////////////////TextElement/////////////////////////////	
	
/**
 * @class TextElement
 * @inherits CanvasElement
 * 
 * Renders mutli-line style-able select-able text. 
 * TextElement respects newline characters and will
 * wrap text when width is constrained. If only a single
 * line of text is needed, you should use LabelElement.
 * 
 * @constructor TextElement 
 * Creates new TextElement instance.
 */
function TextElement()
{
	TextElement.base.prototype.constructor.call(this);
	
	this._textField = new TextFieldElement();
	this._textField.setStyle("Multiline", true);
	this._textField.setStyle("Cursor", null);
	this._textField.setStyle("TabStop", -1);
	this._addChild(this._textField);
}

//Inherit from CanvasElement
TextElement.prototype = Object.create(CanvasElement.prototype);
TextElement.prototype.constructor = TextElement;
TextElement.base = CanvasElement;

/////////////Style Types///////////////////////////////

TextElement._StyleTypes = Object.create(null);

/**
 * @style Text String
 * Text to be rendered by the TextElement.
 */
TextElement._StyleTypes.Text = 				{inheritable:false};		// "any string" || null

/**
 * @style Selectable boolean
 * When true, text can be highlighted and copied.
 */
TextElement._StyleTypes.Selectable = 			{inheritable:false};		// true || false


////////////Default Styles////////////////////////////

TextElement.StyleDefault = new StyleDefinition();

//Override base class styles
TextElement.StyleDefault.setStyle("PaddingTop", 					2);
TextElement.StyleDefault.setStyle("PaddingBottom", 					2);
TextElement.StyleDefault.setStyle("PaddingLeft", 					2);
TextElement.StyleDefault.setStyle("PaddingRight", 					2);

//TextElement specific styles
TextElement.StyleDefault.setStyle("Text", 							null);
TextElement.StyleDefault.setStyle("Selectable", 					false);


/////////////Internal Functions///////////////////

//@Override
TextElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("Text" in stylesMap)
			this._textField.setText(this.getStyle("Text"));
		
		if ("Selectable" in stylesMap)
			this._textField.setStyle("Selectable", this.getStyle("Selectable"));
		
		//Proxy padding to TextField for proper mouse handling
		if ("Padding" in stylesMap ||
			"PaddingTop" in stylesMap ||
			"PaddingBottom" in stylesMap ||
			"PaddingLeft" in stylesMap ||
			"PaddingRight" in stylesMap)
		{
			var paddingSize = this._getPaddingSize();
			
			this._textField.setStyle("PaddingTop", paddingSize.paddingTop);
			this._textField.setStyle("PaddingBottom", paddingSize.paddingBottom);
			this._textField.setStyle("PaddingLeft", paddingSize.paddingLeft);
			this._textField.setStyle("PaddingRight", paddingSize.paddingRight);
		}
	};
	
//@Override
TextElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		//Ignore padding, proxied to TextField
		return {width:this._textField._measuredWidth, height:this._textField._measuredHeight};
	};	

//@Override	
TextElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		TextElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//Ignore padding, proxied to TextField for mouse handling.
		this._textField._setActualPosition(0, 0);
		this._textField._setActualSize(this._width, this._height);
	};



/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////////ScrollButtonSkinElement///////////////////////////

/**
 * @class ScrollButtonSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the ScrollButton.
 * 
 * 
 * @constructor ScrollButtonSkinElement 
 * Creates new ScrollButtonSkinElement instance.
 */
function ScrollButtonSkinElement()
{
	ScrollButtonSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
ScrollButtonSkinElement.prototype = Object.create(CanvasElement.prototype);
ScrollButtonSkinElement.prototype.constructor = ScrollButtonSkinElement;
ScrollButtonSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
ScrollButtonSkinElement._StyleTypes = Object.create(null);

/**
 * @style ArrowColor String
 * 
 * Hex color value to be used for the arrow icon. Format like "#FF0000" (red).
 */
ScrollButtonSkinElement._StyleTypes.ArrowColor =					{inheritable:false};		//"#000000"

/**
 * @style ArrowDirection String
 * 
 * Determines the arrow direction. Allowable values are "up", "down", "left", "right". 
 * Note that ScrollBar sets this style directly to the parent button depending on the scroll bar orientation.
 */
ScrollButtonSkinElement._StyleTypes.ArrowDirection =						{inheritable:false};	//"up" || "down" || "left" || "right"


////////Default Styles//////////////////

ScrollButtonSkinElement.StyleDefault = new StyleDefinition();

ScrollButtonSkinElement.StyleDefault.setStyle("ArrowColor", 						"#000000");
ScrollButtonSkinElement.StyleDefault.setStyle("ArrowDirection", 					"up");


/////////Internal Functions////////////////////////

//@Override
ScrollButtonSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ScrollButtonSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ArrowColor" in stylesMap || 
			"ArrowDirection" in stylesMap)
		{
			this._invalidateRender();
		}
	};

//@Override
ScrollButtonSkinElement.prototype._doRender = 
	function()
	{
		ScrollButtonSkinElement.base.prototype._doRender.call(this);
		
		var ctx = this._getGraphicsCtx();
		
		var arrowDirection = this.getStyle("ArrowDirection");
		var arrowColor = this.getStyle("ArrowColor");
		
		var borderThickness = this._getBorderThickness();
		
		var x = borderThickness;
		var y = borderThickness;
		var width = this._width - (borderThickness * 2);
		var height = this._height - (borderThickness * 2);
		
		ctx.beginPath();
		
		if (arrowDirection == "up")
		{
			ctx.moveTo(x + (width / 2), y + (height * .35));
			ctx.lineTo(x + (width * .80), y + (height * .65));
			ctx.lineTo(x + (width * .20), y + (height * .65));
		}
		else if (arrowDirection == "down")
		{
			ctx.moveTo(x + (width / 2), y + (height * .65));
			ctx.lineTo(x + (width * .80), y + (height * .35));
			ctx.lineTo(x + (width * .20), y + (height * .35));
		}
		else if (arrowDirection == "left")
		{
			ctx.moveTo(x + (width * .35), y + (height / 2));
			ctx.lineTo(x + (width * .65), y + (height * .20));
			ctx.lineTo(x + (width * .65), y + (height * .80));
		}
		else if (arrowDirection == "right")
		{
			ctx.moveTo(x + (width * .65), y + (height / 2));
			ctx.lineTo(x + (width * .35), y + (height * .20));
			ctx.lineTo(x + (width * .35), y + (height * .80));
		}
		
		ctx.closePath();
		
		ctx.fillStyle = arrowColor;
		ctx.fill();
		
	};		
	
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////////RadioButtonSkinElement////////////////////////////

/**
 * @class RadioButtonSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the RadioButtonElement.  
 * Renders an inner selected indicator using the BackgroundShape style.
 * 
 * 
 * @constructor RadioButtonSkinElement 
 * Creates new RadioButtonSkinElement instance.
 */
function RadioButtonSkinElement()
{
	RadioButtonSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
RadioButtonSkinElement.prototype = Object.create(CanvasElement.prototype);
RadioButtonSkinElement.prototype.constructor = RadioButtonSkinElement;
RadioButtonSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
RadioButtonSkinElement._StyleTypes = Object.create(null);

/**
 * @style CheckColor String
 * 
 * Hex color value to be used for the check icon. Format like "#FF0000" (red).
 */
RadioButtonSkinElement._StyleTypes.CheckColor =						{inheritable:false};		//"#000000"

/**
 * @style CheckSize Number
 * 
 * Value between 0 and 1 used to determine the size that the "selected" indicator 
 * should be rendered relative to this element's size.
 */
RadioButtonSkinElement._StyleTypes.CheckSize = 						{inheritable:false};


////////Default Styles////////////////
RadioButtonSkinElement.StyleDefault = new StyleDefinition();

//RadioButtonSkinElement specific styles
RadioButtonSkinElement.StyleDefault.setStyle("CheckColor", 			"#000000");
RadioButtonSkinElement.StyleDefault.setStyle("CheckSize", 			.35);


/////////Protected Functions////////////////////////

//@Override
RadioButtonSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		RadioButtonSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SkinState" in stylesMap || "CheckColor" in stylesMap)
			this._invalidateRender();
	};

//@Override
RadioButtonSkinElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:14, height:14};
	};

//@Override
RadioButtonSkinElement.prototype._doRender = 
	function()
	{
		RadioButtonSkinElement.base.prototype._doRender.call(this);
		
		var currentState = this.getStyle("SkinState");
		
		//Draw indicator.
		if (currentState.indexOf("selected") == 0)
		{
			var ctx = this._getGraphicsCtx();
			
			var checkSize = this.getStyle("CheckSize");
			
			var indicatorMetrics = new DrawMetrics();
			indicatorMetrics._width = this._width * checkSize;
			indicatorMetrics._height = this._height * checkSize;
			indicatorMetrics._x = (this._width - indicatorMetrics._width) / 2;
			indicatorMetrics._y = (this._height - indicatorMetrics._height) / 2;
			
			if (indicatorMetrics._width <= 0 || indicatorMetrics._height <= 0)
				return;
			
			ctx.beginPath();
			this._drawBackgroundShape(ctx, indicatorMetrics);
			
			ctx.fillStyle = this.getStyle("CheckColor");
			ctx.fill();
		}
	};		
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////DropdownArrowButtonSkinElement////////////////////////

/**
 * @class DropdownArrowButtonSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for Arrow button in the DropdownElement.
 * Renders the divider line and an arrow.
 *  
 * 
 * @constructor DropdownArrowButtonSkinElement 
 * Creates new DropdownArrowButtonSkinElement instance.
 */
function DropdownArrowButtonSkinElement()
{
	DropdownArrowButtonSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
DropdownArrowButtonSkinElement.prototype = Object.create(CanvasElement.prototype);
DropdownArrowButtonSkinElement.prototype.constructor = DropdownArrowButtonSkinElement;
DropdownArrowButtonSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
DropdownArrowButtonSkinElement._StyleTypes = Object.create(null);

/**
 * @style ArrowColor String
 * 
 * Hex color value to be used for the arrow. Format like "#FF0000" (red).
 */
DropdownArrowButtonSkinElement._StyleTypes.ArrowColor =				{inheritable:false};		//"#000000"

/**
 * @style LineColor String
 * 
 * Hex color value to be used for the divider line. Format like "#FF0000" (red).
 */
DropdownArrowButtonSkinElement._StyleTypes.LineColor =				{inheritable:false};		//"#000000"


//////Default Styles///////////////////

DropdownArrowButtonSkinElement.StyleDefault = new StyleDefinition();

DropdownArrowButtonSkinElement.StyleDefault.setStyle("ArrowColor", 				"#000000"); 		
DropdownArrowButtonSkinElement.StyleDefault.setStyle("LineColor", 				"#000000"); 


/////////Internal Functions////////////////////////

//@Override
DropdownArrowButtonSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DropdownArrowButtonSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ArrowColor" in stylesMap || 
			"LineColor" in stylesMap)
		{
			this._invalidateRender();
		}
	};

//@Override
DropdownArrowButtonSkinElement.prototype._doRender = 
	function()
	{
		DropdownArrowButtonSkinElement.base.prototype._doRender.call(this);
		
		var ctx = this._getGraphicsCtx();
		var paddingMetrics = this._getPaddingMetrics();
		
		var lineColor = this.getStyle("LineColor");
		var arrowColor = this.getStyle("ArrowColor");
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var width = paddingMetrics.getWidth();
		var height = paddingMetrics.getHeight();
		
		ctx.beginPath();
		
		ctx.moveTo(x + (width / 2), y + (height * .60));
		ctx.lineTo(x + (width * .70), y + (height * .40));
		ctx.lineTo(x + (width * .30), y + (height * .40));
		
		ctx.closePath();
		
		ctx.fillStyle = arrowColor;
		ctx.fill();
		

		var lineHeight = height * .65;
		
		ctx.beginPath();

		ctx.moveTo(x, y + (height / 2) - (lineHeight / 2));
		ctx.lineTo(x, y + (height / 2) + (lineHeight / 2));
		ctx.lineTo(x + 1, y + (height / 2) + (lineHeight / 2));
		ctx.lineTo(x + 1, y + (height / 2) - (lineHeight / 2));
		
		ctx.closePath();
		
		ctx.fillStyle = lineColor;
		ctx.fill();
	};	
	
	


/**
 * @depends CanvasElement.js
 */

//////////////////////////////////////////////////////////////////
//////DataGridHeaderColumnDividerSkinElement//////////////////////		
	
/**
 * @class DataGridHeaderColumnDividerSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the draggable DataGrid column dividers.
 * Renders a line, and drag arrows when mouse is over.
 * 
 * 
 * @constructor DataGridHeaderColumnDividerSkinElement 
 * Creates new DataGridHeaderColumnDividerSkinElement instance.
 */
function DataGridHeaderColumnDividerSkinElement()
{
	DataGridHeaderColumnDividerSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
DataGridHeaderColumnDividerSkinElement.prototype = Object.create(CanvasElement.prototype);
DataGridHeaderColumnDividerSkinElement.prototype.constructor = DataGridHeaderColumnDividerSkinElement;
DataGridHeaderColumnDividerSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
DataGridHeaderColumnDividerSkinElement._StyleTypes = Object.create(null);

/**
 * @style DividerLineColor String
 * 
 * Hex color value to be used for the divider line. Format like "#FF0000" (red).
 */
DataGridHeaderColumnDividerSkinElement._StyleTypes.DividerLineColor =			{inheritable:false};		//"#000000"

/**
 * @style DividerArrowColor String
 * 
 * Hex color value to be used for the arrows. Format like "#FF0000" (red).
 */
DataGridHeaderColumnDividerSkinElement._StyleTypes.DividerArrowColor =			{inheritable:false};		//"up" || "down" || "left" || "right"


////////Default Styles////////////////

DataGridHeaderColumnDividerSkinElement.StyleDefault = new StyleDefinition();

DataGridHeaderColumnDividerSkinElement.StyleDefault.setStyle("DividerLineColor", 		"#777777");
DataGridHeaderColumnDividerSkinElement.StyleDefault.setStyle("DividerArrowColor", 		"#444444");



//@Override
DataGridHeaderColumnDividerSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridHeaderColumnDividerSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("DividerLineColor" in stylesMap ||
			"DividerArrowColor" in stylesMap)
		{
			this._invalidateRender();
		}
	};

//@Override
DataGridHeaderColumnDividerSkinElement.prototype._doRender = 
	function()
	{
		DataGridHeaderColumnDividerSkinElement.base.prototype._doRender.call(this);
		
		var ctx = this._getGraphicsCtx();
		
		var lineColor = this.getStyle("DividerLineColor");
		var arrowColor = this.getStyle("DividerArrowColor");
		var currentState = this.getStyle("SkinState");
		
		var x = 0;
		var y = 0;
		var w = this._width;
		var h = this._height;
		
		ctx.beginPath();

		ctx.moveTo(x + (w / 2) - .5, y);
		ctx.lineTo(x + (w / 2) - .5, y + h);
		ctx.lineTo(x + (w / 2) + .5, y + h);
		ctx.lineTo(x + (w / 2) + .5, y);
		
		ctx.closePath();
		
		ctx.fillStyle = lineColor;
		ctx.fill();
		
		////////////////////////////
		
		if (currentState == "over" || currentState == "down")
		{
			var arrowHeight = h / 2;
			
			ctx.fillStyle = arrowColor;
			
			ctx.beginPath();
			
			ctx.moveTo(x + (w / 2) - .5 - 1, (h / 2) - (arrowHeight / 2));
			ctx.lineTo(x + (w / 2) - .5 - 1, (h / 2) + (arrowHeight / 2));
			ctx.lineTo(x, y + (h / 2));
			
			ctx.closePath();
			ctx.fill();
			
			ctx.beginPath();
			
			ctx.moveTo(x + (w / 2) + .5 + 1, (h / 2) - (arrowHeight / 2));
			ctx.lineTo(x + (w / 2) + .5 + 1, (h / 2) + (arrowHeight / 2));
			ctx.lineTo(x + w, y + (h / 2));
			
			ctx.closePath();
			ctx.fill();
		}
	};
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////CheckboxSkinElement/////////////////////////////

/**
 * @class CheckboxSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the CheckboxElement.
 * 
 * 
 * @constructor CheckboxSkinElement 
 * Creates new CheckboxSkinElement instance.
 */
function CheckboxSkinElement()
{
	CheckboxSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
CheckboxSkinElement.prototype = Object.create(CanvasElement.prototype);
CheckboxSkinElement.prototype.constructor = CheckboxSkinElement;
CheckboxSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
CheckboxSkinElement._StyleTypes = Object.create(null);

/**
 * @style CheckColor String
 * 
 * Hex color value to be used for the check icon. Format like "#FF0000" (red).
 */
CheckboxSkinElement._StyleTypes.CheckColor =				{inheritable:false};		//"#000000"


////////Default Styles////////////////

CheckboxSkinElement.StyleDefault = new StyleDefinition();

//CheckboxSkinElement specific styles
CheckboxSkinElement.StyleDefault.setStyle("CheckColor", 						"#000000");


/////////Protected Functions////////////////////////

//@Override
CheckboxSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		CheckboxSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SkinState" in stylesMap || "CheckColor" in stylesMap)
			this._invalidateRender();
	};

//@Override
CheckboxSkinElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:14, height:14};
	};

//@Override
CheckboxSkinElement.prototype._doRender = 
	function()
	{
		CheckboxSkinElement.base.prototype._doRender.call(this);
		
		var currentState = this.getStyle("SkinState");
		
		//Draw check or dash.
		if (currentState.indexOf("selected") == 0 || 
			currentState.indexOf("half") == 0)
		{
			var ctx = this._getGraphicsCtx();
			
			var borderThickness = this._getBorderThickness();
			var checkColor = this.getStyle("CheckColor");
			
			var x = borderThickness;
			var y = borderThickness;
			var width = this._width - (borderThickness * 2);
			var height = this._height - (borderThickness * 2);
			
			if (currentState.indexOf("selected") == 0) //Draw check
			{
				ctx.beginPath();
				
				ctx.moveTo(x + (width * .10), 
							y + (height * .60));
				
				ctx.lineTo(x + (width * .40),
							y + height * .90);
				
				ctx.lineTo(x + (width * .90),
							y + (height * .26));
				
				ctx.lineTo(x + (width * .78),
							y + (height * .10));
				
				ctx.lineTo(x + (width * .38),
							y + height * .65);
				
				ctx.lineTo(x + (width * .20),
							y + height * .45);
				
				ctx.closePath();
			}
			else //Half selected - Draw dash
			{
				ctx.beginPath();
				
				ctx.moveTo(x + (width * .12), 
							y + (height * .42));
				
				ctx.lineTo(x + (width * .12),
							y + height * .58);
				
				ctx.lineTo(x + (width * .88),
							y + (height * .58));
				
				ctx.lineTo(x + (width * .88),
							y + (height * .42));
				
				ctx.closePath();
			}
			
			ctx.fillStyle = checkColor;
			ctx.fill();
		}
	};		
	
	


/**
 * @depends CanvasElement.js
 */

//////////////////////////////////////////////////////////////////////
///////////////////////SkinnableElement///////////////////////////////	
	
/**
 * @class SkinnableElement
 * @inherits CanvasElement
 * 
 * Abstract base class for skin-able components. Allows changing states, stores a list
 * of skins per state and toggles skin visibility per the current state. 
 * Any states may be used. As an example, ButtonElement uses "up", "over", "down", and "disabled" states.
 * Override appropriate functions to return skin classes and style definitions per the element's states. 
 * SkinnableElement does not render itself, its skins do. It proxies all rendering 
 * related styles to its skins (such as BackgroundColor).
 * 
 * @seealso StyleProxy
 * 
 * 
 * @constructor SkinnableElement 
 * Creates new SkinnableElement instance.
 */
function SkinnableElement()
{
	SkinnableElement.base.prototype.constructor.call(this);
	
	this._skins = Object.create(null);
	this._currentSkin = null;
	
	/**
	 * @member _currentSkinState String
	 * Read only - String representing the current state.
	 */
	this._currentSkinState = "";
	
}

//Inherit from CanvasElement
SkinnableElement.prototype = Object.create(CanvasElement.prototype);
SkinnableElement.prototype.constructor = SkinnableElement;
SkinnableElement.base = CanvasElement;


//Proxy map for styles we want to pass to skins.
SkinnableElement._SkinProxyMap = Object.create(null);

//Proxy styles that affect rendering.
SkinnableElement._SkinProxyMap.BorderType = 				true;
SkinnableElement._SkinProxyMap.BorderColor = 				true;
SkinnableElement._SkinProxyMap.BorderThickness = 			true;
SkinnableElement._SkinProxyMap.BackgroundColor = 			true;
SkinnableElement._SkinProxyMap.AutoGradientType = 			true;
SkinnableElement._SkinProxyMap.AutoGradientStart = 			true;
SkinnableElement._SkinProxyMap.AutoGradientStop = 			true;
SkinnableElement._SkinProxyMap.BackgroundShape = 			true;

//Proxy styles that are not defined by the element.
SkinnableElement._SkinProxyMap._Arbitrary =					true;


//////////////////Internal Functions///////////////////
/**
 * @function _getSkinClass
 * Gets the skin class to use per the provided state. 
 * Override this to return different skin classes for different states.
 * 
 * @param state String
 * The state for which to return a skin class.
 * 
 * @returns Function
 * Return the constructor of the appropriate skin class.
 */
SkinnableElement.prototype._getSkinClass = 
	function (state)
	{
		return null;
	};

/**
 * @function _getSkinStyleDefinitions
 * Gets an array of StyleDefinitions to be applied to the skin class per the provided state.
 * Override this to return different StyleDefinitions for different states.
 * 
 * @param state String
 * The state for which to return an array of StyleDefinitions.
 * 
 * @returns Array
 * Return the appropriate array of StyleDefinitions for the provided state.
 */	
SkinnableElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		return null;
	};

/**
 * @function _getSkinStyleDefinitionDefault
 * Gets the default StyleDefinition to be applied to the skin class per the provided state.
 * Override this to return different default StyleDefinitions for different states. Use 
 * _getDefaultStyle() to return the appropriate default style definition.
 * 
 * @param state String
 * The state for which to return a default StyleDefinition.
 * 
 * @returns StyleDefinition
 * Return the appropriate default StyleDefinition per _getDefaultStyle("MyStyleNameForMyState") for the provided state.
 */	
SkinnableElement.prototype._getSkinStyleDefinitionDefault = 
	function (state)
	{
		return null;
	};
	
/**
 * @function _getSkinStyleProxyMap
 * Gets the Style proxy map to pass to skins. Override this if you need to pass additional styles
 * to custom skins. You should include all the styles provided in the default SkinnableElement style map.
 * 
 * @returns Object
 * Return a style proxy map to be applied to this element to all skins. Formatted as:
 * 
 * MyProxyMap = Object.create(null);
 * MyProxyMap.StyleName1 = true;
 * MyProxyMap.StyleName2 = true;
 * 
 * @seealso StyleProxy
 */	
SkinnableElement.prototype._getSkinStyleProxyMap = 
	function ()
	{
		return SkinnableElement._SkinProxyMap;
	};
	
/**
 * @function _updateSkinStyleDefinitions
 * Updates the StyleDefinition for the skin of the provided state. Subclasses should call
 * this within their _doStylesUpdated() when skin style definitions change.
 * 
 * @param state String
 * The state for which to update the StyleDefinition.
 */	
SkinnableElement.prototype._updateSkinStyleDefinitions = 
	function (state)
	{
		var skinElement = this._skins[state];
		
		//Skin instance not yet created.
		if (skinElement == null)
			return;
	
		skinElement.setStyleDefinitions(this._getSkinStyleDefinitions(state));
	};
	
/**
 * @function _updateSkinClass
 * Updates the skin class for the skin of the provided state. Subclasses should call
 * this within their _doStylesUpdated() when skin style class changes.
 * 
 * @param state String
 * The state for which to update the skin class.
 */		
SkinnableElement.prototype._updateSkinClass = 
	function (state)
	{
		//If the skin hasnt been created bail. State change will create later.
		if (this._skins[state] == null && state != this._currentSkinState)
			return;
		
		var newSkinClass = this._getSkinClass(state);
		var currentSkinClass = null;
		
		if (this._skins[state] != null)
			currentSkinClass = this._skins[state].constructor;
		
		//Skin class has not changed.
		if (newSkinClass == currentSkinClass)
			return;
		
		//Nuke the old skin
		if (this._skins[state] != null)
		{
			this._removeChild(this._skins[state]);
			this._skins[state] = null;
		}
		
		//Only create the new skin if its active, otherwise state change will create later.
		if (this._currentSkinState == state)
		{
			//Create new and adjust visibility if needed
			var newSkin = this._createSkin(state);
			this._currentSkin = newSkin;
			
			if (newSkin != null)
				newSkin.setStyle("Visible", true);
		}
	};	
	
//@private	
SkinnableElement.prototype._createSkin = 
	function (state)
	{
		var skinClass = this._getSkinClass(state);
		if (skinClass == null)
		{
			this._skins[state] = null;
			return null;
		}
	
		var newSkin = new (skinClass)();
		
		this._skins[state] = newSkin;
		
		newSkin._setStyleDefinitionDefault(this._getSkinStyleDefinitionDefault(state));
		newSkin._setStyleProxy(new StyleProxy(this, this._getSkinStyleProxyMap()));
		
		newSkin.setStyle("MouseEnabled", false);
		newSkin.setStyle("SkinState", state);
		this._updateSkinStyleDefinitions(state);
		
		this._addChildAt(newSkin, 0);
		
		return newSkin;
	};
	
/**
 * @function _changeState
 * Called when the element changes skin state. Do not call this function directly.
 * You may override this if you need to make additional changes to your component
 * when the skin state changes (such as updating a label color).
 * 
 * @param state String
 * The skin state that this element is changing too.
 * 
 * @returns boolean
 * Returns true if the element state has actually changed, false if it is the same state. 
 * Subclasses can check what this base function returns before making additional changes for better performance.
 */	
SkinnableElement.prototype._changeState = 
	function (state)
	{
		if (this._currentSkinState == state || state == "" || state == null)
			return false;
	
		this._currentSkinState = state;
		
		var foundSkin = false;
		for (var skinState in this._skins)
		{
			//Ignore null skins.
			if (this._skins[skinState] == null)
				continue;
			
			if (skinState == state)
			{
				this._currentSkin = this._skins[skinState];
				this._skins[skinState].setStyle("Visible", true);
				foundSkin = true;
			}
			else 
				this._skins[skinState].setStyle("Visible", false);
		}
		
		//Attempt to create the skin (this may be null anyway)
		if (foundSkin == false)
		{
			this._currentSkin = this._createSkin(state);
			
			if (this._currentSkin != null)
				this._currentSkin.setStyle("Visible", true);
		}
		
		return true;
	};

//@override	
SkinnableElement.prototype._setActualRotation = 
	function (degrees, centerX, centerY)
	{
		var currentDegrees = this._rotateDegrees;
	
		SkinnableElement.base.prototype._setActualRotation.call(this, degrees, centerX, centerY);
	
		//Rotation changed
		if (this._rotateDegrees != currentDegrees)
		{
			var autoGradientType;
			var backgroundColor;
			var borderType;
			
			for (var skinState in this._skins)
			{
				//Check if we need to re-render due to auto gradient
				autoGradientType = this._skins[skinState].getStyle("AutoGradientType");
				backgroundColor = this._skins[skinState].getStyle("BackgroundColor");
				borderType = this._skins[skinState].getStyle("BorderType");
				
				if (autoGradientType != null && autoGradientType != "none" && 
					(backgroundColor != null || (borderType != null && borderType != "none")))
				{
					this._skins[skinState]._invalidateRender();
				}
			}
		}
	};	
	
//@override
SkinnableElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		SkinnableElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SkinState" in stylesMap)
			this._changeState(this.getStyle("SkinState"));
	};	
	
//@override	
SkinnableElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		SkinnableElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//We have to size all skins, not just the current skin. Otherwise if multiple skins 
		//are created within 1 cycle (multiple immediate state changes) we could end up with 
		//a skin that never gets sized unless we invalidate layout on every skin change.
		for (var prop in this._skins)
		{
			if (this._skins[prop] == null)
				continue;
			
			this._skins[prop]._setActualSize(this._width, this._height);
			this._skins[prop]._setActualPosition(0, 0);
		}
	};	

//@Override
SkinnableElement.prototype._doRender = 
	function ()
	{
		//Do nothing, don't call base. SkinnableElement does not render itself, its skins do.
	
		//TODO: Use the active skin metrics & shape to render the focus ring.
		//if (this._renderFocusRing == true)
		//	this._drawFocusRing(ctx, this._getBorderMetrics());
	};	
	
	


/**
 * @depends SkinnableElement.js
 */

/////////////////////////////////////////////////////////
///////////////TextInputElement//////////////////////////	
	
/**
 * @class TextInputElement
 * @inherits SkinnableElement
 * 
 * TextInput is an edit-able single line text box.
 * 
 * 
 * @constructor TextInputElement 
 * Creates new TextInputElement instance.
 */
function TextInputElement()
{
	TextInputElement.base.prototype.constructor.call(this);
	
	this._textField = new TextFieldElement();
	this._textField.setStyle("Selectable", true);
	this._textField.setStyle("Cursor", null);
	this._textField.setStyle("TabStop", -1);
	this._addChild(this._textField);
	
	var _self = this;
	
	//Private event handlers, need different instance for each TextInput. Proxy to prototype.
	this._onTextInputFocusEventInstance = 
		function (event)
		{
			if (event.getType() == "focusin")
				_self._onTextInputFocusIn(event);
			else
				_self._onTextInputFocusOut(event);
		};
	
	this._onTextInputKeyDownInstance = 
		function (keyboardEvent)
		{
			_self._onTextInputKeyDown(keyboardEvent);
		};
		
	this._onTextInputTextFieldChangedInstance = 
		function (event)
		{
			_self._onTextInputTextFieldChanged(event);
		};
		
	this.addEventListener("focusin", this._onTextInputFocusEventInstance);
	this.addEventListener("focusout", this._onTextInputFocusEventInstance);	
}

//Inherit from SkinnableElement
TextInputElement.prototype = Object.create(SkinnableElement.prototype);
TextInputElement.prototype.constructor = TextInputElement;
TextInputElement.base = SkinnableElement;

/////////////Events////////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the text is modified as a result of user input.
 */


/////////////Style Types///////////////////////////////

TextInputElement._StyleTypes = Object.create(null);

/**
 * @style MaxChars int
 * 
 * Maximum number of characters allowed.
 */
TextInputElement._StyleTypes.MaxChars = 								{inheritable:false};		// number

/**
 * @style SkinClass CanvasElement
 * 
 * The CanvasElement constructor type to apply to all skin states. 
 * Specific states such as UpSkinClass will override SkinClass.
 */
TextInputElement._StyleTypes.SkinClass =								{inheritable:false};		//Element constructor()

/**
 * @style UpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the skin when in the "up" state. 
 * This will override SkinClass.
 */
TextInputElement._StyleTypes.UpSkinClass = 								{inheritable:false};		//Element constructor()

/**
 * @style UpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "up" state skin element.
 */
TextInputElement._StyleTypes.UpSkinStyle = 								{inheritable:false};		//StyleDefinition

/**
 * @style UpTextColor String
 * 
 * Hex color value to be used for the button TextInput is in the "up" state. Format like "#FF0000" (red).
 * This will override the TextColor style.
 */
TextInputElement._StyleTypes.UpTextColor = 								{inheritable:false};		// color "#000000"

/**
 * @style UpTextHighlightedColor String
 * 
 * Hex color value to be used for highlighted text when the TextInput is in the "up" state. Format like "#FF0000" (red).
 * This will override the TextHighlightedColor style.
 */
TextInputElement._StyleTypes.UpTextHighlightedColor = 					{inheritable:false};		// color "#FFFFFF"

/**
 * @style UpTextHighlightedBackgroundColor String
 * 
 * Hex color value to be used for highlighted text background when the TextInput is in the "up" state. Format like "#FF0000" (red).
 * This will override the TextHighlightedBackgroundColor style.
 */
TextInputElement._StyleTypes.UpTextHighlightedBackgroundColor = 	{inheritable:false};			// color "#000000"

/**
 * @style DisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the TextInput is in the "disabled" state.
 * When this is null, the base SkinClass style will be used.
 */
TextInputElement._StyleTypes.DisabledSkinClass = 						{inheritable:false};		// Element constructor()

/**
 * @style DisabledSkinStyle StyleDefinition
 * The StyleDefinition to apply to the "disabled" state skin element.
 * When this is null, the base SkinTyle will be used.
 */
TextInputElement._StyleTypes.DisabledSkinStyle = 						{inheritable:false};		// StyleDefinition

/**
 * @style DisabledTextColor String
 * 
 * Hex color value to be used for the button TextInput is in the "disabled" state. Format like "#FF0000" (red).
 * This will override the TextColor style.
 */
TextInputElement._StyleTypes.DisabledTextColor = 						{inheritable:false};		// color "#000000"

/**
 * @style DisabledTextHighlightedColor String
 * 
 * Hex color value to be used for highlighted text when the TextInput is in the "disabled" state. Format like "#FF0000" (red).
 * When this is null, the base TextHighlightedColor style will be used.
 */
TextInputElement._StyleTypes.DisabledTextHighlightedColor = 			{inheritable:false};		// color "#FFFFFF"

/**
 * @style DisabledTextHighlightedBackgroundColor String
 * 
 * Hex color value to be used for highlighted text background when the TextInput is in the "disabled" state. Format like "#FF0000" (red).
 * When this is null, the base TextHighlightedBackgroundColor style will be used.
 */
TextInputElement._StyleTypes.DisabledTextHighlightedBackgroundColor = 	{inheritable:false};		// color "#000000"


/////////////Default Styles///////////////////////////

TextInputElement.StyleDefault = new StyleDefinition();

TextInputElement.StyleDefault.setStyle("MaxChars", 									0);
TextInputElement.StyleDefault.setStyle("Enabled", 									true);

TextInputElement.StyleDefault.setStyle("UpTextColor", 								"#000000");
TextInputElement.StyleDefault.setStyle("UpTextHighlightedColor", 					"#FFFFFF");
TextInputElement.StyleDefault.setStyle("UpTextHighlightedBackgroundColor", 			"#000000");

TextInputElement.StyleDefault.setStyle("DisabledTextColor", 						"#888888");
TextInputElement.StyleDefault.setStyle("DisabledTextHighlightedColor", 				"#FFFFFF");
TextInputElement.StyleDefault.setStyle("DisabledTextHighlightedBackgroundColor", 	"#000000");

TextInputElement.StyleDefault.setStyle("PaddingTop",								3);
TextInputElement.StyleDefault.setStyle("PaddingBottom",								3);
TextInputElement.StyleDefault.setStyle("PaddingLeft",								3);
TextInputElement.StyleDefault.setStyle("PaddingRight",								3);

TextInputElement.StyleDefault.setStyle("TabStop", 									0);
TextInputElement.StyleDefault.setStyle("Cursor", 									"text");

TextInputElement.StyleDefault.setStyle("SkinClass", 								CanvasElement);
TextInputElement.StyleDefault.setStyle("UpSkinClass", 								CanvasElement);
TextInputElement.StyleDefault.setStyle("DisabledSkinClass", 						CanvasElement);

/////Skin styles//
TextInputElement.DisabledSkinStyleDefault = new StyleDefinition();

TextInputElement.DisabledSkinStyleDefault.setStyle("BorderType", 					"inset");
TextInputElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 				1);
TextInputElement.DisabledSkinStyleDefault.setStyle("BorderColor", 					"#999999");
TextInputElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 				"#ECECEC");
TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));

TextInputElement.UpSkinStyleDefault = new StyleDefinition();

TextInputElement.UpSkinStyleDefault.setStyle("BorderType", 							"inset");
TextInputElement.UpSkinStyleDefault.setStyle("BorderThickness", 					1);
TextInputElement.UpSkinStyleDefault.setStyle("BorderColor", 						"#606060");
TextInputElement.UpSkinStyleDefault.setStyle("BackgroundColor", 					"#F5F5F5");

//Apply skin defaults
TextInputElement.StyleDefault.setStyle("UpSkinStyle", 								TextInputElement.UpSkinStyleDefault);
TextInputElement.StyleDefault.setStyle("DisabledSkinStyle", 						TextInputElement.DisabledSkinStyleDefault);



////////Public///////////////////////

/**
 * @function setText
 * Sets the text to be displayed.
 * 
 * @param text String
 * Text to be displayed.
 */
TextInputElement.prototype.setText = 
	function (text)
	{
		this._textField.setText(text);
	};

/**
 * @function getText
 * Gets the text currently displayed.
 * 
 * @returns String
 * Text currently displayed.
 */	
TextInputElement.prototype.getText = 
	function ()
	{
		return this._textField.getText();
	};


////////Internal/////////////////////

/**
 * @function _onTextInputTextFieldChanged
 * Event handler for the internal TextField "changed" event. Only active when TextInput is Enabled.
 * Dispatches a "changed" event from this TextInput element.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to be processed.
 */	
TextInputElement.prototype._onTextInputTextFieldChanged = 
	function (elementEvent)
	{
		//Pass on the changed event
	
		if (this.hasEventListener("changed", null) == true)
			this._dispatchEvent(new ElementEvent("changed", false));
	};
	
/**
 * @function _onTextInputKeyDown
 * Event handler for "keydown" event. Only active when TextInput is enabled. 
 * Proxies keyboard event to internal TextField.
 * 
 * @param keyboardEvent ElementKeyboardEvent
 * ElementKeyboardEvent to process.
 */	
TextInputElement.prototype._onTextInputKeyDown = 
	function (keyboardEvent)
	{
		if (keyboardEvent.getDefaultPrevented() == true)
			return;
		
		var clonedEvent = keyboardEvent.clone();
		clonedEvent._bubbles = false; //Dont bubble.
		
		//Dispatch non-bubbling keyboard event to our text field.
		this._textField._dispatchEvent(clonedEvent);
		
		if (clonedEvent.getIsCanceled() == true)
			keyboardEvent.cancelEvent();
			
		if (clonedEvent.getDefaultPrevented() == true)
			keyboardEvent.preventDefault();
	};

/**
 * @function _onTextInputFocusIn
 * Event handler for "focusin" event. 
 * Proxies focus event to internal TextField.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to process.
 */		
TextInputElement.prototype._onTextInputFocusIn = 
	function (elementEvent)
	{
		//This only works because TextField doesnt look at _isFocused (manages caret state with different flag)
		this._textField._dispatchEvent(elementEvent.clone()); 
	};

/**
 * @function _onTextInputFocusOut
 * Event handler for "focusout" event. 
 * Proxies focus event to internal TextField.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to process.
 */		
TextInputElement.prototype._onTextInputFocusOut = 
	function (elementEvent)
	{
		//This only works because TextField doesnt look at _isFocused (manages caret state with different flag)
		this._textField._dispatchEvent(elementEvent.clone());
	};
	
//@Override
TextInputElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
		
		if (state == "up")
			stateSkinClass = this.getStyleData("UpSkinClass");
		else if (state == "disabled")
			stateSkinClass = this.getStyleData("DisabledSkinClass");
		
		var skinClass = this.getStyleData("SkinClass");
		
		//Shouldnt have null stateSkinClass
		if (stateSkinClass == null || skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
	
//@override	
TextInputElement.prototype._getSkinStyleDefinitions = 
function (state)
{
	if (state == "up")
		return this.getStyle("UpSkinStyle");
	else if (state == "disabled")
		return this.getStyle("DisabledSkinStyle");
	
	return TextInputElement.base.prototype._getSkinStyleDefinitions.call(this, state);
};	

//@Override
TextInputElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "up")
			return this._getDefaultStyle("UpSkinStyle");
		else if (state == "disabled")
			return this._getDefaultStyle("DisabledSkinStyle");
		
		return TextInputElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};		
	
/**
 * @function _updateState
 * Updates the current SkinState in response to style changes.
 */	
TextInputElement.prototype._updateState = 
	function ()
	{
		var newState = "up";

		if (this.getStyle("Enabled") == false)
			newState = "disabled";
		
		this.setStyle("SkinState", newState);
	};	
	
//@Override
TextInputElement.prototype._changeState = 
	function (state)
	{
		TextInputElement.base.prototype._changeState.call(this, state);
	
		this._updateTextColors();
	};
	
/**
 * @function _updateTextColors
 * Updates the text colors based on the current state. Called when state changes and when added to display hierarchy.
 */	
TextInputElement.prototype._updateTextColors = 
	function ()
	{
		this._textField.setStyle("TextColor", this._getTextColor(this._currentSkinState));
		this._textField.setStyle("TextHighlightedColor", this._getTextHighlightedColor(this._currentSkinState));
		this._textField.setStyle("TextHighlightedBackgroundColor", this._getTextHighlightedBackgroundColor(this._currentSkinState));
	};
	
/**
 * @function _getTextColor
 * Gets the text color for the supplied state based on text styles.
 * 
 * @param state String
 * The skin state to return the text color.
 * 
 * @returns String
 * Hex color value.
 */	
TextInputElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextColor");
	
		var textColor = this.getStyleData("TextColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};
	
/**
 * @function _getTextHighlightedColor
 * Gets the highlighted text color for the supplied state based on text styles.
 * 
 * @param state String
 * The skin state to return the highlighted text color.
 * 
 * @returns String
 * Hex color value.
 */		
TextInputElement.prototype._getTextHighlightedColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextHighlightedColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextHighlightedColor");
	
		var textColor = this.getStyleData("TextHighlightedColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};
	
/**
 * @function _getTextHighlightedBackgroundColor
 * Gets the highlighted text background color for the supplied state based on text styles.
 * 
 * @param state String
 * The skin state to return the highlighted text background color.
 * 
 * @returns String
 * Hex color value.
 */		
TextInputElement.prototype._getTextHighlightedBackgroundColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextHighlightedBackgroundColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextHighlightedBackgroundColor");
	
		var textColor = this.getStyleData("TextHighlightedBackgroundColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};
	
//@Override
TextInputElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextInputElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("MaxChars" in stylesMap)
			this._textField.setStyle("MaxChars", this.getStyle("MaxChars"));
		
		if ("Enabled" in stylesMap)
		{
			var enabled = this.getStyle("Enabled");
			this._textField.setStyle("Enabled", enabled);
			
			if (enabled == true)
			{
				if (this.hasEventListener("keydown", this._onTextInputKeyDownInstance) == false)
					this.addEventListener("keydown", this._onTextInputKeyDownInstance);
				
				if (this._textField.hasEventListener("changed", this._onTextInputTextFieldChangedInstance) == false)
					this._textField.addEventListener("changed", this._onTextInputTextFieldChangedInstance);					
			}
			else
			{
				if (this.hasEventListener("keydown", this._onTextInputKeyDownInstance) == true)
					this.removeEventListener("keydown", this._onTextInputKeyDownInstance);
				
				if (this._textField.hasEventListener("changed", this._onTextInputTextFieldChangedInstance) == true)
					this._textField.removeEventListener("changed", this._onTextInputTextFieldChangedInstance);
			}
		}
		
		if ("TextLinePaddingTop" in stylesMap || 
			"TextLinePaddingBottom" in stylesMap)
		{
			this._invalidateMeasure();
		}
		
		if ("Padding" in stylesMap ||
			"PaddingTop" in stylesMap ||
			"PaddingBottom" in stylesMap ||
			"PaddingLeft" in stylesMap ||
			"PaddingRight" in stylesMap)
		{
			var paddingSize = this._getPaddingSize();
			
			this._textField.setStyle("PaddingTop", paddingSize.paddingTop);
			this._textField.setStyle("PaddingBottom", paddingSize.paddingBottom);
			this._textField.setStyle("PaddingLeft", paddingSize.paddingLeft);
			this._textField.setStyle("PaddingRight", paddingSize.paddingRight);
			
			this._invalidateMeasure();
		}
		
		this._updateSkinClass("up");
		this._updateSkinStyleDefinitions("up");
		
		this._updateSkinClass("disabled");
		this._updateSkinStyleDefinitions("disabled");
		
		this._updateState();
		this._updateTextColors();
	};
	
//@Override
TextInputElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width:0, height:this.getStyle("TextSize") + this.getStyle("TextLinePaddingTop") + this.getStyle("TextLinePaddingBottom")};
		measuredSize.width = measuredSize.height * 10;
		
		measuredSize.width += padWidth;
		measuredSize.height += padHeight;
	
		return measuredSize;
	};
	
//@Override	
TextInputElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		TextInputElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//Ignore padding, proxied to TextField for proper mouse handling.		
		this._textField._setActualPosition(0, 0);
		this._textField._setActualSize(this._width, this._height);
	};
	
	


/**
 * @depends CanvasElement.js
 */

/////////////////////////////////////////////////////////
/////////////////LabelElement////////////////////////////	
	
/**
 * @class LabelElement
 * @inherits CanvasElement
 * 
 * Basic label for rendering single line style-able text. 
 * Can be styled to automatically truncate text to fit the available 
 * space with a supplied string like ellipses "...".
 * 
 * 
 * @constructor LabelElement 
 * Creates new LabelElement instance.
 */
function LabelElement()
{
	LabelElement.base.prototype.constructor.call(this);
	
	this._textWidth = null;
	this._textHeight = null;
	this._truncateStringWidth = null;
}

//Inherit from CanvasElement
LabelElement.prototype = Object.create(CanvasElement.prototype);
LabelElement.prototype.constructor = LabelElement;
LabelElement.base = CanvasElement;

/////////////Style Types///////////////////////////////

LabelElement._StyleTypes = Object.create(null);

/**
 * @style Text String
 * Text to be rendered by the Label.
 */
LabelElement._StyleTypes.Text = 				{inheritable:false};		// "any string" || null

/**
 * @style TruncateToFit String
 * String to use when truncating a label that does not fit the available area. Defaults to "...".
 */
LabelElement._StyleTypes.TruncateToFit = 		{inheritable:false};		// null || "string" ("...")


////////////Default Styles////////////////////////////

LabelElement.StyleDefault = new StyleDefinition();

//Override base class styles
LabelElement.StyleDefault.setStyle("PaddingTop",					2);
LabelElement.StyleDefault.setStyle("PaddingBottom",					2);
LabelElement.StyleDefault.setStyle("PaddingLeft",					2);
LabelElement.StyleDefault.setStyle("PaddingRight",					2);

//LabelElement specific styles
LabelElement.StyleDefault.setStyle("Text", 							null);
LabelElement.StyleDefault.setStyle("TruncateToFit", 				"...");


/////////////LabelElement Internal Functions///////////////////

//@Override
LabelElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		LabelElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap ||
			"Text" in stylesMap ||
			"TextLinePaddingTop" in stylesMap || 
			"TextLinePaddingBottom" in stylesMap)
		{
			this._textWidth = null;
			this._textHeight = null;
			
			this._invalidateMeasure();
			this._invalidateRender();
		}
		
		if ("TruncateToFit" in stylesMap)
		{
			this._truncateStringWidth = null;
			
			this._invalidateRender();
		}
		
		if ("TextAlign" in stylesMap ||
			"TextBaseline" in stylesMap ||
			"TextColor" in stylesMap ||
			"TextFillType" in stylesMap)
		{
			this._invalidateRender();
		}
	};	
	
//@Override
LabelElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		if (this._textWidth == null || this._textHeight == null)
		{
			var measureText = this.getStyle("Text");
			if (measureText == null)
				measureText = "";
		
			this._textHeight = this.getStyle("TextSize") + this.getStyle("TextLinePaddingTop") + this.getStyle("TextLinePaddingBottom");
			this._textWidth = CanvasElement._measureText(measureText, this._getFontString());
		}
		
		return {width:this._textWidth + padWidth, height:this._textHeight + padHeight};
	};	

//@override
LabelElement.prototype._doRender = 
	function ()
	{
		LabelElement.base.prototype._doRender.call(this);
		
		var text = this.getStyle("Text");
		if (text == null || text.length == 0)
			return;
		
		var ctx = this._getGraphicsCtx();
		var paddingMetrics = this._getPaddingMetrics();
		
		//For convienence
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var fontString = this._getFontString();
		var totalWidth =  this._textWidth;
		
		//Truncate if necessary
		if (totalWidth > w)
		{
			var truncateString = this.getStyle("TruncateToFit");
			
			//Get number of truncate chars
			var numTruncateChars = 0;
			if (truncateString != null)
				numTruncateChars = truncateString.length;
			
			//Get truncate chars width
			if (this._truncateStringWidth == null)
			{
				if (truncateString == null)
					this._truncateStringWidth = 0;
				else
					this._truncateStringWidth = CanvasElement._measureText(truncateString, fontString);
			}
			
			var charWidth = 0;
			var numTextChars = text.length;
			totalWidth = this._textWidth + this._truncateStringWidth;
			
			//Remove text characters until we fit or run out.
			while (numTextChars > 0 && totalWidth > w)
			{
				charWidth = CanvasElement._measureText(text[numTextChars - 1], fontString);
				
				numTextChars--;
				totalWidth -= charWidth;
			}
			
			//Remove truncate characters until we fit or run out
			while (numTruncateChars > 0 && totalWidth > w)
			{
				charWidth = CanvasElement._measureText(truncateString[numTruncateChars - 1], fontString);
				
				numTruncateChars--;
				totalWidth -= charWidth;
			}
			
			text = text.substring(0, numTextChars) + truncateString.substring(0, numTruncateChars);
		}
		
		var linePaddingTop = this.getStyle("TextLinePaddingTop");
		var linePaddingBottom = this.getStyle("TextLinePaddingBottom");
		
		var textBaseline = this.getStyle("TextBaseline");
		var textAlign = this.getStyle("TextAlign");
		var textFillType = this.getStyle("TextFillType");
		var textColor = this.getStyle("TextColor");
		
		//Get x position
		var textXPosition;
		if (textAlign == "left")
			textXPosition = x;
		else if (textAlign == "right")
			textXPosition = x + w - totalWidth;
		else //center
			textXPosition = Math.round(x + (w / 2) - (totalWidth / 2));
		
		//Get y position
		var textYPosition;
		if (textBaseline == "top")
			textYPosition = y + linePaddingTop;
		else if (textBaseline == "bottom")
			textYPosition = y + h - linePaddingBottom;
		else //middle
			textYPosition = Math.round(y + (h / 2) + (linePaddingTop / 2) - (linePaddingBottom / 2));
		
		//Render text
		if (textFillType == "stroke")
			CanvasElement._strokeText(ctx, text, textXPosition, textYPosition, fontString, textColor, textBaseline);
		else
			CanvasElement._fillText(ctx, text, textXPosition, textYPosition, fontString, textColor, textBaseline);
	};
	
	
	


/**
 * @depends CanvasElement.js
 */

////////////////////////////////////////////////////
//////////////////ImageElement//////////////////////

/**
 * @class ImageElement
 * @inherits CanvasElement
 * 
 * ImageElement renders an image (imagine that). 
 * Images can be loaded via "url" or pre-loaded via DOM image reference and can be stretched, tiled, or aligned. 
 * 
 * @constructor ImageElement 
 * Creates new ImageElement instance.
 */
function ImageElement()
{
	ImageElement.base.prototype.constructor.call(this);
	
	this._imageLoader = null;
	
	this._imageSource = null;
	
	/**
	 * @member _imageLoadComplete boolean
	 * Read Only - True if the image has completed loading, otherwise false.
	 */
	this._imageLoadComplete = false;
	
	var _self = this;
	
	//Private event handler, need different instance for each element.
	this._onImageElementLoadCompleteInstance = 
		function (event)
		{
			_self._imageLoader.removeEventListener("load", _self._onImageElementLoadCompleteInstance);
			_self._imageLoadComplete = true;
			
			_self._invalidateMeasure();
			_self._invalidateLayout();
			_self._invalidateRender();
		};
}

//Inherit from CanvasElement
ImageElement.prototype = Object.create(CanvasElement.prototype);
ImageElement.prototype.constructor = ImageElement;
ImageElement.base = CanvasElement;


/////////////Style Types///////////////////////////////

ImageElement._StyleTypes = Object.create(null);

/**
 * @style ImageSource String
 * Image to render. This may be a String URL, or a reference to a DOM image or canvas.
 */
ImageElement._StyleTypes.ImageSource = 					{inheritable:false};		// null || image || "url" 

/**
 * @style ImageSourceClipX Number
 * X position in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipX = 			{inheritable:false};		// null || number

/**
 * @style ImageSourceClipY Number
 * Y position in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipY = 			{inheritable:false};		// null || number

/**
 * @style ImageSourceClipWidth Number
 * Width in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipWidth = 		{inheritable:false};		// null || number

/**
 * @style ImageSourceClipHeight Number
 * Height in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipHeight = 		{inheritable:false};		// null || number

/**
 * @style ImageScaleType String
 * Determines how the image should be stretched or scaled. Allowable values are "none", "fit", "stretch", "tile", or "tilefit".
 * "none" will not modify the original image, 
 * "fit" stretches the image but maintains the aspect ratio to fit the available area's minimum width/height constraint,
 * "stretch" stretches the image to fit the entire available area disregarding aspect ratio,
 * "tile" will not modify the original image but repeat it in both directions to fill the available area.
 * "tilefit" stretches the image but maintains the aspect ratio, any remaining space in the areas maximum width/height constraint is tiled with the stretched image.
 */
ImageElement._StyleTypes.ImageScaleType = 				{inheritable:false};		// "none" || "fit" || "stretch" || "tile" || "tilefit"

/**
 * @style ImageVerticalAlign String
 * Aligns the image vertically when using ImageScaleType "none" or "fit" and not all of the available space is consumed.
 * Allowable values are "top", "middle", "bottom".
 */
ImageElement._StyleTypes.ImageVerticalAlign = 			{inheritable:false};		// "top" || "middle" || "bottom"

/**
 * @style ImageHorizontalAlign String
 * Aligns the image horizontally when using ImageScaleType "none" or "fit" and not all of the available space is consumed.
 * Allowable values are "left", "center", "right".
 */
ImageElement._StyleTypes.ImageHorizontalAlign = 		{inheritable:false};		// "left" || "center" || "right"


////////////Default Styles////////////////////////////

ImageElement.StyleDefault = new StyleDefinition();

ImageElement.StyleDefault.setStyle("ImageSource", 						null);			// null || image || "url"
ImageElement.StyleDefault.setStyle("ImageSourceClipX", 					null);			// null || number
ImageElement.StyleDefault.setStyle("ImageSourceClipY", 					null);			// null || number
ImageElement.StyleDefault.setStyle("ImageSourceClipWidth", 				null);			// null || number
ImageElement.StyleDefault.setStyle("ImageSourceClipHeight", 			null);			// null || number

ImageElement.StyleDefault.setStyle("ImageScaleType", 					"stretch");		// "none" || "fit" || "stretch" || "tile" || "tilefit"
ImageElement.StyleDefault.setStyle("ImageHorizontalAlign", 				"left");		// "left" || "center" || "right"
ImageElement.StyleDefault.setStyle("ImageVerticalAlign", 				"top");			// "top" || "middle" || "bottom"


/////////////ImageElement Protected Functions///////////////////

//@Override
ImageElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ImageElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("ImageSource" in stylesMap)
		{
			var newSource = this.getStyle("ImageSource");
			if (this._imageSource != newSource)
			{
				//Clean up old loader
				if (this._imageLoader != null && this._imageLoadComplete == false)
					this._imageLoader.removeEventListener("load", this._onImageElementLoadCompleteInstance);
				
				this._imageLoader = null;
				this._imageLoadComplete = false;
				
				//May be img, string, TODO: Canvas / Video
				this._imageSource = newSource;
				
				if (this._imageSource instanceof HTMLImageElement)
				{
					this._imageLoader = this._imageSource;
					this._imageLoadComplete = this._imageSource.complete;
					
					if (this._imageLoadComplete == false)
						this._imageLoader.addEventListener("load", this._onImageElementLoadCompleteInstance, false);
				}
				else
				{
					this._imageLoader = new Image();
					this._imageLoader.addEventListener("load", this._onImageElementLoadCompleteInstance, false);
					this._imageLoader.src = this._imageSource;
				}
				
				this._invalidateMeasure();
				this._invalidateRender();
			}
		}
		else
		{
			if ("ImageSourceClipX" in stylesMap ||
				"ImageSourceClipY" in stylesMap ||
				"ImageSourceClipWidth" in stylesMap ||
				"ImageSourceClipHeight" in stylesMap)
			{
				this._invalidateMeasure();
				this._invalidateRender();
			}
			else if ("ImageScaleType" in stylesMap ||
					"ImageVerticalAlign" in stylesMap ||
					"ImageHorizontalAlign" in stylesMap)
			{
				this._invalidateRender();
			}
		}
	};
	
//@Override
ImageElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width: padWidth, height: padHeight};
		
		var clipX = this.getStyle("ImageSourceClipX");
		var clipY = this.getStyle("ImageSourceClipY");
		
		var clipWidth = this.getStyle("ImageSourceClipWidth");
		var clipHeight = this.getStyle("ImageSourceClipHeight");
		
		if (clipX == null)
			clipX = 0;
		
		if (clipY == null)
			clipY = 0;
		
		if (clipWidth != null)
			measuredSize.width += clipWidth;
		else if (this._imageLoadComplete == true)
			measuredSize.width += (this._imageLoader.naturalWidth - clipX);

		if (clipHeight != null)
			measuredSize.height += clipHeight;
		else if (this._imageLoadComplete == true)
			measuredSize.height += (this._imageLoader.naturalHeight - clipY);
		
		return measuredSize;
	};	
	
//@Override
ImageElement.prototype._doRender =
	function()
	{
		ImageElement.base.prototype._doRender.call(this);
		
		if (this._imageLoadComplete == false)
			return;
		
		var paddingMetrics = this._getPaddingMetrics();
		var ctx = this._getGraphicsCtx();
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		if (w <= 0 || h <= 0)
			return;
		
		var clipX = this.getStyle("ImageSourceClipX");
		var clipY = this.getStyle("ImageSourceClipY");
		var clipW = this.getStyle("ImageSourceClipWidth");
		var clipH = this.getStyle("ImageSourceClipHeight");
		
		var scaleType = this.getStyle("ImageScaleType");
		
		if (clipX == null)
			clipX = 0;
		if (clipY == null)
			clipY = 0;
		
		if (clipW == null)
			clipW = this._imageLoader.naturalWidth - clipX;
		if (clipH == null)
			clipH = this._imageLoader.naturalHeight - clipY;
		
		if (clipW <= 0 || clipH <= 0)
			return;
		
		if (scaleType == "stretch")
		{
			ctx.drawImage(
				this._imageLoader, 
				clipX, clipY, clipW, clipH, 
				x, y, w, h);
		}
		else if (scaleType == "tile")
		{
			var currentX = x;
			var currentY = y;
			
			var drawWidth = clipW;
			var drawHeight = clipH;
			
			while (true)
			{
				drawWidth = Math.min(clipW, x + w - currentX);
				drawHeight = Math.min(clipH, y + h - currentY);
				
				ctx.drawImage(
					this._imageLoader, 
					clipX, clipY, drawWidth, drawHeight, 
					currentX, currentY, drawWidth, drawHeight);
				
				currentX += drawWidth;
				if (currentX >= x + w)
				{
					currentX = x;
					currentY += drawHeight;
					
					if (currentY >= y + h)
						break;
				}
			}
		}
		else if (scaleType == "tilefit")
		{
			var thisRatio = w / h;
			var imageRatio = clipW / clipH;
			
			var drawWidth = clipW;
			var drawHeight = clipH;
			
			//Size to our height
			if (thisRatio > imageRatio)
			{
				var currentX = x;
				
				drawHeight = h;
				drawWidth = h * imageRatio;
				
				while (true)
				{
					if (currentX + drawWidth > x + w)
					{
						var availableWidth = x + w - currentX;
						var widthRatio = availableWidth / drawWidth;
						
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW * widthRatio, clipH, 
							currentX, y, drawWidth * widthRatio, drawHeight);
						
						break;
					}
					else
					{
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW, clipH, 
							currentX, y, drawWidth, drawHeight);
						
						currentX += drawWidth;
						if (currentX == x + w)
								break;
					}
				}
			}
			else //Size to our width
			{
				var currentY = y;
				
				drawWidth = w;
				drawHeight = w / imageRatio;
				
				while (true)
				{
					if (currentY + drawHeight > y + h)
					{
						var availableHeight = y + h - currentY;
						var heightRatio = availableHeight / drawHeight;
						
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW, clipH * heightRatio, 
							x, currentY, drawWidth, drawHeight * heightRatio);
						
						break;
					}
					else
					{
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW, clipH, 
							x, currentY, drawWidth, drawHeight);
						
						currentY += drawHeight;
						if (currentY == y + h)
							break;
					}
				}
			}
		}
		else if (scaleType == "fit" || scaleType == "none")
		{
			var verticalAlign = this.getStyle("ImageVerticalAlign");
			var horizontalAlign = this.getStyle("ImageHorizontalAlign");
			
			var drawWidth = clipW;
			var drawHeight = clipH;
			
			if (scaleType == "fit")
			{
				var thisRatio = w / h;
				var imageRatio = clipW / clipH;
				
				//Size to our height
				if (thisRatio > imageRatio)
				{
					drawHeight = h;
					drawWidth = h * imageRatio;
				}
				else //Size to our width
				{
					drawWidth = w;
					drawHeight = w / imageRatio;
				}
			}
			else //scaleType == "none"
			{
				//Reduce image clipping area to render size.
				if (w < clipW)
				{
					if (horizontalAlign == "right")
						clipX += (clipW - w);
					else if (horizontalAlign == "center")
						clipX += ((clipW - w) / 2);
					
					clipW = w;
					drawWidth = w;
				}
				if (h < clipH)
				{
					if (verticalAlign == "bottom")
						clipY += (clipH - h);
					else if (verticalAlign == "middle")
						clipY += ((clipH - h) / 2);
					
					clipH = h;
					drawHeight = h;
				}
			}
			
			var drawX = x;
			var drawY = y;
			
			if (horizontalAlign == "right")
				drawX += w - drawWidth;
			else if (horizontalAlign == "center")
				drawX += ((w - drawWidth) / 2);
			
			if (verticalAlign == "bottom")
				drawY += h - drawHeight;
			else if (verticalAlign == "middle")
				drawY += ((h - drawHeight) / 2);
			
			ctx.drawImage(
				this._imageLoader, 
				clipX, clipY, clipW, clipH, 
				drawX, drawY, drawWidth, drawHeight);
		}
		
	};
	
	
	


/**
 * @depends SkinnableElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataRendererBaseElement/////////////////////////
	
/**
 * @class DataRendererBaseElement
 * @inherits SkinnableElement
 * 
 * Abstract base class for DataList item rendering. Any CanvasElement
 * can be a data renderer. This class is just here for convenience as it
 * implements some commonly used functionality if you wish to subclass it. 
 * 
 * Adds skin states and styles for "up", "alt", "over", and "selected" states. 
 *  
 * 
 * @constructor DataRendererBaseElement 
 * Creates new DataRendererBaseElement instance.
 */
function DataRendererBaseElement()
{
	DataRendererBaseElement.base.prototype.constructor.call(this);
	
	var _self = this;
	
	//Private event handler, proxy to prototype.
	this._onDataRendererBaseEventInstance = 
		function (elementEvent)
		{
			if (elementEvent.getType() == "rollover")
				_self._onDataRendererRollover(elementEvent);
			else if (elementEvent.getType() == "rollout")
				_self._onDataRendererRollout(elementEvent);
		};
		
	this.addEventListener("rollover", this._onDataRendererBaseEventInstance);
	this.addEventListener("rollout", this._onDataRendererBaseEventInstance);
}
	
//Inherit from SkinnableElement
DataRendererBaseElement.prototype = Object.create(SkinnableElement.prototype);
DataRendererBaseElement.prototype.constructor = DataRendererBaseElement;
DataRendererBaseElement.base = SkinnableElement;


/////////////Style Types////////////////////////////////////////////

DataRendererBaseElement._StyleTypes = Object.create(null);

/**
 * @style SkinClass CanvasElement
 * 
 * The CanvasElement constructor type to apply to all skin states. 
 * Specific states such as UpSkinClass will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.SkinClass =					{inheritable:false};		//Element constructor()

/**
 * @style UpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "up" state. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.UpSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style UpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "up" state skin element.
 */
DataRendererBaseElement._StyleTypes.UpSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style AltSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "alt" state. 
 * This is used to create different styles for alternating rows. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.AltSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style AltSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "alt" state skin element.
 */
DataRendererBaseElement._StyleTypes.AltSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style OverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "over" state. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.OverSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style OverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "over" state skin element.
 */
DataRendererBaseElement._StyleTypes.OverSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style SelectedSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "selected" state. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.SelectedSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style SelectedSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selected" state skin element.
 */
DataRendererBaseElement._StyleTypes.SelectedSkinStyle = 		{inheritable:false};		//StyleDefinition

//Proxied from DataList (intended only for reading)
/**
 * @style Selectable boolean
 * 
 * When false, prevents "over" and "selected" states. Proxied from parent DataList.
 */
DataRendererBaseElement._StyleTypes.Selectable = 				{inheritable:false};		// true || false


///////////Default Styles///////////////////////////////////////////

DataRendererBaseElement.StyleDefault = new StyleDefinition();

//Skin Defaults////////////////////////////
DataRendererBaseElement.OverSkinStyleDefault = new StyleDefinition();

DataRendererBaseElement.OverSkinStyleDefault.setStyle("BackgroundColor", 			"#E0E0E0");
DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 			(+.03));
DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 			(-.03));

DataRendererBaseElement.SelectedSkinStyleDefault = new StyleDefinition();

DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("BackgroundColor", 			"#CDCDCD");
DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientStart", 			(+.03));
DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientStop", 			(-.03));
//////////////////////////////////////////

DataRendererBaseElement.StyleDefault.setStyle("Selectable", 			true);												// intended only for reading, its proxied from DataList

DataRendererBaseElement.StyleDefault.setStyle("SkinClass", 				CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("UpSkinClass", 			CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("AltSkinClass", 			CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("OverSkinClass", 			CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("SelectedSkinClass", 		CanvasElement);										// Element constructor()

DataRendererBaseElement.StyleDefault.setStyle("UpSkinStyle", 			null);												// StyleDefinition
DataRendererBaseElement.StyleDefault.setStyle("AltSkinStyle", 			null);												// StyleDefinition
DataRendererBaseElement.StyleDefault.setStyle("OverSkinStyle", 			DataRendererBaseElement.OverSkinStyleDefault);		// StyleDefinition
DataRendererBaseElement.StyleDefault.setStyle("SelectedSkinStyle", 		DataRendererBaseElement.SelectedSkinStyleDefault);	// StyleDefinition


/////////////Internal///////////////////////////

/**
 * @function _updateState
 * Updates the SkinState style in response to mouse and ListData changes.
 */
DataRendererBaseElement.prototype._updateState = 
	function ()
	{
		var newState = "";
	
		if (this._listSelected == true)
			newState = "selected";
		else if (this._mouseIsOver == true && this.getStyle("Selectable") == true)
			newState = "over";
		else // "up"
		{
			if (this._listData == null || this._listData._itemIndex % 2 == 0)
				newState = "up";
			else
				newState = "alt";
		}
		
		this.setStyle("SkinState", newState);
	};

//@Override
DataRendererBaseElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
		
		if (state == "up")
			stateSkinClass = this.getStyleData("UpSkinClass");
		else if (state == "alt")
			stateSkinClass = this.getStyleData("AltSkinClass");
		else if (state == "over")
			stateSkinClass = this.getStyleData("OverSkinClass");
		else if (state == "selected")
			stateSkinClass = this.getStyleData("SelectedSkinClass");
		
		var skinClass = this.getStyleData("SkinClass");
		
		//Shouldnt have null stateSkinClass
		if (stateSkinClass == null || skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
		
//@override	
DataRendererBaseElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "up")
			return this.getStyle("UpSkinStyle");
		else if (state == "alt")
			return this.getStyle("AltSkinStyle");
		else if (state == "over")
			return this.getStyle("OverSkinStyle");
		else if (state == "selected")
			return this.getStyle("SelectedSkinStyle");
		
		return DataRendererBaseElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};

//@Override
DataRendererBaseElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "up")
			return this._getDefaultStyle("UpSkinStyle");
		else if (state == "alt")
			return this._getDefaultStyle("AltSkinStyle");
		else if (state == "over")
			return this._getDefaultStyle("OverSkinStyle");
		else if (state == "selected")
			return this._getDefaultStyle("SelectedSkinStyle");
		
		return DataRendererBaseElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};	
	
/**
 * @function _onDataRendererRollover
 * Event handler for "rollover" event. Updates the skin state.
 * Overriding this is more efficient than adding an additional "rollover" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
DataRendererBaseElement.prototype._onDataRendererRollover = 
	function (elementEvent)
	{
		this._updateState();
	};
	
/**
 * @function _onDataRendererRollout
 * Event handler for "rollout" event. Updates the skin state.
 * Overriding this is more efficient than adding an additional "rollout" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
DataRendererBaseElement.prototype._onDataRendererRollout = 
	function (elementEvent)
	{
		this._updateState();
	};

//@Override	
DataRendererBaseElement.prototype._setListSelected = 
	function (selected)
	{
		DataRendererBaseElement.base.prototype._setListSelected.call(this, selected);
		
		this._updateState();
	};
	
//@Override	
DataRendererBaseElement.prototype._setListData = 
	function (listData, itemData)
	{
		DataRendererBaseElement.base.prototype._setListData.call(this, listData, itemData);
		
		this._updateState();
	};

//@Override
DataRendererBaseElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataRendererBaseElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		//Always update these, they dont do anything if no changes
		//and cheaper to call this than to check SkinClass inheritance.
		this._updateSkinClass("up");
		this._updateSkinStyleDefinitions("up");
		
		this._updateSkinClass("alt");
		this._updateSkinStyleDefinitions("alt");
		
		this._updateSkinClass("over");
		this._updateSkinStyleDefinitions("over");
		
		this._updateSkinClass("selected");
		this._updateSkinStyleDefinitions("selected");
		
		if ("Selectable" in stylesMap)
			this._updateState();
	};
	
	


/**
 * @depends DataRendererBaseElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataRendererLabelElement////////////////////////

/**
 * @class DataRendererLabelElement
 * @inherits DataRendererBaseElement
 * 
 * DataList DataRenderer for a basic label.
 * Adds text color styles for DataRenderer states and 
 * sets label text when the parent DataList sets our list data.
 * 
 * @constructor DataRendererLabelElement 
 * Creates new DataRendererLabelElement instance.
 */
function DataRendererLabelElement()
{
	DataRendererLabelElement.base.prototype.constructor.call(this);
	
	this._labelElement = new LabelElement();
	this._labelElement.setStyle("Padding", 0); //Wipe out default padding (no doubly padding, only this elements padding is necessary)
	
	this._addChild(this._labelElement);
}
	
//Inherit from DataRendererBaseElement
DataRendererLabelElement.prototype = Object.create(DataRendererBaseElement.prototype);
DataRendererLabelElement.prototype.constructor = DataRendererLabelElement;
DataRendererLabelElement.base = DataRendererBaseElement;


/////////////Style Types/////////////////////////

DataRendererLabelElement._StyleTypes = Object.create(null);

/**
 * @style UpTextColor String
 * 
 * Hex color value to be used for the label when in the "up" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.UpTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style AltTextColor String
 * 
 * Hex color value to be used for the label when in the "alt" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.AltTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style OverTextColor String
 * 
 * Hex color value to be used for the label when in the "over" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.OverTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style SelectedTextColor String
 * 
 * Hex color value to be used for the label when in the "selected" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.SelectedTextColor = 		{inheritable:false};		//"#000000"


////////////Default Styles///////////////////////

DataRendererLabelElement.StyleDefault = new StyleDefinition();

DataRendererLabelElement.StyleDefault.setStyle("PaddingTop", 				4);
DataRendererLabelElement.StyleDefault.setStyle("PaddingBottom", 			4);
DataRendererLabelElement.StyleDefault.setStyle("PaddingLeft", 				4);
DataRendererLabelElement.StyleDefault.setStyle("PaddingRight", 				4);
DataRendererLabelElement.StyleDefault.setStyle("BorderType", 				"none");

DataRendererLabelElement.StyleDefault.setStyle("UpTextColor", 				"#000000");
DataRendererLabelElement.StyleDefault.setStyle("AltTextColor", 				"#000000");
DataRendererLabelElement.StyleDefault.setStyle("OverTextColor", 			"#000000");
DataRendererLabelElement.StyleDefault.setStyle("SelectedTextColor", 		"#000000");


////////////Internal/////////////////////////////

//@Override
DataRendererLabelElement.prototype._changeState = 
	function (state)
	{
		DataRendererLabelElement.base.prototype._changeState.call(this, state);
		
		this._updateLabelTextColor();
	};
	
/**
 * @function _getTextColor
 * Gets the text color style for the supplied state.
 * 
 * @param state String
 * The current state.
 * 
 * @returns String
 * Text color style for the supplied state.
 */	
DataRendererLabelElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextColor");
		else if (state == "alt")
			stateTextColor = this.getStyleData("AltTextColor");
		else if (state == "over")
			stateTextColor = this.getStyleData("OverTextColor");
		else if (state == "selected")
			stateTextColor = this.getStyleData("SelectedTextColor");
	
		var textColor = this.getStyleData("TextColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

/**
 * @function _updateLabelTextColor
 * Updates the text color base on the current state.
 */	
DataRendererLabelElement.prototype._updateLabelTextColor = 
	function ()
	{
		var color = this._getTextColor(this._currentSkinState);
		if (color != null)
			this._labelElement.setStyle("TextColor", color);
	};
	
/**
 * @function _updateLabelTextColor
 * Updates the label text base on the list data and ItemLabelFunction.
 */		
DataRendererLabelElement.prototype._updateLabelText = 
	function ()
	{
		if (this._itemData == null)
			this._labelElement.setStyle("Text", "");
		else
		{
			var labelFunction = this._listData._parentList.getStyle("ItemLabelFunction");
			this._labelElement.setStyle("Text", labelFunction(this._itemData));
		}
	};
	
//@Override
DataRendererLabelElement.prototype._setListData = 
	function (listData, itemData)
	{
		DataRendererLabelElement.base.prototype._setListData.call(this, listData, itemData);
		
		this._updateLabelText();
	};

//@Override
DataRendererLabelElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataRendererLabelElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		this._updateLabelTextColor();
	};

//@Override
DataRendererLabelElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width: this._labelElement._getStyledOrMeasuredWidth() + padWidth, 
				height: this._labelElement._getStyledOrMeasuredHeight() + padHeight};
	};

//@Override	
DataRendererLabelElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataRendererLabelElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		this._labelElement._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
		this._labelElement._setActualSize(paddingMetrics.getWidth(), paddingMetrics.getHeight());
	};
	
	


/**
 * @depends CanvasElement.js
 * @depends DataRendererLabelElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataListElement/////////////////////////////////		
	
/**
 * @class DataListElement
 * @inherits CanvasElement
 * 
 * DataListElement is a data-driven container that renders items in a 
 * horizontal or vertical orientation via a supplied ListCollection and a supplied DataRenderer class.
 * A DataRenderer is any CanvasElement that implements _setListData() and _setListSelected()
 * and is used to render the corresponding ListCollection item. A scroll bar will be added
 * if the collection size exceeds the available area. DataListElement only renders visible 
 * DataRenderers so collection size does not impact performance.
 * 
 * DataRendereBaseElement is an abstract base class that implements common
 * features and can be sub-classed if desired.
 * 
 * The default DataRenderer is the DataRendererLabelElement which renders
 * a text label per the LabelFunction style. 
 * 
 * @seealso DataRendererBaseElement
 * @seealso DataRendererLabelElement
 * 
 * 
 * @constructor DataListElement 
 * Creates new DataListElement instance.
 */
function DataListElement()
{
	DataListElement.base.prototype.constructor.call(this);
	
	this._listCollection = null; //Data collection
	
	this._contentSize = 0;
	
	this._scrollBar = null;
	this._scrollIndex = 0;
	
	this._selectedIndex = -1;
	this._selectedItem = null;
	
	this._contentPane = new CanvasElement();
	this._contentPane.setStyle("ClipContent", true);
	this._addChild(this._contentPane);
	
	var _self = this;
	
	//Private event listener, need an instance for each DataList, proxy to prototype.
	this._onDataListCollectionChangedInstance = 
		function (collectionChangedEvent)
		{
			_self._onDataListCollectionChanged(collectionChangedEvent);
		};
		
	this._onDataListScrollBarChangedInstance = 
		function (elementEvent)
		{
			_self._onDataListScrollBarChanged(elementEvent);
		};
		
	this._onDataListMouseWheelEventInstance = 
		function (elementMouseWheelEvent)
		{
			_self._onDataListMouseWheelEvent(elementMouseWheelEvent);
		};
	
	this._onDataListRendererClickInstance = 
		function (elementMouseEvent)
		{
			_self._onDataListRendererClick(elementMouseEvent);
		};
		
	this.addEventListener("wheel", this._onDataListMouseWheelEventInstance);	
}

//Inherit from SkinnableElement
DataListElement.prototype = Object.create(CanvasElement.prototype);
DataListElement.prototype.constructor = DataListElement;
DataListElement.base = CanvasElement;

/**
 * @function DefaultItemLabelFunction
 * @static
 * Default ItemLabelFunction function. Looks for typeof String or "label" property of supplied itemData.
 * 
 * @param itemData Object
 * Collection item to extract label text.
 * 
 * @returns String
 * Label text.
 */
DataListElement.DefaultItemLabelFunction = 
	function (itemData)
	{
		if (itemData == null)
			return "";
		
		if (typeof itemData === "string" || itemData instanceof String)
			return itemData;
	
		if ("label" in itemData)
			return itemData["label"];
		
		return itemData.toString();
	};


/////////////Events///////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the selected item/index changes as a result of user interaction.
 * 
 * @event listitemclick ElementListItemClickEvent
 * Dispatched when a DataRenderer is clicked. Includes associated collection item/index.
 */



/////////////Style Types////////////////////////////////////////////

DataListElement._StyleTypes = Object.create(null);

/**
 * @style ListDirection String
 * 
 * Determines the layout direction of this DataList. Allowable values are "horizontal" or "vertical".
 */
DataListElement._StyleTypes.ListDirection = 					{inheritable:false};		// "horizontal" || "vertical

/**
 * @style ListAlign String
 * 
 * Determines the alignment of content when there is not enough data in the ListCollection to fill the DataList.
 * Allowable values are "left", "center", "right" for horizontal layout, and "top", "middle", "bottom" for vertical layout. 
 */
DataListElement._StyleTypes.ListAlign = 						{inheritable:false};		// "left" || "center" || "right" / "top" || "middle" || "bottom"

/**
 * @style Selectable boolean
 * 
 * When true, list items can be selected and the DataList will dispatch "changed" events.
 */
DataListElement._StyleTypes.Selectable = 						{inheritable:false};		// true || false

/**
 * @style ScrollBarDisplay String
 * 
 * Determines the behavior of the scroll bar. Allowable values are "on", "off", and "auto".
 */
DataListElement._StyleTypes.ScrollBarDisplay = 					{inheritable:false};		// "on" || "off" || "auto"

/**
 * @style ScrollBarPlacement String
 * 
 * Determines the placement of the scroll bar. 
 * Allowable values are "top" or "bottom" for horizontal layout and "left" or "right" for vertical layout.
 */
DataListElement._StyleTypes.ScrollBarPlacement = 				{inheritable:false};		// "top" || "bottom" / "left || "right"

/**
 * @style ScrollBarStyle StyleDefinition
 * 
 * The StyleDefinition to be applied to the scroll bar.
 */
DataListElement._StyleTypes.ScrollBarStyle = 					{inheritable:false};		// StyleDefinition

//Returns the string to use for the label per provided data.
/**
 * @style ItemLabelFunction Function
 * 
 * A function that returns a text string per a supplied collection item.
 * function (itemData) { return "" }
 */
DataListElement._StyleTypes.ItemLabelFunction = 				{inheritable:false}; 		// function (itemData) { return "" }

/**
 * @style ListItemClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataRenderer.
 */
DataListElement._StyleTypes.ListItemClass = 					{inheritable:false};		//DataRendererBaseElement constructor()

/**
 * @style ListItemStyle StyleDefinition
 * 
 * The StyleDefinition to be applied to the DataRenderer.
 */
DataListElement._StyleTypes.ListItemStyle = 					{inheritable:false};		//StyleDefinition


///////////Default Styles////////////////////////////////////

DataListElement.StyleDefault = new StyleDefinition();

DataListElement.StyleDefault.setStyle("ListDirection", 				"vertical");								// "horizontal" || "vertical
DataListElement.StyleDefault.setStyle("ListAlign", 					"top");										// "left" || "center" || "right" / "top" || "middle" || "bottom"

DataListElement.StyleDefault.setStyle("ItemLabelFunction", 			DataListElement.DefaultItemLabelFunction);	// function (data) { return "" }

DataListElement.StyleDefault.setStyle("ListItemClass", 				DataRendererLabelElement); 					// Element constructor()
DataListElement.StyleDefault.setStyle("ListItemStyle", 				null);										// StyleDefinition

DataListElement.StyleDefault.setStyle("Selectable", 				true);										// true || false

DataListElement.StyleDefault.setStyle("ScrollBarDisplay", 			"auto");									// "on" || "off" || "auto"
DataListElement.StyleDefault.setStyle("ScrollBarPlacement", 		"right");									// "top" || "bottom" / "left || "right"
DataListElement.StyleDefault.setStyle("ScrollBarStyle", 			null);										// StyleDefinition


/////////DataRenderer Proxy Map/////////////////////////////

//Proxy map for styles we want to pass to the DataRenderer.
DataListElement._DataRendererProxyMap = Object.create(null);

DataListElement._DataRendererProxyMap.Selectable = 				true;
DataListElement._DataRendererProxyMap._Arbitrary = 				true;


/////////////Public///////////////////////////////

/**
 * @function setSelectedIndex
 * Sets the selected collection index/item.
 * 
 * @param index int
 * The collection index to be selected.
 */	
DataListElement.prototype.setSelectedIndex = 
	function (index)
	{
		if (this._selectedIndex == index)
			return true;
		
		if (index > this._listCollection.length -1)
			return false;
		
		if (index < -1)
			index = -1;
		
		var oldIndex = this._selectedIndex;
		
		this._selectedIndex = index;
		this._selectedItem = this._listCollection.getItemAt(index);
		
		//Update renderer data.
		if (this._contentPane._children.length > 0)
		{
			var firstIndex = this._contentPane._children[0]._listData._itemIndex;
			var lastIndex = this._contentPane._children[this._contentPane._children.length - 1]._listData._itemIndex;
			
			if (index != null && index >= firstIndex && index <= lastIndex)
				this._contentPane._children[index - firstIndex]._setListSelected(true);
			if (oldIndex != null && oldIndex >= firstIndex && oldIndex <= lastIndex)
				this._contentPane._children[oldIndex - firstIndex]._setListSelected(false);
		}
		
		return true;
	};

/**
 * @function getSelectedIndex
 * Gets the selected collection index. 
 * 
 * @returns int
 * The selected collection index or -1 if none selected.
 */		
DataListElement.prototype.getSelectedIndex = 
	function ()
	{
		return this._selectedIndex;
	};
	
/**
 * @function setSelectedItem
 * Sets the selected collection item/index.
 * 
 * @param item Object
 * The collection item to be selected.
 */	
DataListElement.prototype.setSelectedItem = 
	function (item)
	{
		var index = this._listCollection.getItemIndex(item);
		this.setSelectedIndex(index);
	};
	
/**
 * @function getSelectedItem
 * Gets the selected collection item. 
 * 
 * @returns Object
 * The selected collection item or null if none selected.
 */		
DataListElement.prototype.getSelectedItem = 
	function ()
	{
		return this._selectedItem;
	};
	
/**
 * @function setScrollIndex
 * Sets the collection item index to scroll too. 
 * 
 * @param scrollIndex int
 * Collection item index.
 */	
DataListElement.prototype.setScrollIndex = 
	function (scrollIndex)
	{
		scrollIndex = CanvasElement.roundToPrecision(scrollIndex, 6);
	
		this._invalidateLayout();
		
		if (this._contentPane._children.length == 0 || this._listCollection == null)
		{
			this._scrollIndex = 0;
			
			//No data, purge the renderers.
			while (this._contentPane._children.length > 0)
				this._contentPane._removeChildAt(0);
			
			return;
		}
		
		if (scrollIndex >= this._listCollection.getLength())
			scrollIndex = this._listCollection.getLength() - 1;
		if (scrollIndex < 0)
			scrollIndex = 0;		
		
		this._scrollIndex = scrollIndex;
		
		var itemIndex = Math.floor(scrollIndex);
		var currentIndex = this._contentPane._children[0]._listData._itemIndex;
		
		var renderer = null;
		
		if (itemIndex == currentIndex - 1) //Move bottom renderer to top
		{
			renderer = this._contentPane._children[this._contentPane._children.length - 1];
			this._contentPane._setChildIndex(renderer, 0);
			
			this._updateRendererData(renderer, itemIndex);
		}
		else if (itemIndex == currentIndex + 1) //Move top renderer to bottom (or delete)
		{
			if (this._listCollection.getLength() >= itemIndex + this._contentPane._children.length)
			{
				renderer = this._contentPane._children[0];
				this._contentPane._setChildIndex(renderer, this._contentPane._children.length - 1);
				
				this._updateRendererData(renderer, itemIndex + this._contentPane._children.length - 1);
			}
			else //No more data, purge the renderer.
				this._contentPane._removeChildAt(0);
		}
		else //Reset renderer data. (Even if index hasnt changed, we call this if the collection is sorted or changed)
		{
			for (var i = 0; i < this._contentPane._children.length; i++)
			{
				if (this._listCollection.getLength() > itemIndex + i)
				{
					//Update list data
					renderer = this._contentPane._children[i];
					this._updateRendererData(renderer, itemIndex + i);
				}
				else
				{
					//No more data, purge the rest of the renderers.
					while (this._contentPane._children.length > i)
						this._contentPane._removeChildAt(i);
				}
			}
		}
	};

/**
 * @function setListCollection
 * Sets the DataLists's associated ListCollection to generate DataRenderers.
 * 
 * @param listCollection ListCollection
 * The ListCollection to be used as the data-provider.
 */	
DataListElement.prototype.setListCollection = 
	function (listCollection)
	{
		if (this._listCollection == listCollection)
			return;
	
		if (this._manager == null)
		{
			this._listCollection = listCollection;
		}
		else
		{
			if (this._listCollection != null)
				this._listCollection.removeEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
			
			this._listCollection = listCollection;
			
			if (this._listCollection != null)
				this._listCollection.addEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
		}
		
		//Fix selected index/item
		if (this._listCollection == null)
		{
			this._selectedIndex = -1;
			this._selectedItem = null;
		}
		else
		{
			if (this._selectedItem != null)
			{
				this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
				
				if (this._selectedIndex == -1)
					this._selectedItem = null;
			}
		}
		
		this.setScrollIndex(this._scrollIndex); //Reset renderer data.
		this._invalidateLayout();
	};
	
/**
 * @function getListCollection
 * Gets the DataLists's associated ListCollection. 
 * 
 * @returns ListCollection
 * The associated ListCollection or null if none assigned.
 */		
DataListElement.prototype.getListCollection = 
	function ()
	{
		return this._listCollection;
	};	
	
///////////Internal//////////////////////////////
	
/**
 * @function _getContentSize
 * Gets the content size of the DataList. This is only accurate after the DataList
 * has finished its layout phase. Currently only used by the Dropdown to fix the
 * vertical height of the drop down pop-up list when there are too few items.
 * 
 * @returns Number
 * Content size in pixels of the DataListElement. Only valid after layout phase completed.
 */	
//Helpers function (currently only used by dropdown) ///
DataListElement.prototype._getContentSize = 
	function ()
	{
		var paddingSize = this._getPaddingSize();
	
		if (this.getStyle("ListDirection") == "vertical")
			return this._contentSize + paddingSize.height;
		else //if (this.getStyle("ListDirection") == "horizontal")
			return this._contentSize + paddingSize.width;
	};

/**
 * @function _getNumRenderers
 * Gets the number of DataRenderers that are currently being rendered.
 * 
 * @returns int
 * the number of DataRenderers that are currently being rendered.
 */	
DataListElement.prototype._getNumRenderers = 
	function ()
	{
		return this._contentPane._children.length;
	};	
	
/**
 * @function _onDataListMouseWheelEvent
 * Event handler for the DataList "wheel" event. Starts the scroll bar tween.
 * 
 * @param elementMouseWheelEvent ElementMouseWheelEvent
 * The ElementMouseWheelEvent to process.
 */		
DataListElement.prototype._onDataListMouseWheelEvent = 
	function (elementMouseWheelEvent)
	{
		if (elementMouseWheelEvent.getDefaultPrevented() == true)
			return;
	
		//No renderers or event prevented.
		if (this._contentPane._children.length == 0 || this._listCollection.getLength() == 0)
			return;
	
		var delta = 0;
		var listDirection = this.getStyle("ListDirection");
		
		var minScrolled = false;
		var maxScrolled = false;
		
		var firstRenderer = this._contentPane._children[0];
		var lastRenderer = this._contentPane._children[this._contentPane._children.length - 1];
		
		if (listDirection == "horizontal")
		{
			delta = elementMouseWheelEvent.getDeltaX();
			
			if (delta == 0)
				return;
			
			if (firstRenderer._listData._itemIndex == 0 && 
				firstRenderer._x >= 0)
			{
				minScrolled = true;
			}
			
			if (minScrolled == true && delta < 0)
				return;
			
			if (lastRenderer._listData._itemIndex == this._listCollection.getLength() - 1 && 
				lastRenderer._x <= this._contentPane._width - lastRenderer._width)
			{
				maxScrolled = true;
			}
			
			if (maxScrolled == true && delta > 0)
				return;
		}
		else //if (listDirection == "vertical")
		{
			delta = elementMouseWheelEvent.getDeltaY();
			
			if (delta == 0)
				return;
			
			if (firstRenderer._listData._itemIndex == 0 && 
				firstRenderer._y >= 0)
			{
				minScrolled = true;
			}
			
			if (minScrolled == true && delta < 0)
				return;
			
			if (lastRenderer._listData._itemIndex == this._listCollection.getLength() - 1 && 
				lastRenderer._y <= this._contentPane._height - lastRenderer._height)
			{
				maxScrolled = true;
			}
			
			if (maxScrolled == true && delta > 0)
				return;
		}
		
		if (this._scrollBar != null)
		{
			var tweeningTo = this._scrollBar.getTweenToValue();
			if (tweeningTo == null)
				tweeningTo = this._scrollIndex;
			
			this._scrollBar.startScrollTween(tweeningTo + delta);
		}
		else
			this.setScrollIndex(this._scrollIndex + delta);
		
		//We've consumed the wheel event, don't want parents double scrolling.
		elementMouseWheelEvent.preventDefault();
	};	

/**
 * @function _onDataListScrollBarChanged
 * Event handler for the scroll bar "changed" event. Updates DataRenderers.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
DataListElement.prototype._onDataListScrollBarChanged = 
	function (elementEvent)
	{
		//Handle rounding errors
		var scrollValue = CanvasElement.roundToPrecision(this._scrollBar.getScrollValue(), 6);
		var scrollPageSize = CanvasElement.roundToPrecision(this._scrollBar.getScrollPageSize(), 6);
		var scrollViewSize = CanvasElement.roundToPrecision(this._scrollBar.getScrollViewSize(), 6);
		
		//Fix for issue where last renderer is larger than first, resulting in exponential adjustments 
		//due to view size shrinking / scroll range increasing at the same time as scroll. We check if the
		//scroll bar hit the end and increment the Lists scroll index rather than taking the scroll bar value.
		if (scrollValue == scrollPageSize - scrollViewSize && scrollValue - this._scrollIndex < 1)
			scrollValue = this._scrollIndex + 1;
	
		this.setScrollIndex(scrollValue);
	};
	
/**
 * @function _onDataListCollectionChanged
 * Event handler for the ListCollection "collectionchanged" event. Updates DataRenderers.
 * 
 * @param collectionChangedEvent CollectionChangedEvent
 * The CollectionChangedEvent to process.
 */		
DataListElement.prototype._onDataListCollectionChanged = 
	function (collectionChangedEvent)
	{
		var type = collectionChangedEvent.getKind();
		var index = collectionChangedEvent.getIndex();
	
		//Always invalidate layout (we need to adjust the scroll bar)
		this._invalidateLayout();
		
		if (this._contentPane._children.length == 0)
			return;
	
		//Reset all renderers (collection was cleared, or swapped)
		if (type == "reset")
		{
			//Fix selected index/item
			if (this._selectedItem != null)
			{
				this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
				
				if (this._selectedIndex == -1)
					this._selectedItem = null;
			}
			
			this.setScrollIndex(this._scrollIndex); //Reset renderer data.
		}
		else
		{
			var firstIndex = 0;
			var lastIndex = 0;
			
			if (this._contentPane._children.length > 0)
			{
				firstIndex = this._contentPane._children[0]._listData._itemIndex;
				lastIndex = this._contentPane._children[this._contentPane._children.length - 1]._listData._itemIndex;
			}
			
			if (this._selectedIndex == index && type == "remove") //We removed the selected item.
			{
				this._selectedIndex = -1;
				this._selectedItem = null;
			}
			
			if (index <= lastIndex && (type == "add" || type == "remove"))
			{
				//Adjust selected index
				if (index <= this._selectedIndex)
				{
					if (type == "add")
						this._selectedIndex++;
					else // if (type == "remove)
						this._selectedIndex--;
				}
				
				if (index < firstIndex)
				{
					var newIndex;
					var indexAdjust;
					
					//Fix scroll/item indexes (we added/removed an item on top thats out of the view)
					//Dont invalidate, only the index has changed, not the data, we dont want renderers shuffling around.
					if (type == "add")
						indexAdjust = 1;
					else // "remove"
						indexAdjust = -1;
					
					this._scrollIndex = this._scrollIndex + indexAdjust;
					
					//Adjust all indexes
					for (var i = 0; i < this._contentPane._children.length; i++)
					{
						newIndex = this._contentPane._children[i]._listData._itemIndex + indexAdjust;
						this._updateRendererData(this._contentPane._children[i], newIndex);
					}
				}
				else //Visible renderers changed
				{
					if (type == "add")
					{
						var newRenderer = this._createRenderer(index);
						
						//Push in a new renderer, layout will deal with purging excess if necessary
						this._contentPane._addChildAt(newRenderer, index - firstIndex);
						index++;
					}
					else // if (type == "remove")
					{
						//Pop the removed renderer, layout will deal with adding more if necessary
						this._contentPane._removeChildAt(index - firstIndex);
					}
					
					//Adjust downstream indexes.
					for (var i = index - firstIndex; i < this._contentPane._children.length; i++)
					{
						this._updateRendererData(this._contentPane._children[i], index);
						index++;
					}
				}
			}
			else if (type == "update" && index >= firstIndex && index <= lastIndex)
				this._updateRendererData(this._contentPane._children[index - firstIndex], index);
		}
	};
	
//@Override	
DataListElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		DataListElement.base.prototype._onCanvasElementAdded.call(this, addedRemovedEvent);
	
		if (this._listCollection != null)
			this._listCollection.addEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
	};

//@Override	
DataListElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		DataListElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		if (this._listCollection != null)
			this._listCollection.removeEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
	};	

/**
 * @function _invalidateListRenderersLayout
 * Calls _invalidateLayout() on all DataRenderers.
 */	
DataListElement.prototype._invalidateListRenderersLayout = 
	function ()
	{
		for (var i = 0; i < this._contentPane._children.length; i++)
			this._contentPane._children[i]._invalidateLayout();
	};
	
/**
 * @function _invalidateListRenderersMeasure
 * Calls _invalidateMeasure() on all DataRenderers.
 */		
DataListElement.prototype._invalidateListRenderersMeasure = 
	function ()
	{
		for (var i = 0; i < this._contentPane._children.length; i++)
			this._contentPane._children[i]._invalidateMeasure();
	};
	
//@Override
DataListElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataListElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ListItemClass" in stylesMap)
		{
			//Check if class changed
			if (this._contentPane._children.length > 0 && 
				this._contentPane._children[0].constructor != this.getStyle("ListItemClass"))
			{
				//Purge all renderers
				while (this._contentPane._children.length > 0)
					this._contentPane._removeChildAt(0);
				
				this._invalidateLayout();
			}
		}
		else if ("ListItemStyle" in stylesMap)
		{
			var listItemStyle = this.getStyle("ListItemStyle");
			
			for (var i = 0; i < this._contentPane._children.length; i++)
				this._contentPane._children[i].setStyleDefinitions(listItemStyle);
			
			this._invalidateLayout();
		}
		
		if ("ListDirection" in stylesMap)
		{
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("ScrollBarPlacement" in stylesMap || "ScrollBarDisplay" in stylesMap ||  "ListAlign" in stylesMap)
			this._invalidateLayout();
		
		if ("ScrollBarStyle" in stylesMap && this._scrollBar != null)
			this._scrollBar.setStyleDefinitions(this.getStyle("ScrollBarStyle"));
		
		if ("ItemLabelFunction" in stylesMap)
			this.setScrollIndex(this._scrollIndex); //Reset renderer data.
	};

//@Override
DataListElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:16, height:16};
	};

/**
 * @function _onDataListRendererClick
 * Event handler for the DataRenderer "click" event. Updates selected index/item and dispatches "listitemclick" and "changed" events.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */		
DataListElement.prototype._onDataListRendererClick = 
	function (elementMouseEvent)
	{
		var itemIndex = elementMouseEvent.getCurrentTarget()._listData._itemIndex;
		var itemData = elementMouseEvent.getCurrentTarget()._itemData;
		
		var dispatchChanged = false;
		var elementIsSelectable = elementMouseEvent.getCurrentTarget().getStyle("Selectable");
		
		//Update selected index
		if (this.getStyle("Selectable") == true && (elementIsSelectable === undefined || elementIsSelectable == true))
		{
			if (this.setSelectedIndex(itemIndex) == true)
				dispatchChanged = true;
		}
		
		//Dispatch events
		this._dispatchEvent(new ElementListItemClickEvent(itemData, itemIndex));
		
		if (dispatchChanged == true)
			this._dispatchEvent(new ElementEvent("changed", false));
	};
	
/**
 * @function _createRenderer
 * Generates a DataRenderer based on the ListItemClass style.
 * 
 * @param itemIndex int
 * Collection index associated with the DataRenderer.
 * 
 * @returns CanvasElement
 * The new DataRenderer instance.
 */	
DataListElement.prototype._createRenderer = 
	function (itemIndex)
	{
		var newRenderer = new (this.getStyle("ListItemClass"))();
		newRenderer._setStyleDefinitionDefault(this._getDefaultStyle("ListItemStyle"));
		newRenderer._setStyleProxy(new StyleProxy(this, DataListElement._DataRendererProxyMap));
		newRenderer.setStyleDefinitions(this.getStyle("ListItemStyle"));
		
		this._updateRendererData(newRenderer, itemIndex);
		
		newRenderer.addEventListener("click", this._onDataListRendererClickInstance);
		
		return newRenderer;
	};

/**
 * @function _updateRendererData
 * Updates the DataRenderer list data and selected state.
 * 
 * @param renderer CanvasElement
 * DataRenderer to update.
 * 
 * @param itemIndex int
 * Collection index to associate with the DataRenderer.
 */	
DataListElement.prototype._updateRendererData = 
	function (renderer, itemIndex)
	{
		var listData = null;
		
		//Optimize, dont create new data unless its actually changed.
		if (renderer._listData != null && renderer._listData._itemIndex == itemIndex)
			listData = renderer._listData;
		else
			listData = new DataListData(this, itemIndex);
	
		//Always call the function even if data has not changed, this indicates to the
		//renderer to inspect its parent related data and it may make changes even if
		//this data is the same. An example is changes to a DataGrid's columns.
		renderer._setListData(
			listData,
			this._listCollection.getItemAt(itemIndex));
		
		if (this._selectedIndex == itemIndex)
			renderer._setListSelected(true);
		else
			renderer._setListSelected(false);
	};
	
//@Override	
DataListElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataListElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var availableSize = h;
		var listItem = null;
		var i;
		
		var listDirection = this.getStyle("ListDirection");
		var itemIndex = Math.floor(this._scrollIndex);
		
		var collectionLength = 0;
		if (this._listCollection != null)
			collectionLength = this._listCollection.getLength();
		
		if (collectionLength == 0)
		{
			itemIndex = 0;
			this._scrollIndex = itemIndex;
		}
		else if (itemIndex > collectionLength -1)
		{
			itemIndex = collectionLength -1;
			this._scrollIndex = itemIndex;
		}
		
		var clipFirst = 0;
		var clipLast = 0;
		
		this._contentSize = 0;
		var itemSize = 0;
		
		//Measure existing content & clipping amounts.
		for (i = 0; i < this._contentPane._children.length; i++)
		{
			listItem = this._contentPane._children[i];
			
			if (listDirection == "horizontal")
				itemSize = listItem._getStyledOrMeasuredWidth();
			else // if (listDirection == "vertical")
				itemSize = listItem._getStyledOrMeasuredHeight();
				
			this._contentSize += itemSize;
			
			if (listItem._listData._itemIndex <= itemIndex)
			{
				if (listItem._listData._itemIndex < itemIndex)
					clipFirst += itemSize;
				else
					clipFirst += itemSize * (this._scrollIndex - itemIndex);
			}
			
			if (this._contentSize - clipFirst >= availableSize)
			{
				clipLast = (this._contentSize - clipFirst - availableSize);
				
				//Purge Excess renderers.
				while (this._contentPane._children.length - 1 > i)
					this._contentPane._removeChildAt(this._contentPane._children.length - 1);
			}
		}
		
		//Adjust scroll index due to new renderer added on top.
		//Happens when we're max scrolled and DataList size increases.
		if (this._contentPane._children.length > 0 && 
			this._contentPane._children[0]._listData._itemIndex < itemIndex)
		{
			clipFirst += clipLast;
			clipLast = 0; //No clipping last item (scrolled to bottom)
			
			itemIndex = this._contentPane._children[0]._listData._itemIndex;
			
			//Fix scroll index
			if (listDirection == "horizontal")
				this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredWidth());
			else // if (listDirection == "vertical")
				this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredHeight());
			
			//Handle rounding errors
			this._scrollIndex = CanvasElement.roundToPrecision(this._scrollIndex, 6);
		}
		
		//Extra space - need another renderer or scroll shift
		if (this._contentSize - clipFirst - clipLast < availableSize)
		{
			if (itemIndex + this._contentPane._children.length < collectionLength)
			{//Create a new renderer and put it on bottom.
				
				var newRenderer = this._createRenderer(itemIndex + this._contentPane._children.length);
				this._contentPane._addChild(newRenderer);
				
				//Wait for the new renderer to measure.
				//Re-invalidate ourself, (content pane doesnt measure so wont do it for us).
				this._invalidateLayout();
				return;
			}
			else
			{//Add before (or shift up scroll position)
				
				var excessSize = availableSize - (this._contentSize - clipFirst - clipLast);
				
				if (clipFirst >= excessSize) 
				{//We have enough clipping to cover the gap, un-clip and adjust scroll index
					
					clipFirst -= excessSize;
					
					if (listDirection == "horizontal")
						this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredWidth());
					else // if (listDirection == "vertical")
						this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredHeight());
					
					//Handle rounding errors
					this._scrollIndex = CanvasElement.roundToPrecision(this._scrollIndex, 6);
				}
				else if (clipFirst > 0 && collectionLength == this._contentPane._children.length)
				{//We dont have enough clipping, but we're out of data (cannot make new renderer)
					
					clipFirst = 0;
					this._scrollIndex = 0;
				}
				else if (collectionLength > this._contentPane._children.length)
				{//Create a new renderer and put it on top
					
					var newRenderer = this._createRenderer(itemIndex - 1);
					this._contentPane._addChildAt(newRenderer, 0);
					
					//Wait for the new renderer to measure.
					//Re-invalidate ourself, (content pane doesnt measure so wont do it for us).
					this._invalidateLayout();
					return;
				}
			}
		}
		
		var needsScrollBar = false;
		var scrollDisplay = this.getStyle("ScrollBarDisplay");
		
		if (scrollDisplay == "on" || 
			(scrollDisplay == "auto" && availableSize > 0 && (this._contentSize > availableSize || this._contentPane._children.length < collectionLength)))
		{
			needsScrollBar = true;
		}
		
		//Create ScrollBar
		if (needsScrollBar == true && this._scrollBar == null)
		{
			this._scrollBar = new ScrollBarElement();
			this._scrollBar._setStyleDefinitionDefault(this._getDefaultStyle("ScrollBarStyle"));
			this._scrollBar.setStyleDefinitions(this.getStyle("ScrollBarStyle"));
			this._scrollBar.setStyle("ScrollBarDirection", listDirection);
			this._scrollBar.setScrollLineSize(1);
			
			this._scrollBar.addEventListener("changed", this._onDataListScrollBarChangedInstance);
			this._addChild(this._scrollBar);
			
			//Wait for measure.
			return;
		}
		
		//Destroy ScrollBar
		if (needsScrollBar == false && this._scrollBar != null)
		{			
			this._removeChild(this._scrollBar);
			this._scrollBar = null;
			
			//Wait for measure
			return;
		}
		
		//Size / Position the scroll bar and content pane.
		if (this._scrollBar != null)
		{
			var scrollBarPlacement = this.getStyle("ScrollBarPlacement");
			
			if (listDirection == "horizontal")
			{
				this._scrollBar._setActualSize(w, this._scrollBar._getStyledOrMeasuredHeight());
				this._contentPane._setActualSize(w, h - this._scrollBar._height);
				
				if (scrollBarPlacement == "top" || scrollBarPlacement == "left")
				{
					this._contentPane._setActualPosition(x, y + this._scrollBar._height);
					this._scrollBar._setActualPosition(x, y);
				}
				else //if (scrollBarPlacement == "bottom" || scrollBarPlacement == "right")
				{
					this._contentPane._setActualPosition(x, y);
					this._scrollBar._setActualPosition(x, y + this._contentPane._height);
				}
			}
			else // if (listDirection == "vertical")
			{
				this._scrollBar._setActualSize(this._scrollBar._getStyledOrMeasuredWidth(), h);
				this._contentPane._setActualSize(w - this._scrollBar._width, h);
				
				if (scrollBarPlacement == "top" || scrollBarPlacement == "left")
				{
					this._scrollBar._setActualPosition(x, y);
					this._contentPane._setActualPosition(x + this._scrollBar._width, y);
				}
				else //if (scrollBarPlacement == "bottom" || scrollBarPlacement == "right")
				{
					this._scrollBar._setActualPosition(x + this._contentPane._width, y);
					this._contentPane._setActualPosition(x, y);
				}
			}
		}
		else
		{
			this._contentPane._setActualPosition(x, y);
			this._contentPane._setActualSize(w, h);
		}

		//Layout content pane children.
		var currentPosition = clipFirst * -1;
		if (this._contentSize < availableSize)
		{
			var listAlign = this.getStyle("ListAlign");
			
			if (listAlign == "top" || listAlign == "left")
				currentPosition = 0;
			else if (listAlign == "center" || listAlign == "middle")
				currentPosition = (availableSize / 2) - (this._contentSize / 2);
			else //if (listAlign == "bottom" || listAlign == "right")
				currentPosition = availableSize - this._contentSize;
		}
		
		for (i = 0; i < this._contentPane._children.length; i++)
		{
			listItem = this._contentPane._children[i];
			
			if (listDirection == "horizontal")
			{
				listItem._setActualSize(listItem._getStyledOrMeasuredWidth(), this._contentPane._height);
				listItem._setActualPosition(currentPosition, 0);
				
				currentPosition += listItem._width;
			}
			else // if (listDirection == "vertical")
			{
				listItem._setActualSize(this._contentPane._width, listItem._getStyledOrMeasuredHeight());
				listItem._setActualPosition(0, currentPosition);
				
				currentPosition += listItem._height;
			}
		}
		
		//Adjust scroll bar parameters.
		if (this._scrollBar != null)
		{
			var viewSize = this._contentPane._children.length;
			
			if (this._contentPane._children.length)
			{
				if (listDirection == "horizontal")
				{
					viewSize -= clipFirst / this._contentPane._children[0]._width;
					viewSize -= clipLast / this._contentPane._children[this._contentPane._children.length - 1]._width;
				}
				else // if (listDirection == "vertical")
				{
					viewSize -= clipFirst / this._contentPane._children[0]._height;
					viewSize -= clipLast / this._contentPane._children[this._contentPane._children.length - 1]._height;
				}
			}
			
			this._scrollBar.setScrollPageSize(collectionLength);
			this._scrollBar.setScrollViewSize(viewSize);
			
			if (CanvasElement.roundToPrecision(this._scrollBar.getScrollValue(), 6) != this._scrollIndex)
			{
				this._scrollBar.endScrollTween();
				this._scrollBar.setScrollValue(this._scrollIndex);
			}
		}
	};
	
	


/**
 * @depends LabelElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////DataGridLabelItemRenderer/////////////////////////	
	
/**
 * @class DataGridLabelItemRenderer
 * @inherits LabelElement
 * 
 * DataGrid ItemRenderer for a basic label. Updates label text via 
 * DataGridColumnDefiniton RowItemLabelFunction.
 * 
 * This class needs more work to add  text color styles for DataRenderer states.
 * 
 * @constructor DataGridLabelItemRenderer 
 * Creates new DataGridLabelItemRenderer instance.
 */
function DataGridLabelItemRenderer()
{
	DataGridLabelItemRenderer.base.prototype.constructor.call(this);
}

//Inherit from LabelElement
DataGridLabelItemRenderer.prototype = Object.create(LabelElement.prototype);
DataGridLabelItemRenderer.prototype.constructor = DataGridLabelItemRenderer;
DataGridLabelItemRenderer.base = LabelElement;


///////////Default Styles//////////////////////

DataGridLabelItemRenderer.StyleDefault = new StyleDefinition();

DataGridLabelItemRenderer.StyleDefault.setStyle("Padding", 				5);			// Override


//////////////Internal//////////////////////////////////////////

//@Override
DataGridLabelItemRenderer.prototype._setListData = 
	function (listData, itemData)
	{
		DataGridLabelItemRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		this._updateLabelText();
	};

/**
 * @function _updateLabelText
 * Updates the label text in response to list data changes using the associated parent grid column's RowItemLabelFunction.
 */	
DataGridLabelItemRenderer.prototype._updateLabelText = 
	function ()
	{
		if (this._itemData == null || this._listData == null)
			this.setStyle("Text", "");
		else
		{
			var parentGrid = this._listData._parentGrid;
			var columnDefinition = parentGrid._gridColumns[this._listData._columnIndex];
			var labelFunction = columnDefinition.getStyle("RowItemLabelFunction");
			
			this.setStyle("Text", labelFunction(this._itemData, this._listData._columnIndex));
		}
	};
	
	


/**
 * @depends DataRendererBaseElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataGridDataRenderer////////////////////////////

/**
 * @class DataGridDataRenderer
 * @inherits DataRendererBaseElement
 * 
 * Default DataGrid ListItemClass used to render DataGrid rows. Renders
 * column items per the parent DataGrid's column definitions. 
 * 
 * @constructor DataGridDataRenderer 
 * Creates new DataGridDataRenderer instance.
 */

//Used to render the DataGrid rows. 
function DataGridDataRenderer()
{
	DataGridDataRenderer.base.prototype.constructor.call(this);
	
	//Use a containing element for the renderers so we dont interfere with our skins.
	this._itemRenderersContainer = new CanvasElement();
	this._addChild(this._itemRenderersContainer);
}
	
//Inherit from DataRendererBaseElement
DataGridDataRenderer.prototype = Object.create(DataRendererBaseElement.prototype);
DataGridDataRenderer.prototype.constructor = DataGridDataRenderer;
DataGridDataRenderer.base = DataRendererBaseElement;

//////////Default Styles/////////////////////////

DataGridDataRenderer.StyleDefault = new StyleDefinition();

//Skin Defaults///////
DataGridDataRenderer.UpSkinStyleDefault = new StyleDefinition();
DataGridDataRenderer.UpSkinStyleDefault.setStyle("BackgroundColor", 			"#FFFFFF");
DataGridDataRenderer.UpSkinStyleDefault.setStyle("AutoGradientType", 			"none");

DataGridDataRenderer.AltSkinStyleDefault = new StyleDefinition();
DataGridDataRenderer.AltSkinStyleDefault.setStyle("BackgroundColor", 			"#F0F0F0");
DataGridDataRenderer.AltSkinStyleDefault.setStyle("AutoGradientType", 			"none");
/////////////////////

DataGridDataRenderer.StyleDefault.setStyle("UpSkinStyle", 						DataGridDataRenderer.UpSkinStyleDefault);	// StyleDefinition
DataGridDataRenderer.StyleDefault.setStyle("AltSkinStyle", 						DataGridDataRenderer.AltSkinStyleDefault);	// StyleDefinition


//@Override
DataGridDataRenderer.prototype._setListData = 
	function (listData, itemData)
	{
		DataGridDataRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		var renderer = null;
		for (var i = 0; i < listData._parentList._gridColumns.length; i++)
		{
			renderer = this._itemRenderersContainer._getChildAt(i);
			
			if (renderer == null)
			{
				renderer = listData._parentList._createRowItemRenderer(listData._itemIndex, i);
				this._itemRenderersContainer._addChildAt(renderer, i);
			}
			else
			{
				columnDef = listData._parentList._gridColumns[i];
				
				if (renderer.constructor != columnDef.getStyle("RowItemClass"))
				{ //Renderer Class changed
					
					this._itemRenderersContainer._removeChildAt(i);
					renderer = listData._parentList._createRowItemRenderer(listData._itemIndex, i);
					this._itemRenderersContainer._addChildAt(renderer, i);
				}
				else
				{ //Update DataGridData
					
					listData._parentList._updateRowItemRendererData(renderer, listData._itemIndex, i);
				}
			}
		}
		
		//Purge excess renderers.
		while (this._itemRenderersContainer._children.length > this._listData._parentList._gridColumns.length)
			this._itemRenderersContainer._removeChildAt(this._itemRenderersContainer._children.length - 1);
		
		//Invalidate, the item renderer container doesnt measure so wont do it for us.
		this._invalidateMeasure();
		this._invalidateLayout();
	};
	
//@Override
DataGridDataRenderer.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width: 0, height: 0};
		var childSize = 0;
		
		for (var i = 0; i < this._itemRenderersContainer._children.length; i++)
		{
			childSize = this._itemRenderersContainer._children[i]._getStyledOrMeasuredHeight();
			
			if (measuredSize.height < childSize)
				measuredSize.height = childSize;
			
			measuredSize.width += this._itemRenderersContainer._children[i]._getStyledOrMeasuredWidth();
		}
	
		measuredSize.width += padWidth;
		measuredSize.height += padHeight;
		
		return measuredSize;
	};
	
//@Override	
DataGridDataRenderer.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataGridDataRenderer.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._listData == null)
			return;
		
		this._itemRenderersContainer._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
		this._itemRenderersContainer._setActualSize(paddingMetrics.getWidth(), paddingMetrics.getHeight());
		
		var parentGrid = this._listData._parentList;
		var rowItemRenderer = null;
		var currentPosition = 0;
		var columnSize = 0;
		
		var paddingSize = this._getPaddingSize();
		
		for (var i = 0; i < parentGrid._columnSizes.length; i++)
		{
			rowItemRenderer = this._itemRenderersContainer._children[i];
			columnSize = parentGrid._columnSizes[i];
			
			if (i == 0)
				columnSize -= paddingSize.paddingLeft;
			else if (i == parentGrid._columnSizes.length - 1) //Consume the rest available.
				columnSize = this._itemRenderersContainer._width - currentPosition;
			
			rowItemRenderer._setActualPosition(currentPosition, 0);
			rowItemRenderer._setActualSize(columnSize, this._itemRenderersContainer._height);
			
			currentPosition += columnSize;
		}
	};	
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////ContainerBaseElement////////////////////////////////

/**
 * @class ContainerBaseElement
 * @inherits CanvasElement
 * 
 * Abstract base class for Container elements. Wraps internal child modification functions
 * such as _addChild() and _removeChild() with public functions such as addElement() and removeElement() 
 * for proper index management when using skins and overlays in conjunction with content children. 
 * 
 * Container children are not all considered equal. Content children added via the addElement() and removeElement()
 * functions maintain their own indexes and are placed in between raw children, such as skins, which render
 * underneath and overlay children which render above (elements intended to always be on top of content children).
 * 
 * Raw children added via _addChild() or _addChildAt() will be indexed before content children.
 * Content children added via addElement() or addElementAt() will be indexed after raw children and before overlay children.
 * Overlay children added via _addOverlayChild() will be index last, after content children.
 * All 3 lists maintain their own indexes.
 * 
 * @constructor ContainerBaseElement 
 * Creates new ContainerBaseElement instance.
 */

function ContainerBaseElement()
{
	ContainerBaseElement.base.prototype.constructor.call(this);
	
	//Storage for user added elements.
	this._elements = [];
	
	//Children that come after user added elements
	this._overlayChildren = [];
}	
	
//Inherit from CanvasElement
ContainerBaseElement.prototype = Object.create(CanvasElement.prototype);
ContainerBaseElement.prototype.constructor = ContainerBaseElement;
ContainerBaseElement.base = CanvasElement;
	

/////////////Default Styles///////////////////////////////

ContainerBaseElement.StyleDefault = new StyleDefinition();
ContainerBaseElement.StyleDefault.setStyle("ClipContent",						true);


////////////ContainerBaseElement Public Functions//////////////////////////

//Expose child modification functions.

/**
 * @function addElement
 * Adds a content child element to the end of this element's content child list.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a content child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added.
 */	
ContainerBaseElement.prototype.addElement = 
	function (element)
	{
		return this.addElementAt(element, this._elements.length);
	};

/**
 * @function addElementAt
 * Inserts a content child element to this element's content child list at the specified index.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a content child of this element.
 * 
 * @param index int
 * Child index to insert the element.
 * 
 * @returns CanvasElement
 * Returns the element just added when successful, null if the element could not
 * be added due to the index being out of range.
 */		
ContainerBaseElement.prototype.addElementAt = 
	function (element, index)
	{
		if (!(element instanceof CanvasElement))
			return null;
	
		if (index < 0 || index > this._elements.length)
			return null;
		
		var childIndex = this._children.length - this._overlayChildren.length - this._elements.length + index;
		
		this._elements.splice(index, 0, element);
		ContainerBaseElement.base.prototype._addChildAt.call(this, element, childIndex);
		
		return element;
	};
	
/**
 * @function removeElement
 * Removes a content child element from this element's content children list.
 * 
 * @param element CanvasElement
 * Content child to be removed.
 * 
 * @returns CanvasElement
 * Returns the CanvasElement just removed if successful, null if the
 * element could not be removed due to it not being a content child of this element.
 */		
ContainerBaseElement.prototype.removeElement = 
	function (element)
	{
		var index = this._elements.indexOf(element);
		return this.removeElementAt(index);
	};
	
/**
 * @function removeElementAt
 * Removes a content child element at specified index.
 * 
 * @param index int
 * Content index to be removed.
 * 
 * @returns CanvasElement
 * Returns the CanvasElement just removed if successful, null if the element could
 * not be removed due it it not being a child of this element, or index out of range.
 */			
ContainerBaseElement.prototype.removeElementAt = 
	function (index)
	{
		if (index < 0 || index >= this._elements.length)
			return null;
	
		var childIndex = this._children.length - this._overlayChildren.length - this._elements.length + index;

		this._elements.splice(index, 1);
		return ContainerBaseElement.base.prototype._removeChildAt.call(this, childIndex);
	};

/**
 * @function getElementAt
 * Gets the content child element at the supplied index.
 * 
 * @param index int
 * Content index of child element to return;
 * 
 * @returns CanvasElement
 * The CanvasElement at the supplied index, or null if index is out of range. 
 */		
ContainerBaseElement.prototype.getElementAt = 
	function (index)
	{
		if (index < 0 || index >= this._elements.length)
			return null;
		
		return this._elements[index];
	};
	
/**
 * @function getElementIndex
 * Returns the index of the supplied content child element.
 * 
 * @param element CanvasElement
 * Content child element to return the index.
 * 
 * @returns int
 * Returns the child index or -1 if the element is not
 * a content child of this element.
 */		
ContainerBaseElement.prototype.getElementIndex = 
	function (element)
	{
		return this._elements.indexOf(element);
	};

/**
 * @function setElementIndex
 * Changes a content child element's index. 
 * 
 * @param element CanvasElement
 * Content child element to change index.
 * 
 * @param index int
 * New content index of the content child element.
 * 
 * @returns boolean
 * Returns true if the child's index is successfully changed, false if the element
 * is not a content child of this element or the index is out of range.
 */		
ContainerBaseElement.prototype.setElementIndex = 
	function (element, index)
	{
		if (index < 0 || index >= this._elements.length)
			return false;
		
		var currentIndex = this._elements.indexOf(element);
		if (currentIndex == -1 || currentIndex == index)
			return false;
		
		var childIndex = this._children.length - this._overlayChildren.length - this._elements.length + index;
		
		this._elements.splice(index, 0, this._elements.splice(currentIndex, 1)[0]);
		ContainerBaseElement.base.prototype._setChildIndex.call(this, element, childIndex);
		
		return true;
	};
	
/**
 * @function getNumElements
 * Gets this elements number of content children.
 * 
 * @returns int
 * The number of content child elements.
 */		
ContainerBaseElement.prototype.getNumElements = 
	function ()
	{
		return this._elements.length;
	};

/**
 * @function _addOverlayChild
 * Adds an overlay child element to the end of this element's overlay child list.
 * 
 * @param element CanvasElement
 * Element to be added as an overlay child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added.
 */		
ContainerBaseElement.prototype._addOverlayChild = 
	function (element)
	{
		return this._addOverlayChildAt(element, this._overlayChildren.length);
	};
	
/**
 * @function _addOverlayChildAt
 * Inserts an overlay child element to this elements overlay child list at the specified index.
 * 
 * @param element CanvasElement
 * Element to be added as an overlay child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added when successful, null if the element could not
 * be added due to the index being out of range.
 */			
ContainerBaseElement.prototype._addOverlayChildAt = 
	function (element, index)
	{
		if (!(element instanceof CanvasElement))
			return null;
	
		if (index < 0 || index > this._overlayChildren.length)
			return null;
		
		var childIndex = this._children.length - this._overlayChildren.length + index;
		
		this._overlayChildren.splice(index, 0, element);
		ContainerBaseElement.base.prototype._addChildAt.call(this, element, childIndex);
		
		return element;
	};	

/**
 * @function _removeOverlayChild
 * Removes an overlay child element from this elements overlay child list.
 * 
 * @param element CanvasElement
 * Overlay child to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successful, null if the
 * element could not be removed due to it not being an overlay child of this element.
 */		
ContainerBaseElement.prototype._removeOverlayChild = 
	function (element)
	{
		var index = this._overlayChildren.indexOf(element);
		return this._removeOverlayChildAt(index);
	};

/**
 * @function _removeOverlayChildAt
 * Removes an overlay child element at specified index.
 * 
 * @param index int
 * Overlay index to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successful, null if the element could
 * not be removed due it it not being an overlay child of this element, or index out of range.
 */			
ContainerBaseElement.prototype._removeOverlayChildAt = 
	function (index)
	{
		if (index < 0 || index >= this._overlayChildren.length)
			return null;
		
		var childIndex = this._children.length - this._overlayChildren.length + index;

		this._overlayChildren.splice(index, 1);
		return ContainerBaseElement.base.prototype._removeChildAt.call(this, childIndex);
	};	

/**
 * @function _getOverlayChildAt
 * Gets the overlay child element at the supplied index.
 * 
 * @param index int
 * Overlay index of child element to return;
 * 
 * @returns CanvasElement
 * The element at the supplied overlay index, or null if index is out of range. 
 */		
ContainerBaseElement.prototype._getOverlayChildAt = 
	function (index)
	{
		if (index < 0 || index >= this._overlayChildren.length)
			return null;
		
		return this._overlayChildren[index];
	};	
	
/**
 * @function _getOverlayChildIndex
 * Returns the overlay index of the supplied child element.
 * 
 * @param element CanvasElement
 * Child element to return the overlay index.
 * 
 * @returns int
 * Returns the child's overlay index or -1 if the element is not
 * an overlay child of this element.
 */		
ContainerBaseElement.prototype._getOverlayChildIndex = 
	function (element)
	{
		return this._overlayChildren.indexOf(element);
	};	
	
/**
 * @function _setOverlayChildIndex
 * Changes an overlay child element's overlay index. 
 * 
 * @param element CanvasElement
 * Overlay child element to change index.
 * 
 * @param index int
 * New overlay index of the child element.
 * 
 * @returns boolean
 * Returns true if the child's index is successfully changed, false if the element
 * is not an overlay child of this element or the index is out of range.
 */		
ContainerBaseElement.prototype._setOverlayChildIndex = 
	function (element, index)
	{
		if (index < 0 || index >= this._overlayChildren.length)
			return false;
		
		var currentIndex = this._overlayChildren.indexOf(element);
		if (currentIndex < 0 || currentIndex == index)
			return false;
		
		var childIndex = this._children.length - this._overlayChildren.length + index;
		
		this._overlayChildren.splice(index, 0, this._overlayChildren.splice(currentIndex, 1)[0]);
		ContainerBaseElement.base.prototype._setChildIndex.call(this, element, childIndex);
		
		return true;
	}; 	
	
/**
 * @function _getNumOverlayChildren
 * Gets this elements number of overlay children.
 * 
 * @returns int
 * The number of overlay child elements.
 */		
ContainerBaseElement.prototype._getNumOverlayChildren = 
	function ()
	{
		return this._overlayChildren.length;
	};
	
//Override - Add the child before elements & overlay
ContainerBaseElement.prototype._addChild = 
	function (element)
	{
		var index = this._children.length - this._elements.length - this._overlayChildren.length;
		return ContainerBaseElement.base.prototype._addChildAt.call(this, element, index);
	};
	
//Override - Dont allow insertion into elements or overlay range
ContainerBaseElement.prototype._addChildAt = 
	function (element, index)
	{
		var maxIndex = this._children.length - this._elements.length - this._overlayChildren.length;
		
		if (index < 0 || index > maxIndex)
			return null;
		
		return ContainerBaseElement.base.prototype._addChildAt.call(this, element, index);
	};

//Override - Remove from element or overlay if necessary
ContainerBaseElement.prototype._removeChildAt = 
	function (index)
	{
		if (index < 0 || index >= this._children.length)
			return null;
		
		var element = this._children.splice(index, 1)[0]; //Returns array of removed items.
		
		var subIndex = this._elements.indexOf(element);
		if (subIndex >= 0)
			return this.removeElementAt(subIndex);
		
		subIndex = this._overlayChildren.indexOf(element);
		if (subIndex >= 0)
			return this._removeOverlayChildAt(subIndex);
		
		return ContainerBaseElement.base.prototype._removeChildAt.call(this, index);
	};

//@Override	- Dont allow swapping in or out of element & overlay ranges.
ContainerBaseElement.prototype._setChildIndex = 
	function (element, index)
	{
		var maxIndex = this._children.length - this._elements.length - this._overlayChildren.length;
	
		if (index < 0 || index >= maxIndex)
			return false;
		
		var currentIndex = this._getChildIndex(element);
		if (currentIndex < 0 || currentIndex >= maxIndex || currentIndex == index)
			return false;
		
		return ContainerBaseElement.base.prototype._setChildIndex.call(this, element, index);
	};
	
	


/**
 * @depends ContainerBaseElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////ListContainerElement////////////////////////////////

/**
 * @class ListContainerElement
 * @inherits ContainerBaseElement
 * 
 * The ListContainer can be used to lay out children in a vertical or horizontal fashion.
 * This container uses children's styles Width, Height, PercentWidth, and PercentHeight.
 * Nesting containers is the best way to quickly and simply build complex layouts.
 * 
 * Width, and Height are treated as highest priority and will override PercentWidth and PercentHeight styles.
 * Exact behavior of conflicting styles is not defined and subject to change. 
 * 
 * See the associated style documentation for additional details.
 * 
 * @constructor ListContainerElement 
 * Creates new ListContainerElement instance.
 */
function ListContainerElement()
{
	ListContainerElement.base.prototype.constructor.call(this);
}

//Inherit from ContainerBaseElement
ListContainerElement.prototype = Object.create(ContainerBaseElement.prototype);
ListContainerElement.prototype.constructor = ListContainerElement;
ListContainerElement.base = ContainerBaseElement;	
	
/////////////Style Types///////////////////////////////

ListContainerElement._StyleTypes = Object.create(null);

/**
 * @style LayoutDirection String
 * 
 * Determines the layout direction of this ListContainer. Allowable values are "horizontal" or "vertical".
 */
ListContainerElement._StyleTypes.LayoutDirection = 			{inheritable:false};		// "horizontal" || "vertical"

/**
 * @style LayoutGap Number
 * 
 * Space in pixels to leave between child elements.
 */
ListContainerElement._StyleTypes.LayoutGap = 				{inheritable:false};		// number

/**
 * @style LayoutVerticalAlign String
 * 
 * Child vertical alignment to be used when children do not fill all available space. Allowable values are "top", "bottom", or "middle". 
 */
ListContainerElement._StyleTypes.LayoutVerticalAlign = 		{inheritable:false};		// "top" || "bottom" || "middle" 

/**
 * @style LayoutHorizontalAlign String
 * 
 * Child horizontal alignment to be used when children do not fill all available space. Allowable values are "left", "right", or "center". 
 */
ListContainerElement._StyleTypes.LayoutHorizontalAlign = 	{inheritable:false};		//"left" || "right" || "center"


////////////Default Styles////////////////////////////

ListContainerElement.StyleDefault = new StyleDefinition();

//ListContainerElement specific styles
ListContainerElement.StyleDefault.setStyle("LayoutDirection", 			"vertical");
ListContainerElement.StyleDefault.setStyle("LayoutGap", 				0);
ListContainerElement.StyleDefault.setStyle("LayoutVerticalAlign", 		"top");
ListContainerElement.StyleDefault.setStyle("LayoutHorizontalAlign", 	"left");


//////////////ListContainerElement Protected Functions//////////////

//@Override
ListContainerElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ListContainerElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("LayoutDirection" in stylesMap ||
			"LayoutGap" in stylesMap)
		{
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("LayoutAlign" in stylesMap)
			this._invalidateLayout();
	};

//@Override
ListContainerElement.prototype._doMeasure = 
	function (padWidth, padHeight)
	{
		var contentSize = {width:0, height:0};
		
		var layoutGap = this.getStyle("LayoutGap");
		var layoutDirection = this.getStyle("LayoutDirection");
		
		var child = null;
		
		var width = null;
		var height = null;
		var rotateDegrees = null;
		
		var tempWidth;
		var tempHeight;
		var tempRotateDegrees;		
		
		var insertGap = false;
		
		for (var i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			rotateDegrees = child.getStyle("RotateDegrees");
			
			width = child._getStyledOrMeasuredWidth();
			height = child._getStyledOrMeasuredHeight();
			
			if (rotateDegrees != 0)
			{
				//Record child's current w/h & rotation
				tempWidth = child._width;
				tempHeight = child._height;
				tempRotateDegrees = child._rotateDegrees;
				
				//TODO: Update getMetrics() so we can pass child values.
				//Spoof the rotation position/size so we can get parent metrics.
				child._width = width;
				child._height = height;
				child._rotateDegrees = rotateDegrees;
				
				//Get parent metrics for spoof position
				rotatedMetrics = child.getMetrics(this);
				
				//Put back current values
				child._width = tempWidth;
				child._height = tempHeight;
				child._rotateDegrees = tempRotateDegrees;
				
				width = Math.ceil(rotatedMetrics.getWidth());
				height = Math.ceil(rotatedMetrics.getHeight());
			}
		
			if (layoutDirection == "horizontal")
			{
				//Increment width
				contentSize.width += width;
				
				//Use maximum child height
				if (height > contentSize.height)
					contentSize.height = height;
			}
			else //if (layoutDirection == "vertical")
			{
				//Increment height
				contentSize.height += height;
				
				//Use maximum child height
				if (width > contentSize.width)
					contentSize.width = width;
			}
			
			if (insertGap == true)
			{
				if (layoutDirection == "horizontal")
					contentSize.width += layoutGap;
				else //if (layoutDirection == "vertical")
					contentSize.height += layoutGap;
			}
			else
				insertGap = true;
		}
		
		contentSize.width += padWidth;
		contentSize.height += padHeight;
		
		return contentSize;		
	};

//@Override
ListContainerElement.prototype._doLayout =
	function(paddingMetrics)
	{
		ListContainerElement.base.prototype._doLayout.call(this, paddingMetrics);
	
		var layoutGap = this.getStyle("LayoutGap");
		var layoutDirection = this.getStyle("LayoutDirection");
		var layoutVerticalAlign = this.getStyle("LayoutVerticalAlign");
		var layoutHorizontalAlign = this.getStyle("LayoutHorizontalAlign");
	
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var i;
		
		var child = null;
		var childSizeData = [];
		
		var totalPercentUsed = 0;
		var numRenderables = 0;
		
		//Record element sizing data.
		for (i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			numRenderables++;
			
			var sizeData = {
				element:child,
				width:null, 
				height:null, 
				pWidth:null, 
				pHeight:null, 
				maxWidth:null, 
				maxHeight:null, 
				minWidth:null, 
				minHeight:null,
				rotateDegrees:null};
			
			sizeData.rotateDegrees = child.getStyle("RotateDegrees");
			
			sizeData.width = child.getStyle("Width");
			if (sizeData.width == null)
			{
				//Percent sizing not supported on transformed elements.
				if (sizeData.rotateDegrees == 0)
					sizeData.pWidth = child.getStyle("PercentWidth");
				
				sizeData.minWidth = child.getStyle("MinWidth");
				sizeData.maxWidth = child.getStyle("MaxWidth");
				
				if (sizeData.pWidth != null && layoutDirection == "horizontal")
					totalPercentUsed += sizeData.pWidth;
			}
			
			sizeData.height = child.getStyle("Height");
			if (sizeData.height == null)
			{
				//Percent sizing not supported on transformed elements.
				if (sizeData.rotateDegrees == 0)
					sizeData.pHeight = child.getStyle("PercentHeight");
				
				sizeData.minHeight = child.getStyle("MinHeight");
				sizeData.maxHeight = child.getStyle("MaxHeight");
				
				if (sizeData.pHeight != null && layoutDirection == "vertical")
					totalPercentUsed += sizeData.pHeight;
			}
			
			if (sizeData.minWidth == null)
				sizeData.minWidth = 0;
			if (sizeData.minHeight == null)
				sizeData.minHeight = 0;
			if (sizeData.maxWidth == null)
				sizeData.maxWidth = Number.MAX_VALUE;
			if (sizeData.maxHeight == null)
				sizeData.maxHeight = Number.MAX_VALUE;
			
			childSizeData.push(sizeData);
		}
		
		var totalGap = 0;
		if (numRenderables > 1)
			totalGap = (numRenderables - 1) * layoutGap;
		
		//Available space for children in layout axis.
		var availableSize = 0;
		if (layoutDirection == "horizontal")
			availableSize = w - totalGap;
		else
			availableSize = h - totalGap;
		
		////////////Calculate element sizes//////////////////
		
		var rotatedMetrics = null;
		var percentSizedElements = [];
		
		//Size all explicitly sized elements, record percent sized, and adjust available size for percent elements.
		for (i = 0; i < childSizeData.length; i++)
		{
			child = childSizeData[i];
			
			//Percent sized elements cannot be rotated
			child.element._setActualRotation(child.rotateDegrees, 0, 0);
			
			if (layoutDirection == "horizontal" && childSizeData[i].width == null && childSizeData[i].pWidth != null)
			{
				child.percentSize = child.pWidth;
				child.minSize = child.minWidth;
				child.maxSize = child.maxWidth;
				percentSizedElements.push(child);
				
				if (child.height == null)
				{
					if (child.pHeight != null)
						child.height = Math.round(h * (child.pHeight / 100));
					else
						child.height = child.element._measuredHeight;
					
					child.height = Math.min(child.maxHeight, child.height);
					child.height = Math.max(child.minHeight, child.height);
				}
			}
			else if (layoutDirection == "vertical" && childSizeData[i].height == null && childSizeData[i].pHeight != null)
			{
				child.percentSize = child.pHeight;
				child.minSize = child.minHeight;
				child.maxSize = child.maxHeight;
				percentSizedElements.push(child);
				
				if (child.width == null)
				{
					if (child.pWidth != null)
						child.width = Math.round(w * (child.pWidth / 100));
					else
						child.width = child.element._measuredWidth;
					
					child.width = Math.min(child.maxWidth, child.width);
					child.width = Math.max(child.minWidth, child.width);
				}
			}
			else
			{
				if (child.width == null)
				{
					if (child.pWidth != null)
						child.width = Math.round(w * (child.pWidth / 100));
					else
						child.width = child.element._measuredWidth;
					
					child.width = Math.min(child.maxWidth, child.width);
					child.width = Math.max(child.minWidth, child.width);
				}
				
				if (child.height == null)
				{
					if (child.pHeight != null)
						child.height = Math.round(h * (child.pHeight / 100));
					else
						child.height = child.element._measuredHeight;
					
					child.height = Math.min(child.maxHeight, child.height);
					child.height = Math.max(child.minHeight, child.height);
				}
				
				child.element._setActualSize(child.width, child.height);
				
				//Update the sizing to reflect size after rotation transform (for layout).
				if (child.rotateDegrees != 0)
				{
					rotatedMetrics = child.element.getMetrics(this);
					
					child.width = Math.ceil(rotatedMetrics.getWidth());
					child.height = Math.ceil(rotatedMetrics.getHeight());
				}
				
				if (layoutDirection == "horizontal")
					availableSize -= child.width;
				else // "vertical"
					availableSize -= child.height;
			}
		}
		
		//We're not using all the space, shrink us.
		if (totalPercentUsed < 100)
			availableSize = Math.round(availableSize * (totalPercentUsed / 100));
		
		//Calculate percent sized elements actual size.
		CanvasElement._calculateMinMaxPercentSizes(percentSizedElements, availableSize);
			
		//Size the percent sized elements.
		for (i = 0; i < percentSizedElements.length; i++)
		{
			child = percentSizedElements[i];
			
			if (layoutDirection == "horizontal")
				child.width = child.actualSize;
			else // "vertical"
				child.height = child.actualSize;
			
			child.element._setActualSize(child.width, child.height);
		}
			
		//Get total content size (gap + elements).
		var totalContentSize = totalGap;
		for (i = 0; i < childSizeData.length; i++)
		{
			if (layoutDirection == "horizontal")
				totalContentSize += childSizeData[i].width;
			else // "vertical"
				totalContentSize += childSizeData[i].height;
		}
		
		var actualX = x;
		var actualY = y;
		
		//Adjust starting position.
		if (layoutDirection == "horizontal" && totalContentSize != w)
		{
			if (layoutHorizontalAlign == "center")
				actualX += Math.round((w / 2) - (totalContentSize / 2));
			else if (layoutHorizontalAlign == "right")
				actualX += (w - totalContentSize);
		}
		else if (layoutDirection == "vertical" && totalContentSize != h)
		{
			if (layoutVerticalAlign == "middle")
				actualY += Math.round((h / 2) - (totalContentSize / 2));
			else if (layoutVerticalAlign == "bottom")
				actualY += (h - totalContentSize);
		}

		//Place elements.
		var insertGap = false;
		for (i = 0; i < childSizeData.length; i++)
		{
			child = childSizeData[i];
			
			if (layoutDirection == "horizontal")
			{
				if (insertGap == true)
					actualX += layoutGap;
				else
					insertGap = true;
				
				if (layoutVerticalAlign == "top")
					actualY = y;
				else if (layoutVerticalAlign == "bottom")
					actualY = y + h - child.height;
				else //middle
					actualY = Math.round(y + (h / 2) - (child.height / 2));
				
				if (child.rotateDegees == 0)
					child.element._setActualPosition(actualX, actualY);
				else
					child.element._setRelativePosition(actualX, actualY, this);
				
				actualX += child.width;
			}
			else // "vertical"
			{
				if (insertGap == true)
					actualY += layoutGap;
				else
					insertGap = true;
				
				if (layoutHorizontalAlign == "left")
					actualX = x;
				else if (layoutHorizontalAlign == "right")
					actualX = x + w - child.width;
				else //center
					actualX = Math.round(x + (w / 2) - (child.width / 2));
				
				if (child.rotateDegrees == 0)
					child.element._setActualPosition(actualX, actualY);
				else
					child.element._setRelativePosition(actualX, actualY, this);				
				
				actualY += child.height;
			}
		}
	};
	
	


/**
 * @depends SkinnableElement.js
 */

/////////////////////////////////////////////////
//////////////////ButtonElement//////////////////

/**
 * @class ButtonElement
 * @inherits SkinnableElement
 * 
 * Button is a skin-able element that supports 4 states corresponding to mouse states
 * "up", "over", "down" and "disabled". It also has an optional label. 
 * 
 * Being a SkinnableElement, Button proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the Button itself. 
 * 
 * Button is used as a base class for many click-able elements such as
 * ToggleButton, Checkbox, RadioButton, etc. 
 * 
 * 
 * @constructor ButtonElement 
 * Creates new ButtonElement instance.
 */
function ButtonElement()
{
	ButtonElement.base.prototype.constructor.call(this);

	var _self = this;
	
	this._labelElement = null;
	
	//Private handler, need different instance for each button, proxy to prototype.	
	this._onButtonEventInstance = 
		function (elementEvent)
		{
			if (elementEvent.getType() == "mousedown")
				_self._onButtonMouseDown(elementEvent);
			else if (elementEvent.getType() == "mouseup")
				_self._onButtonMouseUp(elementEvent);
			else if (elementEvent.getType() == "click")
				_self._onButtonClick(elementEvent);
			else if (elementEvent.getType() == "rollover")
				_self._onButtonRollover(elementEvent);
			else if (elementEvent.getType() == "rollout")
				_self._onButtonRollout(elementEvent);
		};
		
	this.addEventListener("mousedown", this._onButtonEventInstance);
	this.addEventListener("mouseup", this._onButtonEventInstance);
	this.addEventListener("rollover", this._onButtonEventInstance);
	this.addEventListener("rollout", this._onButtonEventInstance);
	this.addEventListener("click", this._onButtonEventInstance);
}

//Inherit from SkinnableElement
ButtonElement.prototype = Object.create(SkinnableElement.prototype);
ButtonElement.prototype.constructor = ButtonElement;
ButtonElement.base = SkinnableElement;


/////////////Style Types///////////////////////////////

ButtonElement._StyleTypes = Object.create(null);

//New button specific styles.

/**
 * @style Text String
 * 
 * Text string to be displayed as the button label.
 */
ButtonElement._StyleTypes.Text = 						{inheritable:false};		// "any string" || null

/**
 * @style SkinClass CanvasElement
 * 
 * The CanvasElement constructor type to apply to all skin states. 
 * Specific states such as UpSkinClass will override SkinClass when they are equal priority.
 */
ButtonElement._StyleTypes.SkinClass =					{inheritable:false};	//Element constructor()

/**
 * @style UpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "up" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.UpSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style UpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "up" state skin element.
 */
ButtonElement._StyleTypes.UpSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style UpTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "up" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.UpTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style OverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "over" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.OverSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style OverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "over" state skin element.
 */
ButtonElement._StyleTypes.OverSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style OverTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "over" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.OverTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style DownSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "down" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.DownSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style DownSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "down" state skin element.
 */
ButtonElement._StyleTypes.DownSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style DownTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "down" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.DownTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style DisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "disabled" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.DisabledSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style DisabledSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "disabled" state skin element.
 */
ButtonElement._StyleTypes.DisabledSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style DisabledTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "disabled" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.DisabledTextColor = 			{inheritable:false};		//"#000000"


//Change some of the text styles not to inherit, we'll set these to the label 
//so the label will use button defaults if no style explicitly set.

/**
 * @style TextAlign String
 * 
 * Determines alignment when rendering text. Available values are "left", "center", and "right".
 */
ButtonElement._StyleTypes.TextAlign =					{inheritable:false};		// "left" || "center" || "right"

/**
 * @style TextBaseline String
 * 
 * Determines the baseline when rendering text. Available values are "top", "middle", or "bottom".
 */
ButtonElement._StyleTypes.TextBaseline =				{inheritable:false};  		// "top" || "middle" || "bottom"


/////////Default Styles//////////////////////////////

ButtonElement.StyleDefault = new StyleDefinition();

//Override base class styles
ButtonElement.StyleDefault.setStyle("PaddingTop",						3);
ButtonElement.StyleDefault.setStyle("PaddingBottom",                    3);
ButtonElement.StyleDefault.setStyle("PaddingLeft",                      4);
ButtonElement.StyleDefault.setStyle("PaddingRight",                     4);

ButtonElement.StyleDefault.setStyle("TextAlign", 						"center"); 
ButtonElement.StyleDefault.setStyle("TextBaseline",                     "middle");

ButtonElement.StyleDefault.setStyle("TabStop", 							0);			// number

//ButtonElement specific styles.
ButtonElement.StyleDefault.setStyle("Text", 							null);
ButtonElement.StyleDefault.setStyle("SkinClass", 						CanvasElement); //Not necessary, just for completeness

ButtonElement.StyleDefault.setStyle("UpSkinClass", 						CanvasElement);
ButtonElement.StyleDefault.setStyle("OverSkinClass", 					CanvasElement);
ButtonElement.StyleDefault.setStyle("DownSkinClass", 					CanvasElement);
ButtonElement.StyleDefault.setStyle("DisabledSkinClass", 				CanvasElement);

ButtonElement.StyleDefault.setStyle("UpTextColor", 						"#000000");
ButtonElement.StyleDefault.setStyle("OverTextColor", 					"#000000");
ButtonElement.StyleDefault.setStyle("DownTextColor", 					"#000000");
ButtonElement.StyleDefault.setStyle("DisabledTextColor", 				"#888888");

//Skin Defaults////////////////////////////
ButtonElement.UpSkinStyleDefault = new StyleDefinition();

ButtonElement.UpSkinStyleDefault.setStyle("BorderType", 				"solid");
ButtonElement.UpSkinStyleDefault.setStyle("BorderThickness", 			1);
ButtonElement.UpSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ButtonElement.UpSkinStyleDefault.setStyle("BackgroundColor", 			"#EBEBEB");
ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStop", 			(-.05));

ButtonElement.OverSkinStyleDefault = new StyleDefinition();

ButtonElement.OverSkinStyleDefault.setStyle("BorderType", 				"solid");
ButtonElement.OverSkinStyleDefault.setStyle("BorderThickness", 			1);
ButtonElement.OverSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ButtonElement.OverSkinStyleDefault.setStyle("BackgroundColor", 			"#DDDDDD");
ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 		(+.05));
ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 		(-.05));

ButtonElement.DownSkinStyleDefault = new StyleDefinition();

ButtonElement.DownSkinStyleDefault.setStyle("BorderType", 				"solid");
ButtonElement.DownSkinStyleDefault.setStyle("BorderThickness", 			1);
ButtonElement.DownSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ButtonElement.DownSkinStyleDefault.setStyle("BackgroundColor", 			"#CCCCCC");
ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStart", 		(-.06));
ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStop", 		(+.02));

ButtonElement.DisabledSkinStyleDefault = new StyleDefinition();

ButtonElement.DisabledSkinStyleDefault.setStyle("BorderType", 			"solid");
ButtonElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 		1);
ButtonElement.DisabledSkinStyleDefault.setStyle("BorderColor", 			"#999999");
ButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 		"#ECECEC");
ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 	"linear");
ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 	(+.05));
ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 	(-.05));
//Not used by button, used by scrollbutton, but want button, scrollbutton to use the same style.
ButtonElement.DisabledSkinStyleDefault.setStyle("ArrowColor", 			"#777777");
/////////////////////////////////////////////////

//Apply Skin Defaults
ButtonElement.StyleDefault.setStyle("UpSkinStyle", 						ButtonElement.UpSkinStyleDefault);
ButtonElement.StyleDefault.setStyle("OverSkinStyle", 					ButtonElement.OverSkinStyleDefault);
ButtonElement.StyleDefault.setStyle("DownSkinStyle", 					ButtonElement.DownSkinStyleDefault);
ButtonElement.StyleDefault.setStyle("DisabledSkinStyle", 				ButtonElement.DisabledSkinStyleDefault);


	
/////////////ButtonElement Protected Functions/////////////////////	
	
/**
 * @function _updateState
 * Called in response to mouse events, and when the Button is added to the display hierarchy (if mouse is enabled).
 * Updates the Button skin state.
 */
ButtonElement.prototype._updateState = 
	function ()
	{
		var newState = "up";
	
		if (this.getStyle("Enabled") == false)
			newState = "disabled";
		else
		{
			if (this._mouseIsDown == true)
				newState = "down";
			else if (this._mouseIsOver == true)
				newState = "over";
		}
		
		this.setStyle("SkinState", newState);
	};

/**
 * @function _onButtonMouseDown
 * Event handler for "mousedown" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "mousedown" event listener.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */	
ButtonElement.prototype._onButtonMouseDown = 
	function (elementMouseEvent)
	{
		this._updateState();
	};
	
/**
 * @function _onButtonMouseUp
 * Event handler for "mouseup" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "mouseup" event listener.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */		
ButtonElement.prototype._onButtonMouseUp = 
	function (elementMouseEvent)
	{
		this._updateState();
	};		

/**
 * @function _onButtonRollover
 * Event handler for "rollover" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "rollover" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ButtonElement.prototype._onButtonRollover = 
	function (elementEvent)
	{
		this._updateState();
	};

/**
 * @function _onButtonRollout
 * Event handler for "rollout" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "rollout" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ButtonElement.prototype._onButtonRollout = 
	function (elementEvent)
	{
		this._updateState();
	};	
	
/**
 * @function _onButtonClick
 * Event handler for "click" event. Cancels the event if the Button is disabled.
 * Overriding this is more efficient than adding an additional "click" event listener.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */			
ButtonElement.prototype._onButtonClick = 
	function (elementMouseEvent)
	{
		//Implementor will not expect a click event when button is disabled. 
		if (this.getStyle("Enabled") == false)
			elementMouseEvent.cancelEvent();
	};
	
//@override
ButtonElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
	
		if (state == "up")
			stateSkinClass = this.getStyleData("UpSkinClass");
		else if (state == "over")
			stateSkinClass = this.getStyleData("OverSkinClass");
		else if (state == "down")
			stateSkinClass = this.getStyleData("DownSkinClass");
		else if (state == "disabled")
			stateSkinClass = this.getStyleData("DisabledSkinClass");
		
		var skinClass = this.getStyleData("SkinClass");
		
		//Shouldnt have null stateSkinClass
		if (stateSkinClass == null || skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
	
//@override	
ButtonElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "up")
			return this.getStyle("UpSkinStyle");
		else if (state == "over")
			return this.getStyle("OverSkinStyle");
		else if (state == "down")
			return this.getStyle("DownSkinStyle");
		else if (state == "disabled")
			return this.getStyle("DisabledSkinStyle");
		
		return ButtonElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};

//@override
ButtonElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "up")
			return this._getDefaultStyle("UpSkinStyle");
		else if (state == "over")
			return this._getDefaultStyle("OverSkinStyle");
		else if (state == "down")
			return this._getDefaultStyle("DownSkinStyle");
		else if (state == "disabled")
			return this._getDefaultStyle("DisabledSkinStyle");
		
		return ButtonElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};
	
//@override
ButtonElement.prototype._changeState = 
	function (state)
	{
		ButtonElement.base.prototype._changeState.call(this, state);
		
		this._updateTextColor();
	};
	
/**
 * @function _getTextColor
 * Gets the text color to be used for the supplied state. 
 * Override this to add styles for additional states.
 * 
 * @param state String
 * String representing the state to return the text color style.
 * 
 * @returns string
 * Text color for the supplied state.
 */	
ButtonElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextColor");
		else if (state == "over")
			stateTextColor = this.getStyleData("OverTextColor");
		else if (state == "down")
			stateTextColor = this.getStyleData("DownTextColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextColor");

		var textColor = this.getStyleData("TextColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

/**
 * @function _updateTextColor
 * Updates the text color in response to state changes.
 */		
ButtonElement.prototype._updateTextColor = 
	function ()
	{
		if (this._labelElement == null)
			return;
		
		this._labelElement.setStyle("TextColor", this._getTextColor(this._currentSkinState));
	};
	
/**
 * @function _updateText
 * Updates the buttons label text in response to style changes.
 */	
ButtonElement.prototype._updateText = 
	function ()
	{
		var text = this.getStyle("Text");
		if (text == null || text == "")
		{
			if (this._labelElement != null)
			{
				this._removeChild(this._labelElement);
				this._labelElement = null;
			}
		}
		else
		{
			if (this._labelElement == null)
			{
				this._labelElement = this._createLabel();
				if (this._labelElement != null)
				{
					this._updateTextColor();
					this._addChild(this._labelElement);
				}
			}
			
			if (this._labelElement != null)
				this._labelElement.setStyle("Text", text);
		}	
	};
	
//@override
ButtonElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ButtonElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		//Always update these, they dont do anything if no changes
		//and cheaper to call this than to check SkinClass inheritance.
		this._updateSkinClass("up");
		this._updateSkinStyleDefinitions("up");
		
		this._updateSkinClass("over");
		this._updateSkinStyleDefinitions("over");
		
		this._updateSkinClass("down");
		this._updateSkinStyleDefinitions("down");
		
		this._updateSkinClass("disabled");
		this._updateSkinStyleDefinitions("disabled");
		
		//Create / Destroy and proxy text to label.
		if ("Text" in stylesMap)
			this._updateText();
		
		//Only update the state if mouse is enabled, when disabled it means states are being manually controlled.
		if ("Enabled" in stylesMap && this.getStyle("MouseEnabled") == true)
			this._updateState();
		
		if ("TextAlign" in stylesMap && this._labelElement != null)
			this._labelElement.setStyle("TextAlign", this.getStyle("TextAlign"));
		
		if ("TextBaseline" in stylesMap && this._labelElement != null)
			this._labelElement.setStyle("TextBaseline", this.getStyle("TextBaseline"));
		
		//Always call (can optimize by checking for all text color styles)
		this._updateTextColor();
	};	
	
/**
 * @function _createLabel
 * Creates the Button's label instance when Text style is not null or empty.
 * 
 * @returns LabelElement
 * New LabelElement instance
 */	
ButtonElement.prototype._createLabel = 
	function ()
	{
		var label = new LabelElement();
	
		label.setStyle("MouseEnabled", false);
		label.setStyle("TextAlign", this.getStyle("TextAlign"));
		label.setStyle("TextBaseline", this.getStyle("TextBaseline"));
		
		label.setStyle("Padding", 0); //Wipe out default padding (no doubly padding, only this elements padding is necessary)
		
		return label;
	};
	
//@override
ButtonElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = null;
	
		//Base size off of label.
		if (this._labelElement != null)
		{
			var labelWidth = this._labelElement._getStyledOrMeasuredWidth();
			var labelHeight = this._labelElement._getStyledOrMeasuredHeight();
			
			measuredSize = {width:labelWidth + padWidth, height:labelHeight + padHeight};
		}
		else
			measuredSize = ButtonElement.base.prototype._doMeasure.call(this, padWidth, padHeight);

		return measuredSize;
	};

//@override	
ButtonElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		ButtonElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._labelElement != null)
		{
			this._labelElement._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
			this._labelElement._setActualSize(paddingMetrics.getWidth(), paddingMetrics.getHeight());
		}
	};	
	


/**
 * @depends ButtonElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////ToggleButtonElement/////////////////////////////////

/**
 * @class ToggleButtonElement
 * @inherits ButtonElement
 * 
 * ToggleButton is identical to a button except that it adds "selected" versions of
 * the 4 button states and Toggles from selected to not-selected when clicked. It also
 * dispatches a "changed" event when the selected state changes.
 * 
 * ToggleButton selected states:
 * "selectedUp", "selectedOver", "selectedDown", "selectedDisabled".
 * 
 * Being a SkinnableElement, ToggleButton proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the ToggleButton itself. 
 * 
 * ToggleButton is a base class for components such as Checkbox and RadioButton.
 * 
 * 
 * @constructor ToggleButtonElement 
 * Creates new ToggleButtonElement instance.
 */
function ToggleButtonElement()
{
	ToggleButtonElement.base.prototype.constructor.call(this);
	
	this._isSelected = false;
}

//Inherit from ButtonElement
ToggleButtonElement.prototype = Object.create(ButtonElement.prototype);
ToggleButtonElement.prototype.constructor = ToggleButtonElement;
ToggleButtonElement.base = ButtonElement;

////////////Events/////////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the ToggleButton's selection state changes as a result of user interaction.
 */


/////////////Style Types///////////////////////////////

ToggleButtonElement._StyleTypes = Object.create(null);

//New toggle button specific styles.

/**
 * @style AllowDeselect boolean
 * 
 * When false, the ToggleButton cannot be de-selected by the user and the "selectedOver" and "selectedDown" states are not used, 
 * as with the case for most tab or radio button type elements.
 */
ToggleButtonElement._StyleTypes.AllowDeselect = 				{inheritable:false};		// true || false

/**
 * @style SelectedUpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedUp" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedUpSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style SelectedUpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedUp" state skin element.
 */
ToggleButtonElement._StyleTypes.SelectedUpSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style SelectedUpTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedUp" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedUpTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style SelectedOverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedOver" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedOverSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style SelectedOverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedOver" state skin element. 
 */
ToggleButtonElement._StyleTypes.SelectedOverSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style SelectedOverTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedOver" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedOverTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style SelectedDownSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedDown" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedDownSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style SelectedDownSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedDown" state skin element. 
 */
ToggleButtonElement._StyleTypes.SelectedDownSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style SelectedDownTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedDown" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedDownTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style SelectedDisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedDisabled" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedDisabledSkinClass = 	{inheritable:false};		//Element constructor()

/**
 * @style SelectedDisabledSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedDisabled" state skin element. 
 */
ToggleButtonElement._StyleTypes.SelectedDisabledSkinStyle = 	{inheritable:false};		//StyleDefinition

/**
 * @style SelectedDisabledTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedDisabled" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedDisabledTextColor = 	{inheritable:false};		//"#000000"


////////////Default Styles/////////////////////////////

ToggleButtonElement.StyleDefault = new StyleDefinition();

//ToggleButtonElement specific styles
ToggleButtonElement.StyleDefault.setStyle("AllowDeselect", 							true);

ToggleButtonElement.StyleDefault.setStyle("SelectedUpSkinClass", 					CanvasElement);
ToggleButtonElement.StyleDefault.setStyle("SelectedOverSkinClass", 					CanvasElement);
ToggleButtonElement.StyleDefault.setStyle("SelectedDownSkinClass", 					CanvasElement);
ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledSkinClass", 				CanvasElement);

ToggleButtonElement.StyleDefault.setStyle("SelectedOverTextColor", 					"#000000");
ToggleButtonElement.StyleDefault.setStyle("SelectedUpTextColor", 					"#000000");
ToggleButtonElement.StyleDefault.setStyle("SelectedDownTextColor", 					"#000000");
ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledTextColor", 				"#888888");

//Skin Defaults /////////////////////////////////////
ToggleButtonElement.SelectedUpSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderType", 				"solid");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderThickness", 			1);
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BackgroundColor", 			"#CCCCCC");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientStart", 		(-.06));
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientStop", 		(+.02));

ToggleButtonElement.SelectedOverSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderType", 			"solid");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderThickness", 		1);
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderColor", 			"#333333");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BackgroundColor", 		"#BDBDBD");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientStart", 		(-.08));
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientStop", 		(+.05));

ToggleButtonElement.SelectedDownSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderType", 			"solid");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderThickness", 		1);
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderColor", 			"#333333");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BackgroundColor", 		"#B0B0B0");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientStart", 		(-.08));
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientStop", 		(+.05));

ToggleButtonElement.SelectedDisabledSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderType", 		"solid");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderThickness", 	1);
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderColor", 		"#777777");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BackgroundColor", 	"#C7C7C7");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientType", 	"linear");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientStart", 	(-.08));
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientStop", 	(+.05));
///////////////////////////////////////////////////////

ToggleButtonElement.StyleDefault.setStyle("SelectedUpSkinStyle", 					ToggleButtonElement.SelectedUpSkinStyleDefault);
ToggleButtonElement.StyleDefault.setStyle("SelectedOverSkinStyle", 					ToggleButtonElement.SelectedOverSkinStyleDefault);
ToggleButtonElement.StyleDefault.setStyle("SelectedDownSkinStyle", 					ToggleButtonElement.SelectedDownSkinStyleDefault);
ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledSkinStyle", 				ToggleButtonElement.SelectedDisabledSkinStyleDefault);


//////////////Public Functions/////////////////////////////////////////

/**
 * @function setSelected
 * Sets the selected state of the ToggleButton.
 * 
 * @param isSelected boolean
 * When true the toggle button is selected.
 */	
ToggleButtonElement.prototype.setSelected = 
	function (isSelected)
	{
		if (this._isSelected == isSelected)
			return;
		
		this._isSelected = isSelected;
		this._updateState();
	};
	
/**
 * @function getSelected
 * Gets the selected state of the ToggleButton.
 * 
 * @returns boolean
 * When true the toggle button is selected.
 */	
ToggleButtonElement.prototype.getSelected = 
	function ()
	{
		return this._isSelected;
	};



/////////////Internal Functions/////////////////////	

//@Override
ToggleButtonElement.prototype._updateState = 
	function ()
	{
		if (this._isSelected == false)
		{
			//Call base if we're not selected, handles non-selected states.
			ToggleButtonElement.base.prototype._updateState.call(this);
		}
		else
		{
			var newState = "selectedUp";
			
			if (this.getStyle("Enabled") == false)
				newState = "selectedDisabled";
			else if (this.getStyle("AllowDeselect") == true)
			{
				if (this._mouseIsDown == true)
					newState = "selectedDown";
				else if (this._mouseIsOver == true)
					newState = "selectedOver";
			}
			
			this.setStyle("SkinState", newState);
		}
	};

//@Override	
ToggleButtonElement.prototype._onButtonClick = 
	function (elementMouseEvent)
	{
		//Not calling base
	
		//Implementor will not expect a click event when button is disabled. 
		if (this.getStyle("Enabled") == false)
			elementMouseEvent.cancelEvent();
		else
		{
			if (this._isSelected == false || this.getStyle("AllowDeselect") == true) 
			{
				//Toggle selected state.
				this._isSelected = !this._isSelected;
				
				this._updateState();
				
				//Dispatch changed event.
				if (this.hasEventListener("changed", null) == true)
					this._dispatchEvent(new ElementEvent("changed", false));
			}	
		}
	};
	
//@override
ToggleButtonElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
	
		if (state == "selectedUp")
			stateSkinClass = this.getStyleData("SelectedUpSkinClass");
		else if (state == "selectedOver")
			stateSkinClass = this.getStyleData("SelectedOverSkinClass");
		else if (state == "selectedDown")
			stateSkinClass = this.getStyleData("SelectedDownSkinClass");
		else if (state == "selectedDisabled")
			stateSkinClass = this.getStyleData("SelectedDisabledSkinClass");
		else //base class state
			return ToggleButtonElement.base.prototype._getSkinClass.call(this, state);
		
		var skinClass = this.getStyleData("SkinClass");
		
		if (skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};	
	
//@override	
ToggleButtonElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "selectedUp")
			return this.getStyle("SelectedUpSkinStyle");
		else if (state == "selectedOver")
			return this.getStyle("SelectedOverSkinStyle");
		else if (state == "selectedDown")
			return this.getStyle("SelectedDownSkinStyle");
		else if (state == "selectedDisabled")
			return this.getStyle("SelectedDisabledSkinStyle");
		
		return ToggleButtonElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};	
	
//@Override
ToggleButtonElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "selectedUp")
			return this._getDefaultStyle("SelectedUpSkinStyle");
		else if (state == "selectedOver")
			return this._getDefaultStyle("SelectedOverSkinStyle");
		else if (state == "selectedDown")
			return this._getDefaultStyle("SelectedDownSkinStyle");
		else if (state == "selectedDisabled")
			return this._getDefaultStyle("SelectedDisabledSkinStyle");
		
		return ToggleButtonElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};	
	
//@Override
ToggleButtonElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
	
		if (state == "selectedUp")
			stateTextColor = this.getStyleData("SelectedUpTextColor");
		else if (state == "selectedOver")
			stateTextColor = this.getStyleData("SelectedOverTextColor");
		else if (state == "selectedDown")
			stateTextColor = this.getStyleData("SelectedDownTextColor");
		else if (state == "selectedDisabled")
			stateTextColor = this.getStyleData("SelectedDisabledTextColor");
		else //base class state
			return ToggleButtonElement.base.prototype._getTextColor.call(this, state);
	
		var textColor = this.getStyleData("TextColor");
		
		if (textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

//@Override
ToggleButtonElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ToggleButtonElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		//Always update these, they dont do anything if no changes
		//and cheaper to call this than to check SkinClass inheritance.
		this._updateSkinClass("selectedUp");
		this._updateSkinStyleDefinitions("selectedUp");
		
		this._updateSkinClass("selectedOver");
		this._updateSkinStyleDefinitions("selectedOver");
		
		this._updateSkinClass("selectedDown");
		this._updateSkinStyleDefinitions("selectedDown");
		
		this._updateSkinClass("selectedDisabled");
		this._updateSkinStyleDefinitions("selectedDisabled");
		
		if ("AllowDeselect" in stylesMap)
			this._updateState();
	};	
	

	
	


/**
 * @depends CanvasElement.js
 * @depends ScrollButtonSkinElement.js
 * @depends ButtonElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////ScrollBarElement/////////////////////////////////

/**
 * @class ScrollBarElement
 * @inherits CanvasElement
 * 
 * ScrollBarElement renders a skin-able scroll bar that can be
 * oriented horizontally or vertically and assigns a default
 * skin to the scroll buttons. 
 * 
 * See the default skin ScrollButtonSkinElement for additional skin styles.
 * 
 * @seealso ScrollButtonSkinElement
 * 
 * 
 * @constructor ScrollBarElement 
 * Creates new ScrollBarElement instance.
 */
function ScrollBarElement()
{
	ScrollBarElement.base.prototype.constructor.call(this);
	
	this._buttonIncrement = null;
	this._buttonDecrement = null;
	this._buttonTrack = null;
	this._buttonTab = null;
	
	this._scrollPageSize = 0;
	this._scrollViewSize = 0;
	this._scrollLineSize = 1;
	
	this._scrollValue = 0;
	
	this._scrollTween = null;
	
	var _self = this;
	
	//Private event handlers, need different instance for each ScrollBar, proxy to prototype.
	this._onScrollButtonClickInstance = 
		function (elementMouseEvent)
		{
			_self._onScrollButtonClick(elementMouseEvent);
		};
		
	this._onScrollTabDragInstance = 
		function (elementEvent)
		{
			_self._onScrollTabDrag(elementEvent);
		};
		
	this._onScrollBarEnterFrameInstance = 
		function (event)
		{
			_self._onScrollBarEnterFrame(event);
		};
}

//Inherit from CanvasElement
ScrollBarElement.prototype = Object.create(CanvasElement.prototype);
ScrollBarElement.prototype.constructor = ScrollBarElement;
ScrollBarElement.base = CanvasElement;

/////////////Events////////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the scroll position changes as a result of user interation or tween.
 */


/////////////Style Types///////////////////////////////

ScrollBarElement._StyleTypes = Object.create(null);

/**
 * @style ScrollBarDirection String
 * Determines the orientation of the scroll bar. Allowable values are "horizontal" or "vertical".
 */
ScrollBarElement._StyleTypes.ScrollBarDirection = 			{inheritable:false};		// "horizontal" || "vertical"

/**
 * @style ScrollTweenDuration Number
 * Time in milliseconds the scroll tween animation should run.
 */
ScrollBarElement._StyleTypes.ScrollTweenDuration =			{inheritable:false};		// number (milliseconds)

//ScrollButton / Button styles.
/**
 * @style ScrollButtonIncrementStyle StyleDefinition
 * StyleDefinition to be applied to the Scroll increment Button.
 * ScrollBar automatically sets an inline "ArrowDirection" style to this button which is either "down" or "right" depending on ScrollBarDirection.
 */
ScrollBarElement._StyleTypes.ScrollButtonIncrementStyle = 	{inheritable:false};		// StyleDefinition

/**
 * @style ScrollButtonDecrementStyle StyleDefinition
 * StyleDefinition to be applied to the Scroll decrement Button.
 * ScrollBar automatically sets an inline "ArrowDirection" style to this button which is either "up" or "left" depending on ScrollBarDirection.
 */
ScrollBarElement._StyleTypes.ScrollButtonDecrementStyle = 	{inheritable:false};		// StyleDefinition

/**
 * @style ButtonTrackStyle StyleDefinition
 * StyleDefinition to be applied to the scroll bar track Button.
 */
ScrollBarElement._StyleTypes.ButtonTrackStyle = 			{inheritable:false};		// StyleDefinition

/**
 * @style ButtonTabStyle StyleDefinition
 * StyleDefinition to be applied to the scroll bar tab (draggable) Button.
 */
ScrollBarElement._StyleTypes.ButtonTabStyle = 				{inheritable:false};		// StyleDefinition


////////////Default Styles////////////////////////////

ScrollBarElement.StyleDefault = new StyleDefinition();

//Button style defaults
ScrollBarElement.ButtonTrackStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonTrackStyleDefault.setStyle("BorderType", 					"none");
ScrollBarElement.ButtonTrackStyleDefault.setStyle("UpSkinStyle", 					ButtonElement.UpSkinStyleDefault);  //Dont need this same as button default
ScrollBarElement.ButtonTrackStyleDefault.setStyle("OverSkinStyle", 					ButtonElement.UpSkinStyleDefault); 
ScrollBarElement.ButtonTrackStyleDefault.setStyle("DownSkinStyle", 					ButtonElement.UpSkinStyleDefault);
ScrollBarElement.ButtonTrackStyleDefault.setStyle("DisabledSkinStyle", 				ButtonElement.DisabledSkinStyleDefault); //Dont need this same as button default

ScrollBarElement.ButtonTabStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonTabStyleDefault.setStyle("UpSkinStyle", 						ButtonElement.UpSkinStyleDefault);		//Dont actually need these (could be null)	
ScrollBarElement.ButtonTabStyleDefault.setStyle("OverSkinStyle", 					ButtonElement.OverSkinStyleDefault);
ScrollBarElement.ButtonTabStyleDefault.setStyle("DownSkinStyle", 					ButtonElement.DownSkinStyleDefault);
ScrollBarElement.ButtonTabStyleDefault.setStyle("DisabledSkinStyle", 				ButtonElement.DisabledSkinStyleDefault);

ScrollBarElement.ButtonScrollArrowIncStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("SkinClass", 			ScrollButtonSkinElement);			
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("ArrowColor", 			"#000000");
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("UpSkinStyle", 			ButtonElement.UpSkinStyleDefault);		//Dont actually need these (could be null)	
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("OverSkinStyle", 		ButtonElement.OverSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("DownSkinStyle", 		ButtonElement.DownSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("DisabledSkinStyle", 	ButtonElement.DisabledSkinStyleDefault);

ScrollBarElement.ButtonScrollArrowDecStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("SkinClass", 			ScrollButtonSkinElement);			
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("ArrowColor", 			"#000000");
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("UpSkinStyle", 			ButtonElement.UpSkinStyleDefault);		//Dont actually need these (could be null)	
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("OverSkinStyle", 		ButtonElement.OverSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("DownSkinStyle", 		ButtonElement.DownSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("DisabledSkinStyle", 	ButtonElement.DisabledSkinStyleDefault);

ScrollBarElement.StyleDefault.setStyle("ScrollButtonIncrementStyle", 				ScrollBarElement.ButtonScrollArrowIncStyleDefault); 
ScrollBarElement.StyleDefault.setStyle("ScrollButtonDecrementStyle", 				ScrollBarElement.ButtonScrollArrowDecStyleDefault); 
ScrollBarElement.StyleDefault.setStyle("ButtonTrackStyle", 							ScrollBarElement.ButtonTrackStyleDefault);
ScrollBarElement.StyleDefault.setStyle("ButtonTabStyle", 							ScrollBarElement.ButtonTabStyleDefault);
ScrollBarElement.StyleDefault.setStyle("ScrollTweenDuration", 						180); 			// number (milliseconds)

ScrollBarElement.StyleDefault.setStyle("ScrollBarDirection", 						"vertical");	// "vertical" || "horizontal"



/////////////ScrollBarElement Public Functions///////////////////

/**
 * @function setScrollPageSize
 * Sets the total number of scroll lines.
 * 
 * @param pageSize int
 * The total number of scroll lines.
 */
ScrollBarElement.prototype.setScrollPageSize = 
	function (pageSize)
	{
		if (this._scrollPageSize == pageSize)
			return;
	
		this._scrollPageSize = pageSize;
		this._invalidateLayout();
	};

/**
 * @function getScrollPageSize
 * Gets the total number of scroll lines.
 * 
 * @returns int
 * The total number of scroll lines.
 */	
ScrollBarElement.prototype.getScrollPageSize = 
	function ()
	{
		return this._scrollPageSize;
	};
	
/**
 * @function setScrollViewSize
 * Sets the number of scroll lines that fit within the view.
 * 
 * @param viewSize int
 * The number of scroll lines that fit within the view.
 */	
ScrollBarElement.prototype.setScrollViewSize = 
	function (viewSize)
	{
		if (this._scrollViewSize == viewSize)
			return;
		
		this._scrollViewSize = viewSize;
		this._invalidateLayout();
	};
	
/**
 * @function getScrollViewSize
 * Gets the number of scroll lines that fit within the view.
 * 
 * @returns int
 * The number of scroll lines that fit within the view.
 */	
ScrollBarElement.prototype.getScrollViewSize = 
	function ()
	{
		return this._scrollViewSize;
	};
	
/**
 * @function setScrollLineSize
 * Sets the number of lines to scroll when a scroll button is pressed.
 * 
 * @param lineSize int
 * The number of lines to scroll when a scroll button is pressed.
 */	
ScrollBarElement.prototype.setScrollLineSize = 
	function (lineSize)
	{
		this._scrollLineSize = lineSize;
	};		
	
/**
 * @function getScrollLineSize
 * Gets the number of lines to scroll when a scroll button is pressed.
 * 
 * @returns int
 * The number of lines to scroll when a scroll button is pressed.
 */	
ScrollBarElement.prototype.getScrollLineSize = 
	function ()
	{
		return this._scrollLineSize;
	};
	
/**
 * @function setScrollValue
 * Sets the position to scroll too. Range is 0 to (page size - view size).
 * 
 * @param value int
 * The position to scroll too.
 */	
ScrollBarElement.prototype.setScrollValue = 
	function (value)
	{
		if (this._scrollValue == value)
			return;
		
		this._scrollValue = value;
		this._invalidateLayout();
	};

/**
 * @function getScrollValue
 * Gets the scroll position.  Range is 0 to (page size - view size).
 * 
 * @returns int
 * The scroll position.
 */	
ScrollBarElement.prototype.getScrollValue = 
	function ()
	{
		return this._scrollValue;
	};

/**
 * @function startScrollTween
 * Starts a tween animation to scroll bar to the supplied scroll position.
 * 
 * @param tweenToValue int
 * The position to scroll too.
 */	
ScrollBarElement.prototype.startScrollTween = 
	function (tweenToValue)
	{
		var tweenDuration = this.getStyle("ScrollTweenDuration");
		if (tweenDuration > 0)
		{
			if (this._scrollTween == null)
			{
				this._scrollTween = new Tween();
				this._scrollTween.startVal = this._scrollValue;
				this._scrollTween.endVal = tweenToValue;
				this._scrollTween.duration = tweenDuration;
				this._scrollTween.startTime = Date.now();
				this._scrollTween.easingFunction = Tween.easeInOutSine;
				
				this.addEventListener("enterframe", this._onScrollBarEnterFrameInstance);
			}
			else
			{
				this._scrollTween.startVal = this._scrollValue;
				this._scrollTween.endVal = tweenToValue;
				this._scrollTween.startTime = Date.now();
				this._scrollTween.easingFunction = Tween.easeOutSine;
			}
		}
		else
		{
			this.endScrollTween();
			this.setScrollValue(tweenToValue);
			this._dispatchEvent(new ElementEvent("changed", false));
		}
	};
	
/**
 * @function endScrollTween
 * Ends the scroll tween animation. Immediately moves the scroll position to
 * the ending position if the tween is still running.
 */		
ScrollBarElement.prototype.endScrollTween = 
	function ()
	{
		if (this._scrollTween != null)
		{
			this.setScrollValue(this._scrollTween.endVal);
			this.removeEventListener("enterframe", this._onScrollBarEnterFrameInstance);
			this._scrollTween = null;
		}
	};	
	
/**
 * @function getTweenToValue
 * Gets the scroll position being tweened too.
 * 
 * @returns int
 * The scroll position beeing tweened too or null if no tween is running.
 */	
ScrollBarElement.prototype.getTweenToValue = 
	function ()
	{
		if (this._scrollTween == null)
			return null;
		
		return this._scrollTween.endVal;
	};
	
/////////////ScrollBarElement Internal Functions///////////////////

//@private - only active when a tween is running.
ScrollBarElement.prototype._onScrollBarEnterFrame = 
	function (event)
	{
		var scrollValue = this._scrollTween.getValue(Date.now());
		
		if (scrollValue == this._scrollTween.endVal)
			this.endScrollTween();
		else
			this.setScrollValue(scrollValue);
		
		this._dispatchEvent(new ElementEvent("changed", false));
	};
	
//@Override	
ScrollBarElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		ScrollBarElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		this.endScrollTween();
	};		
	
/**
 * @function _onScrollButtonClick
 * Event handler for Buttons (increment, decrement, and track) "click" event. 
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */		
ScrollBarElement.prototype._onScrollButtonClick = 
	function (elementMouseEvent)
	{
		var incrementSize = null;
		
		var startScrollValue = this._scrollValue;
		if (this._scrollTween != null)
			startScrollValue = this._scrollTween.endVal;
		
		startScrollValue = Math.min(this._scrollPageSize - this._scrollViewSize, startScrollValue);
		startScrollValue = Math.max(0, startScrollValue);
		
		if (elementMouseEvent.getTarget() == this._buttonIncrement || 
			elementMouseEvent.getTarget() == this._buttonDecrement)
		{
			incrementSize = this.getScrollLineSize();
			
			if (elementMouseEvent.getTarget() == this._buttonDecrement)
				incrementSize = incrementSize * -1;
		}
		else if (elementMouseEvent.getTarget() == this._buttonTrack)
		{
			incrementSize = this._scrollViewSize * .75;
			
			if (this.getStyle("ScrollBarDirection") == "horizontal")
			{
				if (elementMouseEvent.getX() <= this._buttonTab._x + (this._buttonTab._width / 2))
					incrementSize = incrementSize * -1;
			}
			else //vertical
			{
				if (elementMouseEvent.getY() <= this._buttonTab._y + (this._buttonTab._height / 2))
					incrementSize = incrementSize * -1;
			}
		}
		
		var endScrollValue = startScrollValue + incrementSize;
		
		endScrollValue = Math.min(this._scrollPageSize - this._scrollViewSize, endScrollValue);
		endScrollValue = Math.max(0, endScrollValue);
		
		if (endScrollValue != startScrollValue)
			this.startScrollTween(endScrollValue);
	};

/**
 * @function _onScrollTabDrag
 * Event handler for Tab Button's "dragging" event. 
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ScrollBarElement.prototype._onScrollTabDrag = 
	function (elementEvent)
	{
		var tabPosition = null;
		var trackSize = null;
		var tabSize = null;
		
		var direction = this.getStyle("ScrollBarDirection");
		var oldScrollValue = this._scrollValue;
		
		if (direction == "horizontal")
		{
			trackSize = this._buttonTrack._width;
			tabPosition = this._buttonTab._x - this._buttonTrack._x;
			tabSize = this._buttonTab._width;
		}
		else
		{
			trackSize = this._buttonTrack._height;
			tabPosition = this._buttonTab._y - this._buttonTrack._y;
			tabSize = this._buttonTab._height;
		}
		
		//Correct position
		if (tabPosition > trackSize - tabSize)
			tabPosition = trackSize - tabSize;
		if (tabPosition < 0)
			tabPosition = 0;
		
		trackSize = trackSize - tabSize;
		
		//Calculate new ScrollValue
		var scrollRange = this._scrollPageSize - this._scrollViewSize;
		var pixelsPerScaleUnit = trackSize / scrollRange;
		
		var newScrollValue = (tabPosition / pixelsPerScaleUnit);
		if (oldScrollValue != newScrollValue)
		{
			this.setScrollValue(newScrollValue);
			this._dispatchEvent(new ElementEvent("changed", false));
		}
		
		//Always invalidate layout, need to correct drag position.
		this._invalidateLayout();
	};

/**
 * @function _createChildren
 * Creates the scroll bar child buttons when the ScrollBar is first added to the display hierarchy.
 */	
ScrollBarElement.prototype._createChildren = 
	function ()
	{
		this._buttonIncrement = new ButtonElement();
		this._buttonIncrement._setStyleDefinitionDefault(this._getDefaultStyle("ScrollButtonIncrementStyle"));
		
		this._buttonIncrement.addEventListener("click", this._onScrollButtonClickInstance);
		this._addChild(this._buttonIncrement);

		this._buttonDecrement = new ButtonElement();
		this._buttonDecrement._setStyleDefinitionDefault(this._getDefaultStyle("ScrollButtonDecrementStyle"));
		
		this._buttonDecrement.addEventListener("click", this._onScrollButtonClickInstance);
		this._addChild(this._buttonDecrement);

		this._buttonTrack = new ButtonElement();
		this._buttonTrack._setStyleDefinitionDefault(this._getDefaultStyle("ButtonTrackStyle"));
		
		this._buttonTrack.addEventListener("click", this._onScrollButtonClickInstance);
		this._addChild(this._buttonTrack);

		this._buttonTab = new ButtonElement();
		this._buttonTab._setStyleDefinitionDefault(this._getDefaultStyle("ButtonTabStyle"));
		this._buttonTab.setStyle("Draggable", true);
		
		this._buttonTab.addEventListener("dragging", this._onScrollTabDragInstance);
		this._addChild(this._buttonTab);
	};
	
//@Override
ScrollBarElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ScrollBarElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if (this._buttonIncrement == null)
			this._createChildren();
		
		if ("ScrollButtonIncrementStyle" in stylesMap)
			this._buttonIncrement.setStyleDefinitions(this.getStyle("ScrollButtonIncrementStyle"));
		
		if ("ScrollButtonDecrementStyle" in stylesMap)
			this._buttonDecrement.setStyleDefinitions(this.getStyle("ScrollButtonDecrementStyle"));
		
		if ("ButtonTrackStyle" in stylesMap)
			this._buttonTrack.setStyleDefinitions(this.getStyle("ButtonTrackStyle"));
		
		if ("ButtonTabStyle" in stylesMap)
			this._buttonTab.setStyleDefinitions(this.getStyle("ButtonTabStyle"));
		
		if ("ScrollBarDirection" in stylesMap)
		{
			if (this.getStyle("ScrollBarDirection") == "horizontal")
			{
				this._buttonIncrement.setStyle("ArrowDirection", "right");
				this._buttonDecrement.setStyle("ArrowDirection", "left");
			}
			else
			{
				this._buttonIncrement.setStyle("ArrowDirection", "down");
				this._buttonDecrement.setStyle("ArrowDirection", "up");
			}
			
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		
		if ("ScrollTweenDuration" in stylesMap && this.getStyle("ScrollTweenDuration") == 0)
			this.endScrollTween();
	};
	
	
//@Override
ScrollBarElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var largestSize = 0;
		if (this.getStyle("ScrollBarDirection") == "horizontal")
		{
			var buttonDecHeight = this._buttonDecrement.getStyle("Height");
			var buttonIncHeight = this._buttonIncrement.getStyle("Height");
			var buttonTrackHeight = this._buttonTrack.getStyle("Height");
			var buttonTabHeight = this._buttonTab.getStyle("Height");
			
			largestSize = Math.max(largestSize, buttonDecHeight);
			largestSize = Math.max(largestSize, buttonIncHeight);
			largestSize = Math.max(largestSize, buttonTrackHeight);
			largestSize = Math.max(largestSize, buttonTabHeight);

			if (largestSize == 0)
				largestSize = 15;
			
			var buttonDecWidth = this._buttonDecrement.getStyle("Width");
			var buttonIncWidth = this._buttonIncrement.getStyle("Width");
			var buttonTabWidth = this._buttonTab.getStyle("Width");
			
			if (buttonDecWidth == null)
				buttonDecWidth = largestSize;
			if (buttonIncWidth == null)
				buttonIncWidth = largestSize;
			if (buttonTabWidth == null)
				buttonTabWidth = buttonDecWidth + buttonIncWidth;			
			
			return {width: padWidth + buttonDecWidth + buttonIncWidth + (buttonTabWidth * 2),
					height: padHeight + largestSize};
		}
		else
		{
			var buttonDecWidth = this._buttonDecrement.getStyle("Width");
			var buttonIncWidth = this._buttonIncrement.getStyle("Width");
			var buttonTrackWidth = this._buttonTrack.getStyle("Width");
			var buttonTabWidth = this._buttonTab.getStyle("Width");
			
			largestSize = Math.max(largestSize, buttonDecWidth);
			largestSize = Math.max(largestSize, buttonIncWidth);
			largestSize = Math.max(largestSize, buttonTrackWidth);
			largestSize = Math.max(largestSize, buttonTabWidth);
			
			if (largestSize == 0)
				largestSize = 15;
			
			var buttonDecHeight = this._buttonDecrement.getStyle("Height");
			var buttonIncHeight = this._buttonIncrement.getStyle("Height");
			var buttonTabHeight = this._buttonTab.getStyle("Height");
			
			if (buttonDecHeight == null)
				buttonDecHeight = largestSize;
			if (buttonIncHeight == null)
				buttonIncHeight = largestSize;
			if (buttonTabHeight == null)
				buttonTabHeight = buttonDecWidth + buttonIncWidth;			
			
			return {width: padWidth + largestSize,
					height: padHeight + buttonDecHeight + buttonIncHeight + (buttonTabHeight * 2)};
		}
	};	
	
//@Override	
ScrollBarElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		ScrollBarElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		var direction = this.getStyle("ScrollBarDirection");

		//Correct the scroll value (size reduction forces us to scroll up)
		this._scrollValue = Math.min(this._scrollValue, this._scrollPageSize - this._scrollViewSize);
		this._scrollValue = Math.max(this._scrollValue, 0);
		
		//Disable / Enable components
		if (this._scrollViewSize >= this._scrollPageSize)
		{
			this._buttonIncrement.setStyle("Enabled", false);
			this._buttonDecrement.setStyle("Enabled", false);
			this._buttonTrack.setStyle("Enabled", false);
			this._buttonTab.setStyle("Visible", false);
		}
		else
		{
			this._buttonIncrement.setStyle("Enabled", true);
			this._buttonDecrement.setStyle("Enabled", true);
			this._buttonTrack.setStyle("Enabled", true);
			this._buttonTab.setStyle("Visible", true);
		}
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var buttonDecWidth = this._buttonDecrement.getStyle("Width");
		var buttonDecHeight = this._buttonDecrement.getStyle("Height");
		
		var buttonIncWidth = this._buttonIncrement.getStyle("Width");
		var buttonIncHeight = this._buttonIncrement.getStyle("Height");
		
		var buttonTabWidth = this._buttonTab.getStyle("Width");
		var buttonTabHeight = this._buttonTab.getStyle("Height");
		
		var minTabSize = null;
		var availableTrackSize = null;
		var pixelsPerScaleUnit = null;
		
		if (direction == "horizontal")
		{
			if (buttonDecWidth == null)
				buttonDecWidth = h;
			if (buttonDecHeight == null)
				buttonDecHeight = h;
			
			if (buttonIncWidth == null)
				buttonIncWidth = h;
			if (buttonIncHeight == null)
				buttonIncHeight = h;
			
			var trackHeight = this._buttonTrack.getStyle("Height");
			if (trackHeight == null)
				trackHeight = h;
			
			//Center vertically
			this._buttonDecrement._setActualPosition(x, y + (h / 2) - (buttonDecHeight / 2));
			this._buttonDecrement._setActualSize(buttonDecWidth, buttonDecHeight);
			
			this._buttonIncrement._setActualPosition(x + w - buttonIncWidth, y + (h / 2) - (buttonIncHeight / 2));
			this._buttonIncrement._setActualSize(buttonIncWidth, buttonIncHeight);
			
			this._buttonTrack._setActualPosition(x + buttonDecWidth, y + (h / 2) - (trackHeight / 2));
			this._buttonTrack._setActualSize(w - buttonDecWidth - buttonIncWidth, trackHeight);
			
			if (buttonTabHeight == null)
				buttonTabHeight = h;
			if (buttonTabWidth == null)
			{
				minTabSize = (buttonDecWidth + buttonIncWidth);
				
				if (this._scrollPageSize > 0)
					buttonTabWidth = this._buttonTrack._width * (this._scrollViewSize / this._scrollPageSize);
				else
					buttonTabWidth = 0;
				
				buttonTabWidth = Math.max(minTabSize, buttonTabWidth);
			}
			
			availableTrackSize = this._buttonTrack._width - buttonTabWidth;
			pixelsPerScaleUnit = availableTrackSize / (this._scrollPageSize - this._scrollViewSize);
			
			this._buttonTab._setActualPosition(x + buttonDecWidth + (this._scrollValue * pixelsPerScaleUnit), y + (h / 2) - (buttonTabHeight / 2));
			this._buttonTab._setActualSize(buttonTabWidth, buttonTabHeight);
		}
		else
		{
			if (buttonDecWidth == null)
				buttonDecWidth = w;
			if (buttonDecHeight == null)
				buttonDecHeight = w;
			
			if (buttonIncWidth == null)
				buttonIncWidth = w;
			if (buttonIncHeight == null)
				buttonIncHeight = w;
			
			var trackWidth = this._buttonTrack.getStyle("Width");
			if (trackWidth == null)
				trackWidth = w;
			
			//Center horizontally
			this._buttonDecrement._setActualPosition(x + (w / 2) - (buttonDecWidth / 2), y);
			this._buttonDecrement._setActualSize(buttonDecWidth, buttonDecHeight);
			
			this._buttonIncrement._setActualPosition(x + (w / 2) - (buttonIncWidth / 2), y + h - buttonIncHeight);
			this._buttonIncrement._setActualSize(buttonIncWidth, buttonIncHeight);
			
			this._buttonTrack._setActualPosition(x + (w / 2) - (trackWidth / 2), y + buttonDecHeight);
			this._buttonTrack._setActualSize(trackWidth, h - buttonDecHeight - buttonIncHeight);
			
			if (buttonTabWidth == null)
				buttonTabWidth = w;
			if (buttonTabHeight == null)
			{
				minTabSize = (buttonDecHeight + buttonIncHeight);
				
				if (this._scrollPageSize > 0)
					buttonTabHeight = this._buttonTrack._height * (this._scrollViewSize / this._scrollPageSize);
				else
					buttonTabHeight = 0;
				
				buttonTabHeight = Math.max(minTabSize, buttonTabHeight);
			}
			
			availableTrackSize = this._buttonTrack._height - buttonTabHeight;
			pixelsPerScaleUnit = availableTrackSize / (this._scrollPageSize - this._scrollViewSize);
			
			this._buttonTab._setActualPosition(x + (w / 2) - (buttonTabWidth / 2), y + buttonDecHeight + (this._scrollValue * pixelsPerScaleUnit));
			this._buttonTab._setActualSize(buttonTabWidth, buttonTabHeight);
		}
	};	
	
	


/**
 * @depends ToggleButtonElement.js
 * @depends RadioButtonSkinElement.js
 * @depends EllipseShape.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////////RadioButtonElement////////////////////////////////

/**
 * @class RadioButtonElement
 * @inherits ToggleButtonElement
 * 
 * RadioButton is a skinned ToggleButton that adjusts the placement of the skin and label. 
 * ToggleButtonGroup may be used to group radio buttons so only 1 may be selected at a time.
 * 
 * When a label is in use, the skin is placed next to the label rather than underneath and is assumed to be square. 
 * When a label is not in use, the skin will span the entire bounding box.
 * 
 * Being a SkinnableElement, RadioButton proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the RadioButton itself. 
 * 
 * See the default skin RadioButtonSkinElement for additional skin styles.
 * 
 * @seealso RadioButtonSkinElement
 * @seealso ToggleButtonGroup
 * 
 * 
 * @constructor RadioButtonElement 
 * Creates new RadioButtonElement instance.
 */
function RadioButtonElement()
{
	RadioButtonElement.base.prototype.constructor.call(this);
}

//Inherit from ToggleButtonElement
RadioButtonElement.prototype = Object.create(ToggleButtonElement.prototype);
RadioButtonElement.prototype.constructor = RadioButtonElement;
RadioButtonElement.base = ToggleButtonElement;	


/////////////Style Types///////////////////////////////

RadioButtonElement._StyleTypes = Object.create(null);

//New RadioButtonElement specific styles

/**
 * @style LabelPlacement String
 * 
 * Determines if the label should be placed to the left or right of the skin. 
 * Allowable values are "left" or "right".
 */
RadioButtonElement._StyleTypes.LabelPlacement =						{inheritable:false};		// "left" || "right"

/**
 * @style LabelGap Number
 * 
 * Determines distance in pixels the label should be placed from the skin.
 */
RadioButtonElement._StyleTypes.LabelGap =							{inheritable:false};		// number



////////////Default Styles//////////////////////

RadioButtonElement.StyleDefault = new StyleDefinition();

//New RadioButton styles
RadioButtonElement.StyleDefault.setStyle("LabelPlacement", 						"right");
RadioButtonElement.StyleDefault.setStyle("LabelGap", 							5);

//Override base class styles
RadioButtonElement.StyleDefault.setStyle("AllowDeselect", 						false);

RadioButtonElement.StyleDefault.setStyle("PaddingTop",                          0);
RadioButtonElement.StyleDefault.setStyle("PaddingBottom",                       0);
RadioButtonElement.StyleDefault.setStyle("PaddingLeft",                         0);
RadioButtonElement.StyleDefault.setStyle("PaddingRight",                        0);

RadioButtonElement.StyleDefault.setStyle("TextAlign", 							"left");
RadioButtonElement.StyleDefault.setStyle("TextBaseline", 						"middle");

RadioButtonElement.StyleDefault.setStyle("SkinClass", 							RadioButtonSkinElement); //Not necessary, just for completeness

RadioButtonElement.StyleDefault.setStyle("UpSkinClass", 						RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("OverSkinClass", 						RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("DownSkinClass", 						RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("DisabledSkinClass", 					RadioButtonSkinElement);

RadioButtonElement.StyleDefault.setStyle("SelectedUpSkinClass", 				RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("SelectedOverSkinClass", 				RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("SelectedDownSkinClass", 				RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("SelectedDisabledSkinClass", 			RadioButtonSkinElement);


//Skin Defaults
RadioButtonElement.UpSkinStyleDefault = new StyleDefinition();

RadioButtonElement.UpSkinStyleDefault.setStyle("BackgroundShape",				new EllipseShape());
RadioButtonElement.UpSkinStyleDefault.setStyle("BorderType", 					"solid");
RadioButtonElement.UpSkinStyleDefault.setStyle("BorderThickness", 				1);
RadioButtonElement.UpSkinStyleDefault.setStyle("BorderColor", 					"#333333");
RadioButtonElement.UpSkinStyleDefault.setStyle("BackgroundColor", 				"#EBEBEB");
RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));
RadioButtonElement.UpSkinStyleDefault.setStyle("CheckColor", 					"#000000");

RadioButtonElement.OverSkinStyleDefault = new StyleDefinition();

RadioButtonElement.OverSkinStyleDefault.setStyle("BackgroundShape",				new EllipseShape());
RadioButtonElement.OverSkinStyleDefault.setStyle("BorderType", 					"solid");
RadioButtonElement.OverSkinStyleDefault.setStyle("BorderThickness", 			1);
RadioButtonElement.OverSkinStyleDefault.setStyle("BorderColor", 				"#333333");
RadioButtonElement.OverSkinStyleDefault.setStyle("BackgroundColor", 			"#DDDDDD");
RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 			(-.05));
RadioButtonElement.OverSkinStyleDefault.setStyle("CheckColor", 					"#000000");

RadioButtonElement.DownSkinStyleDefault = new StyleDefinition();

RadioButtonElement.DownSkinStyleDefault.setStyle("BackgroundShape",				new EllipseShape());
RadioButtonElement.DownSkinStyleDefault.setStyle("BorderType", 					"solid");
RadioButtonElement.DownSkinStyleDefault.setStyle("BorderThickness", 			1);
RadioButtonElement.DownSkinStyleDefault.setStyle("BorderColor", 				"#333333");
RadioButtonElement.DownSkinStyleDefault.setStyle("BackgroundColor", 			"#CCCCCC");
RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStart", 			(-.06));
RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStop", 			(+.02));
RadioButtonElement.DownSkinStyleDefault.setStyle("CheckColor", 					"#000000");

RadioButtonElement.DisabledSkinStyleDefault = new StyleDefinition();

RadioButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundShape",			new EllipseShape());
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderType", 				"solid");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 		1);
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderColor", 			"#999999");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 		"#ECECEC");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 		(+.05));
RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 		(-.05));
RadioButtonElement.DisabledSkinStyleDefault.setStyle("CheckColor", 				"#777777");

//Apply Skin Defaults
RadioButtonElement.StyleDefault.setStyle("UpSkinStyle", 						RadioButtonElement.UpSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("OverSkinStyle", 						RadioButtonElement.OverSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("DownSkinStyle", 						RadioButtonElement.DownSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("DisabledSkinStyle", 					RadioButtonElement.DisabledSkinStyleDefault);

RadioButtonElement.StyleDefault.setStyle("SelectedUpSkinStyle", 				RadioButtonElement.UpSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("SelectedOverSkinStyle", 				RadioButtonElement.OverSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("SelectedDownSkinStyle", 				RadioButtonElement.DownSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("SelectedDisabledSkinStyle", 			RadioButtonElement.DisabledSkinStyleDefault);


/////////////Internal Functions/////////////////////	

//@override
RadioButtonElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width: padWidth, height: padHeight};
	
		if (this._labelElement != null)
		{
			var labelWidth = this._labelElement._getStyledOrMeasuredWidth();
			var labelHeight = this._labelElement._getStyledOrMeasuredHeight();
			
			measuredSize.height = padHeight + labelHeight;
			measuredSize.width = measuredSize.height + padWidth + labelWidth + this.getStyle("LabelGap");
		}
		else
		{
		    measuredSize.height = padHeight + 14;
		    measuredSize.width = padWidth + 14;
		}
		
		return measuredSize;
	};

//@override	
RadioButtonElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		if (this._labelElement != null)
		{
			var labelPlacement = this.getStyle("LabelPlacement");
			var labelGap = this.getStyle("LabelGap");
			
			for (var prop in this._skins)
			{
				this._skins[prop]._setActualSize(this._height, this._height);
				
				if (labelPlacement == "left")
					this._skins[prop]._setActualPosition(this._width - this._height, 0);
				else
					this._skins[prop]._setActualPosition(0, 0);
			}
			
			if (labelPlacement == "left")
				this._labelElement._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
			else
				this._labelElement._setActualPosition(this._height + labelGap + paddingMetrics.getX(), paddingMetrics.getY());
			
			this._labelElement._setActualSize(paddingMetrics.getWidth() - labelGap - this._height, paddingMetrics.getHeight());
		}
		else
		{
			for (var prop in this._skins)
			{
				this._skins[prop]._setActualSize(this._width, this._height);
				this._skins[prop]._setActualPosition(0, 0);
			}
		}
	};	




/**
 * @depends ButtonElement.js
 * @depends DropdownArrowButtonSkinElement.js
 * @depends DataGridDataRenderer.js
 * @depends DataRendererLabelElement.js
 * @depends Tween.js
 * @depends DataListElement.js
 */

//////////////////////////////////////////////////////////////
//////////////////DropdownElement/////////////////////////////

/**
 * @class DropdownElement
 * @inherits ButtonElement
 * 
 * DropdownElement is a compound button that creates a pop-up drop-down list which the user
 * can select a value which is then displayed on the by the Dropdown. The values
 * in the list are generated by a supplied ListCollection and associated styling.
 * 
 * The Dropdown button itself contains a child button which is used to render
 * the divider line and arrow. Dropdown proxies its SkinState style to the arrow
 * button so the arrow button will change states along with the Dropdown itself.
 * See the default skin for the arrow button DropdownArrowButtonSkinElement for additional styles.
 * 
 * @seealso DropdownArrowButtonSkinElement
 * 
 * 
 * @constructor DropdownElement 
 * Creates new DropdownElement instance.
 */
function DropdownElement()
{
	DropdownElement.base.prototype.constructor.call(this);

	this._listCollection = null; //Data collection
	
	this._arrowButton = null;
	
	this._selectedIndex = -1;
	this._selectedItem = null;
	
	this._dataListPopupClipContainer = new CanvasElement();
	this._dataListPopupClipContainer.setStyle("ClipContent", true);
	this._dataListPopup = null;
	
	this._openDirection = null;
	this._openHeight = null;
	this._dropdownManagerMetrics = null;
	
	this._sampledTextWidth = null;
	
	this._openCloseTween = null;
	
	var _self = this;
	
	//Private event listener, need an instance for each DropdownElement, proxy to prototype.
	this._onDropdownListCollectionChangedInstance = 
		function (collectionChangedEvent)
		{
			_self._onDropdownListCollectionChanged(collectionChangedEvent);
		};
		
	this._onDropdownDataListPopupChangedInstance = 
		function (event)
		{
			_self._onDropdownDataListPopupChanged(event);
		};
	
	this._onDropdownDataListPopupListItemClickedInstance = 
		function (event)
		{
			_self._onDropdownDataListPopupListItemClicked(event);
		};
		
	this._onDropdownDataListPopupLayoutCompleteInstance = 
		function (event)
		{
			_self._onDropdownDataListPopupLayoutComplete(event);
		};
		
	this._onDropdownManagerCaptureEventInstance = 
		function (event)
		{
			_self._onDropdownManagerCaptureEvent(event);
		};
		
	this._onDropdownManagerResizeEventInstance = 
		function (event)
		{
			_self._onDropdownManagerResizeEvent(event);
		};
		
	this._onDropDownEnterFrameInstance = 
		function (event)
		{
			_self._onDropDownEnterFrame(event);
		};
}

//Inherit from ButtonElement
DropdownElement.prototype = Object.create(ButtonElement.prototype);
DropdownElement.prototype.constructor = DropdownElement;
DropdownElement.base = ButtonElement;

////////////Events///////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the drop down selection changes as a result of user input.
 * 
 * @event listitemclick ElementListItemClickEvent
 * Dispatched when a DataRenderer in the popup list is clicked. Includes associated collection item/index.
 */



/////////////Style Types/////////////////////////

DropdownElement._StyleTypes = Object.create(null);

/**
 * @style ItemLabelFunction Function
 * 
 * A function that returns a text string per a supplied collection item.
 * function (itemData) { return "" }
 */
DropdownElement._StyleTypes.ItemLabelFunction = 			{inheritable:false}; 		// function (itemData) { return "" }

/**
 * @style PopupDataListClass DataListElement
 * 
 * The DataListElement or subclass constructor to be used for the pop up list. 
 */
DropdownElement._StyleTypes.PopupDataListClass =			{inheritable:false};		// DataListElement constructor.

/**
 * @style PopupDataListStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the pop up list element.
 */
DropdownElement._StyleTypes.PopupDataListStyle = 			{inheritable:false}; 		// StyleDefinition

/**
 * @style MaxPopupHeight Number
 * Maximum height in pixels of the pop up list element.
 */
DropdownElement._StyleTypes.MaxPopupHeight = 				{inheritable:false}; 		// number

/**
 * @style ArrowButtonClass CanvasElement
 * 
 * The CanvasElement or subclass constructor to be used for the arrow icon. Defaults to Button. 
 * Note that Dropdown proxies its SkinState style to the arrow button so the arrow will change states with the Dropdown.
 */
DropdownElement._StyleTypes.ArrowButtonClass = 				{inheritable:false}; 		// CanvasElement constructor

/**
 * @style ArrowButtonStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the arrow icon class.
 */
DropdownElement._StyleTypes.ArrowButtonStyle = 				{inheritable:false}; 		// StyleDefinition

/**
 * @style OpenCloseTweenDuration Number
 * 
 * Duration in milliseconds the open and close animation should run.
 */
DropdownElement._StyleTypes.OpenCloseTweenDuration = 		{inheritable:false}; 		// number (milliseconds)

/**
 * @style OpenCloseTweenEasingFunction Function
 * 
 * Easing function used on the open and close animations. Defaults to Tween.easeInOutSine().
 */
DropdownElement._StyleTypes.OpenCloseTweenEasingFunction = 	{inheritable:false}; 		// function (fraction) { return fraction} - see Tween.easing

/**
 * @style PopupDataListClipTopOrBottom Number
 * 
 * Size in pixels to clip off the pop up list. Clips top when opening down, bottom when opening up. 
 * Defaults to 1 to collapse pop up list and dropdown default borders.
 */
DropdownElement._StyleTypes.PopupDataListClipTopOrBottom = 	{inheritable:false}; 		// number


////////////Default Styles////////////////////


/////Arrow default style///////
DropdownElement.ArrowButtonStyleDefault = new StyleDefinition();
DropdownElement.ArrowButtonStyleDefault.setStyle("BorderType", 					"none");
DropdownElement.ArrowButtonStyleDefault.setStyle("BackgroundColor", 			null);
DropdownElement.ArrowButtonStyleDefault.setStyle("SkinClass", 					DropdownArrowButtonSkinElement);

//Note that SkinState is proxied to the arrow button, so the arrow will change state along with the Dropdown (unless you turn mouse back on)
DropdownElement.ArrowButtonStyleDefault.setStyle("MouseEnabled", 				false);

//Wipe out the skin styles provided by button (we're currently just using the base state for all skins).
DropdownElement.ArrowButtonStyleDefault.setStyle("UpSkinStyle", 				null);
DropdownElement.ArrowButtonStyleDefault.setStyle("OverSkinStyle", 				null);
DropdownElement.ArrowButtonStyleDefault.setStyle("DownSkinStyle", 				null);
DropdownElement.ArrowButtonStyleDefault.setStyle("DisabledSkinStyle", 			null);
///////////////////////////////

/////Dropdown DataList Style//////

//DataList Scrollbar style
DropdownElement.DataListScrollBarStyleDefault = new StyleDefinition();
DropdownElement.DataListScrollBarStyleDefault.setStyle("Padding", -1);			//Expand by 1px to share borders

//DataList ListItem style
DropdownElement.DataListItemStyleDefault = new StyleDefinition();
DropdownElement.DataListItemStyleDefault.setStyle("UpSkinStyle", 				DataGridDataRenderer.UpSkinStyleDefault);
DropdownElement.DataListItemStyleDefault.setStyle("AltSkinStyle", 				DataGridDataRenderer.AltSkinStyleDefault);

//DataList style
DropdownElement.DataListStyleDefault = new StyleDefinition();
DropdownElement.DataListStyleDefault.setStyle("ScrollBarStyle", 				DropdownElement.DataListScrollBarStyleDefault);
DropdownElement.DataListStyleDefault.setStyle("ListItemClass", 					DataRendererLabelElement);	//Same as DataList default (not needed)
DropdownElement.DataListStyleDefault.setStyle("ListItemStyle", 					DropdownElement.DataListItemStyleDefault);										
DropdownElement.DataListStyleDefault.setStyle("BorderType", 					"solid");
DropdownElement.DataListStyleDefault.setStyle("BorderThickness", 				1);
DropdownElement.DataListStyleDefault.setStyle("PaddingTop",						1);
DropdownElement.DataListStyleDefault.setStyle("PaddingBottom",					1);
DropdownElement.DataListStyleDefault.setStyle("PaddingLeft",					1);
DropdownElement.DataListStyleDefault.setStyle("PaddingRight",					1);
///////////////////////////////////

DropdownElement.StyleDefault = new StyleDefinition();
DropdownElement.StyleDefault.setStyle("PaddingTop",								4);
DropdownElement.StyleDefault.setStyle("PaddingBottom",							4);
DropdownElement.StyleDefault.setStyle("PaddingRight",							4);
DropdownElement.StyleDefault.setStyle("PaddingLeft",							4);

DropdownElement.StyleDefault.setStyle("PopupDataListClass", 					DataListElement); 								// DataListElement constructor
DropdownElement.StyleDefault.setStyle("PopupDataListStyle", 					DropdownElement.DataListStyleDefault); 			// StyleDefinition
DropdownElement.StyleDefault.setStyle("ArrowButtonClass", 						ButtonElement); 								// Element constructor
DropdownElement.StyleDefault.setStyle("ArrowButtonStyle", 						DropdownElement.ArrowButtonStyleDefault); 		// StyleDefinition
DropdownElement.StyleDefault.setStyle("TextAlign", 								"left"); 								
DropdownElement.StyleDefault.setStyle("MaxPopupHeight", 						200); 											// number
DropdownElement.StyleDefault.setStyle("OpenCloseTweenDuration", 				300); 											// number (milliseconds)
DropdownElement.StyleDefault.setStyle("OpenCloseTweenEasingFunction", 			Tween.easeInOutSine); 							// function (fraction) { return fraction}
DropdownElement.StyleDefault.setStyle("PopupDataListClipTopOrBottom", 			1); 											// number
DropdownElement.StyleDefault.setStyle("ItemLabelFunction", 						DataListElement.DefaultItemLabelFunction); 		// function (itemData) { return "" }


/////////Style Proxy Maps/////////////////////////////

//Proxy map for styles we want to pass to the DataList popup.
DropdownElement._PopupDataListProxyMap = Object.create(null);
DropdownElement._PopupDataListProxyMap.ItemLabelFunction = 				true;
DropdownElement._PopupDataListProxyMap._Arbitrary = 					true;

//Proxy map for styles we want to pass to the arrow button.
DropdownElement._ArrowButtonProxyMap = Object.create(null);
DropdownElement._ArrowButtonProxyMap.SkinState = 						true;
DropdownElement._ArrowButtonProxyMap._Arbitrary = 						true;


/////////////Public///////////////////////////////

/**
 * @function setSelectedIndex
 * Sets the selection collection index. Also updates selected item.
 * 
 * @param index int
 * Collection index to select.
 */
DropdownElement.prototype.setSelectedIndex = 
	function (index)
	{
		if (this._selectedIndex == index)
			return false;
		
		if (this._listCollection == null || index > this._listCollection.length -1)
			return false;
		
		if (index < -1)
			index = -1;
		
		if (this._dataListPopup != null)
			this._dataListPopup.setSelectedIndex(index);
		
		this._selectedIndex = index;
		this._selectedItem = this._listCollection.getItemAt(index);
		this._updateText();

		return true;
	};

/**
 * @function getSelectedIndex
 * Gets the selected collection index.
 * 
 * @returns int
 * Selected collection index or -1 if none selected.
 */	
DropdownElement.prototype.getSelectedIndex = 
	function ()
	{
		return this._selectedIndex;
	};
	
/**
 * @function setSelectedItem
 * Sets the collection item to select, also updates selected index.
 * 
 * @param item Object
 * Collection item to select.
 */	
DropdownElement.prototype.setSelectedItem = 
	function (item)
	{
		var index = this._listCollection.getItemIndex(item);
		this._setSelectedIndex(index);
	};
	
/**
 * @function getSelectedItem
 * Gets the selected collection item.
 * 
 * @returns Object
 * Selected collection item or null if none selected.
 */	
DropdownElement.prototype.getSelectedItem = 
	function ()
	{
		return this._selectedItem;
	};
	
/**
 * @function setListCollection
 * Sets the ListCollection to be used as the data-provider.
 * 
 * @param listCollection ListCollection
 * ListCollection to be used as the data-provider.
 */	
DropdownElement.prototype.setListCollection = 
	function (listCollection)
	{
		if (this._listCollection == listCollection)
			return;
	
		if (this._manager == null)
		{
			this._listCollection = listCollection;
		}
		else
		{
			if (this._listCollection != null)
				this._listCollection.removeEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
			
			this._listCollection = listCollection;
			
			if (this._listCollection != null)
				this._listCollection.addEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
		}
		
		//Fix selected index/item
		if (this._listCollection == null)
		{
			this._selectedIndex = -1;
			this._selectedItem = null;
		}
		else
		{
			if (this._selectedItem != null)
			{
				this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
				
				if (this._selectedIndex == -1)
					this._selectedItem = null;
			}
		}
		
		this._updateText();
		this._sampledTextWidth = null;
		this._invalidateMeasure();
		
		if (this._dataListPopup != null)
			this._dataListPopup.setListCollection(listCollection);
	};	

/**
 * @function open
 * Opens the Dropdown pop up list.
 * 
 * @param animate boolean
 * When true animates the appearance of the pop-up list.
 */	
DropdownElement.prototype.open = 
	function (animate)
	{
		if (this._manager == null || this._listCollection == null || this._listCollection.getLength() == 0)
			return;
	
		if (this._dataListPopup == null)
		{
			this._dataListPopup = this._createDataListPopup();
			this._dataListPopupClipContainer._addChild(this._dataListPopup);
		}
		
		if (this._dropdownManagerMetrics == null)
			this._dropdownManagerMetrics = this.getMetrics(this._manager);
		
		//Add the pop-up list. Wait for layoutcomplete to adjust positioning and size (will set openHeight once done)
		this._addDataListPopup(); 
		
		var tweenDuration = this.getStyle("OpenCloseTweenDuration");
		
		if (animate == false || tweenDuration <= 0)
		{
			if (this._openCloseTween != null && this._openHeight != null) //Tween running 
			{
				this._endOpenCloseTween();
				this._updateTweenPosition(this._openHeight);
			}
		}
		else
		{
			if (this._openCloseTween != null) //Tween running
			{
				if (this._openCloseTween.startVal != 0) //Reverse if closing, ignore if opening.
					this._reverseTween();
			}
			else if (this._openHeight == null) //Dont open if already open
			{
				this._openCloseTween = new Tween();
				this._openCloseTween.startVal = 0; 
				this._openCloseTween.endVal = null;	//Dont know the end val yet (popup size unknown)
				this._openCloseTween.duration = tweenDuration;
				this._openCloseTween.startTime = Date.now();
				this._openCloseTween.easingFunction = this.getStyle("OpenCloseTweenEasingFunction");
				
				this.addEventListener("enterframe", this._onDropDownEnterFrameInstance);
			}
		}
	};
	
/**
 * @function close
 * Closes the Dropdown pop up list.
 * 
 * @param animate boolean
 * When true animates the disappearance of the pop-up list.
 */		
DropdownElement.prototype.close = 
	function (animate)
	{
		var tweenDuration = this.getStyle("OpenCloseTweenDuration");
	
		if (animate == false || tweenDuration <= 0)
		{
			this._endOpenCloseTween();		
			this._removeDataListPopup();
		}
		else 
		{
			if (this._openCloseTween != null) //Tween running
			{
				if (this._openCloseTween.startVal == 0) //Reverse if opening, ignore if closing.
					this._reverseTween();
			}
			else if (this._openHeight != null) //Dont close if already closed
			{
				this._openCloseTween = new Tween();
				this._openCloseTween.startVal = this._openHeight - this.getStyle("PopupDataListClipTopOrBottom");
				this._openCloseTween.endVal = 0;
				this._openCloseTween.duration = tweenDuration;
				this._openCloseTween.startTime = Date.now();
				this._openCloseTween.easingFunction = this.getStyle("OpenCloseTweenEasingFunction");
				
				this.addEventListener("enterframe", this._onDropDownEnterFrameInstance);
			}
		}
	};

	
/////////////Internal///////////////////////////////	
	
/**
 * @function _removeDataListPopup
 * Removes the pop up list and cleans up event listeners.
 */	
DropdownElement.prototype._removeDataListPopup = 
	function ()
	{
		if (this._dataListPopupClipContainer._parent == null)
			return;
	
		this._dataListPopupClipContainer._manager.removeCaptureListener("wheel", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.removeCaptureListener("mousedown", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.removeEventListener("resize", this._onDropdownManagerResizeEventInstance);
		
		this._dataListPopupClipContainer._manager.removeElement(this._dataListPopupClipContainer);
		
		this._dropdownManagerMetrics = null;
		this._openDirection = null;
		this._openHeight = null;
	};

/**
 * @function _addDataListPopup
 * Adds the pop up list and registers event listeners.
 */		
DropdownElement.prototype._addDataListPopup = 
	function ()
	{
		if (this._dataListPopupClipContainer._parent != null)
			return;
		
		var popupHeight = this.getStyle("MaxPopupHeight");
		
		this._dataListPopupClipContainer.setStyle("Width", this._dropdownManagerMetrics._width);
		this._dataListPopupClipContainer.setStyle("Height", popupHeight);
		this._dataListPopupClipContainer.setStyle("X", this._dropdownManagerMetrics._x);
		this._dataListPopupClipContainer.setStyle("Y", this._dropdownManagerMetrics._y + this._dropdownManagerMetrics._height);
		
		this._dataListPopup._setActualPosition(0, 0);
		this._dataListPopup._setActualSize(this._dropdownManagerMetrics._width, popupHeight);
		
		this._manager.addElement(this._dataListPopupClipContainer);
		
		this._dataListPopupClipContainer._manager.addCaptureListener("wheel", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.addCaptureListener("mousedown", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.addEventListener("resize", this._onDropdownManagerResizeEventInstance);
	};
	
//@private	
DropdownElement.prototype._onDropDownEnterFrame = 
	function (event)
	{
		//Tween created, but layoutcomplete has not yet finished. 
		//When we first create the popup list, we need to wait a cycle for the list layout to finish.
		//However, enter frame fires first *before* the list cycle has finished.
		if (this._openCloseTween.endVal == null)
			return;
	
		var value = this._openCloseTween.getValue(Date.now());
		this._updateTweenPosition(value);
		
		if (value == this._openCloseTween.endVal)
		{
			if (value == 0)
				this.close(false);
			else
				this._endOpenCloseTween();
		}
	};
	
//@private
DropdownElement.prototype._endOpenCloseTween = 
	function ()
	{
		if (this._openCloseTween != null)
		{
			this.removeEventListener("enterframe", this._onDropDownEnterFrameInstance);
			this._openCloseTween = null;
		}
	};
	
//@private	
DropdownElement.prototype._updateTweenPosition = 
	function (value)
	{
		this._dataListPopupClipContainer.setStyle("Height", value);
		
		if (this._openDirection == "up")
			this._dataListPopupClipContainer.setStyle("Y", this._dropdownManagerMetrics._y - value);
		else //if (this._openDirection == "down")
			this._dataListPopup._setActualPosition(0, value - this._dataListPopup._height);
	};
	
/**
 * @function _onDropdownManagerCaptureEvent
 * Capture event handler for CanvasManager "wheel" and "mousedown". Used to close 
 * the drop down when events happen outside the Dropdown or pop up list. Only active when pop up list is open.
 * 
 * @param event ElementEvent
 * ElementEvent to process.
 */	
DropdownElement.prototype._onDropdownManagerCaptureEvent = 
	function (event)
	{
		//Check if the dropdown list is in this target's parent chain.
		var target = event.getTarget();
		while (target != null)
		{
			//Yes, leave the drop down open
			if (target == this._dataListPopup || 
				(event.getType() == "mousedown" && target == this))
				return;
			
			target = target._parent;
		}
		
		//Kill the drop down, event happened outside the popup list.
		this.close(false);
	};
	
/**
 * @function _onDropdownManagerResizeEvent
 * Capture event handler for CanvasManager "resize". Used to close the dropdown.
 * Only active when pop up list is open.
 * 
 * @param event DispatcherEvent
 * DispatcherEvent to process.
 */		
DropdownElement.prototype._onDropdownManagerResizeEvent = 
	function (event)
	{
		this.close(false);
	};

/**
 * @function _onDropdownDataListPopupLayoutComplete
 * Event handler for pop up list "layoutcomplete". 
 * Updates the pop up list height after content size is known and determines
 * if drop down opens up or down depending on available space.
 * 
 * @param event DispatcherEvent
 * DispatcherEvent to process.
 */		
DropdownElement.prototype._onDropdownDataListPopupLayoutComplete =
	function (event)
	{
		var maxHeight = this.getStyle("MaxPopupHeight");
		var height = null;
		
		if (this._dataListPopup.getStyle("ListDirection") == "horizontal")
			height = maxHeight;
		else
		{
			//Get actual Popup list height.
			var contentSize = this._dataListPopup._getContentSize();
			
			if (contentSize < maxHeight)
			{
				if (this._listCollection != null && this._dataListPopup._getNumRenderers() < this._listCollection.getLength())
					height = maxHeight;
				else
					height = contentSize;
			}
			else //contentSize >= maxHeight
				height = maxHeight;
		}
		
		//Determine open up/down and correct if not enough available space.
		var availableBottom = this._manager._height - (this._dropdownManagerMetrics._y + this._dropdownManagerMetrics._height);
		if (availableBottom >= height)
		{
			this._openDirection = "down";
			this._openHeight = height;
		}
		else //if (availableBottom < height)
		{
			var availableTop = this._dropdownManagerMetrics._y;
			if (availableTop >= height)
			{
				this._openDirection = "up";
				this._openHeight = height;
			}
			else //if (availableTop < height)
			{
				if (availableBottom >= availableTop)
				{
					this._openDirection = "down";
					this._openHeight = availableBottom;
				}
				else
				{
					this._openDirection = "up";
					this._openHeight = availableTop;
				}
			}
		}

		//Fix list height
		this._dataListPopup._setActualSize(this._dataListPopup._width, this._openHeight);
		this._dataListPopupClipContainer.setStyle("Height", this._openHeight);
		
		var clipTopOrBottom = this.getStyle("PopupDataListClipTopOrBottom");
		
		if (this._openCloseTween != null)
		{
			if (this._openCloseTween.startVal == 0) //Closing
				this._openCloseTween.endVal = this._openHeight - clipTopOrBottom;
			else //Opening
				this._openCloseTween.startVal = this._openHeight - clipTopOrBottom;
			
			this._onDropDownEnterFrame(null); //Force a tween update.
		}
		else
			this._updateTweenPosition(this._openHeight - clipTopOrBottom);
	};
	
/**
 * @function _onDropdownDataListPopupChanged
 * Event handler for pop up list "changed" event. Updates selected item/index and re-dispatches "changed" event.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to process.
 */	
DropdownElement.prototype._onDropdownDataListPopupChanged = 
	function (elementEvent)
	{
		this.setSelectedIndex(this._dataListPopup.getSelectedIndex());
		this.close(true);
		
		if (this.hasEventListener("changed", null) == true)
			this._dispatchEvent(new ElementEvent("changed", false));
	};

/**
 * @function _onDropdownDataListPopupListItemClicked
 * Event handler for pop up list "listitemclick" event. 
 * 
 * @param elementListItemClickEvent ElementListItemClickEvent
 * ElementListItemClickEvent to process.
 */		
DropdownElement.prototype._onDropdownDataListPopupListItemClicked = 
	function (elementListItemClickEvent)
	{
		//Just proxy the event from the popup list
		if (this.hasEventListener("listitemclick", null) == true)
			this._dispatchEvent(elementListItemClickEvent);
	};
	
/**
 * @function _createDataListPopup
 * Generates and sets up a pop up list element instance per styling.
 * 
 * @returns DataListElement
 * New pop up list instance.
 */	
DropdownElement.prototype._createDataListPopup = 
	function ()
	{
		//TODO: Use PopupDataListClass style.
	
		var dataListPopup = new DataListElement();
		dataListPopup._setStyleDefinitionDefault(this._getDefaultStyle("PopupDataListStyle"));
		dataListPopup._setStyleProxy(new StyleProxy(this, DropdownElement._PopupDataListProxyMap));
		dataListPopup.setStyleDefinitions(this.getStyle("PopupDataListStyle"));
		
		dataListPopup.setListCollection(this._listCollection);
		dataListPopup.setSelectedIndex(this._selectedIndex);
		
		dataListPopup.addEventListener("changed", this._onDropdownDataListPopupChangedInstance);
		dataListPopup.addEventListener("listitemclick", this._onDropdownDataListPopupListItemClickedInstance);
		dataListPopup.addEventListener("layoutcomplete", this._onDropdownDataListPopupLayoutCompleteInstance);
		
		return dataListPopup;
	};
	
//@override	
DropdownElement.prototype._updateText = 
	function ()
	{
		var text = null;
		var labelFunction = this.getStyle("ItemLabelFunction");
		
		if (this._selectedItem == null || labelFunction == null)
			text = this.getStyle("Text");
		else
			text = labelFunction(this._selectedItem);
		
		if (text == null || text == "")
		{
			if (this._labelElement != null)
			{
				this._removeChild(this._labelElement);
				this._labelElement = null;
			}
		}
		else
		{
			if (this._labelElement == null)
			{
				this._labelElement = this._createLabel();
				if (this._labelElement != null)
				{
					this._updateTextColor();
					this._addChild(this._labelElement);
				}
			}
			
			if (this._labelElement != null)
				this._labelElement.setStyle("Text", text);
		}
	};	
	
/**
 * @function _onDropdownListCollectionChanged
 * Event handler for the ListCollection data-providers "collectionchanged" event. 
 * 
 * @param collectionChangedEvent CollectionChangedEvent
 * CollectionChangedEvent to process.
 */	
DropdownElement.prototype._onDropdownListCollectionChanged = 
	function (collectionChangedEvent)
	{
		//Room to optimize here
//		var type = collectionChangedEvent.getKind();
//		var index = collectionChangedEvent.getIndex();
	
		//Fix selected index/item 
		if (this._selectedItem != null)
		{
			this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
			
			if (this._selectedIndex == -1)
				this._selectedItem = null;
		}
		
		this._updateText();
		
		this._sampledTextWidth = null;
		this._invalidateMeasure();
	};	
	
//@Override	
DropdownElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		DropdownElement.base.prototype._onCanvasElementAdded.call(this, addedRemovedEvent);
	
		if (this._listCollection != null && this._listCollection.hasEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance) == false)
			this._listCollection.addEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
	};

//@Override	
DropdownElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		DropdownElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		if (this._listCollection != null && this._listCollection.hasEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance) == true)
			this._listCollection.removeEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
		
		this.close(false);
	};	

//@private	
DropdownElement.prototype._reverseTween = 
	function ()
	{
		var start = this._openCloseTween.startVal;
		var end = this._openCloseTween.endVal;
		var now = Date.now();
		var elapsed = now - this._openCloseTween.startTime;
		
		this._openCloseTween.startVal = end;
		this._openCloseTween.endVal = start;
		this._openCloseTween.startTime = now + elapsed - this._openCloseTween.duration;		
	};
	
//@Override	
DropdownElement.prototype._onButtonClick = 
	function (elementMouseEvent)
	{
		//Just cancels event if we're disabled.
		DropdownElement.base.prototype._onButtonClick.call(this, elementMouseEvent);
		
		if (elementMouseEvent.getIsCanceled() == true)
			return;
		
		if (this._openCloseTween != null)
			this._reverseTween();
		else 
		{
			if (this._openHeight == null)
				this.open(true);
			else
				this.close(true);
		}
	};	
	
/**
 * @function _createArrowButton
 * Generates and sets up the arrow element instance per styling.
 * 
 * @returns DataListElement
 * New arrow element instance.
 */		
DropdownElement.prototype._createArrowButton = 
	function (arrowClass)
	{
		var newIcon = new (arrowClass)();
		newIcon._setStyleDefinitionDefault(this._getDefaultStyle("ArrowButtonStyle"));
		newIcon._setStyleProxy(new StyleProxy(this, DropdownElement._ArrowButtonProxyMap));
		newIcon.setStyleDefinitions(this.getStyle("ArrowButtonStyle"));
		
		return newIcon;
	};
	
//@private	
DropdownElement.prototype._updateArrowButton = 
	function ()
	{
		var arrowClass = this.getStyle("ArrowButtonClass");
		
		if (arrowClass == null)
		{
			if (this._arrowButton != null)
			{
				this._removeChild(this._arrowButton);
				this._arrowButton = null;
			}
		}
		else
		{
			if (this._arrowButton == null)
			{
				this._arrowButton = this._createArrowButton(arrowClass);
				this._addChild(this._arrowButton);
			}
			else if (this._arrowButton.constructor != arrowClass)
			{ //Class changed
				this._removeChild(this._arrowButton);
				this._arrowButton = this._createArrowButton(arrowClass);
				this._addChild(this._arrowButton);
			}
			else
				this._arrowButton.setStyleDefinitions(this.getStyle("ArrowButtonStyle"));
		}
	};
	
//@Override
DropdownElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DropdownElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ItemLabelFunction" in stylesMap)
		{
			this._sampledTextWidth = null;
			this._invalidateMeasure();
			this._updateText();
		}
		
		if ("PopupDataListStyle" in stylesMap && this._dataListPopup != null)
			this._dataListPopup.setStyleDefinitions(this.getStyle("PopupListStyle"));
		
		if ("ArrowButtonClass" in stylesMap || "ArrowButtonStyle" in stylesMap)
			this._updateArrowButton();
		
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap ||
			"TextAlign" in stylesMap ||
			"TextBaseline" in stylesMap || 
			"Text" in stylesMap)
		{
			this._sampledTextWidth = null;
			this._invalidateMeasure();
		}
	};
	
/**
 * @function _sampleTextWidths
 * Measures text width of first 10 ListCollection items for measurement.
 * 
 * @returns Number
 * Largest text width in pixels.
 */	
DropdownElement.prototype._sampleTextWidths = 
	function ()
	{
		var labelFont = this._getFontString();
		
		var text = this.getStyle("Text");
		if (text == null)
			text = "";
		
		var measuredTextWidth = CanvasElement._measureText(text, labelFont);
		
		//Sample the first 10 items.
		var labelFunction = this.getStyle("ItemLabelFunction");
		if (this._listCollection != null && labelFunction != null)
		{
			var textWidth = 0;
			for (var i = 0; i < 10; i++)
			{
				if (i == this._listCollection.getLength())
					break;
				
				textWidth = CanvasElement._measureText(labelFunction(this._listCollection.getItemAt(i)), labelFont);
				
				if (textWidth > measuredTextWidth)
					measuredTextWidth = textWidth;
			}
		}
		
		return measuredTextWidth;
	};
	
//@Override
DropdownElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		if (this._sampledTextWidth == null)
			this._sampledTextWidth = this._sampleTextWidths();
		
		var textHeight = this.getStyle("TextSize") + this.getStyle("TextLinePaddingTop") + this.getStyle("TextLinePaddingBottom");
		
		var measuredSize = {width: this._sampledTextWidth + padWidth, height: textHeight + padHeight};
		measuredSize.width += 20; //Add some extra space
		
		if (this._arrowButton != null)
		{
			var iconWidth = this._arrowButton.getStyle("Width");
			var iconHeight = this._arrowButton.getStyle("Height");
			
			if (iconHeight != null && iconHeight > measuredSize.height)
				measuredSize.height = iconHeight;
			if (iconWidth != null)
				measuredSize.width += iconWidth;
			else
				measuredSize.width += Math.round(measuredSize.height * .85);
		}

		return measuredSize;
	};	
	
//@Override	
DropdownElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DropdownElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._openDirection != null) //dropdown open
		{
			//Update the dropdown metrics
			this._dropdownManagerMetrics = this.getMetrics(this._manager);
			
			//Update the widths of the popup container and list. (Heights handled by tween / list layoutcomplete)
			//This is here so that when the Dropdown is using measured width, and the collection changes,
			//it may change the width of the dropdown button, so we need to make sure we keep the widths in sync.
			this._dataListPopupClipContainer.setStyle("Width", this._dropdownManagerMetrics._width);
			this._dataListPopup._setActualSize(this._dropdownManagerMetrics._width, this._dataListPopup._height);
		}
		
		if (this._arrowButton != null)
		{
			var x = paddingMetrics.getX();
			var y = paddingMetrics.getY();
			var w = paddingMetrics.getWidth();
			var h = paddingMetrics.getHeight();
			
			var iconWidth = this._arrowButton.getStyle("Width");
			var iconHeight = this._arrowButton.getStyle("Height");
			
			if (iconHeight == null)
				iconHeight = this._height;
			if (iconWidth == null)
				iconWidth = this._height * .85;
			
			if (this._width < iconWidth)
			{
				this._arrowButton._setActualSize(0, 0);
				this._labelElement._setActualSize(0, 0);
			}
			else
			{
				if (this._labelElement != null)
				{
					this._labelElement._setActualPosition(x, y);
					this._labelElement._setActualSize(w - iconWidth, h);
				}
					
				this._arrowButton._setActualPosition(this._width - iconWidth, y + (h / 2) - (iconHeight / 2));
				this._arrowButton._setActualSize(iconWidth, iconHeight);
			}
		}
	};


/**
 * @depends ButtonElement.js
 */

//////////////////////////////////////////////////////////////////
/////////////DataGridHeaderItemRenderer////////////////////////////

/**
 * @class DataGridHeaderItemRenderer
 * @inherits ButtonElement
 * 
 * Default DataGrid HeaderItem renderer based on Button. 
 * Adds sort icons.
 * 
 * @constructor DataGridHeaderItemRenderer 
 * Creates new DataGridHeaderItemRenderer instance.
 */
function DataGridHeaderItemRenderer()
{
	DataGridHeaderItemRenderer.base.prototype.constructor.call(this);
	
	this._sortAscIcon = null;
	this._sortDescIcon = null;
	this._currentSortDirection = null;
}

//Inherit from ButtonElement
DataGridHeaderItemRenderer.prototype = Object.create(ButtonElement.prototype);
DataGridHeaderItemRenderer.prototype.constructor = DataGridHeaderItemRenderer;
DataGridHeaderItemRenderer.base = ButtonElement;

//////Style Types//////////////////////
DataGridHeaderItemRenderer._StyleTypes = Object.create(null);

/**
 * @style SortAscIconClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the ascending sort icon. 
 * Defaults to Button. HeaderItemRenderer proxies its SkinState style to the sort icons so
 * the sort icons will change state along with the HeaderItemRenderer.
 */
DataGridHeaderItemRenderer._StyleTypes.SortAscIconClass =			{inheritable:false};		// CanvasElement constructor

/**
 * @style SortAscIconStyle StyleDefinition
 * 
 * The StyleDefinition to apply ascending sort icon element.
 */
DataGridHeaderItemRenderer._StyleTypes.SortAscIconStyle =			{inheritable:false};		// StyleDefinition

/**
 * @style SortDescIconClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the descending sort icon. 
 * Defaults to Button. HeaderItemRenderer proxies its SkinState style to the sort icons so
 * the sort icons will change state along with the HeaderItemRenderer.
 */
DataGridHeaderItemRenderer._StyleTypes.SortDescIconClass =			{inheritable:false};		// CanvasElement constructor

/**
 * @style SortDescIconStyle StyleDefinition
 * 
 * The StyleDefinition to apply descending sort icon element.
 */
DataGridHeaderItemRenderer._StyleTypes.SortDescIconStyle =			{inheritable:false};		// StyleDefinition

/**
 * @style IconGap Number
 * 
 * Distance in pixels between the sort icon and the header label.
 */
DataGridHeaderItemRenderer._StyleTypes.IconGap =					{inheritable:false};		// number

/**
 * @style IconPlacement String
 * 
 * Determines placement of the sort icon. Allowable values are "left" or "right".
 */
DataGridHeaderItemRenderer._StyleTypes.IconPlacement =				{inheritable:false};		// "left" || "right"


/////////Default Styles///////////////

DataGridHeaderItemRenderer.StyleDefault = new StyleDefinition();

//Override disabled styles, make them same as "up" state styles.
DataGridHeaderItemRenderer.StyleDefault.setStyle("DisabledSkinStyle", 		ButtonElement.UpSkinStyleDefault);
DataGridHeaderItemRenderer.StyleDefault.setStyle("DisabledTextColor", 		null);

DataGridHeaderItemRenderer.StyleDefault.setStyle("BorderType", 				"none");		
DataGridHeaderItemRenderer.StyleDefault.setStyle("TextSize", 				12);
DataGridHeaderItemRenderer.StyleDefault.setStyle("TextAlign", 				"left");
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingTop",				3);
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingBottom",			3);
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingLeft",				8);
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingRight",			8);

/////Sort Icon default styles //////

//Ascending Sort Icon
DataGridHeaderItemRenderer.SortAscIconBgShapeDefault = new ArrowShape();
DataGridHeaderItemRenderer.SortAscIconBgShapeDefault.setStyle("Direction", "up");

DataGridHeaderItemRenderer.SortAscIconStyleDefault = new StyleDefinition();
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BorderType", 				"none");
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BackgroundColor", 			"#444444");
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BackgroundShape", 			DataGridHeaderItemRenderer.SortAscIconBgShapeDefault);
//Note that SkinState is proxied to the sort icons, so the sort icons will change state along with the HeaderRenderer (unless you turn mouse back on)
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("MouseEnabled", 			false);

//Wipe out the skin styles provided by button (we're currently just using the base state for all skins).
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("UpSkinStyle", 				null);
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("OverSkinStyle", 			null);
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("DownSkinStyle", 			null);
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("DisabledSkinStyle", 		null);

//Descending Sort Icon
DataGridHeaderItemRenderer.SortDescIconBgShapeDefault = new ArrowShape();
DataGridHeaderItemRenderer.SortDescIconBgShapeDefault.setStyle("Direction", "down");

DataGridHeaderItemRenderer.SortDescIconStyleDefault = new StyleDefinition();
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BorderType", 				"none");
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BackgroundColor", 		"#444444");
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BackgroundShape", 		DataGridHeaderItemRenderer.SortDescIconBgShapeDefault);
//Note that SkinState is proxied to the sort icons, so the sort icons will change state along with the HeaderRenderer (unless you turn mouse back on)
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("MouseEnabled", 			false);

//Wipe out the skin styles provided by button (we're currently just using the base state for all skins).
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("UpSkinStyle", 			null);
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("OverSkinStyle", 			null);
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("DownSkinStyle", 			null);
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("DisabledSkinStyle", 		null);
///////////////////////////////////

DataGridHeaderItemRenderer.StyleDefault.setStyle("SortAscIconClass",					ButtonElement);											// CanvasElement constructor
DataGridHeaderItemRenderer.StyleDefault.setStyle("SortAscIconStyle",					DataGridHeaderItemRenderer.SortAscIconStyleDefault);	// StyleDefinition
DataGridHeaderItemRenderer.StyleDefault.setStyle("SortDescIconClass",					ButtonElement);											// CanvasElement constructor
DataGridHeaderItemRenderer.StyleDefault.setStyle("SortDescIconStyle",					DataGridHeaderItemRenderer.SortDescIconStyleDefault);	// StyleDefinition

DataGridHeaderItemRenderer.StyleDefault.setStyle("IconGap",								3);			// number
DataGridHeaderItemRenderer.StyleDefault.setStyle("IconPlacement",						"right");	// "left" || "right"



//////Proxy////////////////////////////
DataGridHeaderItemRenderer._SortIconProxyMap = Object.create(null);

//Proxy the SkinState this way we can trigger icon skin changes when our skin changes without
//impacting the functionality of a custom icon. We'll also disable mouse on the default style.
DataGridHeaderItemRenderer._SortIconProxyMap.SkinState = 		true;


///////////Internal/////////////////////

/**
 * @function _createSortIcon
 * Generates a sort icon based on the IconClass styles.
 * 
 * @param isDecending boolean
 * True if the icon should be a descending icon, false otherwise.
 * 
 * @returns CanvasElement
 * The resulting sort icon element instance.
 */
DataGridHeaderItemRenderer.prototype._createSortIcon = 
	function (isDecending)
	{
		var iconClass = null;
		var iconDefaultStyle = null;
		var iconStyle = null;
		
		if (isDecending == true)
		{
			iconClass = this.getStyle("SortDescIconClass");
			iconDefaultStyle = this._getDefaultStyle("SortDescIconStyle");
			iconStyle = this.getStyle("SortDescIconStyle");
		}
		else
		{
			iconClass = this.getStyle("SortAscIconClass");
			iconDefaultStyle = this._getDefaultStyle("SortAscIconStyle");
			iconStyle = this.getStyle("SortAscIconStyle");
		}
		
		var newIcon = new (iconClass)();
		newIcon._setStyleDefinitionDefault(iconDefaultStyle);
		newIcon._setStyleProxy(new StyleProxy(this,DataGridHeaderItemRenderer._SortIconProxyMap));
		newIcon.setStyleDefinitions(iconStyle);
		
		return newIcon;
	};

/**
 * @function _updateSortIcons
 * Updates sort icons in response to style and list data changes.
 */
DataGridHeaderItemRenderer.prototype._updateSortIcons = 
	function ()
	{
		if (this._listData == null)
			return;
	
		var listData = this._listData;
		var dataCollection = listData._parentGrid._listCollection;
		
		var sortDirection = null;
		
		if (dataCollection != null && 
			dataCollection._collectionSort != null && 
			dataCollection._collectionSort == listData._parentGrid._gridColumns[listData._columnIndex].getStyle("CollectionSort"))
		{
			if (dataCollection._collectionSort._isDecending == true)
				sortDirection = "down";
			else
				sortDirection = "up";
		}

		if (this._currentSortDirection != sortDirection)
		{
			this._currentSortDirection = sortDirection;
			this._invalidateLayout();
		}
		
		if (sortDirection == null)
		{
			if (this._sortAscIcon != null)
				this._sortAscIcon.setStyle("Visible", false);
			if (this._sortDescIcon != null)
				this._sortDescIcon.setStyle("Visible", false);
		}
		else if (sortDirection == "up")
		{
			var upIconClass = this.getStyle("SortAscIconClass");
			
			if (upIconClass == null)
			{
				if (this._sortAscIcon != null)
				{
					this._removeChild(this._sortAscIcon);
					this._sortAscIcon = null;
				}
			}
			else
			{
				if (this._sortAscIcon == null)
				{
					this._sortAscIcon = this._createSortIcon(false);
					this._addChild(this._sortAscIcon);
				}
				else if (this._sortAscIcon.constructor != upIconClass)
				{ //Icon Class changed
					this._removeChild(this._sortAscIcon);
					this._sortAscIcon = this._createSortIcon(false);
					this._addChild(this._sortAscIcon);
				}
				else
					this._sortAscIcon.setStyleDefinitions(this.getStyle("SortAscIconStyle"));
				
				if (this._sortDescIcon != null)
					this._sortDescIcon.setStyle("Visible", false);
				
				this._sortAscIcon.setStyle("Visible", true);
			}
		}
		else if (sortDirection == "down")
		{
			var downIconClass = this.getStyle("SortDescIconClass");
			
			if (downIconClass == null)
			{
				if (this._sortDescIcon != null)
				{
					this._removeChild(this._sortDescIcon);
					this._sortDescIcon = null;
				}
			}
			else
			{
				if (this._sortDescIcon == null)
				{
					this._sortDescIcon = this._createSortIcon(true);
					this._addChild(this._sortDescIcon);
				}
				else if (this._sortDescIcon.constructor != downIconClass)
				{ //Icon Class changed
					this._removeChild(this._sortDescIcon);
					this._sortDescIcon = this._createSortIcon(true);
					this._addChild(this._sortDescIcon);
				}
				else
					this._sortDescIcon.setStyleDefinitions(this.getStyle("SortDescIconStyle"));
				
				if (this._sortAscIcon != null)
					this._sortAscIcon.setStyle("Visible", false);
				
				this._sortDescIcon.setStyle("Visible", true);
			}
		}
	};

//@Override
DataGridHeaderItemRenderer.prototype._setListData = 
	function (listData, itemData)
	{
		DataGridHeaderItemRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		if (listData == null)
			return;
		
		this.setStyle("Text", listData._parentGrid._gridColumns[listData._columnIndex].getStyle("HeaderLabel"));
		this._updateSortIcons();
	};

//@Override
DataGridHeaderItemRenderer.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridHeaderItemRenderer.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SortAscIconClass" in stylesMap ||
			"SortAscIconStyle" in stylesMap ||
			"SortDescIconClass" in stylesMap ||
			"SortDescIconStyle" in stylesMap)
		{
			this._updateSortIcons();
		}
		
		if ("IconGap" in stylesMap || "IconPlacement" in stylesMap)
			this._invalidateLayout();
	};	
	
//@Override	
DataGridHeaderItemRenderer.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataGridHeaderItemRenderer.base.prototype._doLayout.call(this, paddingMetrics);
	
		//Fix label position to leave room for sort indicator.
		if (this._labelElement != null && this._currentSortDirection != null)
		{
			var sortIcon = null;
			if (this._currentSortDirection == "up")
				sortIcon = this._sortAscIcon;
			else
				sortIcon = this._sortDescIcon;
			
			if (sortIcon != null)
			{
				var x = paddingMetrics.getX();
				var y = paddingMetrics.getY();
				var w = paddingMetrics.getWidth();
				var h = paddingMetrics.getHeight();
				
				var iconWidth = sortIcon.getStyle("Width");
				var iconHeight = sortIcon.getStyle("Height");
				
				if (iconHeight == null)
					iconHeight = paddingMetrics.getHeight() * .35;
				if (iconWidth == null)
					iconWidth = iconHeight * 1.5;
				
				if (w < iconWidth)
				{
					sortIcon._setActualSize(0, 0);
					this._labelElement._setActualSize(0, 0);
				}
				else
				{
					var gap = this.getStyle("IconGap");
					var iconPlacement = this.getStyle("IconPlacement");
					
					if (iconPlacement == "left")
					{
						this._labelElement._setActualPosition(x + iconWidth + gap, y);
						this._labelElement._setActualSize(w - iconWidth - gap, h);
						
						sortIcon._setActualPosition(x, y + (h / 2) - (iconHeight / 2));
						sortIcon._setActualSize(iconWidth, iconHeight);
					}
					else // "right"
					{
						this._labelElement._setActualPosition(x, y);
						this._labelElement._setActualSize(w - iconWidth - gap, h);
						
						sortIcon._setActualPosition(x + w - iconWidth, y + (h / 2) - (iconHeight / 2));
						sortIcon._setActualSize(iconWidth, iconHeight);
					}
				}
			}
		}
	};	


/**
 * @depends DataGridDataRenderer.js
 * @depends DataGridHeaderColumnDividerSkinElement.js
 * @depends ButtonElement.js
 */

//////////////////////////////////////////////////////////////////
/////////////DataGridHeaderElement////////////////////////////////

/**
 * @class DataGridHeaderElement
 * @inherits DataGridDataRenderer
 * 
 * Default DataGrid header element. 
 * Renders header items per parent grid's columns. 
 * Adds drag-able column dividers and updates parent grid's column widths.
 * 
 * 
 * @constructor DataGridHeaderElement 
 * Creates new DataGridHeaderElement instance.
 */
function DataGridHeaderElement()
{
	DataGridHeaderElement.base.prototype.constructor.call(this);
	
	var _self = this;
	
	this._onColumnDividerDragInstance = 
		function (elementEvent)
		{
			_self._onColumnDividerDrag(elementEvent);
		};
}
	
//Inherit from DataGridDataRenderer
DataGridHeaderElement.prototype = Object.create(DataGridDataRenderer.prototype);
DataGridHeaderElement.prototype.constructor = DataGridHeaderElement;
DataGridHeaderElement.base = DataGridDataRenderer;	

/////////////Style Types/////////////////////////

DataGridHeaderElement._StyleTypes = Object.create(null);

/**
 * @style ColumnDividerClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the draggable column divider (defaults to Button). 
 */
DataGridHeaderElement._StyleTypes.ColumnDividerClass = 		{inheritable:false}; 	// Element constructor()

/**
 * @style ColumnDividerStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the column divider element.
 * See default skin class is DataGridHeaderColumnDividerSkinElement for additional styles.
 * 
 * @seealso DataGridHeaderColumnDividerSkinElement
 */
DataGridHeaderElement._StyleTypes.ColumnDividerStyle = 		{inheritable:false}; 	// StyleDefinition

/**
 * @style DraggableColumns boolean
 * 
 * When true, column dividers are draggable.
 */
DataGridHeaderElement._StyleTypes.DraggableColumns = 		{inheritable:false}; 	// StyleDefinition


////////////Default Styles////////////////////

DataGridHeaderElement.StyleDefault = new StyleDefinition();

DataGridHeaderElement.StyleDefault.setStyle("BorderType", 				"solid");
DataGridHeaderElement.StyleDefault.setStyle("BorderThickness", 			1);
DataGridHeaderElement.StyleDefault.setStyle("PaddingBottom", 			1);

//Column Divider button style
DataGridHeaderElement.ColumnDividerStyleDefault = new StyleDefinition();

DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("SkinClass", 				DataGridHeaderColumnDividerSkinElement); //
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("DividerLineColor", 		"#777777");
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("DividerArrowColor", 		"#444444");
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("BorderType", 				"none");
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("BackgroundColor", 		null);
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("Width", 					11);
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("TabStop", 				-1);


DataGridHeaderElement.StyleDefault.setStyle("ColumnDividerClass", 			ButtonElement);
DataGridHeaderElement.StyleDefault.setStyle("ColumnDividerStyle", 			DataGridHeaderElement.ColumnDividerStyleDefault); 
DataGridHeaderElement.StyleDefault.setStyle("DraggableColumns", 			true);



////////Internal////////////////////////////////

/**
 * @function _onColumnDividerDrag
 * Event handler for column divider "dragging" event. Updates the header item renderers and 
 * parent grid column widths.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */	
DataGridHeaderElement.prototype._onColumnDividerDrag = 
	function (elementEvent)
	{
		if (this._listData == null)
			return;
		
		var parentGrid = this._listData._parentList;
		var dividerRenderer = null;
		var expectedPosition = 0;
		var totalSize = 0;
		var totalPercent = 0;
		var i;
		
		//Record column data
		var columnData = []; 
		for (i = 0; i < parentGrid._gridColumns.length; i++)
		{
			columnData.push(
				{actualSize:parentGrid._columnSizes[i], 
				percentSize:parentGrid._columnPercents[i],
				oldPercentSize:parentGrid._columnPercents[i],
				minSize:parentGrid._gridColumns[i].getStyle("MinSize"),
				minPercent:0});
			
			totalSize += columnData[i].actualSize;
			totalPercent += columnData[i].percentSize;
		}
		
		//Min percent per column based on its min pixel size.
		for (i = 0; i < columnData.length; i++)
			columnData[i].minPercent = columnData[i].minSize / totalSize * totalPercent;
		
		//Calculate new column widths
		var currentColumn = 0;
		for (i = columnData.length; i < this._itemRenderersContainer._children.length; i++)
		{
			dividerRenderer = this._itemRenderersContainer._children[i];
			currentColumn = i - columnData.length;
			
			expectedPosition += columnData[currentColumn].actualSize;
			
			if (dividerRenderer == elementEvent.getCurrentTarget())
			{
				//Columns left of the divider we adjust by pixel and re-calculate their approximate percents.
				//Columns right of the divider we re-calculate their percents, and then determine the pixel size.
				
				expectedPosition = Math.round(expectedPosition - (dividerRenderer._width / 2)); //Round here
				
				var minPosition = expectedPosition;
				var maxPosition = expectedPosition;
				
				//Record "right" side column data, determine maximum slide position.
				var remainingPercent = 0;
				var remainingSize = 0;
				var remainingColumns = [];
				for (var i2 = currentColumn + 1; i2 < columnData.length; i2++)
				{
					remainingColumns.push(columnData[i2]);
					remainingPercent += columnData[i2].percentSize;
					remainingSize += columnData[i2].actualSize;
					maxPosition += columnData[i2].actualSize - columnData[currentColumn].minSize;
				}
				
				//Minimum slide position.
				for (var i2 = currentColumn; i2 >= 0; i2--)
					minPosition -= (columnData[i2].actualSize - columnData[i2].minSize);

				//Correct if we're outside of min/max
				var actualPosition = dividerRenderer._x;
				if (actualPosition < minPosition)
					actualPosition = minPosition;
				if (actualPosition > maxPosition)
					actualPosition = maxPosition;
				
				//Adjust left side columns
				var percentDelta = 0;
				var availableDelta = actualPosition - expectedPosition;
				remainingSize -= availableDelta;
				
				for (var i2 = currentColumn; i2 >= 0; i2--)
				{
					//Adjust size
					if (columnData[i2].actualSize + availableDelta < columnData[i2].minSize)
					{
						availableDelta -= columnData[i2].actualSize - columnData[i2].minSize;
						columnData[i2].actualSize = columnData[i2].minSize;
					}
					else
					{
						columnData[i2].actualSize += availableDelta;
						availableDelta = 0;
					}
					
					//Calculate column's new percent
					columnData[i2].percentSize = columnData[i2].actualSize / totalSize * totalPercent;
					
					//Add up the percent delta to distribute to "right" side columns.
					percentDelta += columnData[i2].percentSize - columnData[i2].oldPercentSize;
					
					if (availableDelta == 0)
						break;
				}
				
				//Calculate new percentages for remaining columns.
				var percentColumns = remainingColumns.slice();		
				var done = false;
				while (done == false)
				{
					done = true;
					for (var i2 = 0; i2 < percentColumns.length; i2++)
					{
						//Break the percent delta up by ratio.
						var delta = percentDelta * (percentColumns[i2].oldPercentSize / remainingPercent);
						
						//We hit minimum percent, use the minimum, remove it from the calculation and restart.
						if (percentColumns[i2].oldPercentSize - delta < percentColumns[i2].minPercent)
						{
							percentColumns[i2].percentSize = percentColumns[i2].minPercent;
							remainingPercent -= percentColumns[i2].minPercent;
							percentDelta -= (percentColumns[i2].oldPercentSize - percentColumns[i2].percentSize);
							
							percentColumns.splice(i2, 1);
							
							done = false;
							break;
						}
						else
							percentColumns[i2].percentSize = percentColumns[i2].oldPercentSize - delta;
					}
				}
	
				//Translate remaining column percents to actual widths.
				CanvasElement._calculateMinMaxPercentSizes(remainingColumns, remainingSize);
				
				break;
			}
		}
		
		//Update Grids column data.
		for (i = 0; i < columnData.length; i++)
		{
			parentGrid._columnSizes[i] = columnData[i].actualSize;
			parentGrid._columnPercents[i] = columnData[i].percentSize;
		}
		
		this._invalidateLayout();
		parentGrid._invalidateLayout(); //For gridlines
		parentGrid._invalidateListRenderersLayout(); //Adjust columns
	};

//@Override
DataGridHeaderElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridHeaderElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ColumnDividerClass" in stylesMap || "ColumnDividerStyle" in stylesMap)
			this._setListData(this._listData, this._itemData);
		
		if ("DraggableColumns" in stylesMap && this._listData != null)
		{
			var parentGrid = this._listData._parentList;
			var draggableColumns = this.getStyle("DraggableColumns");
			var dividerRenderer = null;
			var hasListener = null;
			
			for (var i = parentGrid._gridColumns.length; i < this._itemRenderersContainer._children.length; i++)
			{
				dividerRenderer = this._itemRenderersContainer._children[i];
				dividerRenderer.setStyle("Draggable", draggableColumns);
				
				hasListener = dividerRenderer.hasEventListener("dragging", this._onColumnDividerDragInstance);
				
				if (draggableColumns == true && hasListener == false)
					dividerRenderer.addEventListener("dragging", this._onColumnDividerDragInstance);
				else if (draggableColumns == false && hasListener == true)
					dividerRenderer.removeEventListener("dragging", this._onColumnDividerDragInstance);
				
				if (draggableColumns == true)
					dividerRenderer.setStyle("Enabled", true);
				else
					dividerRenderer.setStyle("Enabled", false);
			}
		}
	};
	
//@Override
DataGridHeaderElement.prototype._setListData = 
	function (listData, itemData)
	{
		// Call base.base
		DataGridDataRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		if (listData == null)
			return;
		
		var i = 0;
		var renderer = null;
		for (i = 0; i < listData._parentList._gridColumns.length; i++)
		{
			renderer = this._itemRenderersContainer._getChildAt(i);
			
			if (renderer == null)
			{
				renderer = listData._parentList._createHeaderItemRenderer(i);
				this._itemRenderersContainer._addChildAt(renderer, i);
			}
			else
			{
				columnDef = listData._parentList._gridColumns[i];
				
				if (renderer.constructor != columnDef.getStyle("HeaderItemClass"))
				{ //Renderer Class changed
					
					this._itemRenderersContainer._removeChildAt(i);
					renderer = listData._parentList._createHeaderItemRenderer(i);
					this._itemRenderersContainer._addChildAt(renderer, i);
				}
				else
				{ //Update DataGridData
					
					listData._parentList._updateHeaderItemRendererData(renderer, i);
				}
			}
		}
		
		var dividerClass = this.getStyle("ColumnDividerClass");
		var draggableColumns = this.getStyle("DraggableColumns");
		
		var totalElements = listData._parentList._gridColumns.length;
		
		if (dividerClass != null)
			totalElements = (totalElements * 2) - 1;
		
		for (var i2 = i; i2 < totalElements; i2++)
		{
			renderer = this._itemRenderersContainer._getChildAt(i2);
			
			if (renderer != null && renderer.constructor != dividerClass)
			{
				this._itemRenderersContainer._removeChildAt(i2);
				renderer = null;
			}
			
			if (renderer == null)
			{
				renderer = new (dividerClass)();
				renderer._setStyleDefinitionDefault(this._getDefaultStyle("ColumnDividerStyle"));
				renderer.setStyleDefinitions(this.getStyle("ColumnDividerStyle"));
				renderer.setStyle("Draggable", draggableColumns);
				
				if (draggableColumns == true)
					renderer.addEventListener("dragging", this._onColumnDividerDragInstance);
				
				this._itemRenderersContainer._addChildAt(renderer, i2);
			}
			else
				renderer.setStyleDefinitions(this.getStyle("ColumnDividerStyle"));
		}
		
		//Purge excess renderers.
		while (this._itemRenderersContainer._children.length > totalElements)
			this._itemRenderersContainer._removeChildAt(this._itemRenderersContainer._children.length - 1);
		
		//Invalidate, the item renderer container doesnt measure so wont do it for us.
		this._invalidateMeasure();
		this._invalidateLayout();
	};

//@Override	
DataGridHeaderElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataGridHeaderElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._listData == null)
			return;
		
		var parentGrid = this._listData._parentList;
		var dividerRenderer = null;
		var currentPosition = 0;
		var columnSize = 0;
		
		//Size / Position divider lines
		for (var i = parentGrid._columnSizes.length; i < this._itemRenderersContainer._children.length; i++)
		{
			dividerRenderer = this._itemRenderersContainer._children[i];
			columnSize = parentGrid._columnSizes[i - parentGrid._columnSizes.length];
			currentPosition += columnSize;
			
			var dividerHeight = dividerRenderer.getStyle("Height");
			if (dividerHeight == null)
				dividerHeight = Math.round(this._itemRenderersContainer._height * .7);
			
			dividerRenderer._setActualSize(dividerRenderer._getStyledOrMeasuredWidth(), dividerHeight);
			dividerRenderer._setActualPosition(currentPosition - (dividerRenderer._getStyledOrMeasuredWidth() / 2), (this._itemRenderersContainer._height / 2) - (dividerRenderer._height / 2));
		}
	};
	
	
	


/**
 * @depends DataListElement.js
 * @depends DataGridDataRenderer.js
 * @depends DataGridHeaderElement.js
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataGridElement/////////////////////////////////		
	
/**
 * @class DataGridElement
 * @inherits DataListElement
 * 
 * DataGridElement is a data-driven container that renders a header and rows
 * via a supplied ListCollection, DataGridColumnDefinition(s), and Data/Item Renderers.
 * A scroll bar will be added if the collection size exceeds the available area. 
 * DataGridElement only renders visible DataRenderers so collection size does not impact performance
 * and allows the header, rows, header item, and row item classes to be specified and styled if desired.
 * 
 * The default header class is DataGridHeaderElement.
 * The default ListItem DataRenderer (renders a row) is DataGridDataRenderer.
 * 
 * Default header/row ItemRenderers are supplied by the DataGridColumnDefinition and are as follows.
 * The default HeaderItem DataRenderer is DataGridHeaderItemRenderer.
 * The default RowItem DataRenderer DataGridLabelItemRenderer.
 * 
 * 
 * @seealso DataGridHeaderElement
 * @seealso DataGridDataRenderer
 * @seealso DataGridColumnDefinition
 * @seealso DataGridHeaderItemRenderer
 * @seealso DataGridLabelItemRenderer
 * 
 * 
 * @constructor DataGridElement 
 * Creates new DataGridElement instance.
 */
function DataGridElement()
{
	DataGridElement.base.prototype.constructor.call(this);
	
	/**
	 * @member _gridColumns Array
	 * Read Only - Array of DataGridColumnDefinition.
	 */
	this._gridColumns = [];
	
	this._columnSizes = [];
	this._columnPercents = [];	
	
	this._gridHeader = null;
	
	this._gridLineContainer = new CanvasElement();
	this._gridLineContainer.setStyle("MouseEnabled", false);
	this._gridLineContainer.setStyle("ClipContent", true);
	this._addChild(this._gridLineContainer);
	
	var _self = this;
	
	//Private event handler, proxy to prototype.
	this._onDataGridColumnDefinitionChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onDataGridColumnDefinitionChanged(styleChangedEvent);
		};
		
	this._onDataGridRowItemClickInstance = 
		function (elementMouseEvent)
		{
			_self._onDataGridRowItemClick(elementMouseEvent);
		};
		
	this._onDataGridHeaderItemClickInstance = 
		function (elementMouseEvent)
		{
			_self._onDataGridHeaderItemClick(elementMouseEvent);
		};
}

//Inherit from DataListElement
DataGridElement.prototype = Object.create(DataListElement.prototype);
DataGridElement.prototype.constructor = DataGridElement;
DataGridElement.base = DataListElement;

////////////Events////////////////////////////////////////

/**
 * @event listitemclick ElementGridItemClickEvent
 * Dispatched when an ItemRenderer or header is clicked. Includes associated collection item/index.
 */


/////////////Style Types////////////////////////////////////////////

DataGridElement._StyleTypes = Object.create(null);

/**
 * @style HeaderClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataGrid header. Default is DataGridHeaderElement.
 * 
 * @seealso DataGridHeaderElement
 */
DataGridElement._StyleTypes.HeaderClass = 						{inheritable:false};		// Element constructor()

/**
 * @style HeaderStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the header element.
 */
DataGridElement._StyleTypes.HeaderStyle = 						{inheritable:false};		// StyleDefinition

/**
 * @style GridLinesPriority String
 * 
 * Determines which set of grid lines will be rendered first. Allowable values are "vertical" or "horizontal".
 */
DataGridElement._StyleTypes.GridLinesPriority = 				{inheritable:false};		// "vertical" || "horizontal" (Which lines are drawn first / below)

/**
 * @style VerticalGridLinesClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataGrid vertical grid lines. Default is CanvasElement.
 */
DataGridElement._StyleTypes.VerticalGridLinesClass = 			{inheritable:false};		// Element constructor()

/**
 * @style VerticalGridLinesStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the vertical grid line elements.
 */
DataGridElement._StyleTypes.VerticalGridLinesStyle = 			{inheritable:false};		// StyleDefinition

/**
 * @style HorizontalGridLinesClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataGrid horizontal grid lines. Default is null.
 */
DataGridElement._StyleTypes.HorizontalGridLinesClass = 			{inheritable:false};		// Element constructor()

/**
 * @style HorizontalGridLinesStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the horizontal grid line elements.
 */
DataGridElement._StyleTypes.HorizontalGridLinesStyle = 			{inheritable:false};		// StyleDefinition


////////////Default Styles/////////////////////////////////////////

DataGridElement.StyleDefault = new StyleDefinition();

/////GridLines default style //////
DataGridElement.GridLineStyleDefault = new StyleDefinition();
DataGridElement.GridLineStyleDefault.setStyle("Width", 					1);				// number
DataGridElement.GridLineStyleDefault.setStyle("Height", 				1); 			// number
DataGridElement.GridLineStyleDefault.setStyle("BackgroundColor", 		"#BBBBBB");		// "#000000"
///////////////////////////////////

/////ScrollBar default style //////
DataGridElement.ScrollBarStyleDefault = new StyleDefinition();
DataGridElement.ScrollBarStyleDefault.setStyle("Padding", 				-1);			// number
///////////////////////////////////

//Override base class styles
DataGridElement.StyleDefault.setStyle("ListItemClass", 					DataGridDataRenderer); 					// Element constructor()	
DataGridElement.StyleDefault.setStyle("ListItemStyle", 					null); 									// StyleDefinition

DataGridElement.StyleDefault.setStyle("BorderType",		 				"solid"); 	
DataGridElement.StyleDefault.setStyle("BorderThickness",	 			1);
DataGridElement.StyleDefault.setStyle("PaddingTop",	 					1);
DataGridElement.StyleDefault.setStyle("PaddingBottom", 					1);
DataGridElement.StyleDefault.setStyle("PaddingLeft",					1);
DataGridElement.StyleDefault.setStyle("PaddingRight", 					1);
DataGridElement.StyleDefault.setStyle("ScrollBarStyle", 				DataGridElement.ScrollBarStyleDefault);	// StyleDefinition

//DataGrid specific
DataGridElement.StyleDefault.setStyle("HeaderClass", 					DataGridHeaderElement); 				// Element constructor()
DataGridElement.StyleDefault.setStyle("HeaderStyle", 					null); 									// StyleDefinition

DataGridElement.StyleDefault.setStyle("GridLinesPriority", 				"vertical"); 							// "vertical" || "horizontal"

DataGridElement.StyleDefault.setStyle("VerticalGridLinesClass", 		CanvasElement); 						// Element constructor()
DataGridElement.StyleDefault.setStyle("VerticalGridLinesStyle", 		DataGridElement.GridLineStyleDefault); 	// StyleDefinition

DataGridElement.StyleDefault.setStyle("HorizontalGridLinesClass", 		null); 									// Element constructor()
DataGridElement.StyleDefault.setStyle("HorizontalGridLinesStyle", 		DataGridElement.GridLineStyleDefault); 	// StyleDefinition
DataGridElement.StyleDefault.setStyle("TabStop", 						0);


///////////Public//////////////////////////////////

/**
 * @function addColumnDefinition
 * Adds a column definition to be rendered by the DataGrid.
 * 
 * @param columnDefinition DataGridColumnDefinition
 * Column definition to be rendered by the DataGrid.
 */
DataGridElement.prototype.addColumnDefinition = 
	function (columnDefinition)
	{
		return this.addColumnDefinitionAt(columnDefinition, this._gridColumns.length);
	};
	
/**
 * @function addColumnDefinitionAt
 * Adds a column definition to be rendered by the DataGrid at a supplied column index.
 * 
 * @param columnDefinition DataGridColumnDefinition
 * Column definition to be rendered by the DataGrid.
 * 
 * @param index int
 * The index to insert the column definition.
 */	
DataGridElement.prototype.addColumnDefinitionAt = 
	function (columnDefinition, index)
	{
		if (!(columnDefinition instanceof DataGridColumnDefinition))
			throw "Invalid DataGridColumnDefinition";
		
		this._gridColumns.splice(index, 0, columnDefinition);
		this._columnPercents.splice(index, 0, columnDefinition.getStyle("PercentSize"));
		
		if (this._manager != null)
			columnDefinition.addEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
		
		this._columnSizes = []; //Force grid to re-calculate column sizes
		this._columnsChanged();
		
		return columnDefinition;
	};
	
/**
 * @function getColumnDefinitionAt
 * Gets the DataGridColumnDefinition at a supplied column index.
 * 
 * @param index int
 * The index to return the DataGridColumnDefinition.
 * 
 * @returns DataGridColumnDefinition
 * The DataGridColumnDefinition at the supplied index.
 */	
DataGridElement.prototype.getColumnDefinitionAt = 
	function (index)
	{
		if (index < 0 || index >= this._gridColumns.length)
			return null;
	
		return this._gridColumns[index];
	};	
	
/**
 * @function removeColumnDefinition
 * Removes a column definition from the DataGrid.
 * 
 * @param columnDefinition DataGridColumnDefinition
 * Column definition to be removed.
 * 
 * @returns DataGridColumnDefinition
 * The removed column definition.
 */	
DataGridElement.prototype.removeColumnDefinition = 
	function (columnDefinition)
	{
		return this.removeColumnDefinitionAt(this._gridColumns.indexOf(columnDefinition));
	};

/**
 * @function removeColumnDefinitionAt
 * Removes a column definition from the DataGrid.
 * 
 * @param index int
 * Column index of definition to be removed.
 * 
 * @returns DataGridColumnDefinition
 * The removed column definition or null if the index was out of range.
 */		
DataGridElement.prototype.removeColumnDefinitionAt = 
	function (index)
	{
		if (index < 0 || index >= this._gridColumns.length)
			return null;
		
		var removed = this._gridColumns.splice(index, 1)[0]; //Returns array of removed items.
		this._columnPercents.splice(index, 1);
		
		if (this._manager != null)
			removed.removeEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
		
		this._columnSizes = []; //Force grid to re-calculate column sizes
		this._columnsChanged();
		
		return removed;
	};

/**
 * @function getNumColumns
 * Gets the number of column definitions.
 * 
 * @returns int
 * Number of column definitions.
 */		
DataGridElement.prototype.getNumColumns = 
	function ()
	{
		return this._gridColumns.length;
	};
	
	
///////////Internal////////////////////////////////
	
/**
 * @function _onDataGridColumnDefinitionChanged
 * Event handler for DataGridColumnDefinition "stylechanged" event. Updates the DataGrid column.
 * 
 * @param styleChangedEvent StyleChangedEvent
 * The StyleChangedEvent to process.
 */	
DataGridElement.prototype._onDataGridColumnDefinitionChanged = 
	function (styleChangedEvent)
	{
		var styleName = styleChangedEvent.getStyleName();
		
		if (styleName == "PercentSize")
		{
			var columnIndex = this._gridColumns.indexOf(styleChangedEvent.getTarget());
			this._columnPercents[columnIndex] = styleChangedEvent.getNewValue();
			this._columnSizes = []; //Force grid to re-calculate column sizes
			this._invalidateLayout();
		}
		else if (styleName == "MinSize")
		{
			this._columnSizes = []; //Force grid to re-calculate column sizes
			this._invalidateLayout();
		}
		else
			this._columnsChanged();
	};

/**
 * @function _columnsChanged
 * Called in response to columns being added/removed or their styles changed.
 * Updates the DataGrid columns.
 */	
DataGridElement.prototype._columnsChanged = 
	function ()
	{
		//Refresh all the ListData, data hasnt changed, but this
		//also tells the renderer to inspect and adjust the columns.
		if (this._gridHeader != null)
		{
			this._gridHeader._setListData(
				this._gridHeader._listData,
				null);
		}
		
		var renderer = null;
		for (var i = 0; i < this._contentPane._children.length; i++)
		{
			renderer = this._contentPane._children[i];
			
			renderer._setListData(
				renderer._listData,
				renderer._itemData);
		}
		
		this._invalidateLayout();
	};

//Override	
DataGridElement.prototype._onDataListCollectionChanged = 
	function (collectionChangedEvent)
	{
		DataGridElement.base.prototype._onDataListCollectionChanged.call(this, collectionChangedEvent);
		
		//Sort may have happened, update the header's data so it can adjust sort icon.
		if (collectionChangedEvent.getKind() == "reset" && this._gridHeader != null)
		{
			//Data hasnt actually changed.
			this._gridHeader._setListData(
				this._gridHeader._listData,
				null);
		}
	};
	
//@Override	
DataGridElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		DataGridElement.base.prototype._onCanvasElementAdded.call(this, addedRemovedEvent);
	
		for (var i = 0; i < this._gridColumns.length; i++)
			this._gridColumns[i].addEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
	};

//@Override	
DataGridElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		DataGridElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		for (var i = 0; i < this._gridColumns.length; i++)
			this._gridColumns[i].removeEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
	};		
	
//@Override
DataGridElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("HeaderClass" in stylesMap)
		{
			var headerClass = this.getStyle("HeaderClass");
			
			//Destroy if class is null or does not match existing
			if ((headerClass == null && this._gridHeader != null) ||
				this._gridHeader != null && this._gridHeader.constructor != headerClass)
			{
				this._removeChild(this._gridHeader);
				this._gridHeader = null;
			}
			
			//Create
			if (headerClass != null && this._gridHeader == null)
			{
				this._gridHeader = new (headerClass)();
				this._gridHeader._setStyleDefinitionDefault(this._getDefaultStyle("HeaderStyle"));
				
				this._gridHeader._setListData(
					new DataListData(this, -1),
					null);
				
				this._addChild(this._gridHeader);
			}
			
			this._invalidateLayout();
		}
		
		if ("HeaderStyle" in stylesMap && this._gridHeader != null)
			this._gridHeader.setStyleDefinitions(this.getStyle("HeaderStyle"));
		
		if ("GridLinesPriority" in stylesMap ||
			"VerticalGridLinesClass" in stylesMap ||
			"VerticalGridLinesStyle" in stylesMap ||
			"HorizontalGridLinesClass" in stylesMap ||
			"HorizontalGridLinesStyle" in stylesMap)
		{
			this._invalidateLayout();
		}
	};	
	
//@Override		
DataGridElement.prototype._createRenderer = 
	function (itemIndex)
	{
		var newRenderer = new (this.getStyle("ListItemClass"))();
		newRenderer._setStyleDefinitionDefault(this._getDefaultStyle("ListItemStyle"));
		//newRenderer._setStyleProxy(new StyleProxy(this, DataListElement._DataRendererProxyMap));
		newRenderer.setStyleDefinitions(this.getStyle("ListItemStyle"));
		
		this._updateRendererData(newRenderer, itemIndex);
		
		return newRenderer;
	};	

/**
 * @function _createHeaderItemRenderer
 * Generates a header ItemRenderer base on the column definition HeaderItemClass style.
 * 
 * @param columnIndex int
 * Column index associated with the header ItemRenderer.
 * 
 * @returns CanvasElement
 * The new header ItemRenderer instance.
 */		
DataGridElement.prototype._createHeaderItemRenderer = 
	function (columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
		
		var headerItemClass = columnDefinition.getStyle("HeaderItemClass");
		var newRenderer = new (headerItemClass)();
		newRenderer._setStyleDefinitionDefault(columnDefinition._getDefaultStyle("HeaderItemStyle"));
		
		this._updateHeaderItemRendererData(newRenderer, columnIndex);		
		
		newRenderer.addEventListener("click", this._onDataGridHeaderItemClickInstance);
		
		return newRenderer;
	};
	
/**
 * @function _updateHeaderItemRendererData
 * Updates the header ItemRenderer list data.
 * 
 * @param renderer CanvasElement
 * Header ItemRenderer to update.
 * 
 * @param columnIndex int
 * Column index to associate with the header ItemRenderer.
 */		
DataGridElement.prototype._updateHeaderItemRendererData = 
	function (renderer, columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
		
		//Optimize, only create new data if its actually changed.
		var listData = null;
		if (renderer._listData != null && renderer._listData._columnIndex == columnIndex)
			listData = renderer._listData;
		else
			listData = new DataGridItemData(this, -1, columnIndex);
		
		renderer.setStyleDefinitions(columnDefinition.getStyle("HeaderItemStyle"));
		
		renderer._setListData(
			listData,
			null);
	};
	
/**
 * @function _onDataGridHeaderItemClick
 * Event handler for header ItemRenderer "click" event. Sorts the collection if a 
 * CollectionSort is assigned to the DataGridColumDefinition and dispatched "listitemclick" event.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */			
DataGridElement.prototype._onDataGridHeaderItemClick = 
	function (elementMouseEvent)
	{
		var columnIndex = elementMouseEvent.getCurrentTarget()._listData._columnIndex;
		
		var collectionSort = this._gridColumns[columnIndex].getStyle("CollectionSort");
		if (collectionSort != null && collectionSort instanceof CollectionSort)
		{
			if (this._listCollection._collectionSort != collectionSort)
			{
				collectionSort._isDecending = false;
				this._listCollection.setCollectionSort(collectionSort);
				this._listCollection.sort();
			}
			else
			{
				collectionSort._isDecending = !(collectionSort._isDecending);
				this._listCollection.sort();
			}
		}
		
		this._dispatchEvent(new ElementGridItemClickEvent(-1, columnIndex, null));
	};
	
/**
 * @function _createRowItemRenderer
 * Generates a row ItemRenderer base on the column definition RowItemClass style.
 * 
 * @param itemIndex int
 * Collection item index to associate with the row ItemRenderer.
 * 
 * @param columnIndex int
 * Column index to associate with the row ItemRenderer.
 * 
 * @returns CanvasElement
 * The new row ItemRenderer instance.
 */		
DataGridElement.prototype._createRowItemRenderer = 
	function (itemIndex, columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
	
		var rowItemClass = columnDefinition.getStyle("RowItemClass");
		var newRenderer = new (rowItemClass)();
		newRenderer._setStyleDefinitionDefault(columnDefinition._getDefaultStyle("RowItemStyle"));
		
		this._updateRowItemRendererData(newRenderer, itemIndex, columnIndex);		
		
		newRenderer.addEventListener("click", this._onDataGridRowItemClickInstance);
		
		return newRenderer;
	};

/**
 * @function _updateRowItemRendererData
 * Updates the row ItemRenderer list data.
 * 
 * @param renderer CanvasElement
 * Row ItemRenderer to update.
 * 
 * @param itemIndex int
 * Collection item index to associate with the row ItemRenderer.
 * 
 * @param columnIndex int
 * Column index to associate with the row ItemRenderer.
 */		
DataGridElement.prototype._updateRowItemRendererData = 
	function (renderer, itemIndex, columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
		
		//Optimize, only create new data if its actually changed.
		var listData = null;
		if (renderer._listData != null && renderer._listData._columnIndex == columnIndex && renderer._listData._itemIndex == itemIndex)
			listData = renderer._listData;
		else
			listData = new DataGridItemData(this, itemIndex, columnIndex);
		
		renderer.setStyleDefinitions(columnDefinition.getStyle("RowItemStyle"));
	
		renderer._setListData(
			listData,
			this._listCollection.getItemAt(itemIndex));
	};
	
/**
 * @function _onDataGridRowItemClick
 * Event handler for the row ItemRenderer "click" event. Updates selected index/item and dispatches "listitemclick" and "changed" events.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */
DataGridElement.prototype._onDataGridRowItemClick = 
	function (elementMouseEvent)
	{
		var itemIndex = elementMouseEvent.getCurrentTarget()._listData._itemIndex;
		var columnIndex = elementMouseEvent.getCurrentTarget()._listData._columnIndex;
		var itemData = elementMouseEvent.getCurrentTarget()._itemData;
		
		var dispatchChanged = false;
		
		if (this.getStyle("Selectable") == true && this.setSelectedIndex(itemIndex) == true)
			dispatchChanged = true;
		
		this._dispatchEvent(new ElementGridItemClickEvent(itemIndex, columnIndex, itemData));
		
		if (dispatchChanged == true)
			this._dispatchEvent(new ElementEvent("changed", false));
	};
	
//@Override
DataGridElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:16, height:16};
	};
	
/**
 * @function _createGridLine
 * Generates a grid line element based on vertical/horizontal GridLinesClass style.
 * 
 * @param direction String
 * The grid line direction "vertical" or "horizontal"
 * 
 * @returns CanvasElement
 * The new grid line element.
 */		
DataGridElement.prototype._createGridLine = 
	function (direction)
	{
		var line = null;
		if (direction == "vertical")
		{
			line = new (this.getStyle("VerticalGridLinesClass"))();
			line._setStyleDefinitionDefault(this._getDefaultStyle("VerticalGridLinesStyle"));
			line.setStyleDefinitions(this.getStyle("VerticalGridLinesStyle"));
		}
		else
		{
			line = new (this.getStyle("HorizontalGridLinesClass"))();
			line._setStyleDefinitionDefault(this._getDefaultStyle("HorizontalGridLinesStyle"));
			line.setStyleDefinitions(this.getStyle("HorizontalGridLinesStyle"));
		}
		
		return line;
	};
	
//@Override	
DataGridElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		if (this._gridHeader != null)
		{
			var headerHeight = this._gridHeader._getStyledOrMeasuredHeight();
			
			var adjustedPadding = new DrawMetrics();
			adjustedPadding._x = paddingMetrics._x;
			adjustedPadding._y = paddingMetrics._y + headerHeight;
			adjustedPadding._width = paddingMetrics._width;
			adjustedPadding._height = paddingMetrics._height - headerHeight;
			
			//Adjust the padding so base() leaves us room for the header
			DataGridElement.base.prototype._doLayout.call(this, adjustedPadding);
		}
		else
			DataGridElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//Base makes multiple passes, no reason to run below if we're waiting for the DataList to finish anyway.
		if (this._layoutInvalid == true)
			return;
		
		//Size / Position the grid header
		if (this._gridHeader != null)
		{
			this._gridHeader._setActualPosition(this._contentPane._x, paddingMetrics.getY());
			this._gridHeader._setActualSize(paddingMetrics.getWidth(), this._gridHeader._getStyledOrMeasuredHeight());
		}
		
		var i;
		var calculateColumnSizes = false;
		
		//Determine if we need to recalculate column widths (new columns or size change)
		if (this._columnSizes.length != this._gridColumns.length)
			calculateColumnSizes = true;
		else
		{
			var totalSize = 0;
			for (i = 0; i < this._columnSizes.length; i++)
				totalSize += this._columnSizes[i];
			
			if (totalSize != this._contentPane._width)
				calculateColumnSizes = true;
		}
		
		if (calculateColumnSizes == true)
		{
			var columnData = [];
			
			//Record column size info.
			for (i = 0; i < this._gridColumns.length; i++)
			{
				columnData.push(
					{percentSize: this._columnPercents[i], //We dont use column style, its maintained separately. Header can change the percents.
					minSize: this._gridColumns[i].getStyle("MinSize")});
			}
			
			//Calculate actual widths.
			CanvasElement._calculateMinMaxPercentSizes(columnData, this._contentPane._width);
			
			//Update recorded sizes.
			var newColumnSizes = [];
			for (i = 0; i < columnData.length; i++)
				newColumnSizes.push(columnData[i].actualSize);
			
			this._columnSizes = newColumnSizes;
			
			//Invalidate children.
			if (this._gridHeader != null)
				this._gridHeader._invalidateLayout();
			
			this._invalidateListRenderersLayout();
		}
		
		////////Grid Lines//////////////////////////////////////////////////////////////////////////
		this._gridLineContainer._setActualPosition(this._contentPane._x, this._contentPane._y);
		this._gridLineContainer._setActualSize(this._contentPane._width, this._contentPane._height);
		
		var itemIndex = null;
		var lineIndex = 0;
		var gridLine = null;
		var rowRenderer = null;
		var verticalComplete = false;
		var horizontalComplete = false;
		var linePriority = this.getStyle("GridLinesPriority");
		var verticalClass = this.getStyle("VerticalGridLinesClass");
		var verticalStyle = this.getStyle("VerticalGridLinesStyle");
		var horizontalClass = this.getStyle("HorizontalGridLinesClass");
		var horizontalStyle = this.getStyle("HorizontalGridLinesStyle");
		
		while (verticalComplete == false || horizontalComplete == false)
		{
			if ((linePriority == "horizontal" && horizontalComplete == false) || (verticalComplete == true && horizontalComplete == false))
			{
				if (horizontalClass != null)
				{
					for (i = 0; i < this._contentPane._children.length; i++)
					{
						rowRenderer = this._contentPane._children[i];
						itemIndex = rowRenderer._listData._itemIndex;
						if (itemIndex == 0)
							continue;
						
						gridLine = this._gridLineContainer._getChildAt(lineIndex);
						if (gridLine == null)
						{
							gridLine = this._createGridLine("horizontal");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else if (gridLine.constructor != horizontalClass)
						{
							this._gridLineContainer._removeChildAt(lineIndex);
							gridLine = this._createGridLine("horizontal");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else
							gridLine.setStyleDefinitions(horizontalStyle);
						
						gridLine._setActualSize(this._gridLineContainer._width, gridLine.getStyle("Height"));
						gridLine._setActualPosition(0, rowRenderer._y - (gridLine._height / 2));
						
						lineIndex++;
					}
				}
				
				horizontalComplete = true;
			}
			
			if ((linePriority == "vertical" && verticalComplete == false) || (horizontalComplete == true && verticalComplete == false))
			{
				if (verticalClass != null)
				{
					var linePosition = 0;
					for (i = 0; i < this._columnSizes.length - 1; i++)
					{
						linePosition += this._columnSizes[i];
						gridLine = this._gridLineContainer._getChildAt(lineIndex);
						
						if (gridLine == null)
						{
							gridLine = this._createGridLine("vertical");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else if (gridLine.constructor != verticalClass)
						{
							this._gridLineContainer._removeChildAt(lineIndex);
							gridLine = this._createGridLine("vertical");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else
							gridLine.setStyleDefinitions(verticalStyle);
						
						gridLine._setActualSize(gridLine.getStyle("Width"), this._gridLineContainer._height);
						gridLine._setActualPosition(linePosition - (gridLine._width / 2), 0);
						
						lineIndex++;
					}
				}
				
				verticalComplete = true;
			}
		}
		
		//Purge excess line renderers.
		while (lineIndex < this._gridLineContainer._children.length)
			this._gridLineContainer._removeChildAt(this._gridLineContainer._children.length - 1);
	};
	
	




/**
 * @depends StyleableBase.js
 * @depends DataGridHeaderItemRenderer.js
 * @depends DataGridLabelItemRenderer.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////DataGridColumnDefinition////////////////////////////		
	
/**
 * @class DataGridColumnDefinition
 * @inherits StyleableBase
 * 
 * DataGridColumnDefinition defines and stores styles necessary for the DataGrid to render columns.
 * 
 * The default HeaderItemClass is DataGridHeaderItemRenderer.
 * The default RowItemClass is DataGridLabelItemRenderer.
 * 
 * 
 * @seealso DataGridElement
 * @seealso DataGridHeaderItemRenderer
 * @seealso DataGridLabelItemRenderer
 * 
 * @constructor DataGridColumnDefinition 
 * Creates new DataGridColumnDefinition instance.
 */
function DataGridColumnDefinition()
{
	DataGridColumnDefinition.base.prototype.constructor.call(this);
}
	
//Inherit from StyleableBase
DataGridColumnDefinition.prototype = Object.create(StyleableBase.prototype);
DataGridColumnDefinition.prototype.constructor = DataGridColumnDefinition;
DataGridColumnDefinition.base = StyleableBase;

/////////////Style Types///////////////////////////////

DataGridColumnDefinition._StyleTypes = Object.create(null);

/**
 * @style PercentSize Number
 * 
 * The percentage of available space the column should consume. Percentages
 * are allowed to add to more than 100 and will consume all of the available space. 
 */
DataGridColumnDefinition._StyleTypes.PercentSize = 					{inheritable:false};		// number || null

/**
 * @style MinSize Number
 * 
 * Minimum number of pixels the column should consume.
 */
DataGridColumnDefinition._StyleTypes.MinSize = 						{inheritable:false};		// number || null

/**
 * @style HeaderLabel String
 * Text label to be used for the column header.
 */
DataGridColumnDefinition._StyleTypes.HeaderLabel = 					{inheritable:false};		// "string"

/**
 * @style HeaderItemClass CanvasElement
 * 
 * The DataRenderer CanvasElement constructor to be used for the column header. 
 */
DataGridColumnDefinition._StyleTypes.HeaderItemClass = 				{inheritable:false};		// Element constructor()

/**
 * @style HeaderItemStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the HeaderItem DataRenderer.
 */
DataGridColumnDefinition._StyleTypes.HeaderItemStyle = 				{inheritable:false};		// StyleDefinition

/**
 * @style CollectionSort CollectionSort
 * 
 * CollectionSort to be used to sort the column.
 */
DataGridColumnDefinition._StyleTypes.CollectionSort = 				{inheritable:false};		// CollectionSort() 

/**
 * @style RowItemClass CanvasElement
 * 
 * The DataRenderer CanvasElement constructor to be used for this columns rows. 
 */
DataGridColumnDefinition._StyleTypes.RowItemClass = 				{inheritable:false};		// Element constructor()

/**
 * @style RowItemStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the RowItem DataRenderer.
 */
DataGridColumnDefinition._StyleTypes.RowItemStyle = 				{inheritable:false};		// StyleDefinition

/**
 * @style RowItemLabelFunction Function
 * 
 * A function that returns a text string per a supplied collection item and columnIndex. 
 * function (itemData, columnIndex) { return "" }
 */
DataGridColumnDefinition._StyleTypes.RowItemLabelFunction = 		{inheritable:false};		// function (data, columnIndex) { return "" }


/////////Default Styles///////////////////////////////

DataGridColumnDefinition.StyleDefault = new StyleDefinition();

DataGridColumnDefinition.StyleDefault.setStyle("PercentSize", 				100);							// number || null
DataGridColumnDefinition.StyleDefault.setStyle("MinSize", 					12);							// number || null

DataGridColumnDefinition.StyleDefault.setStyle("HeaderLabel", 				"");							// "string"
DataGridColumnDefinition.StyleDefault.setStyle("HeaderItemClass", 			DataGridHeaderItemRenderer);	// Element constructor()
DataGridColumnDefinition.StyleDefault.setStyle("HeaderItemStyle", 			null);							// StyleDefinition
DataGridColumnDefinition.StyleDefault.setStyle("CollectionSort", 			null);							// CollectionSort()

DataGridColumnDefinition.StyleDefault.setStyle("RowItemClass", 				DataGridLabelItemRenderer);		// Element constructor()
DataGridColumnDefinition.StyleDefault.setStyle("RowItemStyle", 				null);							// StyleDefinition
DataGridColumnDefinition.StyleDefault.setStyle("RowItemLabelFunction", 		null);							// function (data, columnIndex) { return "" }




/**
 * @depends RadioButtonElement.js
 * @depends CheckboxSkinElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////CheckboxElement/////////////////////////////////

/**
 * @class CheckboxElement
 * @inherits RadioButtonElement
 * 
 * Checkbox adds "halfSelected" versions of the 4 button states and assigns a default skin. 
 * The HalfSelected state may only be set programmatically. 
 * 
 * Checkbox half selected states:
 * "halfSelectedUp", "halfSelectedOver", "halfSelectedDown", "halfSelectedDisabled".
 * 
 * Being a SkinnableElement, Checkbox proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the Checkbox itself. 
 * 
 * See the default skin CheckBoxSkin for additional skin styles.
 * 
 * @seealso CheckboxSkinElement
 * 
 * 
 * @constructor CheckboxElement 
 * Creates new CheckboxElement instance.
 */
function CheckboxElement()
{
	CheckboxElement.base.prototype.constructor.call(this);
}

//Inherit from ToggleButtonElement
CheckboxElement.prototype = Object.create(RadioButtonElement.prototype);
CheckboxElement.prototype.constructor = CheckboxElement;
CheckboxElement.base = RadioButtonElement;	
	
/////////////Style Types///////////////////////////////

CheckboxElement._StyleTypes = Object.create(null);

//New checkbox specific styles, add half selected state.

/**
 * @style HalfSelectedUpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedUp" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedUpSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedUpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedUp" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedUpSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedUpTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedUp" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedUpTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style HalfSelectedOverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedOver" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedOverSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedOverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedOver" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedOverSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedOverTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedOver" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedOverTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style HalfSelectedDownSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedDown" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedDownSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedDownSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedDown" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedDownSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedDownTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedDown" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedDownTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style HalfSelectedDisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedDisabled" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedDisabledSkinClass = 	{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedDisabledSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedDisabled" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedDisabledSkinStyle = 	{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedDisabledTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedDisabled" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedDisabledTextColor = 	{inheritable:false};		//"#000000"	


////////////Default Styles//////////////////////

CheckboxElement.StyleDefault = new StyleDefinition();

CheckboxElement.StyleDefault.setStyle("AllowDeselect", 							true);

CheckboxElement.StyleDefault.setStyle("SkinClass", 								CheckboxSkinElement); //Not necessary, just for completeness

CheckboxElement.StyleDefault.setStyle("UpSkinClass", 							CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("OverSkinClass", 							CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("DownSkinClass", 							CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("DisabledSkinClass", 						CheckboxSkinElement);

CheckboxElement.StyleDefault.setStyle("SelectedUpSkinClass", 					CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("SelectedOverSkinClass", 					CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("SelectedDownSkinClass", 					CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("SelectedDisabledSkinClass", 				CheckboxSkinElement);

CheckboxElement.StyleDefault.setStyle("HalfSelectedUpSkinClass", 				CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("HalfSelectedOverSkinClass", 				CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDownSkinClass", 				CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledSkinClass", 			CheckboxSkinElement);

CheckboxElement.StyleDefault.setStyle("HalfSelectedUpTextColor", 				"#000000");
CheckboxElement.StyleDefault.setStyle("HalfSelectedOverTextColor", 				"#000000");
CheckboxElement.StyleDefault.setStyle("HalfSelectedDownTextColor", 				"#000000");
CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledTextColor", 			"#888888");


//Skin Defaults
CheckboxElement.UpSkinStyleDefault = new StyleDefinition();

CheckboxElement.UpSkinStyleDefault.setStyle("BorderType", 						"solid");
CheckboxElement.UpSkinStyleDefault.setStyle("BorderThickness", 					1);
CheckboxElement.UpSkinStyleDefault.setStyle("BorderColor", 						"#333333");
CheckboxElement.UpSkinStyleDefault.setStyle("BackgroundColor", 					"#EBEBEB");
CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientStart", 				(+.05));
CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));
CheckboxElement.UpSkinStyleDefault.setStyle("CheckColor", 						"#000000");

CheckboxElement.OverSkinStyleDefault = new StyleDefinition();

CheckboxElement.OverSkinStyleDefault.setStyle("BorderType", 					"solid");
CheckboxElement.OverSkinStyleDefault.setStyle("BorderThickness", 				1);
CheckboxElement.OverSkinStyleDefault.setStyle("BorderColor", 					"#333333");
CheckboxElement.OverSkinStyleDefault.setStyle("BackgroundColor", 				"#DDDDDD");
CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 				(+.05));
CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));
CheckboxElement.OverSkinStyleDefault.setStyle("CheckColor", 					"#000000");

CheckboxElement.DownSkinStyleDefault = new StyleDefinition();

CheckboxElement.DownSkinStyleDefault.setStyle("BorderType", 					"solid");
CheckboxElement.DownSkinStyleDefault.setStyle("BorderThickness", 				1);
CheckboxElement.DownSkinStyleDefault.setStyle("BorderColor", 					"#333333");
CheckboxElement.DownSkinStyleDefault.setStyle("BackgroundColor", 				"#CCCCCC");
CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientStart", 				(-.06));
CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientStop", 				(+.02));
CheckboxElement.DownSkinStyleDefault.setStyle("CheckColor", 					"#000000");

CheckboxElement.DisabledSkinStyleDefault = new StyleDefinition();

CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderType", 				"solid");
CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 			1);
CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderColor", 				"#999999");
CheckboxElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 			"#ECECEC");
CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 			(-.05));
CheckboxElement.DisabledSkinStyleDefault.setStyle("CheckColor", 				"#777777");


//Apply Skin Defaults
CheckboxElement.StyleDefault.setStyle("UpSkinStyle", 							CheckboxElement.UpSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("OverSkinStyle", 							CheckboxElement.OverSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("DownSkinStyle", 							CheckboxElement.DownSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("DisabledSkinStyle", 						CheckboxElement.DisabledSkinStyleDefault);

CheckboxElement.StyleDefault.setStyle("SelectedUpSkinStyle", 					CheckboxElement.UpSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("SelectedOverSkinStyle", 					CheckboxElement.OverSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("SelectedDownSkinStyle", 					CheckboxElement.DownSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("SelectedDisabledSkinStyle", 				CheckboxElement.DisabledSkinStyleDefault);

CheckboxElement.StyleDefault.setStyle("HalfSelectedUpSkinStyle", 				CheckboxElement.UpSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("HalfSelectedOverSkinStyle", 				CheckboxElement.OverSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDownSkinStyle", 				CheckboxElement.DownSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledSkinStyle", 			CheckboxElement.DisabledSkinStyleDefault);

/////////////Public Functions////////////////////////////////////////

/**
 * @function setSelected
 * @override
 * Sets the selected state of the Checkbox.
 * 
 * @param isSelected boolean
 * Checkbox adds a half selected state by setting isSelected = 2.
 * 0 (or false) is unchecked, 1 (or true) is checked, and 2 is half checked.
 */	
CheckboxElement.prototype.setSelected = 
	function (isSelected)
	{
		CheckboxElement.base.prototype.setSelected.call(this, isSelected);
	};


/////////////Internal Functions/////////////////////	

//@override
CheckboxElement.prototype._updateState = 
	function ()
	{
		if (this.getStyle("Selected") == 2)
		{
			var newState = "halfSelectedUp";
			
			if (this.getStyle("Enabled") == false)
				newState = "halfSelectedDisabled";
			else
			{
				if (this._mouseIsDown == true)
					newState = "halfSelectedDown";
				else if (this._mouseIsOver == true)
					newState = "halfSelectedOver";
			}
			
			this.setStyle("SkinState", newState);
		}
		else
		{
			//Call base if we're not selected, handles non-selected states.
			CheckboxElement.base.prototype._updateState.call(this);
		}
	};

//@override
CheckboxElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
		
		if (state == "halfSelectedUp")
			stateSkinClass = this.getStyleData("HalfSelectedUpSkinClass");
		else if (state == "halfSelectedOver")
			stateSkinClass = this.getStyleData("HalfSelectedOverSkinClass");
		else if (state == "halfSelectedDown")
			stateSkinClass = this.getStyleData("HalfSelectedDownSkinClass");
		else if (state == "halfSelectedDisabled")
			stateSkinClass = this.getStyleData("HalfSelectedDisabledSkinClass");
		else //base class state
			return CheckboxElement.base.prototype._getSkinClass.call(this, state);
		
		var skinClass = this.getStyleData("SkinClass");
		
		if (skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
	
//@override	
CheckboxElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "halfSelectedUp")
			return this.getStyle("HalfSelectedUpSkinStyle");
		else if (state == "halfSelectedOver")
			return this.getStyle("HalfSelectedOverSkinStyle");
		else if (state == "halfSelectedDown")
			return this.getStyle("HalfSelectedDownSkinStyle");
		else if (state == "halfSelectedDisabled")
			return this.getStyle("HalfSelectedDisabledSkinStyle");
		
		return CheckboxElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};

//@override
CheckboxElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "halfSelectedUp")
			return this._getDefaultStyle("HalfSelectedUpSkinStyle");
		else if (state == "halfSelectedOver")
			return this._getDefaultStyle("HalfSelectedOverSkinStyle");
		else if (state == "halfSelectedDown")
			return this._getDefaultStyle("HalfSelectedDownSkinStyle");
		else if (state == "halfSelectedDisabled")
			return this._getDefaultStyle("HalfSelectedDisabledSkinStyle");
		
		return CheckboxElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};	
	
//@override
CheckboxElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "halfSelectedUp")
			stateTextColor = this.getStyleData("HalfSelectedUpTextColor");
		else if (state == "halfSelectedOver")
			stateTextColor = this.getStyleData("HalfSelectedOverTextColor");
		else if (state == "halfSelectedDown")
			stateTextColor = this.getStyleData("HalfSelectedDownTextColor");
		else if (state == "halfSelectedDisabled")
			stateTextColor = this.getStyleData("HalfSelectedDisabledTextColor");
		else //base class state
			return CheckboxElement.base.prototype._getTextColor.call(this, state);
	
		var textColor = this.getStyleData("TextColor");
		
		if (textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

//@override
CheckboxElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		CheckboxElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		//Always update these, they don't do anything if no changes, and
		//this already maps our current state to our skin class.
		this._updateSkinClass("halfSelectedUp");
		this._updateSkinStyleDefinitions("halfSelectedUp");
		
		this._updateSkinClass("halfSelectedOver");
		this._updateSkinStyleDefinitions("halfSelectedOver");
		
		this._updateSkinClass("halfSelectedDown");
		this._updateSkinStyleDefinitions("halfSelectedDown");
		
		this._updateSkinClass("HalfSelectedDisabled");
		this._updateSkinStyleDefinitions("halfSelectedDisabled");
	};	
	
	


/**
 * @depends ContainerBaseElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////AnchorContainerElement//////////////////////////////

/**
 * @class AnchorContainerElement
 * @inherits ContainerBaseElement
 * 
 * The AnchorContainer can be used to lay out children via absolute or constraint positioning.
 * This container uses children's styles X, Y, Width, Height, PercentWidth, PercentHeight,
 * Top, Bottom, Left, Right, Horizontal Center, and Vertical Center. Nesting containers
 * is the best way to quickly and simply build complex layouts.
 * 
 * X, Y, Width, and Height are treated as highest priority and will override other styles.
 * Elements Z index is determined by the order they are added (child index).
 * You may use styles such as Top and Bottom in conjunction to relatively size elements.
 * You may also combine styles such as Left or X and PercentWidth. Most styles are combine-able unless
 * they are in direct conflict with each other such as having a Left, Right, and Width which under
 * this scenario the Right style will be ignored. Exact behavior of conflicting styles is not defined 
 * and subject to change. 
 * 
 * See the associated style documentation for additional details.
 * 
 * @constructor AnchorContainerElement 
 * Creates new AnchorContainerElement instance.
 */
function AnchorContainerElement()
{
	AnchorContainerElement.base.prototype.constructor.call(this);
}

//Inherit from ContainerBaseElement
AnchorContainerElement.prototype = Object.create(ContainerBaseElement.prototype);
AnchorContainerElement.prototype.constructor = AnchorContainerElement;
AnchorContainerElement.base = ContainerBaseElement;	
	
//@Override
AnchorContainerElement.prototype._doMeasure = 
	function (padWidth, padHeight)
	{
		var contentSize = {width:0, height:0}; 
		
		var child = null; //for convienence
		
		var x;
		var y;
		var width;
		var height;

		var top;
		var left;
		var bottom;
		var right;
		var hCenter;
		var vCenter;
		var rotateDegrees;
		var rotateCenterX;
		var rotateCenterY;
		var rotatedMetrics;
		
		var tempX;
		var tempY;
		var tempWidth;
		var tempHeight;
		var tempRotateDegrees;
		var tempRotateCenterX;
		var tempRotateCenterY;
		
		for (var i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			var childSize = {width: 0, height:0};
			
			width = child._getStyledOrMeasuredWidth();
			height = child._getStyledOrMeasuredHeight();
			
			x = child.getStyle("X");
			y = child.getStyle("Y");
			top = child.getStyle("Top");
			left = child.getStyle("Left");
			bottom = child.getStyle("Bottom");
			right = child.getStyle("Right");
			
			//prioritize x/y over left/top (but they're the same)
			if (x == null)
				x = left;
			if (y == null)
				y = top;
			
			hCenter = child.getStyle("HorizontalCenter");
			vCenter = child.getStyle("VerticalCenter");
			
			rotateDegrees = child.getStyle("RotateDegrees");
			rotateCenterX = child.getStyle("RotateCenterX");
			rotateCenterY = child.getStyle("RotateCenterY");
			
			if (rotateDegrees != 0)
			{
				//Record child's current x/y & w/h & rotation
				tempX = child._x;
				tempY = child._y;
				tempWidth = child._width;
				tempHeight = child._height;
				tempRotateDegrees = child._rotateDegrees;
				tempRotateCenterX = child._rotateCenterX;
				tempRotateCenterY = child._rotateCenterY;
				
				//TODO: Update getMetrics() so we can pass child values.
				//Spoof the rotation position/size so we can get parent metrics.
				child._x = x == null ? 0 : x;
				child._y = y == null ? 0 : y;
				child._width = width;
				child._height = height;
				child._rotateDegrees = rotateDegrees;
				child._rotateCenterX = rotateCenterX == null ? 0 : rotateCenterX;
				child._rotateCenterY = rotateCenterY == null ? 0 : rotateCenterY;
				
				//Get parent metrics for spoof position
				rotatedMetrics = child.getMetrics(this);
				
				//Put back current values
				child._x = tempX;
				child._y = tempY;
				child._width = tempWidth;
				child._height = tempHeight;
				child._rotateDegrees = tempRotateDegrees;
				child._rotateCenterX = tempRotateCenterX;
				child._rotateCenterY = tempRotateCenterY;
				
				if (rotateCenterX != null && rotateCenterY != null)
				{
					x = Math.max(rotatedMetrics.getX(), 0);
					y = Math.max(rotatedMetrics.getY(), 0);
				}
				
				childSize.width += Math.ceil(rotatedMetrics.getWidth());
				childSize.height += Math.ceil(rotatedMetrics.getHeight());
			}
			else //Non-Rotated Element
			{
				childSize.width += width;
				childSize.height += height;
			}
			
			if (right != null)
				childSize.width += right;
			if (bottom != null)
				childSize.height += bottom;
			
			if (x == null && right == null && hCenter != null)
				childSize.width += Math.abs(hCenter * 2);
			if (y == null && bottom == null && vCenter != null)
				childSize.height += Math.abs(vCenter * 2);
			
			if (x == null || x < 0)
				x = 0;
			if (y == null || y < 0)
				y = 0;
			
			childSize.width += x;
			childSize.height += y;
			
			contentSize.width = Math.max(contentSize.width, Math.ceil(childSize.width));
			contentSize.height = Math.max(contentSize.height, Math.ceil(childSize.height));
		}
		
		return contentSize;
	};
	
//@Override
AnchorContainerElement.prototype._doLayout =
	function(paddingMetrics)
	{
		AnchorContainerElement.base.prototype._doLayout.call(this, paddingMetrics);
	
		var child = null;
		
		var x = null;
		var y = null;
		var width = null;
		var height = null;
		var pWidth = null;
		var pHeight = null;
		var minWidth = null;
		var maxWidth = null;
		var minHeight = null;
		var maxHeight = null;		
		var top = null;
		var left = null;
		var bottom = null;
		var right = null;
		var hCenter = null;
		var vCenter = null;
		var rotateDegrees = null;
		var rotateCenterX = null;
		var rotateCenterY = null;
		var rotatedMetrics = null;
		
		for (var i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			x = child.getStyle("X");
			y = child.getStyle("Y");
			top = child.getStyle("Top");
			left = child.getStyle("Left");
			bottom = child.getStyle("Bottom");
			right = child.getStyle("Right");
			width = child.getStyle("Width");
			height = child.getStyle("Height");
			minWidth = child.getStyle("MinWidth");
			minHeight = child.getStyle("MinHeight");
			maxWidth = child.getStyle("MaxWidth");
			maxHeight = child.getStyle("MaxHeight");
			hCenter = child.getStyle("HorizontalCenter");
			vCenter = child.getStyle("VerticalCenter");
			rotateDegrees = child.getStyle("RotateDegrees");
			rotateCenterX = child.getStyle("RotateCenterX");
			rotateCenterY = child.getStyle("RotateCenterY");
			
			if (minWidth == null)
				minWidth = 0;
			if (minHeight == null)
				minHeight = 0;
			if (maxWidth == null)
				maxWidth = Number.MAX_VALUE;
			if (maxHeight == null)
				maxHeight = Number.MAX_VALUE;
			
			child._setActualRotation(rotateDegrees, rotateCenterX, rotateCenterY);
			
			if (rotateDegrees != 0)
			{
				if (width == null)
				{
					width = child._measuredWidth;
					width = Math.min(width, maxWidth);
					width = Math.max(width, minWidth);
				}
				
				if (height == null)
				{
					height = child._measuredHeight;
					height = Math.min(height, maxHeight);
					height = Math.max(height, minHeight);
				}
				
				child._setActualSize(width, height);
				
				if (rotateCenterX == null || rotateCenterY == null)
				{
					//prioritize x/y over left/top (but they're the same)
					if (x == null)
						x = left;
					if (y == null)
						y = top;
					
					if (x == null || y == null)
					{
						rotatedMetrics = child.getMetrics(this);
						
						width = Math.ceil(rotatedMetrics.getWidth());
						height = Math.ceil(rotatedMetrics.getHeight());
						
						if (x == null && right != null)
							x = this._width - width - right;
						
						if (y == null && bottom != null)
							y = this._height - height - bottom;
						
						if (x == null && hCenter != null)
							x = Math.round((this._width / 2) - (width / 2) + hCenter);
						
						if (y == null && vCenter != null)
							y = Math.round((this._height / 2) - (height / 2) + vCenter);
					}
					
					if (x == null)
						x = 0;
					if (y == null)
						y = 0;
					
					child._setRelativePosition(x, y, this);
				}
				else
				{
					if (x == null)
						x = 0;
					if (y == null)
						y = 0;
					
					child._setActualPosition(x, y);
				}
			}
			else //Non-Rotated Element
			{
				pWidth = child.getStyle("PercentWidth");
				pHeight = child.getStyle("PercentHeight");
			
				//prioritize x/y over left/top (but they're the same)
				if (x == null)
					x = left;
				if (y == null)
					y = top;
				
				if (width == null)
				{
					if (x != null && right != null)
						width = this._width - x - right;
					else
					{
						if (pWidth != null)
							width = Math.round(this._width * (pWidth / 100));
						else
							width = child._measuredWidth;
					}
					
					width = Math.min(width, maxWidth);
					width = Math.max(width, minWidth);
				}
				
				if (height == null)
				{
					if (y != null && bottom != null)
						height = this._height - y - bottom;
					else
					{
						if (pHeight != null)
							height = Math.round(this._height * (pHeight / 100));
						else
							height = child._measuredHeight;
					}
					
					height = Math.min(height, maxHeight);
					height = Math.max(height, minHeight);
				}
				
				if (x == null && right != null)
					x = this._width - width - right;
				
				if (y == null && bottom != null)
					y = this._height - height - bottom;
				
				if (x == null && hCenter != null)
					x = Math.round((this._width / 2) - (width / 2) + hCenter);
				
				if (y == null && vCenter != null)
					y = Math.round((this._height / 2) - (height / 2) + vCenter);
				
				if (x == null)
					x = 0;
				if (y == null)
					y = 0;
				
				child._setActualPosition(x, y);
				child._setActualSize(width, height);
			}
		}
	};	
	
	


/**
 * @depends AnchorContainerElement.js
 */

//////////////////////////////////////////////////////////////
////////////////////CanvasManager/////////////////////////////

/**
 * @class CanvasManager
 * @inherits AnchorContainerElement
 * 
 * CanvasManager is the root of the display hierarchy, manages a single canvas, and is essentially
 * the brain of the system, its responsible things such as driving the component life cycle, 
 * managing CanvasElements, requesting render frames from the browser, etc.  
 * For elements to be rendered to the canvas, they must be added to CanvasManager, or be a descendant of
 * an element that has been added to CanvasManager. 
 * 
 * CanvasManager itself is a subclass of an AnchorContainer and can be used as such, although typically
 * for more complex layouts you will nest containers inside of CanvasManager.
 * 
 * @constructor CanvasManager 
 * Creates new CanvasManager instance.
 */

function CanvasManager()
{
	//Life cycle phases
	this._updateStylesQueue = new CmDepthQueue();
	this._updateMeasureQueue = new CmDepthQueue();
	this._updateLayoutQueue = new CmDepthQueue();
	this._updateRenderQueue = new CmDepthQueue();

	this._compositeRenderQueue = new CmDepthQueue();
	
	//Used to store the add/remove events we need to dispatch after elements are added/removed from the display chain.
	//Adding and removing elements is a recursive process which must finish prior to dispatching any events.
	this._addRemoveDisplayChainQueue = new CmLinkedList();
	this._addRemoveDisplayChainQueueProcessing = false; //Recursion guard
	
	this._broadcastDispatcher = new EventDispatcher(); //Dispatches broadcast events.
	
	this._browserCursor = null;
	this._cursorChain = new CmLinkedList();	//Priority Chain (cursor)
	
	this._tabStopReverse = false;
	this._focusElement = null;				//Target with focus
	
	this._canvas = null;
	this._canvasContext = null;
	this._canvasRenderFramePending = false;
	
	this._mouseX = -1;
	this._mouseY = -1;
	
	this._rollOverInvalid = true;
	this._rollOverElement = null;	//Last roll over target.
	this._rollOverX = -1;			//Position within target (used for mousemove)
	this._rollOverY = -1;
	
	this._mouseDownElement = null; 	//Target to dispatch mouseup
	
	this._draggingElement = null;	//Target currently being dragged.
	this._draggingOffsetX = null;
	this._draggingOffsetY = null;	
	
	this._currentLocale = "en-us";
	
	this._redrawRegionInvalid = true;
	this._redrawRegionPrevMetrics = null;
	
	//Now call base
	CanvasManager.base.prototype.constructor.call(this);

	this._cursorContainer = new CanvasElement();
	this._cursorContainer.setStyle("MouseEnabled", false);
	this._addOverlayChild(this._cursorContainer);	
	
	var _self = this;
	
	//Private handlers, need instance for every CanvasManager
	this._onCursorDefinitionStyleChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onCursorDefinitionStyleChanged(styleChangedEvent);
		};
		
	this._onCanvasFrame = 
		function ()
		{
			//Prevent double render frames if someone changes our associated canvas.
			if (_self._canvasContext == null)
			{
				_self._canvasRenderFramePending = false;
				return;
			}
			
			window.requestAnimationFrame(_self._onCanvasFrame);	
			
			_self.updateNow();
		};
	
	this._canvasResizeEventHandler = 
		function ()
		{
			//Fix canvas manager size.
			_self.setStyle("Width", _self._canvas.clientWidth);
			_self.setStyle("Height", _self._canvas.clientHeight);
			_self._setActualSize(_self._canvas.clientWidth, _self._canvas.clientHeight);
			
			_self._redrawRegionPrevMetrics = null;
			_self._updateRedrawRegion(_self.getMetrics(null));
			
			_self.updateNow();
		};
	
	this._canvasFocusEventHandler = 
		function (browserEvent)
		{
			//Tab focus only (if focused via mouse we'll get the mouse event first)
			if (_self._focusElement == null && browserEvent.type == "focus")
			{
				if (_self._tabStopReverse == true)
					_self._updateFocusElement(_self._findChildTabStopReverse(_self, null, null), true);
				else
					_self._updateFocusElement(_self._findChildTabStopForward(_self, null), true);
			}
			else if (_self._focusElement != null && browserEvent.type == "blur")
				_self._updateFocusElement(null, true);
		};		
		
	this._canvasKeyboardEventHandler = 
		function (browserEvent)
		{
			if (browserEvent.type == "keydown")
			{
				if (browserEvent.key == "Tab" && browserEvent.shiftKey == true)
					_self._tabStopReverse = true;
				else if (browserEvent.key == "Tab" && browserEvent.shiftKey == false)
					_self._tabStopReverse = false;
			}
		
			if (_self._focusElement != null)
			{
				var keyboardEvent = new ElementKeyboardEvent(browserEvent.type, 
											browserEvent.key, browserEvent.which, 
											browserEvent.ctrlKey, browserEvent.altKey, 
											browserEvent.shiftKey, browserEvent.metaKey);
				
				_self._focusElement._dispatchEvent(keyboardEvent);
				
				if (keyboardEvent._canceled == true || keyboardEvent._defaultPrevented == true)
					browserEvent.preventDefault();
				else if (browserEvent.type == "keydown" && keyboardEvent.getKey() == "Tab")
				{
					var tabStopElement = null;
					var currentParent = _self._focusElement;
					var lastParent = null;
					
					if (_self._tabStopReverse == false)
					{
						while (currentParent != null)
						{
							tabStopElement = _self._findChildTabStopForward(currentParent, lastParent);
							
							if (tabStopElement != null)
								break;
							
							lastParent = currentParent;
							currentParent = currentParent._parent;
						}
					}
					else //Tab backwards
					{
						while (currentParent != null)
						{
							tabStopElement = _self._findChildTabStopReverse(currentParent, lastParent, null);
							
							if (tabStopElement != null)
								break;
							
							lastParent = currentParent;
							currentParent = currentParent._parent;
						}
					}
					
					_self._updateFocusElement(tabStopElement, true);
					if (tabStopElement != null)
						browserEvent.preventDefault();
				}
			}
		};
	
	this._canvasMouseEventHandler = 
		function(browserEvent)
		{
			//Translate mouse to local position
			var mousePoint = CanvasManager.getLocalMousePos(browserEvent, _self._canvas);
			
			var i = 0;

			if (browserEvent.type == "mouseup")
			{
				window.removeEventListener('mouseup', _self._canvasMouseEventHandler);

				_self._clearDraggingElement();
				_self._mouseDownElement._mouseIsDown = false;

				//Start at mousedown target, record parents up to canvas manager, fix state.
				var parentChain = [];
				parentChain.push(_self._mouseDownElement);
				
				while (parentChain[parentChain.length - 1]._parent != null)
				{
					parentChain[parentChain.length - 1]._parent._mouseIsDown = false;
					parentChain.push(parentChain[parentChain.length - 1]._parent);
				}

				var clickElement = null;
				var clickPoint = {x:0, y:0};
				
				//Adjust mouse point for target element to dispatch mouseup
				for (i = parentChain.length - 1; i >= 0; i--) //Start at CanvasManager child, work down to target.
				{
					//Rotate the point backwards so we can translate the point to the element's rotated plane.
					parentChain[i].rotatePoint(mousePoint, true);
					
					//Adjust the mouse point to within this element rather than its position in parent.
					mousePoint.x = mousePoint.x - parentChain[i]._x;
					mousePoint.y = mousePoint.y - parentChain[i]._y;
					
					//Dispatch click if we're still over the target element.
					if (mousePoint.x >= 0 && 
						mousePoint.x <= parentChain[i]._width &&
						mousePoint.y >= 0 &&
						mousePoint.y <= parentChain[i]._height)
					{
						clickElement = parentChain[i];
						
						clickPoint.x = mousePoint.x;
						clickPoint.y = mousePoint.y;
					}
				}
				
				_self._mouseDownElement = null;

				//Dispatch mouseup
				parentChain[0]._dispatchEvent(new ElementMouseEvent("mouseup", mousePoint.x, mousePoint.y));
				
				//Dispatch click if we're still over the target element.
				if (clickElement != null)
					clickElement._dispatchEvent(new ElementMouseEvent("click", clickPoint.x, clickPoint.y));
			}
			else if (browserEvent.type == "wheel")
			{
				//Mouse is disabled on CanvasManager
				if (_self.getStyle("MouseEnabled") == false || _self.getStyle("Visible") == false)
					return;
				
				var currentElement = null;
				
				if (mousePoint.x >= 0 && mousePoint.x <= _self._width &&
					mousePoint.y >= 0 && mousePoint.y <= _self._height)
				{
					currentElement = _self;
					
					var foundChild = false;
					while (true)
					{
						foundChild = false;
						for (i = currentElement._children.length -1; i >= 0; i--)
						{
							//Skip element if mouse is disabled or visibility is off.
							if (currentElement._children[i].getStyle("MouseEnabled") == false || 
								currentElement._children[i].getStyle("Visible") == false)
								continue;
							
							//Rotate the point backwards so we can translate the point to the element's rotated plane.
							currentElement._children[i].rotatePoint(mousePoint, true);
							
							if (mousePoint.x >= currentElement._children[i]._x && 
								mousePoint.x <= currentElement._children[i]._x + currentElement._children[i]._width &&
								mousePoint.y >= currentElement._children[i]._y &&
								mousePoint.y <= currentElement._children[i]._y + currentElement._children[i]._height)
							{
								currentElement = currentElement._children[i];
								
								//Adjust the mouse point to within this element rather than its position in parent.
								mousePoint.x = mousePoint.x - currentElement._x;
								mousePoint.y = mousePoint.y - currentElement._y;
								
								foundChild = true;
								break;
							}
							
							//Rotate forwards, we're not over this child, undo the rotation.
							currentElement._children[i].rotatePoint(mousePoint, false);
						}
						
						if (foundChild == false)
							break;
					}
				}
				
				if (currentElement != null)
				{
					var deltaX = 0;
					if (browserEvent.deltaX > 0)
						deltaX = 1;
					else if (browserEvent.deltaX < 0)
						deltaX = -1;
					
					var deltaY = 0;
					if (browserEvent.deltaY > 0)
						deltaY = 1;
					else if (browserEvent.deltaY < 0)
						deltaY = -1;
					
					var mouseWheelEvent = new ElementMouseWheelEvent(mousePoint.x, mousePoint.y, deltaX, deltaY);
					currentElement._dispatchEvent(mouseWheelEvent);
					
					if (mouseWheelEvent._canceled == true || mouseWheelEvent._defaultPrevented == true)
						browserEvent.preventDefault();
				}
			}
			else if (browserEvent.type == "mousedown")
			{
				//Kill focus if we're not over the canvas				
				if (mousePoint.x < 0 || mousePoint.x > this._width || 
					mousePoint.y < 0 || mousePoint.y > this._height)
				{
					_self._updateFocusElement(null, false);
					return;
				}
					
				//Mouse is disabled on CanvasManager
				if (_self.getStyle("MouseEnabled") == false || _self.getStyle("Visible") == false || _self._mouseDownElement != null)
					return;
				
				var draggingElement = null;
				var draggingOffset = {x:0, y:0};
				
				var focusElement = null;
				var focusElementTabStop = -1;
				var currentElementTabStop = -1;
				
				var currentElement = _self; 
				var foundChild = false;
				while (true)
				{
					currentElement._mouseIsDown = true;
					
					//Only allow dragging if we're not in a container, or an AnchorContainer
					if (currentElement.getStyle("Draggable") == true && 
						(currentElement._parent instanceof AnchorContainerElement || !(currentElement._parent instanceof ContainerBaseElement)))
					{
						draggingElement = currentElement;
						draggingOffset = {x:mousePoint.x, y:mousePoint.y};
					}
				
					currentElementTabStop = currentElement.getStyle("TabStop");
					if (currentElementTabStop >= 0 || focusElementTabStop < 0)
					{
						focusElement = currentElement;
						focusElementTabStop = currentElementTabStop;
					}
					
					foundChild = false;
					for (i = currentElement._children.length -1; i >= 0; i--)
					{
						//Skip element if mouse is disabled or visibility is off.
						if (currentElement._children[i].getStyle("MouseEnabled") == false || 
							currentElement._children[i].getStyle("Visible") == false)
							continue;
						
						//Rotate the point backwards so we can translate the point to the element's rotated plane.
						currentElement._children[i].rotatePoint(mousePoint, true);
						
						if (mousePoint.x >= currentElement._children[i]._x && 
							mousePoint.x <= currentElement._children[i]._x + currentElement._children[i]._width &&
							mousePoint.y >= currentElement._children[i]._y &&
							mousePoint.y <= currentElement._children[i]._y + currentElement._children[i]._height)
						{
							currentElement = currentElement._children[i];
							
							//Adjust the mouse point to within this element rather than its position in parent.
							mousePoint.x = mousePoint.x - currentElement._x;
							mousePoint.y = mousePoint.y - currentElement._y;
							
							foundChild = true;
							break;
						}
						
						//Rotate forwards, we're not over this child, undo the rotation.
						currentElement._children[i].rotatePoint(mousePoint, false);
					}
					
					if (foundChild == false)
						break;
				}

				_self._mouseDownElement = currentElement;
				window.addEventListener('mouseup', _self._canvasMouseEventHandler, false);
					
				if (draggingElement != null)
					_self._setDraggingElement(draggingElement, draggingOffset.x, draggingOffset.y);
				
				currentElement._dispatchEvent(new ElementMouseEvent(browserEvent.type, mousePoint.x, mousePoint.y));
				
				_self._updateFocusElement(focusElement, false);
				
				//Always shut off focus ring (even if focus doesnt change)
				if (_self._focusElement != null)
					_self._focusElement._setRenderFocusRing(false);
			}
			else if (browserEvent.type == "mousemove")
			{
				//Mouse is disabled on CanvasManager
				if (_self.getStyle("MouseEnabled") == false)
					return;
				
				_self._mouseX = mousePoint.x;
				_self._mouseY = mousePoint.y;
				_self._rollOverInvalid = true;
				
				_self._updateCursor();
				
				//Adjust dragging element.
				if (_self._draggingElement != null)
				{
					//We use metrics relative to the parent of the element being dragged. We
					//want to keep the element within parent bounds even if its transformed (rotated).
					
					//Get drag element's metrics relative to its parent.
					var metrics = _self._draggingElement.getMetrics(_self._draggingElement._parent);
					
					//Get the drag offset relative to parent.
					var offset = {x: _self._draggingOffsetX, y: _self._draggingOffsetY};
					_self._draggingElement.translatePointTo(offset, _self._draggingElement._parent);
					
					//Get the mouse position relative to parent.
					var newPosition = {	x: mousePoint.x, y: mousePoint.y };
					_self.translatePointTo(newPosition, _self._draggingElement._parent);
					
					//Adjust mouse position for drag start offset.
					newPosition.x += metrics.getX() - offset.x;
					newPosition.y += metrics.getY() - offset.y;
					
					//Correct if we're out of bounds.
					if (newPosition.x < 0)
						newPosition.x = 0;
					if (newPosition.x > _self._draggingElement._parent._width - metrics.getWidth())
						newPosition.x = _self._draggingElement._parent._width - metrics.getWidth();
					if (newPosition.y < 0)
						newPosition.y = 0;
					if (newPosition.y > _self._draggingElement._parent._height - metrics.getHeight())
						newPosition.y = _self._draggingElement._parent._height - metrics.getHeight();
					
					//Set position relative to parent.
					_self._draggingElement._setRelativePosition(
							newPosition.x, 
							newPosition.y, 
							 _self._draggingElement._parent);
					
					//TODO: Can probably be smarter about this... Check style states
					if (_self._draggingElement._parent instanceof AnchorContainerElement)
					{
						if (_self._draggingElement.getStyle("RotateCenterX") == null || _self._draggingElement.getStyle("RotateCenterY") == null)
						{
							if (_self._draggingElement.getStyle("X") != null)
								_self._draggingElement.setStyle("X", newPosition.x);
							if (_self._draggingElement.getStyle("Y") != null)
								_self._draggingElement.setStyle("Y", newPosition.y);
						}
						else
						{
							if (_self._draggingElement.getStyle("X") != null)
								_self._draggingElement.setStyle("X", _self._draggingElement._x);
							if (_self._draggingElement.getStyle("Y") != null)
								_self._draggingElement.setStyle("Y", _self._draggingElement._y);
							
							_self._draggingElement.setStyle("RotateCenterX", _self._draggingElement._rotateCenterX);
							_self._draggingElement.setStyle("RotateCenterY", _self._draggingElement._rotateCenterY);
						}
					}
					
					//Dispatch dragging.
					_self._draggingElement._dispatchEvent(new ElementEvent("dragging", false));
				}
			}
		};
}

//Inherit from AnchorContainerElement
CanvasManager.prototype = Object.create(AnchorContainerElement.prototype);
CanvasManager.prototype.constructor = CanvasManager;
CanvasManager.base = AnchorContainerElement;	


/////////////Style Types///////////////////////////////

CanvasManager._StyleTypes = Object.create(null);

/**
 * @style ShowRedrawRegion boolean
 * 
 * When true the canvas redraw region will be displayed.
 */
CanvasManager._StyleTypes.ShowRedrawRegion = 								{inheritable:false};		


/////////////Default Styles///////////////////////////////

CanvasManager.StyleDefault = new StyleDefinition();

CanvasManager.StyleDefault.setStyle("ShowRedrawRegion", 					false);		// true || false



///////////////////CanvasManager Public Functions//////////////////////

/**
 * @function setCanvas
 * Sets the canvas that CanvasManager should manage.
 * 
 * @param canvas Canvas
 * Reference to the DOM canvas that CanvasManager should manage.
 */
CanvasManager.prototype.setCanvas = 
	function (canvas)
	{
		if (this._canvas == canvas)
			return;
	
		var addedOrRemoved = (this._canvas == null || canvas == null);
		
		//Clean up old canvas
		if (this._canvas != null)
		{
			window.removeEventListener('mousedown', this._canvasMouseEventHandler, false);
			window.removeEventListener('mousemove', this._canvasMouseEventHandler, false);
			window.removeEventListener("wheel", this._canvasMouseEventHandler, false);
			window.removeEventListener("keydown", this._canvasKeyboardEventHandler, false);
			window.removeEventListener("keyup", this._canvasKeyboardEventHandler, false);
			window.removeEventListener("resize", this._canvasResizeEventHandler, false);
			
			this._canvas.removeEventListener("focus", this._canvasFocusEventHandler, true);
			this._canvas.removeEventListener("blur", this._canvasFocusEventHandler, true);
			
			this._canvas = null;
			this._canvasContext = null;
		}

		if (canvas != null)
		{
			this._canvas = canvas;
			this._canvasContext = canvas.getContext("2d");
			
			window.addEventListener("mousedown", this._canvasMouseEventHandler, false);
			window.addEventListener("mousemove", this._canvasMouseEventHandler, false);
			window.addEventListener("wheel", this._canvasMouseEventHandler, false);
			window.addEventListener("keydown", this._canvasKeyboardEventHandler, false);
			window.addEventListener("keyup", this._canvasKeyboardEventHandler, false);
			window.addEventListener("resize", this._canvasResizeEventHandler, false);
			
			this._canvas.addEventListener("focus", this._canvasFocusEventHandler, true);
			this._canvas.addEventListener("blur", this._canvasFocusEventHandler, true);
					
			this._canvas.tabIndex = 1;
			this._canvas.style.outline = "none";
			this._canvas.style.cursor = "default";
			
			//Disable text selection cursor.
//			canvas.onselectstart = function () { return false; }; 
//			canvas.style.userSelect = "none";
//			canvas.style.webkitUserSelect = "none";
//			canvas.style.MozUserSelect = "none";
//			canvas.style.mozUserSelect = "none";
//			canvas.setAttribute("unselectable", "on"); // For IE and Opera

			//Prevent double render frames if someone changes our associated canvas.
			if (this._canvasRenderFramePending == false)
			{
				this._canvasRenderFramePending = true;
				window.requestAnimationFrame(this._onCanvasFrame);	
			}
			
			if (navigator.userAgent.indexOf("Firefox") > 0)
				CanvasElement._browserType = "Firefox";
		}
		
		if (addedOrRemoved == true)
		{
			this._propagateChildData();
			this._processAddRemoveDisplayChainQueue();
		}
		
		if (this._canvas != null)
		{
			this._rollOverInvalid = true;
			this._canvasResizeEventHandler();
		}
	};

/**
 * @function getCanvas
 * Gets the DOM canvas reference CanvasManager is currently managing.
 * 
 * @returns Canvas
 * The DOM canvas reference CanvasManager is currently managing.
 */	
CanvasManager.prototype.getCanvas = 
	function ()
	{
		return this._canvas;
	};

/**
 * @function setLocale
 * Sets the locale to be used when using localized strings. The actual
 * locale value is arbitrary, this simply dispatches an event to notify elements
 * that the locale has changed. Its up to implementors to store their locale strings
 * and update/lookup accordingly. CanvasManager defaults locale to "en-us". 
 * 
 * @param locale String
 * The locale to change too.
 */	
CanvasManager.prototype.setLocale = 
	function (locale)
	{
		if (this._currentLocale == locale)
			return;
		
		this._currentLocale = locale;
		
		if (this._broadcastDispatcher.hasEventListener("localechanged", null) == true)
			this._broadcastDispatcher._dispatchEvent(new DispatcherEvent("localechanged"));
	};
	
/**
 * @function getLocale
 * Gets CanvasManager's current locale.
 * 
 * @returns String
 * String representing CanvasManager's current locale.
 */	
CanvasManager.prototype.getLocale = 
	function ()
	{
		return this._currentLocale;
	};
	
/**
 * @function addCursor
 * Adds a cursor to be used when the mouse is over the canvas. Cursors are managed
 * as a priority chain. Element roll-over cursors use priority 0 so setting any explicit
 * cursor such as a busy cursor should use a priority higher than 0, unless you want Elements
 * to override the canvas cursor on roll-over.
 * 
 * @param cursorDefinition CursorDefinition
 * The cursor to add. This may be a custom CursorDefinition and CanvasManager will hide
 * the native browser cursor and render the custom cursor. It also may be a standard
 * browser CSS cursor String such as "text".
 * 
 * @param priority int
 * The priority to assign to the cursor. Higher priorities override lower priorities.
 * 
 * @returns Object
 * A "cursor instance" object that is to be used to remove the cursor.
 */	
CanvasManager.prototype.addCursor = 
	function (cursorDefinition, priority)
	{
		if (priority == null)
			priority = 0;
	
		if (cursorDefinition instanceof CursorDefinition)
		{
			if (cursorDefinition._addedCount == 0)
				cursorDefinition.addEventListener("stylechanged", this._onCursorDefinitionStyleChangedInstance);
				
			cursorDefinition._addedCount++;
		}
		
		var cursorInstance = new CmLinkedNode();
		cursorInstance.data = cursorDefinition;
		cursorInstance.priority = priority;
		
		var lastCursor = this._cursorChain.back;
		if (lastCursor == null)
			this._cursorChain.pushBack(cursorInstance);
		else
		{
			while (lastCursor != null && lastCursor.priority > cursorInstance.priority)
				lastCursor = lastCursor.prev;
			
			if (lastCursor == null)
				this._cursorChain.pushFront(cursorInstance);
			else
				this._cursorChain.insertAfter(cursorInstance, lastCursor);
		}
		
		this._updateCursor();
		
		return cursorInstance;
	};

/**
 * @function removeCursor
 * Removes a cursor via the cursor instance object returned by addCursor().
 * 
 * @param cursorInstance Object
 * The cursor instance Object returned by addCursor().
 */	
CanvasManager.prototype.removeCursor = 
	function (cursorInstance)
	{
		if (cursorDefinition instanceof CursorDefinition)
		{
			var cursorDefinition = cursorInstance.data;
			cursorDefinition._addedCount--;
				
			if (cursorDefinition._addedCount == 0)
				cursorDefinition.removeEventListener("stylechanged", this._onCursorDefinitionStyleChangedInstance);
		}

		this._cursorChain.removeNode(cursorInstance);
		this._updateCursor();
		
		return true;
	};	
	
/**
 * @function updateNow
 * This is an internal function and should conceivably *never* be called.
 * This forces a full pass of the component life cycle and is incredibly expensive.
 * The system calls this once per render frame with the only known exception being immediately after a canvas resize.
 * If you think you need to call this, you probably have a design problem.
 * Documentation added for unforeseen circumstances. 
 */	
CanvasManager.prototype.updateNow = 
	function ()
	{
		if (this._broadcastDispatcher.hasEventListener("enterframe", null) == true)
			this._broadcastDispatcher._dispatchEvent(new DispatcherEvent("enterframe"));
	
		//Process state updates.
		while (this._updateStylesQueue.length > 0 || 
				this._updateMeasureQueue.length > 0 || 
				this._updateLayoutQueue.length > 0 || 
				this._rollOverInvalid == true ||
				this._updateRenderQueue.length > 0)
		{
			//Process styles queue.
			while (this._updateStylesQueue.length > 0)
				this._updateStylesQueue.removeSmallest().data._validateStyles();
			
			//Process measure queue.
			while (this._updateMeasureQueue.length > 0 && 
					this._updateStylesQueue.length == 0)
			{
				this._updateMeasureQueue.removeLargest().data._validateMeasure();
			}
			
			//Process layout queue.
			while (this._updateLayoutQueue.length > 0 && 
					this._updateMeasureQueue.length == 0 && 
					this._updateStylesQueue.length == 0)
			{
				this._updateLayoutQueue.removeSmallest().data._validateLayout();
			}
			
			//Do rollover/rollout/mousemove
			if (this._rollOverInvalid == true && 
				this._updateLayoutQueue.length == 0 && 
				this._updateMeasureQueue.length == 0 && 
				this._updateStylesQueue.length == 0)
			{
				this._rollOverInvalid = false;
				
				var i;
				var currentElement = null;
				var mousePoint = {x: this._mouseX, y:this._mouseY};
				
				var lastRollOverTarget = this._rollOverElement;
				var lastRollOverX = this._rollOverX;
				var lastRollOverY = this._rollOverY;
				
				this._rollOverElement = null;
				
				var rollOverCommonParent = null;
				var rollOverElements = [];
				
				//Make sure we're over the canvas.				
				if (mousePoint.x >= 0 && mousePoint.x <= this._width &&
					mousePoint.y >= 0 && mousePoint.y <= this._height)
				{
					currentElement = this;
					if (currentElement._mouseIsOver == false)
					{
						rollOverElements.push(currentElement);
						currentElement._mouseIsOver = true;
					}
					else
						rollOverCommonParent = currentElement;
					
					this._rollOverElement = currentElement; 
					this._rollOverX = mousePoint.x;
					this._rollOverY = mousePoint.y;
					
					var foundChild = false;
					while (true)
					{
						foundChild = false;
						for (i = currentElement._children.length -1; i >= 0; i--)
						{
							//Skip element if mouse is disabled or not visible.
							if (currentElement._children[i].getStyle("MouseEnabled") == false ||
								currentElement._children[i].getStyle("Visible") == false)
								continue;
							
							//Rotate the point backwards so we can translate the point to the element's rotated plane.
							currentElement._children[i].rotatePoint(mousePoint, true);
							
							if (mousePoint.x >= currentElement._children[i]._x && 
								mousePoint.x <= currentElement._children[i]._x + currentElement._children[i]._width &&
								mousePoint.y >= currentElement._children[i]._y &&
								mousePoint.y <= currentElement._children[i]._y + currentElement._children[i]._height)
							{
								currentElement = currentElement._children[i];
								if (currentElement._mouseIsOver == false)
								{
									rollOverElements.push(currentElement);
									currentElement._mouseIsOver = true;
								}								
								else
									rollOverCommonParent = currentElement;
								
								//Adjust the mouse point to within this element rather than its position in parent.
								mousePoint.x = mousePoint.x - currentElement._x;
								mousePoint.y = mousePoint.y - currentElement._y;
								
								this._rollOverElement = currentElement;
								this._rollOverX = mousePoint.x;
								this._rollOverY = mousePoint.y;
								
								foundChild = true;
								break;
							}
							
							//Rotate forwards, we're not over this child, undo the rotation.
							currentElement._children[i].rotatePoint(mousePoint, false);
						}
						
						if (foundChild == false)
							break;
					}
				}

				if (currentElement != null && 
					(this._rollOverElement != lastRollOverTarget || 
					this._rollOverX != lastRollOverX || 
					this._rollOverY != lastRollOverY))
				{
					currentElement._dispatchEvent(new ElementMouseEvent("mousemove", mousePoint.x, mousePoint.y));
				}
				
				this._broadcastDispatcher._dispatchEvent(new ElementMouseEvent("mousemoveex", this._mouseX, this._mouseY));
				
				if (lastRollOverTarget != null && this._rollOverElement != lastRollOverTarget)
				{
					var rollOutElements = [];
					currentElement = lastRollOverTarget;
					while (currentElement != rollOverCommonParent)
					{
						currentElement._mouseIsOver = false;
						rollOutElements.push(currentElement);
						currentElement = currentElement._parent;
					}
					
					for (i = 0; i < rollOutElements.length; i++)
						rollOutElements[i]._dispatchEvent(new ElementEvent("rollout", false));
				}
				
				for (i = 0; i < rollOverElements.length; i++)
					rollOverElements[i]._dispatchEvent(new ElementEvent("rollover", false));
			}
			
			//Process render queue.
			while (this._updateRenderQueue.length > 0 && 
					this._rollOverInvalid == false &&
					this._updateLayoutQueue.length == 0 && 
					this._updateMeasureQueue.length == 0 && 
					this._updateStylesQueue.length == 0)
			{
				this._updateRenderQueue.removeSmallest().data._validateRender();
			}
		}
		
		if (this._redrawRegionInvalid == true)
		{
			this._validateRedrawRegion(this, false);
			this._redrawRegionInvalid = false;
		}
		
		//Render composite layers.
		while (this._compositeRenderQueue.length > 0)
			this._compositeRenderQueue.removeLargest().data._validateCompositeRender();
		
		//Render redraw region
		if (this._redrawRegionPrevMetrics != null)
			this._invalidateCompositeRender();
	};

/////////////CanvasManager Static Public Functions///////////////	

/**
 * @function getLocalMousePos
 * @static
 * Translates browser mouse event coordinates to canvas relative coordinates.
 * The system automatically calls this and translates raw browser events to 
 * system events to be consumed by CanvasElements. You probably never need to call this.
 * 
 * @param event BrowserEvent
 * The browser mouse event.
 * 
 * @param canvas Canvas
 * The DOM Canvas reference to translate the mouse coordinates too.
 * 
 * @returns Object
 * A point object containing {x, y}.
 */	
CanvasManager.getLocalMousePos = 
	function (event, canvas)
	{
		//Reliable way to get position with canvas scaling.
		var rect = canvas.getBoundingClientRect();
		return {
			x: Math.round((event.clientX - rect.left) / (rect.right - rect.left) * canvas.width),
			y: Math.round((event.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height)
		};
	};	

//////////////Internal Functions////////////////

//@override	
CanvasManager.prototype._updateCompositeCanvas = 
	function ()
	{
		if (this._compositeCanvas == null)
		{
			this._compositeCanvas = this._canvas;
			this._compositeCtx = this._canvasContext;
		}
		
		if (this._compositeCanvas.width != this._width || 
			this._compositeCanvas.height != this._height)
		{
			this._compositeCanvas.width = this._width;
			this._compositeCanvas.height = this._height;
			
			if (this._compositeCanvasMetrics == null)
				this._compositeCanvasMetrics = new DrawMetrics();
			
			this._compositeCanvasMetrics._x = 0;
			this._compositeCanvasMetrics._y = 0;
			this._compositeCanvasMetrics._width = this._width;
			this._compositeCanvasMetrics._height = this._height;
			
			//Expand the redraw region to this whole canvas.
			if (this._redrawRegionMetrics == null)
				this._redrawRegionMetrics = this._compositeCanvasMetrics.clone();
			else
				this._redrawRegionMetrics.mergeExpand(this._compositeCanvasMetrics);
		}
	};	

//@private (recursive function)	
CanvasManager.prototype._validateRedrawRegion = 
	function (element, forceRegionUpdate)
	{
		var newCompositeMetrics = [];
		var oldVisible = element._renderVisible;
		
		//Get new visibility
		var newVisible = true;
		if ((element._parent != null && element._parent._renderVisible == false) || 
			element.getStyle("Visible") == false || 
			element.getStyle("Alpha") <= 0)
		{
			newVisible = false;
		}
		
		//Composite effect on this element changed, we *must* update the region on ourself and all of our children.
		if (element._compositeEffectChanged == true)
			forceRegionUpdate = true;
		
		//Wipe out the composite metrics (rebuild as we recurse children if we're a composite layer)
		element._compositeVisibleMetrics = null;
		element._transformVisibleMetrics = null;
		element._transformDrawableMetrics = null;
		
		if ((element._renderChanged == true || element._graphicsClear == false) &&
			(oldVisible == true || newVisible == true))
		{
			var parent = element;
			var rawMetrics = element.getMetrics();		//Transformed via points up parent chain
			
			var drawableMetrics = rawMetrics.clone();	//Transformed via metrics up parent chain (recalculated each layer, expands, and clips)
			
			//Used for transforming the raw metrics up the parent chain.
			var pointRawTl = {x:rawMetrics._x, y:rawMetrics._y};
			var pointRawTr = {x:rawMetrics._x + rawMetrics._width, y:rawMetrics._y};
			var pointRawBr = {x:rawMetrics._x + rawMetrics._width, y:rawMetrics._y + rawMetrics._height};
			var pointRawBl = {x:rawMetrics._x, y:rawMetrics._y + rawMetrics._height};
			
			var pointDrawableTl = {x:0, y:0};
			var pointDrawableTr = {x:0, y:0};
			var pointDrawableBr = {x:0, y:0};
			var pointDrawableBl = {x:0, y:0};
			
			var minX = null;
			var maxX = null;
			var minY = null;
			var maxY = null;
			
			//Cached storage of previous metrics per composite parent.
			var oldMetrics = null;	//{element:element, metrics:DrawMetrics, drawableMetrics:DrawMetrics}
			
			var clipMetrics = new DrawMetrics();
			var shadowMetrics = new DrawMetrics();
			var shadowSize = 0;
			
			var drawableMetricsChanged = false;
			var rawMetricsChanged = false;
			
			//Walk up the parent chain invalidating the redraw region and updating _compositeVisibleMetrics
			while (parent != null)
			{
				//Apply clipping to drawable metrics (Always clip root manager)
				if (drawableMetrics != null && (parent == this || parent.getStyle("ClipContent") == true))
				{
					//Clip metrics relative to current element
					clipMetrics._x = 0;
					clipMetrics._y = 0;
					clipMetrics._width = parent._width;
					clipMetrics._height = parent._height;
					
					//Reduce drawable metrics via clipping metrics.
					drawableMetrics.mergeReduce(clipMetrics);
					
					//Kill metrics if completely clipped
					if (drawableMetrics._width <= 0 || drawableMetrics._height <= 0)
						drawableMetrics = null;
				}
				
				//Update redraw region, _compositeVisibleMetrics, and record new stored composite metrics.
				if (parent._isCompositeElement() == true)
				{
					oldMetrics = element._getCompositeMetrics(parent);
					
					if (drawableMetrics != null && newVisible == true && element._graphicsClear == false)
					{
						newCompositeMetrics.push({element:parent, metrics:rawMetrics.clone(), drawableMetrics:drawableMetrics.clone()});
						
						//Update composite parents visible metrics
						if (parent._compositeVisibleMetrics == null)
							parent._compositeVisibleMetrics = drawableMetrics.clone();
						else
							parent._compositeVisibleMetrics.mergeExpand(drawableMetrics);
					}
					else
						newMetrics = null;
					
					drawableMetricsChanged = true;
					if ((oldMetrics == null && drawableMetrics == null) ||
						(oldMetrics != null && drawableMetrics != null && oldMetrics.drawableMetrics.equals(drawableMetrics) == true))
					{
						drawableMetricsChanged = false;
					}
					
					rawMetricsChanged = true;
					if (oldMetrics != null && oldMetrics.metrics.equals(rawMetrics) == true)
					{
						rawMetricsChanged = false;
					}
					
					//Update the composite element's redraw region
					if (forceRegionUpdate == true || 			//Composite effect changed	
						element._renderChanged == true ||		//Render changed
						oldVisible != newVisible ||				//Visible changed
						drawableMetricsChanged == true ||		//Drawable region changed (clipping)
						rawMetricsChanged)						//Position changed
					{
						//If was visible, redraw old metrics
						if (oldVisible == true && oldMetrics != null)
							parent._updateRedrawRegion(oldMetrics.drawableMetrics);
						
						//Redraw new metrics
						if (newVisible == true)
							parent._updateRedrawRegion(drawableMetrics);
					}
				}				
				
				//Drawable metrics will be null if we've been completely clipped. No reason to do any more translation.
				if (drawableMetrics != null)
				{	//Fix current metrics so that we're now relative to our parent.
					
					//Update position
					
					//Drawable metrics////
					drawableMetrics._x += parent._x;
					drawableMetrics._y += parent._y;
					
					shadowSize = parent.getStyle("ShadowSize");
					
					//Expand metrics for shadow
					if (shadowSize > 0 && parent.getStyle("ShadowColor") != null)
					{
						//Copy drawable metrics
						shadowMetrics.copyFrom(drawableMetrics);
						
						//Create shadow position metrics
						shadowMetrics._width += (shadowSize * 2);
						shadowMetrics._height += (shadowSize * 2);
						shadowMetrics._x -= shadowSize;
						shadowMetrics._y -= shadowSize;
						shadowMetrics._x += parent.getStyle("ShadowOffsetX");
						shadowMetrics._y += parent.getStyle("ShadowOffsetY");
						
						//Merge the shadow metrics with the drawable metrics
						drawableMetrics.mergeExpand(shadowMetrics);
						
						//Handle transform
						if (CanvasElement.normalizeDegrees(parent._rotateDegrees) != 0)
						{
							//Transform drawable metrics/////////////
							pointDrawableTl.x = drawableMetrics._x;
							pointDrawableTl.y = drawableMetrics._y;
							
							pointDrawableTr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableTr.y = drawableMetrics._y;
							
							pointDrawableBr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableBr.y = drawableMetrics._y + drawableMetrics._height;
							
							pointDrawableBl.x = drawableMetrics._x;
							pointDrawableBl.y = drawableMetrics._y + drawableMetrics._height;
							
							parent.rotatePoint(pointDrawableTl, false);
							parent.rotatePoint(pointDrawableTr, false);
							parent.rotatePoint(pointDrawableBl, false);
							parent.rotatePoint(pointDrawableBr, false);
							
							minX = Math.min(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							maxX = Math.max(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							minY = Math.min(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							maxY = Math.max(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							
							drawableMetrics._x = minX;
							drawableMetrics._y = minY;
							drawableMetrics._width = maxX - minX;
							drawableMetrics._height = maxY - minY;
						}
						
						//Use drawable metrics as the new raw metrics (shadow uses context of parent applying shadow)
						rawMetrics.copyFrom(drawableMetrics);
						
						pointRawTl.x += rawMetrics._x;
						pointRawTl.y += rawMetrics._y;
						
						pointRawTr.x += rawMetrics._x + rawMetrics._width;
						pointRawTr.y += rawMetrics._y;
						
						pointRawBr.x += rawMetrics._x + rawMetrics._width;
						pointRawBr.y += rawMetrics._y + rawMetrics._height;
						
						pointRawBl.x += rawMetrics._x;
						pointRawBl.y += rawMetrics._y + rawMetrics._height;
					}
					else
					{
						//Raw metrics
						pointRawTl.x += parent._x;
						pointRawTl.y += parent._y;
						
						pointRawTr.x += parent._x;
						pointRawTr.y += parent._y;
						
						pointRawBr.x += parent._x;
						pointRawBr.y += parent._y;
						
						pointRawBl.x += parent._x;
						pointRawBl.y += parent._y;
						
						//Handle transform
						if (CanvasElement.normalizeDegrees(parent._rotateDegrees) != 0)
						{
							//Rotate raw metrics points
							parent.rotatePoint(pointRawTl, false);
							parent.rotatePoint(pointRawTr, false);
							parent.rotatePoint(pointRawBl, false);
							parent.rotatePoint(pointRawBr, false);
							
							//Transform drawable metrics/////////////
							pointDrawableTl.x = drawableMetrics._x;
							pointDrawableTl.y = drawableMetrics._y;
							
							pointDrawableTr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableTr.y = drawableMetrics._y;
							
							pointDrawableBr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableBr.y = drawableMetrics._y + drawableMetrics._height;
							
							pointDrawableBl.x = drawableMetrics._x;
							pointDrawableBl.y = drawableMetrics._y + drawableMetrics._height;
							
							parent.rotatePoint(pointDrawableTl, false);
							parent.rotatePoint(pointDrawableTr, false);
							parent.rotatePoint(pointDrawableBl, false);
							parent.rotatePoint(pointDrawableBr, false);
							
							minX = Math.min(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							maxX = Math.max(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							minY = Math.min(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							maxY = Math.max(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							
							drawableMetrics._x = minX;
							drawableMetrics._y = minY;
							drawableMetrics._width = maxX - minX;
							drawableMetrics._height = maxY - minY;
							/////////////////////////////////////
						}
						
						//Update transformed raw metrics
						minX = Math.min(pointRawTl.x, pointRawTr.x, pointRawBr.x, pointRawBl.x);
						maxX = Math.max(pointRawTl.x, pointRawTr.x, pointRawBr.x, pointRawBl.x);
						minY = Math.min(pointRawTl.y, pointRawTr.y, pointRawBr.y, pointRawBl.y);
						maxY = Math.max(pointRawTl.y, pointRawTr.y, pointRawBr.y, pointRawBl.y);
						
						rawMetrics._x = minX;
						rawMetrics._y = minY;
						rawMetrics._width = maxX - minX;
						rawMetrics._height = maxY - minY;
					}
					
					//Reduce the precision (random rounding errors at *very* high decimal points)
					rawMetrics.roundToPrecision(3);
					
					//Reduce drawable metrics via raw metrics.
					drawableMetrics.mergeReduce(rawMetrics);
					
					//Reduce the precision (random rounding errors at *very* high decimal points)
					drawableMetrics.roundToPrecision(3);
				}
				
				parent = parent._parent;
			}
		}
		
		element._compositeMetrics = newCompositeMetrics;
		element._renderVisible = newVisible;
		element._renderChanged = false;
		
		//Recurse children if we were or are visible.
		if (oldVisible == true || newVisible == true)
		{
			for (var i = 0; i < element._children.length; i++)
				this._validateRedrawRegion(element._children[i], forceRegionUpdate);
			
			if (element._isCompositeElement() == true)
				this._updateTransformMetrics(element);
		}
	};
	
CanvasManager.prototype._updateTransformMetrics = 
	function(compositeElement)
	{
		//No transform of root manager, or invisible layers.
		if (compositeElement == this || compositeElement._compositeVisibleMetrics == null)
			return;
		
		var pointTl = {x:0, y:0};
		var pointTr = {x:0, y:0};
		var pointBr = {x:0, y:0};
		var pointBl = {x:0, y:0};
		
		var minX = null;
		var maxX = null;
		var minY = null;
		var maxY = null;
		
		var shadowSize = 0;
		
		var parent = compositeElement;
		compositeElement._transformVisibleMetrics = compositeElement._compositeVisibleMetrics.clone();
		compositeElement._transformDrawableMetrics = compositeElement._compositeVisibleMetrics.clone();
		
		var clipMetrics = new DrawMetrics();
		var done = false;
		
		while (true)
		{
			if (compositeElement._transformDrawableMetrics != null && parent.getStyle("ClipContent") == true)
			{
				//Clip metrics relative to current element
				clipMetrics._x = 0;
				clipMetrics._y = 0;
				clipMetrics._width = parent._width;
				clipMetrics._height = parent._height;
				
				//Reduce drawable metrics via clipping metrics.
				compositeElement._transformDrawableMetrics.mergeReduce(clipMetrics);
				
				//Kill metrics if completely clipped
				if (compositeElement._transformDrawableMetrics._width <= 0 || compositeElement._transformDrawableMetrics._height <= 0)
				{
					compositeElement._transformDrawableMetrics = null;
					compositeElement._transformVisibleMetrics = null;
					
					return;
				}
			}
			
			if (done == true)
				break;
			
			compositeElement._transformVisibleMetrics._x += parent._x;
			compositeElement._transformVisibleMetrics._y += parent._y;
			
			compositeElement._transformDrawableMetrics._x += parent._x;
			compositeElement._transformDrawableMetrics._y += parent._y;

			shadowSize = parent.getStyle("ShadowSize");
			
			//Expand metrics for shadow
			if (shadowSize > 0 && parent.getStyle("ShadowColor") != null)
			{
				//Copy drawable metrics
				var shadowMetrics = compositeElement._transformDrawableMetrics.clone();
				
				//Create shadow position metrics
				shadowMetrics._width += (shadowSize * 2);
				shadowMetrics._height += (shadowSize * 2);
				shadowMetrics._x -= shadowSize;
				shadowMetrics._y -= shadowSize;
				shadowMetrics._x += parent.getStyle("ShadowOffsetX");
				shadowMetrics._y += parent.getStyle("ShadowOffsetY");
				
				//Merge the shadow metrics with the drawable metrics
				compositeElement._transformDrawableMetrics.mergeExpand(shadowMetrics);
			}
			
			if (CanvasElement.normalizeDegrees(parent._rotateDegrees) != 0)
			{
				//Transform visible
				pointTl.x = compositeElement._transformVisibleMetrics._x;
				pointTl.y = compositeElement._transformVisibleMetrics._y;
				
				pointTr.x = compositeElement._transformVisibleMetrics._x + compositeElement._transformVisibleMetrics._width;
				pointTr.y = compositeElement._transformVisibleMetrics._y;

				pointBr.x = compositeElement._transformVisibleMetrics._x + compositeElement._transformVisibleMetrics._width;
				pointBr.y = compositeElement._transformVisibleMetrics._y + compositeElement._transformVisibleMetrics._height;
				
				pointBl.x = compositeElement._transformVisibleMetrics._x;
				pointBl.y = compositeElement._transformVisibleMetrics._y + compositeElement._transformVisibleMetrics._height;
				
				parent.rotatePoint(pointTl, false);
				parent.rotatePoint(pointTr, false);
				parent.rotatePoint(pointBl, false);
				parent.rotatePoint(pointBr, false);
				
				minX = Math.min(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				maxX = Math.max(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				minY = Math.min(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				maxY = Math.max(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				
				compositeElement._transformVisibleMetrics._x = minX;
				compositeElement._transformVisibleMetrics._y = minY;
				compositeElement._transformVisibleMetrics._width = maxX - minX;
				compositeElement._transformVisibleMetrics._height = maxY - minY;
				
				compositeElement._transformVisibleMetrics.roundToPrecision(3);
				
				//Transform Drawable
				pointTl.x = compositeElement._transformDrawableMetrics._x;
				pointTl.y = compositeElement._transformDrawableMetrics._y;
				
				pointTr.x = compositeElement._transformDrawableMetrics._x + compositeElement._transformDrawableMetrics._width;
				pointTr.y = compositeElement._transformDrawableMetrics._y;
				
				pointBr.x = compositeElement._transformDrawableMetrics._x + compositeElement._transformDrawableMetrics._width;
				pointBr.y = compositeElement._transformDrawableMetrics._y + compositeElement._transformDrawableMetrics._height;
				
				pointBl.x = compositeElement._transformDrawableMetrics._x;
				pointBl.y = compositeElement._transformDrawableMetrics._y + compositeElement._transformDrawableMetrics._height;
				
				parent.rotatePoint(pointTl, false);
				parent.rotatePoint(pointTr, false);
				parent.rotatePoint(pointBl, false);
				parent.rotatePoint(pointBr, false);
				
				minX = Math.min(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				maxX = Math.max(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				minY = Math.min(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				maxY = Math.max(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				
				compositeElement._transformDrawableMetrics._x = minX;
				compositeElement._transformDrawableMetrics._y = minY;
				compositeElement._transformDrawableMetrics._width = maxX - minX;
				compositeElement._transformDrawableMetrics._height = maxY - minY;
				
				compositeElement._transformDrawableMetrics.roundToPrecision(3);
			}
			
			parent = parent._parent;
			
			if (parent._isCompositeElement() == true)
				done = true;
		}
	};
	
//@override (add redraw region visibility)	
CanvasManager.prototype._validateCompositeRender =
	function ()
	{
		if (this.getStyle("ShowRedrawRegion") == true)
		{
			var currentRegion = null;
			if (this._redrawRegionMetrics != null)
			{
				currentRegion = this._redrawRegionMetrics.clone();
				currentRegion._x -= 1;
				currentRegion._y -= 1;
				currentRegion._width += 2;
				currentRegion._height += 2;
				currentRegion.roundUp();
				
				//Expand the redraw region to this whole canvas.
				if (this._redrawRegionPrevMetrics != null)
					this._redrawRegionMetrics.mergeExpand(this._redrawRegionPrevMetrics);
			}
			else if (this._redrawRegionPrevMetrics != null)
				this._redrawRegionMetrics = this._redrawRegionPrevMetrics.clone();
			
			CanvasManager.base.prototype._validateCompositeRender.call(this);
			
			if (currentRegion != null)
			{
				this._canvasContext.lineWidth = 1;
				this._canvasContext.strokeStyle = "#FF0000";
				
				this._canvasContext.beginPath();
				this._canvasContext.moveTo(currentRegion._x + .5, currentRegion._y + .5);
				this._canvasContext.lineTo(currentRegion._x + currentRegion._width - .5, currentRegion._y + .5);
				this._canvasContext.lineTo(currentRegion._x + currentRegion._width - .5, currentRegion._y + currentRegion._height - .5);
				this._canvasContext.lineTo(currentRegion._x + .5, currentRegion._y + currentRegion._height - .5);
				this._canvasContext.closePath();
				this._canvasContext.stroke();	
			}
			
			this._redrawRegionPrevMetrics = currentRegion;
		}
		else
		{
			CanvasManager.base.prototype._validateCompositeRender.call(this);
			this._redrawRegionPrevMetrics = null;
		}
	};	
	
//@private	
CanvasManager.prototype._updateFocusElement = 
	function (newFocusElement, renderFocusRing)
	{
		if (newFocusElement != this._focusElement)
		{
			if (this._focusElement != null)
			{
				this._focusElement._isFocused = false;
				this._focusElement._setRenderFocusRing(false);
				
				if (this._focusElement.hasEventListener("focusout", null) == true)
					this._focusElement._dispatchEvent(new ElementEvent("focusout", false));
			}
			
			this._focusElement = newFocusElement;
			
			if (this._focusElement != null)
			{
				this._focusElement._isFocused = true;
				this._focusElement._setRenderFocusRing(renderFocusRing);
				
				if (this._focusElement.hasEventListener("focusin", null) == true)
					this._focusElement._dispatchEvent(new ElementEvent("focusin", false));
			}
		}
	};
	
//@private	
CanvasManager.prototype._findChildTabStopForward = 
	function (parent, afterChild)
	{
		var index = 0;
		if (afterChild != null)
			index = parent._children.indexOf(afterChild) + 1;
		
		var tabToElement = null;
		
		for (var i = index; i < parent._children.length; i++)
		{
			if (parent._children[i].getStyle("MouseEnabled") == false ||
				parent._children[i].getStyle("Visible") == false || 
				parent._children[i].getStyle("Enabled") == false)
				continue;
			
			if (parent._children[i].getStyle("TabStop") >= 0)
				return parent._children[i];
			
			tabToElement = this._findChildTabStopForward(parent._children[i], null);
			if (tabToElement != null)
				return tabToElement;
		}
		
		return tabToElement;
	};

//@private	
CanvasManager.prototype._findChildTabStopReverse = 
	function (parent, beforeChild, lastTabStopElement)
	{
		var index = parent._children.length - 1;
		if (beforeChild != null)
			index = parent._children.indexOf(beforeChild) - 1;
		
		for (var i = index; i >= 0; i--)
		{
			if (parent._children[i].getStyle("MouseEnabled") == false ||
				parent._children[i].getStyle("Visible") == false || 
				parent._children[i].getStyle("Enabled") == false)
				continue;
			
			if (parent._children[i].getStyle("TabStop") >= 0)
				lastTabStopElement = parent._children[i];
			
			this._findChildTabStopReverse(parent._children[i], null, lastTabStopElement);
			
			if (lastTabStopElement != null)
				return lastTabStopElement;
		}
		
		return lastTabStopElement;
	};	
	
//@private	
CanvasManager.prototype._updateCursor = 
	function ()
	{
		var cursorDefinition = null;
		if (this._cursorChain.back != null)
			cursorDefinition = this._cursorChain.back.data;
		
		var displayedCursorElement = null;
		if (this._cursorContainer._getNumChildren() > 0)
			displayedCursorElement = this._cursorContainer._getChildAt(0);
		
		if (cursorDefinition != null)
		{
			var cursorElement = null;
			if (!(typeof cursorDefinition === "string" || cursorDefinition instanceof String))
			{
				var cursorClass = cursorDefinition.getStyle("CursorClass");
				
				if (cursorClass == null)
					cursorDefinition._cursorElement = null;
				else
				{
					if (cursorDefinition._cursorElement == null || 
						cursorDefinition._cursorElement.constructor != cursorClass)
					{
						cursorDefinition._cursorElement = new (cursorClass)();
						cursorDefinition._cursorElement.setStyleDefinitions(cursorDefinition.getStyle("CursorStyle"));
					}
					else
						cursorDefinition._cursorElement.setStyleDefinitions(cursorDefinition.getStyle("CursorStyle"));
					
					cursorElement = cursorDefinition._cursorElement;
				}
			}
			
			if (displayedCursorElement != cursorElement)
			{
				if (displayedCursorElement != null)
					this._cursorContainer._removeChild(displayedCursorElement);
				if (cursorElement != null)
					this._cursorContainer._addChild(cursorElement);
			}
			
			if (cursorElement != null)
			{
				if (this._browserCursor != "none")
				{
					this._browserCursor = "none";
					this._canvas.style.cursor = "none";
				}
					
				//Make visible if we're over canvas			
				if (this._mouseX >= 0 && this._mouseX <= this._width &&
					this._mouseY >= 0 && this._mouseY <= this._height)
				{
					var cursorWidth = cursorDefinition._cursorElement._getStyledOrMeasuredWidth();
					var cursorHeight = cursorDefinition._cursorElement._getStyledOrMeasuredHeight();
					var offsetX = cursorDefinition.getStyle("CursorOffsetX");
					var offsetY = cursorDefinition.getStyle("CursorOffsetY");
					
					cursorElement._setActualPosition(this._mouseX + offsetX, this._mouseY + offsetY);
					cursorElement._setActualSize(cursorWidth, cursorHeight);
					cursorElement.setStyle("Visible", true);
				}
				else //Hide' mouse is no longer over canvas
					cursorElement.setStyle("Visible", false);
			}
			else if (this._browserCursor != cursorDefinition)
			{
				this._browserCursor = cursorDefinition;
				this._canvas.style.cursor = cursorDefinition;
			}
		}
		else
		{
			if (displayedCursorElement != null)
				this._cursorContainer._removeChildAt(0);
			
			if (this._browserCursor != "default")
			{
				this._browserCursor = "default";
				this._canvas.style.cursor = "default";
			}
		}
	};
	
//@private	
CanvasManager.prototype._onCursorDefinitionStyleChanged = 
	function (styleChangedEvent)
	{
		var cursorDefinition = styleChangedEvent.getTarget();
		
		var styleName = styleChangedEvent.getStyleName();
		if (styleName == "CursorClass" && cursorDefinition._cursorElement != null)
		{
			var cursorClass = cursorDefinition.getStyle("CursorClass");
			if (cursorDefinition._cursorElement.constructor != cursorClass)
				cursorDefinition._cursorElement = null;
		}
		if (styleName == "CursorStyle" && cursorDefinition._cursorElement != null)
			cursorDefinition._cursorElement.setStyleDefinitions(this.getStyle("CursorStyle"));
		
		this._updateCursor();
	};
	
//@private	
CanvasManager.prototype._pushAddRemoveDisplayChainQueue = 
	function (element, type)
	{
		var node = new CmLinkedNode();
		node.data = {element:element, type:type};
		
		this._addRemoveDisplayChainQueue.pushBack(node);
	};

//@private	
CanvasManager.prototype._popAddRemoveDisplayChainQueue = 
	function ()
	{
		if (this._addRemoveDisplayChainQueue.length == 0)
			return null;
		
		var data = this._addRemoveDisplayChainQueue.front.data;
		this._addRemoveDisplayChainQueue.removeNode(this._addRemoveDisplayChainQueue.front);
		
		return data;
	};

//@private	
CanvasManager.prototype._processAddRemoveDisplayChainQueue = 
	function ()
	{
		//Recursion guard. An event may add or remove other elements, we dont want this function to recurse.
		if (this._addRemoveDisplayChainQueueProcessing == true)
			return;
		
		//Block recursion
		this._addRemoveDisplayChainQueueProcessing = true;
		
		var addRemoveData = this._popAddRemoveDisplayChainQueue();
		while (addRemoveData != null)
		{
			addRemoveData.element._dispatchEvent(new AddedRemovedEvent(addRemoveData.type, this));
			addRemoveData = this._popAddRemoveDisplayChainQueue();
		}
		
		//Queue emtpy, allow processing again.
		this._addRemoveDisplayChainQueueProcessing = false;
	};

//@private	
CanvasManager.prototype._clearDraggingElement = 
	function ()
	{
		if (this._draggingElement == null)
			return;

		this._draggingElement = null;
		this._draggingOffsetX = null;
		this._draggingOffsetY = null;
	};

//@private	
CanvasManager.prototype._setDraggingElement = 
	function (element, offsetX, offsetY)
	{
		if (this._draggingElement != null)
			return;

		this._draggingElement = element;
		this._draggingOffsetX = offsetX;
		this._draggingOffsetY = offsetY;
	};
	
//@Override	
CanvasManager.prototype._doLayout = 
function (paddingMetrics)
{
	CanvasManager.base.prototype._doLayout.call(this, paddingMetrics);
	
	this._cursorContainer._setActualSize(this._width, this._height);
};	



//////////Private Helper Classes////////////////////

//Used exclusively by CanvasManager//

//Queue used for processing component cycles (styles, measure, layout) based on display chain depth.
function CmDepthQueue()
{
	this.depthArrayOfLists = []; //Array of CmLinkedList, index based on depth.
	this.length = 0;
	
	//Stores current start/end populated indexes of depthArrayOfLists for performance.
	this.minDepth = -1;
	this.maxDepth = -1;
}

CmDepthQueue.prototype.addNode = 
	function (node, depth)
	{
		var depthToIndex = depth - 1;
	
		if (this.depthArrayOfLists[depthToIndex] == null)
			this.depthArrayOfLists[depthToIndex] = new CmLinkedList();
		
		this.depthArrayOfLists[depthToIndex].pushBack(node);
		
		this.length = this.length + 1;
		
		if (depthToIndex < this.minDepth || this.minDepth == -1)
			this.minDepth = depthToIndex;
		if (depthToIndex > this.maxDepth)
			this.maxDepth = depthToIndex;
	};
	
CmDepthQueue.prototype.removeNode = 
	function (node, depth)
	{
		var depthToIndex = depth - 1; 
	
		this.depthArrayOfLists[depthToIndex].removeNode(node);
		
		this.length = this.length - 1;
		if (this.length == 0)
		{
			this.minDepth = -1;
			this.maxDepth = -1;
		}
	};
	
CmDepthQueue.prototype.removeSmallest = 
	function ()
	{
		if (this.length == 0)
			return null;
		
		for (var i = this.minDepth; i < this.depthArrayOfLists.length; i++)
		{
			this.minDepth = i;
			if (this.depthArrayOfLists[i] == null || this.depthArrayOfLists[i].length == 0)
				continue;
			
			var node = this.depthArrayOfLists[i].front;
			this.depthArrayOfLists[i].removeNode(node);
			
			this.length = this.length - 1;
			if (this.length == 0)
			{
				this.minDepth = -1;
				this.maxDepth = -1;
			}
			
			return node;
		}
	};
	
CmDepthQueue.prototype.removeLargest = 
	function ()
	{
		if (this.length == 0)
			return null;
		
		for (var i = this.maxDepth; i >= 0; i--)
		{
			this.maxDepth = i;
			if (this.depthArrayOfLists[i] == null || this.depthArrayOfLists[i].length == 0)
				continue;
			
			var node = this.depthArrayOfLists[i].back;
			this.depthArrayOfLists[i].removeNode(node);
			
			this.length = this.length - 1;
			if (this.length == 0)
			{
				this.minDepth = -1;
				this.maxDepth = -1;
			}
			
			return node;
		}
	};
	
//Basic linked list	
function CmLinkedList()
{
	this.front = null;
	this.back = null;
	
	this.length = 0;
}

CmLinkedList.prototype.pushFront = 
	function (cmLinkedNode)
	{
		this.length++;
		
		if (this.front == null)
		{
			cmLinkedNode.prev = null;
			cmLinkedNode.next = null;
			
			this.front = cmLinkedNode;
			this.back = cmLinkedNode;
		}
		else
		{
			cmLinkedNode.prev = null;
			cmLinkedNode.next = this.front;
			
			this.front.prev = cmLinkedNode;
			this.front = cmLinkedNode;
		}
	};
	
CmLinkedList.prototype.pushBack =
	function (cmLinkedNode)
	{
		this.length++;
	
		if (this.back == null)
		{
			cmLinkedNode.prev = null;
			cmLinkedNode.next = null;
			
			this.front = cmLinkedNode;
			this.back = cmLinkedNode;
		}
		else
		{
			cmLinkedNode.prev = this.back;
			cmLinkedNode.next = null;
			
			this.back.next = cmLinkedNode;
			this.back = cmLinkedNode;
		}
	};

CmLinkedList.prototype.insertBefore = 
	function (cmLinkedNode, beforeCmLinkedNode)	
	{
		this.length++;
		
		if (this.front == beforeCmLinkedNode)
			this.front = cmLinkedNode;
		
		if (beforeCmLinkedNode.prev != null)
			beforeCmLinkedNode.prev.next = cmLinkedNode;
		
		cmLinkedNode.prev = beforeCmLinkedNode.prev;
		cmLinkedNode.next = beforeCmLinkedNode;
		beforeCmLinkedNode.prev = cmLinkedNode;
	};

CmLinkedList.prototype.insertAfter = 
	function (cmLinkedNode, afterCmLinkedNode)
	{
		this.length++;
		
		if (this.back == afterCmLinkedNode)
			this.back = cmLinkedNode;
		
		if (afterCmLinkedNode.next != null)
			afterCmLinkedNode.next.prev = cmLinkedNode;
		
		cmLinkedNode.next = afterCmLinkedNode.next;
		cmLinkedNode.prev = afterCmLinkedNode;
		afterCmLinkedNode.next = cmLinkedNode;		
	};
	
CmLinkedList.prototype.removeNode = 
	function (cmLinkedNode)
	{
		if (cmLinkedNode == null)
			return null;
		
		this.length--;
		
		if (this.front == cmLinkedNode)
			this.front = cmLinkedNode.next;
		if (this.back == cmLinkedNode)
			this.back = cmLinkedNode.prev;
		
		if (cmLinkedNode.prev != null)
			cmLinkedNode.prev.next = cmLinkedNode.next;
		if (cmLinkedNode.next != null)
			cmLinkedNode.next.prev = cmLinkedNode.prev;
		
		cmLinkedNode.next = null;
		cmLinkedNode.prev = null;
	};
	
//Linked list iterator	
function CmLinkedNode()
{
	this.prev = null;
	this.next = null;
	
	this.data = null;
}




var $jscomp={scope:{}};$jscomp.defineProperty="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){if(c.get||c.set)throw new TypeError("ES3 does not support getters and setters.");a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};$jscomp.polyfill("Array.prototype.fill",function(a){return a?a:function(a,c,d){var b=this.length||0;0>c&&(c=Math.max(0,b+c));if(null==d||d>b)d=b;d=Number(d);0>d&&(d=Math.max(0,b+d));for(c=Number(c||0);c<d;c++)this[c]=a;return this}},"es6-impl","es3");
function Tween(){this.duration=this.endVal=this.startVal=0;this.easingFunction=this.startTime=null}Tween.prototype.constructor=Tween;Tween.prototype.getProgress=function(a){return a>=this.startTime+this.duration?1:a<=this.startTime?0:(a-this.startTime)/this.duration};
Tween.prototype.getValue=function(a){a=this.getProgress(a);if(1==a)return this.endVal;if(0==a)return this.startVal;null!=this.easingFunction&&(a=this.easingFunction(a));var b=Math.abs(this.endVal-this.startVal);return this.startVal<this.endVal?this.startVal+b*a:this.startVal-b*a};Tween.easeInQuad=function(a){return a*a};Tween.easeOutQuad=function(a){return 1-Tween.easeInQuad(1-a)};Tween.easeInOutQuad=function(a){return.5>a?Tween.easeInQuad(2*a)/2:1-Tween.easeInQuad(2*(1-a))/2};
Tween.easeInCubic=function(a){return Math.pow(a,3)};Tween.easeOutCubic=function(a){return 1-Tween.easeInCubic(1-a)};Tween.easeInOutCubic=function(a){return.5>a?Tween.easeInCubic(2*a)/2:1-Tween.easeInCubic(2*(1-a))/2};Tween.easeOutSine=function(a){return Math.sin(Math.PI/2*a)};Tween.easeInSine=function(a){return 1-Tween.easeOutSine(1-a)};Tween.easeInOutSine=function(a){return.5>a?Tween.easeInSine(2*a)/2:1-Tween.easeInSine(2*(1-a))/2};function StyleProxy(a,b){this._proxyElement=a;this._proxyMap=b}
StyleProxy.prototype.constructor=StyleProxy;function DispatcherEvent(a){this._type=a;this._target=null;this._canceled=!1}DispatcherEvent.prototype.constructor=DispatcherEvent;DispatcherEvent.prototype.getType=function(){return this._type};DispatcherEvent.prototype.getTarget=function(){return this._target};DispatcherEvent.prototype.cancelEvent=function(){this._canceled=!0};DispatcherEvent.prototype.getIsCanceled=function(){return this._canceled};
DispatcherEvent.prototype.clone=function(){var a=this._cloneInstance();a._target=this._target;a._canceled=this._canceled;return a};DispatcherEvent.prototype._cloneInstance=function(){return new DispatcherEvent(this._type)};function StyleChangedEvent(a){StyleChangedEvent.base.prototype.constructor.call(this,"stylechanged");this._styleName=a}StyleChangedEvent.prototype=Object.create(DispatcherEvent.prototype);StyleChangedEvent.prototype.constructor=StyleChangedEvent;StyleChangedEvent.base=DispatcherEvent;
StyleChangedEvent.prototype.getStyleName=function(){return this._styleName};StyleChangedEvent.prototype.clone=function(){return StyleChangedEvent.base.prototype.clone.call(this)};StyleChangedEvent.prototype._cloneInstance=function(){return new StyleChangedEvent(this._styleName,this._oldValue,this._newValue)};function ElementEvent(a,b){ElementEvent.base.prototype.constructor.call(this,a);this._currentTarget=null;this._bubbles=b;this._phase=null;this._defaultPrevented=!1}ElementEvent.prototype=Object.create(DispatcherEvent.prototype);
ElementEvent.prototype.constructor=ElementEvent;ElementEvent.base=DispatcherEvent;ElementEvent.prototype.getCurrentTarget=function(){return this._currentTarget};ElementEvent.prototype.getPhase=function(){return this._phase};ElementEvent.prototype.preventDefault=function(){this._defaultPrevented=!0};ElementEvent.prototype.getDefaultPrevented=function(){return this._defaultPrevented};
ElementEvent.prototype.clone=function(){var a=ElementEvent.base.prototype.clone.call(this);a._currentTarget=this._currentTarget;a._phase=this._phase;a._defaultPrevented=this._defaultPrevented;a._bubbles=this._bubbles;return a};ElementEvent.prototype._cloneInstance=function(){return new ElementEvent(this._type,this._bubbles)};function ElementMouseEvent(a,b,c){ElementMouseEvent.base.prototype.constructor.call(this,a,!0);this._x=b;this._y=c}ElementMouseEvent.prototype=Object.create(ElementEvent.prototype);
ElementMouseEvent.prototype.constructor=ElementMouseEvent;ElementMouseEvent.base=ElementEvent;ElementMouseEvent.prototype.getX=function(){return this._x};ElementMouseEvent.prototype.getY=function(){return this._y};ElementMouseEvent.prototype.clone=function(){return ElementMouseEvent.base.prototype.clone.call(this)};ElementMouseEvent.prototype._cloneInstance=function(){return new ElementMouseEvent(this._type,this._x,this._y)};
function ElementMouseWheelEvent(a,b,c,d){ElementMouseWheelEvent.base.prototype.constructor.call(this,"wheel",a,b);this._deltaX=c;this._deltaY=d}ElementMouseWheelEvent.prototype=Object.create(ElementMouseEvent.prototype);ElementMouseWheelEvent.prototype.constructor=ElementMouseWheelEvent;ElementMouseWheelEvent.base=ElementMouseEvent;ElementMouseWheelEvent.prototype.getDeltaX=function(){return this._deltaX};ElementMouseWheelEvent.prototype.getDeltaY=function(){return this._deltaY};
ElementMouseWheelEvent.prototype.clone=function(){return ElementMouseWheelEvent.base.prototype.clone.call(this)};ElementMouseWheelEvent.prototype._cloneInstance=function(){return new ElementMouseWheelEvent(this._x,this._y,this._deltaX,this._deltaY)};function ElementListItemClickEvent(a,b){ElementListItemClickEvent.base.prototype.constructor.call(this,"listitemclick",!1);this._item=a;this._index=b}ElementListItemClickEvent.prototype=Object.create(ElementEvent.prototype);
ElementListItemClickEvent.prototype.constructor=ElementListItemClickEvent;ElementListItemClickEvent.base=ElementEvent;ElementListItemClickEvent.prototype.getItem=function(){return this._item};ElementListItemClickEvent.prototype.getIndex=function(){return this._index};ElementListItemClickEvent.prototype.clone=function(){return ElementListItemClickEvent.base.prototype.clone.call(this)};ElementListItemClickEvent.prototype._cloneInstance=function(){return new ElementListItemClickEvent(this._item,this._index)};
function ElementKeyboardEvent(a,b,c,d,e,f,g){ElementKeyboardEvent.base.prototype.constructor.call(this,a,!0);"Spacebar"==b?b=" ":"Left"==b?b="ArrowLeft":"Right"==b?b="ArrowRight":"Del"==b&&(b="Delete");this._key=b;this._keyCode=c;this._ctrl=d;this._alt=e;this._shift=f;this._meta=g}ElementKeyboardEvent.prototype=Object.create(ElementEvent.prototype);ElementKeyboardEvent.prototype.constructor=ElementKeyboardEvent;ElementKeyboardEvent.base=ElementEvent;ElementKeyboardEvent.prototype.getKey=function(){return this._key};
ElementKeyboardEvent.prototype.getKeyCode=function(){return this._keyCode};ElementKeyboardEvent.prototype.getCtrl=function(){return this._ctrl};ElementKeyboardEvent.prototype.getAlt=function(){return this._alt};ElementKeyboardEvent.prototype.getShift=function(){return this._shift};ElementKeyboardEvent.prototype.getMeta=function(){return this._meta};ElementKeyboardEvent.prototype.clone=function(){return ElementKeyboardEvent.base.prototype.clone.call(this)};
ElementKeyboardEvent.prototype._cloneInstance=function(){return new ElementKeyboardEvent(this._type,this._key,this._keyCode,this._ctrl,this._alt,this._shift,this._meta)};function ElementGridItemClickEvent(a,b,c){ElementGridItemClickEvent.base.prototype.constructor.call(this,a,b);this._columnIndex=c}ElementGridItemClickEvent.prototype=Object.create(ElementListItemClickEvent.prototype);ElementGridItemClickEvent.prototype.constructor=ElementGridItemClickEvent;ElementGridItemClickEvent.base=ElementListItemClickEvent;
ElementGridItemClickEvent.prototype.getColumnIndex=function(){return this._columnIndex};ElementGridItemClickEvent.prototype.clone=function(){return ElementGridItemClickEvent.base.prototype.clone.call(this)};ElementGridItemClickEvent.prototype._cloneInstance=function(){return new ElementListItemClickEvent(this._item,this._index,this._columnIndex)};function CollectionChangedEvent(a,b){CollectionChangedEvent.base.prototype.constructor.call(this,"collectionchanged");this._kind=a;this._index=b}
CollectionChangedEvent.prototype=Object.create(DispatcherEvent.prototype);CollectionChangedEvent.prototype.constructor=CollectionChangedEvent;CollectionChangedEvent.base=DispatcherEvent;CollectionChangedEvent.prototype.getKind=function(){return this._kind};CollectionChangedEvent.prototype.getIndex=function(){return this._index};CollectionChangedEvent.prototype.clone=function(){return CollectionChangedEvent.base.prototype.clone.call(this)};
CollectionChangedEvent.prototype._cloneInstance=function(){return new CollectionChangedEvent(this._kind,this._index)};function AddedRemovedEvent(a,b){AddedRemovedEvent.base.prototype.constructor.call(this,a);this._manager=b}AddedRemovedEvent.prototype=Object.create(DispatcherEvent.prototype);AddedRemovedEvent.prototype.constructor=AddedRemovedEvent;AddedRemovedEvent.base=DispatcherEvent;AddedRemovedEvent.prototype.getManager=function(){return this._manager};AddedRemovedEvent.prototype.clone=function(){return AddedRemovedEvent.base.prototype.clone.call(this)};
AddedRemovedEvent.prototype._cloneInstance=function(){return new AddedRemovedEvent(this._type,this._manager)};function EventDispatcher(){this._eventListeners=Object.create(null)}EventDispatcher.prototype.constructor=EventDispatcher;EventDispatcher.prototype.addEventListener=function(a,b){null==this._eventListeners[a]&&(this._eventListeners[a]=[]);this._eventListeners[a].push(b)};
EventDispatcher.prototype.removeEventListener=function(a,b){if(!(a in this._eventListeners))return!1;for(var c=0;c<this._eventListeners[a].length;c++)if(this._eventListeners[a][c]==b)return this._eventListeners[a].splice(c,1),!0;return!1};EventDispatcher.prototype.hasEventListener=function(a,b){if(!(a in this._eventListeners))return!1;if(null==b)return 0<this._eventListeners[a].length?!0:!1;for(var c=0;c<this._eventListeners[a].length;c++)if(this._eventListeners[a][c]==b)return!0;return!1};
EventDispatcher.prototype._dispatchEvent=function(a){a._canceled=!1;if(a._type in this._eventListeners&&0<this._eventListeners[a._type].length)for(var b=this._eventListeners[a._type].slice(),c,d=0;d<b.length;d++)if(c=a.clone(),c._target=this,b[d](c),1==c._canceled){a._canceled=!0;break}};
function ToggleButtonGroup(){ToggleButtonGroup.base.prototype.constructor.call(this);this._selectedButton=null;this._toggleButtons=[];var a=this;this._toggleButtonChangedInstance=function(b){a._toggleButtonChanged(b)}}ToggleButtonGroup.prototype=Object.create(EventDispatcher.prototype);ToggleButtonGroup.prototype.constructor=ToggleButtonGroup;ToggleButtonGroup.base=EventDispatcher;
ToggleButtonGroup.prototype.addButton=function(a){if(null==a||0==a instanceof ToggleButtonElement||-1<this._toggleButtons.indexOf(a))return!1;this._toggleButtons.push(a);a.addEventListener("changed",this._toggleButtonChangedInstance);return!0};ToggleButtonGroup.prototype.removeButton=function(a){var b=this._toggleButtons.indexOf(a);if(-1==b)return!1;this._toggleButtons.splice(b,1);a.removeEventListener("changed",this._toggleButtonChangedInstance)};
ToggleButtonGroup.prototype.clearButtons=function(){for(var a=0;a<this._toggleButtons.length;a++)this._toggleButtons[a].removeEventListener("changed",this._toggleButtonChangedInstance);this._toggleButtons=[]};
ToggleButtonGroup.prototype.setSelectedButton=function(a){if(this._selectedButton=a)this._selectedButton.setSelected(!0);else if(null==a||-1<this._toggleButtons.indexOf(a)){this._selectedButton=a;null!=this._selectedButton&&this._selectedButton.setSelected(!0);for(var b=0;b<this._toggleButtons.length;b++)this._toggleButtons[b]!=a&&this._toggleButtons[b].setSelected(!1)}};ToggleButtonGroup.prototype.getSelectedButton=function(){return this._selectedButton};
ToggleButtonGroup.prototype._toggleButtonChanged=function(a){a=a.getTarget();1==a.getSelected()?this._selectedButton=a:this._selectedButton=null;for(var b=0;b<this._toggleButtons.length;b++)this._toggleButtons[b]!=a&&this._toggleButtons[b].setSelected(!1);1==this.hasEventListener("changed",null)&&this._dispatchEvent(new DispatcherEvent("changed",!1))};function StyleDefinition(){StyleDefinition.base.prototype.constructor.call(this);this._styleMap=Object.create(null)}StyleDefinition.prototype=Object.create(EventDispatcher.prototype);
StyleDefinition.prototype.constructor=StyleDefinition;StyleDefinition.base=EventDispatcher;StyleDefinition.prototype.getStyle=function(a){if(a in this._styleMap)return this._styleMap[a]};
StyleDefinition.prototype.setStyle=function(a,b){var c=void 0;a in this._styleMap&&(c=this._styleMap[a]);c!==b&&(1==this.hasEventListener("stylechanged",null)?(c=this.getStyle(a),void 0===b?delete this._styleMap[a]:this._styleMap[a]=b,this.getStyle(a)!==c&&this._dispatchEvent(new StyleChangedEvent(a))):void 0===b?delete this._styleMap[a]:this._styleMap[a]=b)};StyleDefinition.prototype.clearStyle=function(a){this.setStyle(a,void 0)};
function StyleData(a){this.styleName=a;this.value=void 0;this.priority=[]}StyleData.prototype.constructor=StyleData;StyleData.prototype.equals=function(a){if(a.styleName!=this.styleName||a.priority.length!=this.priority.length||a.value!==this.value)return!1;for(var b=0;b<this.priority.length;b++)if(a.priority[b]!=this.priority[b])return!1;return!0};
StyleData.prototype.comparePriority=function(a){for(var b=Math.min(this.priority.length,a.priority.length),c=0;c<b;c++){if(this.priority[c]<a.priority[c])return 1;if(this.priority[c]>a.priority[c])return-1}return 0};StyleData.prototype.clone=function(){var a=new StyleData(this.styleName);a.value=this.value;a.priority=this.priority.slice();return a};function StyleableBase(){StyleableBase.base.prototype.constructor.call(this)}StyleableBase.prototype=Object.create(StyleDefinition.prototype);
StyleableBase.prototype.constructor=StyleableBase;StyleableBase.base=StyleDefinition;StyleableBase.StylePriorities={INSTANCE:0,CLASS:1};StyleableBase.prototype.getStyle=function(a){return this.getStyleData(a).value};
StyleableBase.prototype.setStyle=function(a,b){var c=void 0;a in this._styleMap&&(c=this._styleMap[a]);if(c!==b)if(1==this.hasEventListener("stylechanged",null)){c=this.getStyleData(a);void 0===b?delete this._styleMap[a]:this._styleMap[a]=b;var d=this.getStyleData(a);0==c.equals(d)&&this._dispatchEvent(new StyleChangedEvent(a))}else void 0===b?delete this._styleMap[a]:this._styleMap[a]=b};
StyleableBase.prototype.getStyleData=function(a){var b=new StyleData(a);b.value=StyleableBase.base.prototype.getStyle.call(this,a);if(void 0!==b.value)return b.priority.push(StyleableBase.StylePriorities.INSTANCE),b;b.value=this._getClassStyle(a);b.priority.push(StyleableBase.StylePriorities.CLASS);return b};
StyleableBase.prototype._getStyleType=function(a){var b=Object.getPrototypeOf(this);if(null==b||0==b.hasOwnProperty("constructor"))return null;for(var c=b.constructor;;){if("_StyleTypes"in c&&a in c._StyleTypes)return c._StyleTypes[a];b=Object.getPrototypeOf(b);if(null==b||0==b.hasOwnProperty("constructor"))return null;c=b.constructor}};StyleableBase.prototype._getDefaultStyle=function(a){return this._getDefaultStyleData(a).value};
StyleableBase.prototype._getDefaultStyleData=function(a){var b=new StyleData(a);b.value=this._getClassStyle(a);b.priority.push(StyleableBase.StylePriorities.CLASS);return b};
StyleableBase.prototype._getClassStyle=function(a){var b=void 0,c=Object.getPrototypeOf(this);if(null==c||0==c.hasOwnProperty("constructor"))return b;for(var d=c.constructor;;){if("StyleDefault"in d&&(b=d.StyleDefault.getStyle(a),void 0!==b))return b;c=Object.getPrototypeOf(c);if(null==c||0==c.hasOwnProperty("constructor"))return b;d=c.constructor}};function ShapeBase(){ShapeBase.base.prototype.constructor.call(this)}ShapeBase.prototype=Object.create(StyleableBase.prototype);
ShapeBase.prototype.constructor=ShapeBase;ShapeBase.base=StyleableBase;ShapeBase.prototype.drawShape=function(a,b){};function RoundedRectangleShape(){RoundedRectangleShape.base.prototype.constructor.call(this)}RoundedRectangleShape.prototype=Object.create(ShapeBase.prototype);RoundedRectangleShape.prototype.constructor=RoundedRectangleShape;RoundedRectangleShape.base=ShapeBase;RoundedRectangleShape._StyleTypes=Object.create(null);RoundedRectangleShape._StyleTypes.CornerRadius={inheritable:!1};
RoundedRectangleShape._StyleTypes.CornerRadiusTopLeft={inheritable:!1};RoundedRectangleShape._StyleTypes.CornerRadiusTopRight={inheritable:!1};RoundedRectangleShape._StyleTypes.CornerRadiusBottomLeft={inheritable:!1};RoundedRectangleShape._StyleTypes.CornerRadiusBottomRight={inheritable:!1};RoundedRectangleShape.StyleDefault=new StyleDefinition;RoundedRectangleShape.StyleDefault.setStyle("CornerRadius",0);RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusTopLeft",null);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusTopRight",null);RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusBottomLeft",null);RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusBottomRight",null);
RoundedRectangleShape.prototype.drawShape=function(a,b){var c=b.getX(),d=b.getY(),e=b.getWidth(),f=b.getHeight(),g=this.getStyle("CornerRadius"),k=this.getStyle("CornerRadiusTopLeft"),m=this.getStyle("CornerRadiusTopRight"),l=this.getStyle("CornerRadiusBottomLeft"),p=this.getStyle("CornerRadiusBottomRight");null==g&&(g=0);null==k&&(k=g);null==m&&(m=g);null==l&&(l=g);null==p&&(p=g);a.moveTo(c,d+k);0<k&&a.arcTo(c,d,c+k,d,k);a.lineTo(c+e-m,d);0<m&&a.arcTo(c+e,d,c+e,d+m,m);a.lineTo(c+e,d+f-p);0<p&&a.arcTo(c+
e,d+f,c+e-p,d+f,p);a.lineTo(c+l,d+f);0<l&&a.arcTo(c,d+f,c,d+f-l,l);a.closePath()};function EllipseShape(){EllipseShape.base.prototype.constructor.call(this)}EllipseShape.prototype=Object.create(ShapeBase.prototype);EllipseShape.prototype.constructor=EllipseShape;EllipseShape.base=ShapeBase;
EllipseShape.prototype.drawShape=function(a,b){var c=b.getWidth(),d=b.getHeight(),e=c/2*.551784,f=d/2*.551784,g=b.getX(),k=b.getY(),m=g+c/2,l=k+d/2,c=g+c,d=k+d;a.moveTo(g,l);a.bezierCurveTo(g,l-f,m-e,k,m,k);a.bezierCurveTo(m+e,k,c,l-f,c,l);a.bezierCurveTo(c,l+f,m+e,d,m,d);a.bezierCurveTo(m-e,d,g,l+f,g,l);a.closePath()};function ArrowShape(){ArrowShape.base.prototype.constructor.call(this)}ArrowShape.prototype=Object.create(ShapeBase.prototype);ArrowShape.prototype.constructor=ArrowShape;
ArrowShape.base=ShapeBase;ArrowShape._StyleTypes=Object.create(null);ArrowShape._StyleTypes.Direction={inheritable:!1};ArrowShape._StyleTypes.RectBaseWidth={inheritable:!1};ArrowShape._StyleTypes.RectBaseHeight={inheritable:!1};ArrowShape._StyleTypes.RectBasePercentWidth={inheritable:!1};ArrowShape._StyleTypes.RectBasePercentHeight={inheritable:!1};ArrowShape._StyleTypes.CornerRadius={inheritable:!1};ArrowShape._StyleTypes.CornerRadiusTopLeft={inheritable:!1};
ArrowShape._StyleTypes.CornerRadiusTopRight={inheritable:!1};ArrowShape._StyleTypes.CornerRadiusBottomLeft={inheritable:!1};ArrowShape._StyleTypes.CornerRadiusBottomRight={inheritable:!1};ArrowShape.StyleDefault=new StyleDefinition;ArrowShape.StyleDefault.setStyle("Direction","up");ArrowShape.StyleDefault.setStyle("RectBaseWidth",null);ArrowShape.StyleDefault.setStyle("RectBaseHeight",null);ArrowShape.StyleDefault.setStyle("RectBasePercentWidth",null);
ArrowShape.StyleDefault.setStyle("RectBasePercentHeight",null);ArrowShape.StyleDefault.setStyle("CornerRadius",0);ArrowShape.StyleDefault.setStyle("CornerRadiusTopLeft",null);ArrowShape.StyleDefault.setStyle("CornerRadiusTopRight",null);ArrowShape.StyleDefault.setStyle("CornerRadiusBottomLeft",null);ArrowShape.StyleDefault.setStyle("CornerRadiusBottomRight",null);
ArrowShape.prototype.drawShape=function(a,b){var c=this.getStyle("Direction");if("up"==c||"down"==c||"left"==c||"right"==c){var d=b.getX(),e=b.getY(),f=b.getWidth(),g=b.getHeight(),k=this.getStyle("CornerRadius"),m=this.getStyle("CornerRadiusTopLeft"),l=this.getStyle("CornerRadiusTopRight"),p=this.getStyle("CornerRadiusBottomLeft"),q=this.getStyle("CornerRadiusBottomRight");null==k&&(k=0);null==m&&(m=k);null==l&&(l=k);null==p&&(p=k);null==q&&(q=k);var k=this.getStyle("RectBaseWidth"),n=this.getStyle("RectBaseHeight");
null==k&&(k=this.getStyle("RectBasePercentWidth"),k=null==k?0:Math.round(k/100*w));null==n&&(n=this.getStyle("RectBasePercentHeight"),n=null==n?0:Math.round(n/100*h));if(0==k||0==n)n=k=0;"down"==c?(a.moveTo(d+(f-k)/2,e+m),0<m&&a.arcTo(d+(f-k)/2,e,d+(f-k)/2+m,e,m),a.lineTo(d+(f-k)/2+k-l,e),0<l&&a.arcTo(d+(f-k)/2+k,e,d+(f-k)/2+k,e+l,l),a.lineTo(d+(f-k)/2+k,e+n-q),0<q&&a.arcTo(d+(f-k)/2+k,e+n,Math.min(d+(f-k)/2+k+q,d+f),e+n,Math.min(q,(f-k)/2)),a.lineTo(d+f,e+n),a.lineTo(d+f/2,e+g),a.lineTo(d,e+n),a.lineTo(Math.max(d+
(f-k)/2-p,d),e+n),0<p&&a.arcTo(d+(f-k)/2,e+n,d+(f-k)/2,e+n-p,Math.min(p,(f-k)/2))):"left"==c?(a.moveTo(d+f-l,e+(g-n)/2),0<l&&a.arcTo(d+f,e+(g-n)/2,d+f,e+(g-n)/2+l,l),a.lineTo(d+f,e+(g-n)/2+n-q),0<q&&a.arcTo(d+f,e+(g-n)/2+n,d+f-q,e+(g-n)/2+n,q),a.lineTo(d+f-k+p,e+(g-n)/2+n),0<p&&a.arcTo(d+f-k,e+(g-n)/2+n,d+f-k,Math.min(e+(g-n)/2+n+p,e+g),Math.min(p,(g-n)/2)),a.lineTo(d+f-k,e+g),a.lineTo(d,e+g/2),a.lineTo(d+f-k,e),a.lineTo(d+f-k,Math.max(e,e+(g-n)/2-m)),0<m&&a.arcTo(d+f-k,e+(g-n)/2,d+f-k+m,e+(g-n)/
2,Math.min(m,(g-n)/2))):"up"==c?(a.moveTo(d+(f-k)/2+k,e+g-q),0<q&&a.arcTo(d+(f-k)/2+k,e+g,d+(f-k)/2+k-q,e+g,q),a.lineTo(d+(f-k)/2+p,e+g),0<p&&a.arcTo(d+(f-k)/2,e+g,d+(f-k)/2,e+g-p,p),a.lineTo(d+(f-k)/2,e+g-n+m),0<m&&a.arcTo(d+(f-k)/2,e+g-n,Math.max(d+(f-k)/2-m,d),e+g-n,Math.min(m,(f-k)/2)),a.lineTo(d,e+g-n),a.lineTo(d+f/2,e),a.lineTo(d+f,e+g-n),a.lineTo(Math.min(d+(f-k)/2+k+l,d+f),e+g-n),0<l&&a.arcTo(d+(f-k)/2+k,e+g-n,d+(f-k)/2+k,e+g-n+l,Math.min(l,(f-k)/2))):"right"==c&&(a.moveTo(d+p,e+(g-n)/2+n),
0<p&&a.arcTo(d,e+(g-n)/2+n,d,e+(g-n)/2+n-p,p),a.lineTo(d,e+(g-n)/2+m),0<m&&a.arcTo(d,e+(g-n)/2,d+m,e+(g-n)/2,m),a.lineTo(d+k-l,e+(g-n)/2),0<l&&a.arcTo(d+k,e+(g-n)/2,d+k,Math.max(e+(g-n)/2-l,e),Math.min(l,(g-n)/2)),a.lineTo(d+k,e),a.lineTo(d+f,e+g/2),a.lineTo(d+k,e+g),a.lineTo(d+k,Math.min(e+g,e+(g-n)/2+n+q)),0<q&&a.arcTo(d+k,e+(g-n)/2+n,d+k-q,e+(g-n)/2+n,Math.min(q,(g-n)/2)));a.closePath()}};
function ListCollection(a){ListCollection.base.prototype.constructor.call(this);this._backingArray=[];this._collectionSort=null;null!=a&&(this._backingArray=a)}ListCollection.prototype=Object.create(EventDispatcher.prototype);ListCollection.prototype.constructor=ListCollection;ListCollection.base=EventDispatcher;ListCollection.prototype.getLength=function(){return this._backingArray.length};
ListCollection.prototype.setSourceArray=function(a){this._backingArray=a;this._dispatchEvent(new CollectionChangedEvent("reset",-1))};ListCollection.prototype.getSourceArray=function(){return this._backingArray};ListCollection.prototype.setCollectionSort=function(a){if(this._collectionSort!=a){if(!(a instanceof CollectionSort))throw"Invalid CollectionSort";this._collectionSort=a}};ListCollection.prototype.getCollectionSort=function(){return this._collectionSort};
ListCollection.prototype.sort=function(){null!=this._backingArray&&(null==this._collectionSort?this._backingArray.sort():this._collectionSort.sort(this._backingArray),this._dispatchEvent(new CollectionChangedEvent("reset",-1)))};ListCollection.prototype.getItemIndex=function(a){return null==a?-1:this._backingArray.indexOf(a)};ListCollection.prototype.getItemAt=function(a){return 0>a||a>=this._backingArray.length?null:this._backingArray[a]};
ListCollection.prototype.addItem=function(a){return this.addItemAt(a,this._backingArray.length)};ListCollection.prototype.addItemAt=function(a,b){if(0>b||b>this._backingArray.length||null==a)return null;this._backingArray.splice(b,0,a);this._dispatchEvent(new CollectionChangedEvent("add",b));return a};ListCollection.prototype.removeItem=function(a){return this.removeItemAt(this._backingArray.indexOf(a))};
ListCollection.prototype.removeItemAt=function(a){if(0>a||a>=this._backingArray.length)return null;var b=this._backingArray.splice(a,1)[0];this._dispatchEvent(new CollectionChangedEvent("remove",a));return b};ListCollection.prototype.replaceItemAt=function(a,b){if(0>b||b>=this._backingArray.length)return null;var c=this._backingArray[b];this._backingArray[b]=a;this.indexUpdated(b);return c};
ListCollection.prototype.clear=function(){this._backingArray=[];this._dispatchEvent(new CollectionChangedEvent("reset",-1))};ListCollection.prototype.indexUpdated=function(a){this._dispatchEvent(new CollectionChangedEvent("update",a))};function DrawMetrics(){this._height=this._width=this._y=this._x=0}DrawMetrics.prototype.constructor=DrawMetrics;DrawMetrics.prototype.equals=function(a){return this._x==a._x&&this._y==a._y&&this._width==a._width&&this._height==a._height?!0:!1};
DrawMetrics.prototype.clone=function(){var a=new DrawMetrics;a._x=this._x;a._y=this._y;a._width=this._width;a._height=this._height;return a};DrawMetrics.prototype.copyFrom=function(a){this._x=a._x;this._y=a._y;this._width=a._width;this._height=a._height};
DrawMetrics.prototype.mergeExpand=function(a){a._x<this._x&&(this._width+=this._x-a._x,this._x=a._x);a._y<this._y&&(this._height+=this._y-a._y,this._y=a._y);a._x+a._width>this._x+this._width&&(this._width+=a._x+a._width-(this._x+this._width));a._y+a._height>this._y+this._height&&(this._height+=a._y+a._height-(this._y+this._height))};
DrawMetrics.prototype.mergeReduce=function(a){this._x<a._x&&(this._width-=a._x-this._x,this._x=a._x);this._y<a._y&&(this._height-=a._y-this._y,this._y=a._y);this._x+this._width>a._x+a._width&&(this._width-=this._x+this._width-(a._x+a._width));this._y+this._height>a._y+a._height&&(this._height-=this._y+this._height-(a._y+a._height))};
DrawMetrics.prototype.roundToPrecision=function(a){this._x=CanvasElement.roundToPrecision(this._x,a);this._y=CanvasElement.roundToPrecision(this._y,a);this._width=CanvasElement.roundToPrecision(this._width,a);this._height=CanvasElement.roundToPrecision(this._height,a)};DrawMetrics.prototype.roundUp=function(){var a=this._x,b=this._x+this._width,c=this._y,d=this._y+this._height,a=Math.floor(a),b=Math.ceil(b),c=Math.floor(c),d=Math.ceil(d);this._x=a;this._y=c;this._width=b-a;this._height=d-c};
DrawMetrics.prototype.getX=function(){return this._x};DrawMetrics.prototype.getY=function(){return this._y};DrawMetrics.prototype.getWidth=function(){return this._width};DrawMetrics.prototype.getHeight=function(){return this._height};function DataListData(a,b){this._parentList=a;this._itemIndex=b}function DataGridItemData(a,b,c){this._parentGrid=a;this._itemIndex=b;this._columnIndex=c}
function CursorDefinition(){CursorDefinition.base.prototype.constructor.call(this);this._cursorElement=null;this._addedCount=0}CursorDefinition.prototype=Object.create(StyleableBase.prototype);CursorDefinition.prototype.constructor=CursorDefinition;CursorDefinition.base=StyleableBase;CursorDefinition._StyleTypes=Object.create(null);CursorDefinition._StyleTypes.CursorClass={inheritable:!1};CursorDefinition._StyleTypes.CursorStyle={inheritable:!1};CursorDefinition._StyleTypes.CursorOffsetX={inheritable:!1};
CursorDefinition._StyleTypes.CursorOffsetY={inheritable:!1};CursorDefinition.StyleDefault=new StyleDefinition;CursorDefinition.StyleDefault.setStyle("CursorClass","default");CursorDefinition.StyleDefault.setStyle("CursorStyle",null);CursorDefinition.StyleDefault.setStyle("CursorOffsetX",0);CursorDefinition.StyleDefault.setStyle("CursorOffsetY",0);
function CollectionSort(a,b){this._comparatorFunction=a;this._isDecending=b;var c=this;this._collectionSortDecendingComparator=function(a,b){return c._comparatorFunction(b,a)}}CollectionSort.prototype.constructor=CollectionSort;CollectionSort.prototype.setComparatorFunction=function(a){this._comparatorFunction=a};CollectionSort.prototype.getComparatorFunction=function(){return this._comparatorFunction};
CollectionSort.prototype.sort=function(a){1==this._isDecending?a.sort(this._collectionSortDecendingComparator):a.sort(this._comparatorFunction)};CollectionSort.prototype.setIsDecending=function(a){this._isDecending=a};CollectionSort.prototype.getIsDecending=function(){return this._isDecending};
function CanvasElement(){CanvasElement.base.prototype.constructor.call(this);this._styleDefinitionDefault=this._styleProxy=null;this._styleDefinitions=[];this._manager=this._backgroundShape=null;this._displayDepth=0;this._captureListeners=Object.create(null);this._name=null;this._measuredHeight=this._measuredWidth=this._height=this._width=this._y=this._x=0;this._isFocused=this._mouseIsDown=this._mouseIsOver=!1;this._rotateCenterY=this._rotateCenterX=this._rotateDegrees=0;this._parent=null;this._children=
[];this._stylesInvalid=!0;this._stylesInvalidMap=Object.create(null);this._stylesValidateNode=new CmLinkedNode;this._stylesValidateNode.data=this;this._stylesCache=Object.create(null);this._measureInvalid=!0;this._measureValidateNode=new CmLinkedNode;this._measureValidateNode.data=this;this._layoutInvalid=!0;this._layoutValidateNode=new CmLinkedNode;this._layoutValidateNode.data=this;this._renderInvalid=!0;this._renderValidateNode=new CmLinkedNode;this._renderValidateNode.data=this;this._graphicsCtx=
this._graphicsCanvas=null;this._graphicsClear=!0;this._compositeMetrics=[];this._renderChanged=!0;this._compositeRenderInvalid=this._renderVisible=!1;this._compositeRenderValidateNode=new CmLinkedNode;this._compositeRenderValidateNode.data=this;this._compositeEffectChanged=!0;this._rollOverCursorInstance=this._transformDrawableMetrics=this._transformVisibleMetrics=this._compositeCanvasMetrics=this._compositeCanvas=this._compositeCtx=this._redrawRegionMetrics=this._compositeVisibleMetrics=null;this._renderFocusRing=
!1;var a=this;this._onExternalStyleChangedInstance=function(b){a._onExternalStyleChanged(b)};this._onBackgroundShapeStyleChangedInstance=function(b){a._onBackgroundShapeStyleChanged(b)};this._onCanvasElementAddedRemovedInstance=function(b){"added"==b.getType()?a._onCanvasElementAdded(b):"removed"==b.getType()&&a._onCanvasElementRemoved(b)};this._onCanvasElementCursorOverOutInstance=function(b){a._updateRolloverCursorDefinition()};this.addEventListener("added",this._onCanvasElementAddedRemovedInstance);
this.addEventListener("removed",this._onCanvasElementAddedRemovedInstance)}CanvasElement.prototype=Object.create(StyleableBase.prototype);CanvasElement.prototype.constructor=CanvasElement;CanvasElement.base=StyleableBase;CanvasElement.StylePriorities={INSTANCE:0,DEFINITION:1,PROXY:2,INHERITED:3,DEFAULT_DEFINITION:4,DEFAULT_PROXY:5,CLASS:6};CanvasElement._StyleTypes=Object.create(null);CanvasElement._StyleTypes.Visible={inheritable:!1};CanvasElement._StyleTypes.BorderType={inheritable:!1};
CanvasElement._StyleTypes.BorderColor={inheritable:!1};CanvasElement._StyleTypes.BorderThickness={inheritable:!1};CanvasElement._StyleTypes.BackgroundColor={inheritable:!1};CanvasElement._StyleTypes.ShadowSize={inheritable:!1};CanvasElement._StyleTypes.ShadowOffsetX={inheritable:!1};CanvasElement._StyleTypes.ShadowOffsetY={inheritable:!1};CanvasElement._StyleTypes.ShadowColor={inheritable:!1};CanvasElement._StyleTypes.Alpha={inheritable:!1};CanvasElement._StyleTypes.AutoGradientType={inheritable:!1};
CanvasElement._StyleTypes.AutoGradientStart={inheritable:!1};CanvasElement._StyleTypes.AutoGradientStop={inheritable:!1};CanvasElement._StyleTypes.ClipContent={inheritable:!1};CanvasElement._StyleTypes.SkinState={inheritable:!1};CanvasElement._StyleTypes.BackgroundShape={inheritable:!1};CanvasElement._StyleTypes.FocusColor={inheritable:!0};CanvasElement._StyleTypes.FocusThickness={inheritable:!0};CanvasElement._StyleTypes.Padding={inheritable:!1};CanvasElement._StyleTypes.PaddingTop={inheritable:!1};
CanvasElement._StyleTypes.PaddingBottom={inheritable:!1};CanvasElement._StyleTypes.PaddingLeft={inheritable:!1};CanvasElement._StyleTypes.PaddingRight={inheritable:!1};CanvasElement._StyleTypes.Enabled={inheritable:!1};CanvasElement._StyleTypes.MouseEnabled={inheritable:!1};CanvasElement._StyleTypes.Draggable={inheritable:!1};CanvasElement._StyleTypes.Cursor={inheritable:!1};CanvasElement._StyleTypes.TabStop={inheritable:!1};CanvasElement._StyleTypes.X={inheritable:!1};
CanvasElement._StyleTypes.Y={inheritable:!1};CanvasElement._StyleTypes.Width={inheritable:!1};CanvasElement._StyleTypes.Height={inheritable:!1};CanvasElement._StyleTypes.Top={inheritable:!1};CanvasElement._StyleTypes.Left={inheritable:!1};CanvasElement._StyleTypes.Bottom={inheritable:!1};CanvasElement._StyleTypes.Right={inheritable:!1};CanvasElement._StyleTypes.PercentWidth={inheritable:!1};CanvasElement._StyleTypes.PercentHeight={inheritable:!1};CanvasElement._StyleTypes.MinWidth={inheritable:!1};
CanvasElement._StyleTypes.MinHeight={inheritable:!1};CanvasElement._StyleTypes.MaxWidth={inheritable:!1};CanvasElement._StyleTypes.MaxHeight={inheritable:!1};CanvasElement._StyleTypes.HorizontalCenter={inheritable:!1};CanvasElement._StyleTypes.VerticalCenter={inheritable:!1};CanvasElement._StyleTypes.RotateDegrees={inheritable:!1};CanvasElement._StyleTypes.RotateCenterX={inheritable:!1};CanvasElement._StyleTypes.RotateCenterY={inheritable:!1};CanvasElement._StyleTypes.IncludeInLayout={inheritable:!1};
CanvasElement._StyleTypes.CompositeLayer={inheritable:!1};CanvasElement._StyleTypes.TextStyle={inheritable:!0};CanvasElement._StyleTypes.TextFont={inheritable:!0};CanvasElement._StyleTypes.TextSize={inheritable:!0};CanvasElement._StyleTypes.TextAlign={inheritable:!0};CanvasElement._StyleTypes.TextBaseline={inheritable:!0};CanvasElement._StyleTypes.TextLinePaddingTop={inheritable:!0};CanvasElement._StyleTypes.TextLinePaddingBottom={inheritable:!0};CanvasElement._StyleTypes.TextLineSpacing={inheritable:!0};
CanvasElement._StyleTypes.TextColor={inheritable:!0};CanvasElement._StyleTypes.TextFillType={inheritable:!0};CanvasElement._StyleTypes.TextHighlightedColor={inheritable:!0};CanvasElement._StyleTypes.TextHighlightedBackgroundColor={inheritable:!0};CanvasElement._StyleTypes.TextCaretColor={inheritable:!0};CanvasElement.StyleDefault=new StyleDefinition;CanvasElement.StyleDefault.setStyle("Visible",!0);CanvasElement.StyleDefault.setStyle("BorderType","none");
CanvasElement.StyleDefault.setStyle("BorderColor","#000000");CanvasElement.StyleDefault.setStyle("BorderThickness",1);CanvasElement.StyleDefault.setStyle("BackgroundColor",null);CanvasElement.StyleDefault.setStyle("ShadowSize",0);CanvasElement.StyleDefault.setStyle("ShadowOffsetX",0);CanvasElement.StyleDefault.setStyle("ShadowOffsetY",0);CanvasElement.StyleDefault.setStyle("ShadowColor","#000000");CanvasElement.StyleDefault.setStyle("Alpha",1);
CanvasElement.StyleDefault.setStyle("AutoGradientType","none");CanvasElement.StyleDefault.setStyle("AutoGradientStart",.15);CanvasElement.StyleDefault.setStyle("AutoGradientStop",-.15);CanvasElement.StyleDefault.setStyle("ClipContent",!1);CanvasElement.StyleDefault.setStyle("SkinState","");CanvasElement.StyleDefault.setStyle("BackgroundShape",null);CanvasElement.StyleDefault.setStyle("FocusColor","#3333FF");CanvasElement.StyleDefault.setStyle("FocusThickness",1);
CanvasElement.StyleDefault.setStyle("Padding",0);CanvasElement.StyleDefault.setStyle("PaddingTop",0);CanvasElement.StyleDefault.setStyle("PaddingBottom",0);CanvasElement.StyleDefault.setStyle("PaddingLeft",0);CanvasElement.StyleDefault.setStyle("PaddingRight",0);CanvasElement.StyleDefault.setStyle("Enabled",!0);CanvasElement.StyleDefault.setStyle("MouseEnabled",!0);CanvasElement.StyleDefault.setStyle("Draggable",!1);CanvasElement.StyleDefault.setStyle("Cursor",null);
CanvasElement.StyleDefault.setStyle("TabStop",-1);CanvasElement.StyleDefault.setStyle("X",null);CanvasElement.StyleDefault.setStyle("Y",null);CanvasElement.StyleDefault.setStyle("Width",null);CanvasElement.StyleDefault.setStyle("Height",null);CanvasElement.StyleDefault.setStyle("Top",null);CanvasElement.StyleDefault.setStyle("Left",null);CanvasElement.StyleDefault.setStyle("Bottom",null);CanvasElement.StyleDefault.setStyle("Right",null);CanvasElement.StyleDefault.setStyle("PercentWidth",null);
CanvasElement.StyleDefault.setStyle("PercentHeight",null);CanvasElement.StyleDefault.setStyle("MinWidth",5);CanvasElement.StyleDefault.setStyle("MinHeight",5);CanvasElement.StyleDefault.setStyle("MaxWidth",null);CanvasElement.StyleDefault.setStyle("MaxHeight",null);CanvasElement.StyleDefault.setStyle("HorizontalCenter",null);CanvasElement.StyleDefault.setStyle("VerticalCenter",null);CanvasElement.StyleDefault.setStyle("RotateDegrees",0);CanvasElement.StyleDefault.setStyle("RotateCenterX",null);
CanvasElement.StyleDefault.setStyle("RotateCenterY",null);CanvasElement.StyleDefault.setStyle("IncludeInLayout",!0);CanvasElement.StyleDefault.setStyle("CompositeLayer",!1);CanvasElement.StyleDefault.setStyle("TextStyle","normal");CanvasElement.StyleDefault.setStyle("TextFont","Arial");CanvasElement.StyleDefault.setStyle("TextSize",12);CanvasElement.StyleDefault.setStyle("TextAlign","left");CanvasElement.StyleDefault.setStyle("TextBaseline","middle");
CanvasElement.StyleDefault.setStyle("TextLinePaddingTop",1);CanvasElement.StyleDefault.setStyle("TextLinePaddingBottom",1);CanvasElement.StyleDefault.setStyle("TextLineSpacing",0);CanvasElement.StyleDefault.setStyle("TextColor","#000000");CanvasElement.StyleDefault.setStyle("TextFillType","fill");CanvasElement.StyleDefault.setStyle("TextHighlightedColor","#FFFFFF");CanvasElement.StyleDefault.setStyle("TextHighlightedBackgroundColor","#000000");
CanvasElement.StyleDefault.setStyle("TextCaretColor","#000000");CanvasElement.prototype.addStyleDefinition=function(a){return this.addStyleDefinitionAt(a,this._styleDefinitions.length)};
CanvasElement.prototype.addStyleDefinitionAt=function(a,b){if(!(a instanceof StyleDefinition)||0>b||b>this._styleDefinitions.length||-1!=this._styleDefinitions.indexOf(a)||a==this._styleDefinitionDefault)return null;this._styleDefinitions.splice(b,0,a);if(null!=this._manager){a.addEventListener("stylechanged",this._onExternalStyleChangedInstance);for(var c=Object.create(null),d=null,e=b;0<=e;e--)for(d in this._styleDefinitions[e]._styleMap)c[d]=!0;for(d in c)this._onExternalStyleChanged(new StyleChangedEvent(d))}return a};
CanvasElement.prototype.removeStyleDefinition=function(a){a=this._styleDefinitions.indexOf(a);return-1==a?null:this.removeStyleDefinitionAt(a)};
CanvasElement.prototype.removeStyleDefinitionAt=function(a){if(0>a||a>this._styleDefinitions.length-1)return null;if(null!=this._manager){for(var b=Object.create(null),c=null,d=a;0<=d;d--)for(c in this._styleDefinitions[d]._styleMap)b[c]=!0;d=this._styleDefinitions.splice(a,1)[0];d.removeEventListener("stylechanged",this._onExternalStyleChangedInstance);for(c in b)this._onExternalStyleChanged(new StyleChangedEvent(c))}else this._styleDefinitions.splice(a,1);return d};
CanvasElement.prototype.clearStyleDefinitions=function(){if(null!=this._manager){for(var a=Object.create(null),b,c=null,d=0;d<this._styleDefinitions.length;d++)for(c in b=this._styleDefinitions[d],b.removeEventListener("stylechanged",this._onExternalStyleChangedInstance),b._styleMap)a[c]=!0;this._styleDefinitions.splice(0,this._styleDefinitions.length);for(c in a)this._onExternalStyleChanged(new StyleChangedEvent(c))}else this._styleDefinitions.splice(0,this._styleDefinitions.length)};
CanvasElement.prototype.setStyleDefinitions=function(a){null==a&&(a=[]);0==Array.isArray(a)&&(a=[a]);var b;for(b=a.length-1;0<=b;b--)(a.indexOf(a[b])<b||a[b]==this._styleDefinitionDefault)&&a.splice(b,1);if(null!=this._manager){if(a.length==this._styleDefinitions.length){var c=!1;for(b=0;b<a.length;b++)if(a[b]!=this._styleDefinitions[b]){c=!0;break}if(0==c)return}for(var c=null,d=Object.create(null),e;0<this._styleDefinitions.length;)for(c in e=this._styleDefinitions[this._styleDefinitions.length-
1],this._styleDefinitions.splice(this._styleDefinitions.length-1,1),e.removeEventListener("stylechanged",this._onExternalStyleChangedInstance),e._styleMap)d[c]=!0;for(b=0;b<a.length;b++)for(c in e=a[b],this._styleDefinitions.push(e),e.addEventListener("stylechanged",this._onExternalStyleChangedInstance),e._styleMap)d[c]=!0;for(c in d)this._onExternalStyleChanged(new StyleChangedEvent(c))}else for(this._styleDefinitions.splice(0,this._styleDefinitions.length),b=0;b<a.length;b++)this._styleDefinitions.push(a[b])};
CanvasElement.prototype.getNumStyleDefinitions=function(){return this._styleDefinitions.length};CanvasElement.prototype.getStyleDefinitionAt=function(a){return 0>a||a>=this._styleDefinitions.length?null:this._styleDefinitions[a]};CanvasElement.prototype.getStyle=function(a){return CanvasElement.base.prototype.getStyle.call(this,a)};
CanvasElement.prototype.getStyleData=function(a){var b=this._stylesCache[a];null==b&&(b={styleData:new StyleData(a),cacheInvalid:!0},this._stylesCache[a]=b);if(0==b.cacheInvalid)return b.styleData.clone();b.cacheInvalid=!1;b=b.styleData;b.priority=[];b.value=void 0;a in this._styleMap&&(b.value=this._styleMap[a]);if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.INSTANCE),b.clone();var c,d;for(c=this._styleDefinitions.length-1;0<=c;c--)if(b.value=this._styleDefinitions[c].getStyle(a),
void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.DEFINITION),b.priority.push(this._styleDefinitions.length-1-c),b.clone();var e,f;for(e=this._styleProxy;null!=e;){f=e._proxyElement._getStyleType(a);if(null!=f&&0==a in e._proxyMap||null==f&&0=="_Arbitrary"in e._proxyMap)break;a in e._proxyElement._styleMap&&(b.value=e._proxyElement._styleMap[a]);if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.PROXY),b.priority.push(c),b.priority.push(CanvasElement.StylePriorities.INSTANCE),
b.clone();for(d=e._proxyElement._styleDefinitions.length-1;0<=d;d--)if(b.value=e._proxyElement._styleDefinitions[d].getStyle(a),void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.PROXY),b.priority.push(c),b.priority.push(CanvasElement.StylePriorities.DEFINITION),b.priority.push(e._proxyElement._styleDefinitions.length-1-d),b.clone();c++;e=e._proxyElement._styleProxy}c=0;for(var g=this;;){f=g._getStyleType(a);if(null==f||0==f.inheritable)break;g=g._parent;if(null==g)break;a in g._styleMap&&
(b.value=g._styleMap[a]);if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.INHERITED),b.priority.push(c),b.priority.push(CanvasElement.StylePriorities.INSTANCE),b.clone();for(d=g._styleDefinitions.length-1;0<=d;d--)if(b.value=g._styleDefinitions[d].getStyle(a),void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.INHERITED),b.priority.push(c),b.priority.push(CanvasElement.StylePriorities.DEFINITION),b.priority.push(g._styleDefinitions.length-1-d),b.clone();e=
g._styleProxy;for(d=0;null!=e;){f=e._proxyElement._getStyleType(a);if(null!=f&&0==a in e._proxyMap||null==f&&0=="_Arbitrary"in e._proxyMap)break;a in e._proxyElement._styleMap&&(b.value=e._proxyElement._styleMap[a]);if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.INHERITED),b.priority.push(c),b.priority.push(CanvasElement.StylePriorities.PROXY),b.priority.push(d),b.priority.push(CanvasElement.StylePriorities.INSTANCE),b.clone();for(f=e._proxyElement._styleDefinitions.length-
1;0<=f;f--)if(b.value=e._proxyElement._styleDefinitions[f].getStyle(a),void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.INHERITED),b.priority.push(c),b.priority.push(CanvasElement.StylePriorities.PROXY),b.priority.push(d),b.priority.push(CanvasElement.StylePriorities.DEFINITION),b.priority.push(g._styleDefinitions.length-1-f),b.clone();d++;e=e._proxyElement._styleProxy}c++}null!=this._styleDefinitionDefault&&(b.value=this._styleDefinitionDefault.getStyle(a));if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.DEFAULT_DEFINITION),
b.clone();e=this._styleProxy;for(c=0;null!=e;){f=e._proxyElement._getStyleType(a);if(null!=f&&0==a in e._proxyMap||null==f&&0=="_Arbitrary"in e._proxyMap)break;null!=e._proxyElement._styleDefinitionDefault&&(b.value=e._proxyElement._styleDefinitionDefault.getStyle(a));if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.DEFAULT_PROXY),b.priority.push(c),b.clone();c++;e=e._proxyElement._styleProxy}b.value=this._getClassStyle(a);b.priority.push(CanvasElement.StylePriorities.CLASS);
return b.clone()};CanvasElement.prototype.setStyle=function(a,b){var c=void 0;a in this._styleMap&&(c=this._styleMap[a]);c!==b&&(void 0===b?delete this._styleMap[a]:this._styleMap[a]=b,this._onExternalStyleChanged(new StyleChangedEvent(a)))};CanvasElement.prototype.getManager=function(){return this._manager};CanvasElement.prototype.setName=function(a){if(this._name==a)return!1;this._name=a;return!0};CanvasElement.prototype.getName=function(){return this._name};
CanvasElement.prototype.getMouseIsDown=function(){return this._mouseIsDown};CanvasElement.prototype.getParent=function(){return this._parent};
CanvasElement.prototype.rotatePoint=function(a,b){if(0!=this._rotateDegrees){var c=Math.sqrt(Math.abs(a.x-this._rotateCenterX)*Math.abs(a.x-this._rotateCenterX)+Math.abs(a.y-this._rotateCenterY)*Math.abs(a.y-this._rotateCenterY)),d;d=0==b?360-this._rotateDegrees+CanvasElement.radiansToDegrees(Math.atan2(a.x-this._rotateCenterX,a.y-this._rotateCenterY)):360+this._rotateDegrees+CanvasElement.radiansToDegrees(Math.atan2(a.x-this._rotateCenterX,a.y-this._rotateCenterY));a.x=Math.sin(CanvasElement.degreesToRadians(d))*
c+this._rotateCenterX;a.y=Math.cos(CanvasElement.degreesToRadians(d))*c+this._rotateCenterY}};CanvasElement.prototype.translatePointFrom=function(a,b){return b.translatePointTo(a,this)};
CanvasElement.prototype.translatePointTo=function(a,b){if(null==b||b==this||null==this._manager||this._manager!=b._manager)return!1;var c=null,d=[];for(d.push(this);null==c&&null!=d[d.length-1]._parent;)d[d.length-1]._parent==b?c=b:d.push(d[d.length-1]._parent);var e=[];if(null==c)for(e.push(b);null==c&&null!=e[d.length-1]._parent;)e[e.length-1]._parent==this?c=this:e.push(e[e.length-1]._parent);if(null==c)for(;d[d.length-1]==e[e.length-1];)c=d[d.length-1],d.pop(),e.pop();for(d=this;null!=d&&d!=c;)a.x+=
d._x,a.y+=d._y,d.rotatePoint(a,!1),d=d._parent;for(c=e.length-1;0<=c;c--)e[c].rotatePoint(a,!0),a.x-=e[c]._x,a.y-=e[c]._y;return!0};CanvasElement.prototype.translateMetricsFrom=function(a,b){return b.translateMetricsTo(a,this)};
CanvasElement.prototype.translateMetricsTo=function(a,b){var c=new DrawMetrics;if(null==b||b==this)return c._x=a._x,c._y=a._y,c._width=a._width,c._height=a._height,c;if(null==this._manager||this._manager!=b._manager)return null;var d=null,e=[];for(e.push(this);null==d&&null!=e[e.length-1]._parent;)e[e.length-1]._parent==b?d=b:e.push(e[e.length-1]._parent);var f=[];if(null==d)for(f.push(b);null==d&&null!=f[e.length-1]._parent;)f[f.length-1]._parent==this?d=this:f.push(f[f.length-1]._parent);if(null==
d)for(;e[e.length-1]==f[f.length-1];)d=e[e.length-1],e.pop(),f.pop();for(var e={x:a._x,y:a._y},g={x:a._x+a._width,y:a._y},k={x:a._x+a._width,y:a._y+a._height},m={x:a._x,y:a._y+a._height},l=this;null!=l&&l!=d;)e.x+=l._x,e.y+=l._y,g.x+=l._x,g.y+=l._y,k.x+=l._x,k.y+=l._y,m.x+=l._x,m.y+=l._y,l.rotatePoint(e,!1),l.rotatePoint(g,!1),l.rotatePoint(m,!1),l.rotatePoint(k,!1),l=l._parent;for(d=f.length-1;0<=d;d--)f[d].rotatePoint(e,!0),f[d].rotatePoint(g,!0),f[d].rotatePoint(m,!0),f[d].rotatePoint(k,!0),e.x-=
f[d]._x,e.y-=f[d]._y,g.x-=f[d]._x,g.y-=f[d]._y,k.x-=f[d]._x,k.y-=f[d]._y,m.x-=f[d]._x,m.y-=f[d]._y;f=Math.min(e.x,g.x,k.x,m.x);d=Math.max(e.x,g.x,k.x,m.x);l=Math.min(e.y,g.y,k.y,m.y);e=Math.max(e.y,g.y,k.y,m.y);c._x=f;c._y=l;c._width=d-f;c._height=e-l;return c};
CanvasElement.prototype.getMetrics=function(a){null==a&&(a=this);if(null==this._manager||this._manager!=a._manager)return null;var b=new DrawMetrics;b._x=0;b._y=0;b._width=this._width;b._height=this._height;return a==this?b:this.translateMetricsTo(b,a)};
CanvasElement.prototype.addEventListener=function(a,b){CanvasElement.base.prototype.addEventListener.call(this,a,b);"enterframe"!=a&&"localechanged"!=a&&"mousemoveex"!=a||null==this._manager||this._manager._broadcastDispatcher.addEventListener(a,b);return!0};
CanvasElement.prototype.removeEventListener=function(a,b){return 1==CanvasElement.base.prototype.removeEventListener.call(this,a,b)?("enterframe"!=a&&"localechanged"!=a&&"mousemoveex"!=a||null==this._manager||this._manager._broadcastDispatcher.removeEventListener(a,b),!0):!1};CanvasElement.prototype.addCaptureListener=function(a,b){null==this._captureListeners[a]&&(this._captureListeners[a]=[]);this._captureListeners[a].push(b);return!0};
CanvasElement.prototype.removeCaptureListener=function(a,b){if(!(a in this._captureListeners))return!1;for(var c=0;c<this._captureListeners[a].length;c++)if(this._captureListeners[a][c]==b)return this._captureListeners[a].splice(c,1),!0;return!1};CanvasElement.prototype.hasCaptureListener=function(a,b){if(!(a in this._captureListeners))return!1;if(null==b&&0<this._captureListeners[a].length)return!0;for(var c=0;c<this._captureListeners[a].length;c++)if(this._captureListeners[a][c]==b)return!0;return!1};
CanvasElement.adjustColorLight=function(a,b){var c=parseInt(a.slice(1),16),d=0>b?0:255,e=0>b?-1*b:b,f=c>>16,g=c>>8&255,c=c&255;return"#"+(16777216+65536*(Math.round((d-f)*e)+f)+256*(Math.round((d-g)*e)+g)+(Math.round((d-c)*e)+c)).toString(16).slice(1)};CanvasElement.radiansToDegrees=function(a){return 180/Math.PI*a};CanvasElement.degreesToRadians=function(a){return Math.PI/180*a};CanvasElement.normalizeDegrees=function(a){for(;360<=a;)a-=360;for(;0>a;)a+=360;return a};
CanvasElement.roundToPrecision=function(a,b){if(0==b)return Math.round(a);var c=Math.pow(10,b);a=Math.round(a*c);return a/c};CanvasElement._browserType="";CanvasElement._characterWidthMap=Object.create(null);CanvasElement._characterFillBitmapMap=Object.create(null);CanvasElement._characterStrokeBitmapMap=Object.create(null);CanvasElement._measureCharBitmap=null;CanvasElement._measureCharContext=null;
(function(){CanvasElement._measureCharBitmap=document.createElement("canvas");CanvasElement._measureCharBitmap.width=1;CanvasElement._measureCharBitmap.height=1;CanvasElement._measureCharContext=CanvasElement._measureCharBitmap.getContext("2d")})();
CanvasElement._measureText=function(a,b){var c=CanvasElement._characterWidthMap[b];null==c&&(c=Object.create(null),CanvasElement._characterWidthMap[b]=c);for(var d=0,e,f=!1,g=0;g<a.length;g++)e=c[a[g]],null==e&&(0==f&&(CanvasElement._measureCharContext.font=b,f=!0),e=Math.ceil(CanvasElement._measureCharContext.measureText(a[g]).width),c[a[g]]=e),d+=e;return d};
CanvasElement._fillText=function(a,b,c,d,e,f,g){var k=CanvasElement._characterFillBitmapMap[e];null==k&&(k=Object.create(null),CanvasElement._characterFillBitmapMap[e]=k);for(var m=0;m<b.length;m++){var l=k[b[m]];if(null==l){l={canvas:null,context:null,fontSize:0};k[b[m]]=l;l.canvas=document.createElement("canvas");for(var p=e.split(" "),q=0,n=0;n<p.length;n++)if(3<=p[n].length&&"px"==p[n].substr(p[n].length-2,2)){q=Number(p[n].substr(0,p[n].length-2));break}l.fontSize=q;l.canvas.height=q+4;l.canvas.width=
CanvasElement._measureText(b[m],e);l.context=l.canvas.getContext("2d");l.context.font=e;l.context.textBaseline="middle";l.context.textAlign="left";l.context.strokeStyle="#000000";l.context.fillStyle="#000000";l.context.fillText(b[m],0,l.canvas.height/2);l.context.globalCompositeOperation="source-atop"}l.context.fillStyle!=f&&(l.context.fillStyle=f,l.context.beginPath(),l.context.moveTo(0,0),l.context.lineTo(l.canvas.width,0),l.context.lineTo(l.canvas.width,l.canvas.height),l.context.lineTo(0,l.canvas.height),
l.context.closePath(),l.context.fill());"top"==g?a.drawImage(l.canvas,c,Math.round(d-(l.canvas.height-l.fontSize)/2)):"bottom"==g?a.drawImage(l.canvas,c,Math.round(d-((l.canvas.height-l.fontSize)/2+l.fontSize))):a.drawImage(l.canvas,c,Math.round(d-l.canvas.height/2));if(1==b.length)break;c+=CanvasElement._measureText(b[m],e)}};
CanvasElement._strokeText=function(a,b,c,d,e,f,g){var k=CanvasElement._characterStrokeBitmapMap[e];null==k&&(k=Object.create(null),CanvasElement._characterStrokeBitmapMap[e]=k);for(var m=0;m<b.length;m++){var l=k[b[m]];if(null==l){l={canvas:null,context:null};k[b[m]]=l;l.canvas=document.createElement("canvas");for(var p=e.split(" "),q=0,n=0;n<p.length;n++)if(3<=p[n].length&&"px"==p[n].substr(p[n].length-2,2)){q=Number(p[n].substr(0,p[n].length-2));break}l.fontSize=q;l.canvas.height=q+4;l.canvas.width=
CanvasElement._measureText(b[m],e);l.context=l.canvas.getContext("2d");l.context.font=e;l.context.textBaseline="middle";l.context.textAlign="left";l.context.strokeStyle="#000000";l.context.fillStyle="#000000";l.context.strokeText(b[m],0,l.canvas.height/2);l.context.globalCompositeOperation="source-atop"}l.context.fillStyle!=f&&(l.context.fillStyle=f,l.context.beginPath(),l.context.moveTo(0,0),l.context.lineTo(l.canvas.width,0),l.context.lineTo(l.canvas.width,l.canvas.height),l.context.lineTo(0,l.canvas.height),
l.context.closePath(),l.context.fill());"top"==g?a.drawImage(l.canvas,c,Math.round(d-(l.canvas.height-l.fontSize)/2)):"bottom"==g?a.drawImage(l.canvas,c,Math.round(d-((l.canvas.height-l.fontSize)/2+l.fontSize))):a.drawImage(l.canvas,c,Math.round(d-l.canvas.height/2));if(1==b.length)break;c+=CanvasElement._measureText(b[m],e)}};
CanvasElement._calculateMinMaxPercentSizes=function(a,b){if(0!=a.length){var c=a.slice(),d=b,e=0,f;for(f=0;f<c.length;f++)null==c[f].minSize&&(c[f].minSize=0),null==c[f].maxSize&&(c[f].maxSize=Number.MAX_VALUE),null==c[f].percentSize&&(c[f].percentSize=100),e+=c[f].percentSize;for(var g=!1;0==g;)for(g=!0,f=0;f<c.length;f++)if(b=c[f].percentSize/e*d,b>c[f].maxSize){c[f].actualSize=c[f].maxSize;e-=c[f].percentSize;d-=c[f].maxSize;c.splice(f,1);g=!1;break}else if(b<c[f].minSize){c[f].actualSize=c[f].minSize;
e-=c[f].percentSize;d-=c[f].minSize;c.splice(f,1);g=!1;break}else c[f].actualSize=Math.floor(b);for(f=0;f<c.length;f++)d-=c[f].actualSize;for(;1<=d&&0<c.length;)for(f=0;f<c.length;f++){for(;c[f].actualSize+1>c[f].maxSize&&(c.splice(f,1),f!=c.length););if(f==c.length)break;c[f].actualSize++;d--;if(0>=d)break}}};CanvasElement.prototype._onBackgroundShapeStyleChanged=function(a){this._invalidateRender()};
CanvasElement.prototype._onExternalStyleChanged=function(a){if(null!=this._manager){var b=!1,c=!1,d=a.getStyleName(),e=this._getStyleType(d);null!=this._styleProxy&&a.getTarget()==this._styleProxy._proxyElement&&(b=!0);null!=this._parent&&a.getTarget()==this._parent&&(c=!0);0!=(1==b||1==c?1==b&&(1==d in this._styleProxy._proxyMap||null==this._styleProxy._proxyElement._getStyleType(d))||1==c&&null!=e&&1==e.inheritable?!0:!1:!0)&&(b=null,c=this._stylesCache[d],null==c&&(c={styleData:new StyleData(d),
cacheInvalid:!0},this._stylesCache[d]=c),0==c.cacheInvalid&&(b=c.styleData.clone()),c.cacheInvalid=!0,c=this.getStyleData(d),null==b||1!=b.equals(c))&&(null!=e&&this._invalidateStyle(d),this._dispatchEvent(a))}};
CanvasElement.prototype._getDefaultStyleData=function(a){var b=new StyleData(a);null!=this._styleDefinitionDefault&&(b.value=this._styleDefinitionDefault.getStyle(a));if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.DEFAULT_DEFINITION),b;for(var c=this._styleProxy,d=0;null!=c&&(0!=a in c._proxyMap||null==c._proxyElement._getStyleType(a));){null!=c._proxyElement._styleDefinitionDefault&&(b.value=c._proxyElement._styleDefinitionDefault.getStyle(a));if(void 0!==b.value)return b.priority.push(CanvasElement.StylePriorities.DEFAULT_PROXY),
b.priority.push(d),b;d++;c=c._proxyElement._styleProxy}b.value=this._getClassStyle(a);b.priority.push(CanvasElement.StylePriorities.CLASS);return b};CanvasElement.prototype._setStyleDefinitionDefault=function(a){this._styleDefinitionDefault=a};CanvasElement.prototype._setStyleProxy=function(a){this._styleProxy=a};
CanvasElement.prototype._onCanvasElementAdded=function(a){for(var b=0;b<this._styleDefinitions.length;b++)0==this._styleDefinitions[b].hasEventListener("stylechanged",this._onExternalStyleChangedInstance)&&this._styleDefinitions[b].addEventListener("stylechanged",this._onExternalStyleChangedInstance);null!=this._styleProxy&&0==this._styleProxy._proxyElement.hasEventListener("stylechanged",this._onExternalStyleChangedInstance)&&this._styleProxy._proxyElement.addEventListener("stylechanged",this._onExternalStyleChangedInstance);
null!=this._backgroundShape&&0==this._backgroundShape.hasEventListener("stylechanged",this._onBackgroundShapeStyleChangedInstance)&&this._backgroundShape.addEventListener("stylechanged",this._onBackgroundShapeStyleChangedInstance);if("enterframe"in this._eventListeners&&0<this._eventListeners.enterframe.length)for(b=0;b<this._eventListeners.enterframe.length;b++)a.getManager()._broadcastDispatcher.addEventListener("enterframe",this._eventListeners.enterframe[b]);if("localechanged"in this._eventListeners&&
0<this._eventListeners.localechanged.length)for(b=0;b<this._eventListeners.localechanged.length;b++)a.getManager()._broadcastDispatcher.addEventListener("localechanged",this._eventListeners.localechanged[b]);if("mousemoveex"in this._eventListeners&&0<this._eventListeners.mousemoveex.length)for(b=0;b<this._eventListeners.mousemoveex.length;b++)a.getManager()._broadcastDispatcher.addEventListener("mousemoveex",this._eventListeners.mousemoveex[b]);this._invalidateRedrawRegion();this._invalidateCompositeRender();
for(var c in this._stylesCache)this._stylesCache[c].cacheInvalid=!0;a=Object.getPrototypeOf(this);b=null;if(null==a||1==a.hasOwnProperty("constructor"))b=a.constructor;for(;null!=b;){if("_StyleTypes"in b)for(var d in b._StyleTypes)this._invalidateStyle(d);a=Object.getPrototypeOf(a);b=null==a||0==a.hasOwnProperty("constructor")?null:a.constructor}1==this.hasEventListener("localechanged",null)&&this._dispatchEvent(new DispatcherEvent("localechanged"))};
CanvasElement.prototype._onCanvasElementRemoved=function(a){var b;for(b=0;b<this._styleDefinitions.length;b++)0==this._styleDefinitions[b].hasEventListener("stylechanged",this._onExternalStyleChangedInstance)&&this._styleDefinitions[b].removeEventListener("stylechanged",this._onExternalStyleChangedInstance);null!=this._styleProxy&&1==this._styleProxy._proxyElement.hasEventListener("stylechanged",this._onExternalStyleChangedInstance)&&this._styleProxy._proxyElement.removeEventListener("stylechanged",
this._onExternalStyleChangedInstance);null!=this._backgroundShape&&0==this._backgroundShape.hasEventListener("stylechanged",this._onBackgroundShapeStyleChangedInstance)&&this._backgroundShape.removeEventListener("stylechanged",this._onBackgroundShapeStyleChangedInstance);null!=this._rollOverCursorInstance&&(a.getManager().removeCursor(this._rollOverCursorInstance),this._rollOverCursorInstance=null);for(b=0;b<this._compositeMetrics.length;b++)null!=this._compositeMetrics[b].element._manager&&this._compositeMetrics[b].element._updateRedrawRegion(this._compositeMetrics[b].drawableMetrics);
this._renderInvalid=this._layoutInvalid=this._measureInvalid=this._stylesInvalid=!0;this._graphicsCtx=this._graphicsCanvas=null;this._graphicsClear=!0;this._compositeCanvasMetrics=this._compositeCanvas=this._compositeCtx=null;this._renderChanged=!0;this._renderVisible=!1;this._compositeEffectChanged=!0;this._compositeMetrics=[];this._transformDrawableMetrics=this._transformVisibleMetrics=this._redrawRegionMetrics=this._compositeVisibleMetrics=null;if("enterframe"in this._eventListeners&&0<this._eventListeners.enterframe.length)for(b=
0;b<this._eventListeners.enterframe.length;b++)a.getManager()._broadcastDispatcher.removeEventListener("enterframe",this._eventListeners.enterframe[b]);if("localechanged"in this._eventListeners&&0<this._eventListeners.localechanged.length)for(b=0;b<this._eventListeners.localechanged.length;b++)a.getManager()._broadcastDispatcher.removeEventListener("localechanged",this._eventListeners.localechanged[b]);if("mousemoveex"in this._eventListeners&&0<this._eventListeners.mousemoveex.length)for(b=0;b<this._eventListeners.mousemoveex.length;b++)a.getManager()._broadcastDispatcher.removeEventListener("mousemoveex",
this._eventListeners.mousemoveex[b])};CanvasElement.prototype._getFontString=function(){return this.getStyle("TextStyle")+" "+this.getStyle("TextSize")+"px "+this.getStyle("TextFont")};
CanvasElement.prototype._dispatchEvent=function(a){if(a instanceof ElementEvent){a._canceled=!1;a._defaultPrevented=!1;var b=a.clone();b._target=this;var c;if(1==b._bubbles){c=this;var d={x:0,y:0};b instanceof ElementMouseEvent&&(d.x=b._x,d.y=b._y);for(var e=[];null!=c;)e.push({element:c,x:d.x,y:d.y}),b instanceof ElementMouseEvent&&(d.x+=c._x,d.y+=c._y,c.rotatePoint(d,!1)),c=c._parent;b._phase="capture";for(d=e.length-1;0<=d;d--)if(c=e[d].element,b._type in c._captureListeners&&0<c._captureListeners[b._type].length){b._currentTarget=
c;b instanceof ElementMouseEvent&&(b._x=e[d].x,b._y=e[d].y);for(var f=c._captureListeners[b._type].slice(),g=0;g<f.length;g++)if(c=b.clone(),f[g](c),1==c._defaultPrevented&&(a._defaultPrevented=!0),1==c._canceled){a._canceled=!0;return}}b._phase="bubble";for(d=0;d<e.length;d++)if(c=e[d].element,b._type in c._eventListeners&&0<c._eventListeners[b._type].length)for(b._currentTarget=c,b instanceof ElementMouseEvent&&(b._x=e[d].x,b._y=e[d].y),f=c._eventListeners[b._type].slice(),g=0;g<f.length;g++)if(c=
b.clone(),f[g](c),1==c._defaultPrevented&&(a._defaultPrevented=!0),1==c._canceled){a._canceled=!0;return}}else{b._currentTarget=this;b._phase="capture";if(b._type in this._captureListeners&&0<this._captureListeners[b._type].length)for(f=this._captureListeners[b._type].slice(),g=0;g<f.length;g++)if(c=b.clone(),f[g](c),1==c._defaultPrevented&&(a._defaultPrevented=!0),1==c._canceled){a._canceled=!0;return}b._phase="bubble";if(b._type in this._eventListeners&&0<this._eventListeners[b._type].length)for(f=
this._eventListeners[b._type].slice(),g=0;g<f.length;g++)if(c=b.clone(),f[g](c),1==c._defaultPrevented&&(a._defaultPrevented=!0),1==c._canceled){a._canceled=!0;break}}}else CanvasElement.base.prototype._dispatchEvent.call(this,a)};CanvasElement.prototype._addChild=function(a){return this._addChildAt(a,this._children.length)};
CanvasElement.prototype._addChildAt=function(a,b){if(!(a instanceof CanvasElement)||0>b||b>this._children.length)return null;null!=a._parent&&a._parent._removeChild(a);a._parent=this;this._children.splice(b,0,a);this.addEventListener("stylechanged",a._onExternalStyleChangedInstance);a._propagateChildData();this._invalidateMeasure();this._invalidateLayout();null!=this._manager&&(this._manager._rollOverInvalid=!0,this._manager._processAddRemoveDisplayChainQueue());return a};
CanvasElement.prototype._removeChild=function(a){a=this._children.indexOf(a);return-1==a?null:this._removeChildAt(a)};
CanvasElement.prototype._removeChildAt=function(a){if(0>a||a>this._children.length-1)return null;a=this._children.splice(a,1)[0];1==a._mouseIsDown&&(a._manager._mouseDownElement=a._parent);1==a._mouseIsOver&&(a._manager._rollOverElement=a._parent);a._parent=null;this.removeEventListener("stylechanged",a._onExternalStyleChangedInstance);a._propagateChildData();this._invalidateMeasure();this._invalidateLayout();null!=this._manager&&(this._manager._rollOverInvalid=!0,this._manager._processAddRemoveDisplayChainQueue());
return a};CanvasElement.prototype._getChildAt=function(a){return 0>a||a>this._children.length-1?null:this._children[a]};CanvasElement.prototype._getChildIndex=function(a){return this._children.indexOf(a)};CanvasElement.prototype._setChildIndex=function(a,b){if(0>b||b>this._children.length-1)return!1;var c=this._getChildIndex(a);if(-1==c||c==b)return!1;this._children.splice(b,0,this._children.splice(c,1)[0]);this._invalidateMeasure();this._invalidateLayout();return!0};
CanvasElement.prototype._getNumChildren=function(){return this._children.length};
CanvasElement.prototype._propagateChildData=function(){var a=this instanceof CanvasManager;0==a&&(null==this._parent||0==this._parent._displayDepth)||1==a&&null!=this._manager?(null!=this._manager&&(1==this._stylesInvalid&&this._manager._updateStylesQueue.removeNode(this._stylesValidateNode,this._displayDepth),1==this._measureInvalid&&this._manager._updateMeasureQueue.removeNode(this._measureValidateNode,this._displayDepth),1==this._layoutInvalid&&this._manager._updateLayoutQueue.removeNode(this._layoutValidateNode,
this._displayDepth),1==this._renderInvalid&&this._manager._updateRenderQueue.removeNode(this._renderValidateNode,this._displayDepth),1==this._compositeRenderInvalid&&this._manager._compositeRenderQueue.removeNode(this._compositeRenderValidateNode,this._displayDepth),this==this._manager._draggingElement&&this._manager._clearDraggingElement(),this==this._manager._focusElement&&(this._manager._focusElement=null),this._manager._pushAddRemoveDisplayChainQueue(this,"removed")),this._mouseIsDown=this._mouseIsOver=
this._isFocused=this._renderFocusRing=!1,this._displayDepth=0,this._manager=null):(1==a?(this._displayDepth=1,this._manager=this):(this._displayDepth=this._parent._displayDepth+1,this._manager=this._parent._manager),null!=this._manager&&(1==this._stylesInvalid&&this._manager._updateStylesQueue.addNode(this._stylesValidateNode,this._displayDepth),1==this._measureInvalid&&this._manager._updateMeasureQueue.addNode(this._measureValidateNode,this._displayDepth),1==this._layoutInvalid&&this._manager._updateLayoutQueue.addNode(this._layoutValidateNode,
this._displayDepth),1==this._renderInvalid&&this._manager._updateRenderQueue.addNode(this._renderValidateNode,this._displayDepth),1==this._compositeRenderInvalid&&this._manager._compositeRenderQueue.addNode(this._compositeRenderValidateNode,this._displayDepth),this._manager._pushAddRemoveDisplayChainQueue(this,"added")));for(a=0;a<this._children.length;a++)this._children[a]._propagateChildData()};
CanvasElement.prototype._setRelativePosition=function(a,b,c){if(null==c||c==this){if(this._x==a&&this._y==b)return;this._x=a;this._y=b;null!=this._manager&&(this._manager._rollOverInvalid=!0);this._invalidateRedrawRegion()}if(null!=this._manager&&this._manager==c._manager){var d=this.getMetrics(this._parent);a={x:a,y:b};c.translatePointTo(a,this._parent);if(a.x!=d.getX()||a.y!=d.getY())c=a.x-d.getX(),d=a.y-d.getY(),this._x+=c,this._y+=d,0!=this._rotateDegrees&&(this._rotateCenterX+=c,this._rotateCenterY+=
d),null!=this._manager&&(this._manager._rollOverInvalid=!0),this._invalidateRedrawRegion()}};CanvasElement.prototype._setActualPosition=function(a,b){a=Math.round(a);b=Math.round(b);if(this._x!=a||this._y!=b)this._x=a,this._y=b,null!=this._manager&&(this._manager._rollOverInvalid=!0),this._invalidateRedrawRegion()};
CanvasElement.prototype._setActualSize=function(a,b){a=Math.round(a);b=Math.round(b);if(this._width==a&&this._height==b)return!1;this._width=a;this._height=b;this._invalidateLayout();this._invalidateRender();1==this.hasEventListener("resize",null)&&this._dispatchEvent(new DispatcherEvent("resize"),!1);null!=this._manager&&(this._manager._rollOverInvalid=!0);return!0};
CanvasElement.prototype._setActualRotation=function(a,b,c){if(null==b||null==c)c=b=0;if(this._rotateDegrees!=a||this._rotateCenterX!=b||this._rotateCenterY!=c)this._invalidateRedrawRegion(),this._rotateDegrees!=a&&(this._compositeEffectChanged=!0,this._invalidateCompositeRender());this._rotateDegrees=a;this._rotateCenterX=b;this._rotateCenterY=c};
CanvasElement.prototype._setMeasuredSize=function(a,b){if(this._measuredWidth!=a||this._measuredHeight!=b)this._measuredWidth=a,this._measuredHeight=b,null!=this._parent&&(this._parent._invalidateMeasure(),this._parent._invalidateLayout())};CanvasElement.prototype._setRenderFocusRing=function(a){this._renderFocusRing!=a&&(this._renderFocusRing=a,this._invalidateRender())};CanvasElement.prototype._createMetrics=function(){return new DrawMetrics};
CanvasElement.prototype._getGraphicsCtx=function(){null==this._graphicsCanvas&&(this._graphicsCanvas=document.createElement("canvas"),this._graphicsCtx=this._graphicsCanvas.getContext("2d"),this._graphicsCanvas.width=this._width,this._graphicsCanvas.height=this._height);this._renderChanged=!0;this._graphicsClear=!1;this._invalidateRedrawRegion();return this._graphicsCtx};
CanvasElement.prototype._getPaddingSize=function(){var a=this.getStyleData("Padding"),b=this.getStyleData("PaddingTop"),c=this.getStyleData("PaddingBottom"),d=this.getStyleData("PaddingLeft"),e=this.getStyleData("PaddingRight"),f=b.value;0<a.comparePriority(b)&&(f=a.value);b=c.value;0<a.comparePriority(c)&&(b=a.value);c=d.value;0<a.comparePriority(d)&&(c=a.value);d=e.value;0<a.comparePriority(e)&&(d=a.value);return{width:c+d,height:f+b,paddingBottom:b,paddingTop:f,paddingLeft:c,paddingRight:d}};
CanvasElement.prototype._getBorderThickness=function(){var a=0,b=this.getStyle("BorderType"),c=this.getStyle("BorderColor");"solid"!=b&&"inset"!=b&&"outset"!=b||null==c||(a=this.getStyle("BorderThickness"),0>a&&(a=0));return a};CanvasElement.prototype._getStyledOrMeasuredWidth=function(){var a=this.getStyle("Width");null==a&&(a=this._measuredWidth);return a};CanvasElement.prototype._getStyledOrMeasuredHeight=function(){var a=this.getStyle("Height");null==a&&(a=this._measuredHeight);return a};
CanvasElement.prototype._getBorderMetrics=function(){var a=this._createMetrics(),b=this._getBorderThickness();a._x=b/2;a._y=b/2;a._width=this._width-b;a._height=this._height-b;return a};CanvasElement.prototype._getPaddingMetrics=function(){var a=this._createMetrics(),b=this._getPaddingSize();a._x=b.paddingLeft;a._y=b.paddingTop;a._width=this._width-b.paddingLeft-b.paddingRight;a._height=this._height-b.paddingTop-b.paddingBottom;return a};
CanvasElement.prototype._getAutoGradientFill=function(a,b){var c=this.getStyle("AutoGradientType");return"radial"==c?this._getAutoGradientRadial(a,b):"linear"==c?this._getAutoGradientLinear(a,b):null};
CanvasElement.prototype._getAutoGradientMetrics=function(){var a=this.getMetrics(this._manager),b=a.getX(),c=a.getY(),d=a.getWidth(),a=a.getHeight(),e=a*Math.tan(CanvasElement.degreesToRadians(8)),f={x:0,y:c};f.x=e<=d?b+d/2-e/2:b-(e-d)/2;c={x:0,y:c+a};c.x=e<=d?b+d/2+e/2:b+d+(e-d)/2;this._manager.translatePointTo(f,this);this._manager.translatePointTo(c,this);return{startPoint:f,endPoint:c,width:d,height:a}};
CanvasElement.prototype._getAutoGradientLinear=function(a,b){var c=CanvasElement.adjustColorLight(a,this.getStyle("AutoGradientStart")),d=CanvasElement.adjustColorLight(a,this.getStyle("AutoGradientStop")),e=this._getAutoGradientMetrics(),e=b.createLinearGradient(e.startPoint.x,e.startPoint.y,e.endPoint.x,e.endPoint.y);try{e.addColorStop(0,c),e.addColorStop(1,d)}catch(f){return null}return e};
CanvasElement.prototype._getAutoGradientRadial=function(a,b){var c=CanvasElement.adjustColorLight(a,this.getStyle("AutoGradientStart")),d=CanvasElement.adjustColorLight(a,this.getStyle("AutoGradientStop")),e=this._getAutoGradientMetrics(),f=e.endPoint.x-e.startPoint.x,g=e.endPoint.y-e.startPoint.y,k=e.startPoint.x+.42*f,m=e.startPoint.y+.42*g,e=b.createRadialGradient(k,m,Math.max(e.width,e.height)/2+.08*Math.max(f,g),k,m,0);e.addColorStop(0,d);e.addColorStop(1,c);return e};
CanvasElement.prototype._drawBackgroundShape=function(a,b){if(null==this._backgroundShape){var c=b.getX(),d=b.getY(),e=b.getWidth(),f=b.getHeight();a.moveTo(c,d);a.lineTo(c+e,d);a.lineTo(c+e,d+f);a.lineTo(c,d+f);a.closePath()}else this._backgroundShape.drawShape(a,b)};
CanvasElement.prototype._drawFocusRing=function(a,b){var c=this.getStyle("FocusThickness");if(!(0>=c)){var d=this.getStyle("FocusColor");if(null!=d){var e=this.getMetrics(this),f=e.getX()-c,g=e.getY()-c,k=e.getWidth()+2*c,e=e.getHeight()+2*c;a.beginPath();a.moveTo(f,g);a.lineTo(f,g+e);a.lineTo(f+k,g+e);a.lineTo(f+k,g);a.closePath();this._drawBackgroundShape(a,b);a.clip();a.beginPath();this._drawBackgroundShape(a,b);a.strokeStyle=d;a.lineWidth=this._getBorderThickness()+2*c;a.stroke()}}};
CanvasElement.prototype._fillBackground=function(a){var b=this.getStyle("BackgroundColor");if(null!=b){var c=this._getGraphicsCtx(),d=this._getAutoGradientFill(b,c);c.fillStyle=null!=d?d:b;c.beginPath();this._drawBackgroundShape(c,a);c.fill()}};CanvasElement.prototype._drawSolidBorder=function(a,b){var c=this.getStyle("BorderColor");if(null!=c){var d=this.getStyle("BorderThickness");0>d||(a.beginPath(),this._drawBackgroundShape(a,b),a.strokeStyle=c,a.lineWidth=d,a.stroke())}};
CanvasElement.prototype._drawBorder=function(a){var b=this.getStyle("BorderType");if("solid"==b||"inset"==b||"outset"==b){var c=this._getGraphicsCtx();if("solid"==b)this._drawSolidBorder(c,a);else{var d=this.getStyle("BorderColor");a=this.getStyle("BorderThickness");if(!(null==d||0>=a)){var e=this._width,f=this._height,g=CanvasElement.adjustColorLight(d,.3),k=CanvasElement.adjustColorLight(d,-.3),d="inset"==b?k:g,b="inset"==b?g:k;c.beginPath();c.moveTo(0,0+f);c.lineTo(0,0);c.lineTo(0+e,0);c.lineTo(0+
e-a,0+a);c.lineTo(0+a,0+a);c.lineTo(0+a,0+f-a);c.closePath();c.fillStyle=d;c.fill();c.beginPath();c.moveTo(0,0+f);c.lineTo(0+e,0+f);c.lineTo(0+e,0);c.lineTo(0+e-a,0+a);c.lineTo(0+e-a,0+f-a);c.lineTo(0+a,0+f-a);c.closePath();c.fillStyle=b;c.fill();c.lineWidth=1;c.globalAlpha=.15;c.strokeStyle="#000000";c.beginPath();c.moveTo(0,0);c.lineTo(0+a,0+a);c.stroke();c.beginPath();c.moveTo(0+e,0+f);c.lineTo(0+e-a,0+f-a);c.stroke()}}}};
CanvasElement.prototype._validateStyles=function(){this._stylesInvalid=!1;var a=Object.create(null),b;for(b in this._stylesInvalidMap)1==this._stylesInvalidMap[b]&&(a[b]=!0,this._stylesInvalidMap[b]=!1);this._doStylesUpdated(a)};CanvasElement.prototype._validateMeasure=function(){this._measureInvalid=!1;var a=this._getPaddingSize(),a=this._doMeasure(a.width,a.height);this._setMeasuredSize(a.width,a.height)};
CanvasElement.prototype._validateLayout=function(){this._layoutInvalid=!1;this._doLayout(this._getPaddingMetrics());0==this._layoutInvalid&&this.hasEventListener("layoutcomplete",null)&&this._dispatchEvent(new DispatcherEvent("layoutcomplete"))};
CanvasElement.prototype._validateRender=function(){this._renderInvalid=!1;null!=this._graphicsCanvas&&(this._graphicsCanvas.width=this._width,this._graphicsCanvas.height=this._height,this._graphicsCtx.clearRect(0,0,this._graphicsCanvas.width,this._graphicsCanvas.height));0==this._graphicsClear&&(this._graphicsClear=this._renderChanged=!0,this._invalidateRedrawRegion());this._doRender()};
CanvasElement.prototype._getCompositeMetrics=function(a){for(var b=0;b<this._compositeMetrics.length;b++)if(this._compositeMetrics[b].element==a)return this._compositeMetrics[b];return null};
CanvasElement.prototype._validateCompositeRender=function(){1==this._isCompositeElement()?(this._updateCompositeCanvas(),null!=this._redrawRegionMetrics&&null!=this._compositeCanvasMetrics&&(--this._redrawRegionMetrics._x,--this._redrawRegionMetrics._y,this._redrawRegionMetrics._width+=2,this._redrawRegionMetrics._height+=2,this._redrawRegionMetrics.roundUp(),this._redrawRegionMetrics.mergeReduce(this._compositeCanvasMetrics),0<this._redrawRegionMetrics._width&&0<this._redrawRegionMetrics._height&&
(this._compositeCtx.clearRect(this._redrawRegionMetrics._x,this._redrawRegionMetrics._y,this._redrawRegionMetrics._width,this._redrawRegionMetrics._height),this._renderRedrawRegion(this)))):this._compositeCanvasMetrics=this._compositeCtx=this._compositeCanvas=null;this._compositeEffectChanged=this._compositeRenderInvalid=!1;this._redrawRegionMetrics=null};
CanvasElement.prototype._updateCompositeCanvas=function(){if(null==this._compositeVisibleMetrics)this._compositeCanvasMetrics=this._compositeCtx=this._compositeCanvas=null;else{var a=this._compositeVisibleMetrics.clone();a.roundUp();if(null==this._compositeCanvas||0==this._compositeCanvasMetrics.equals(a))null==this._compositeCanvas&&(this._compositeCanvas=document.createElement("canvas"),this._compositeCtx=this._compositeCanvas.getContext("2d")),null==this._compositeCanvasMetrics?this._compositeCanvasMetrics=
a:this._compositeCanvasMetrics.copyFrom(a),this._compositeCanvas.width=this._compositeCanvasMetrics._width,this._compositeCanvas.height=this._compositeCanvasMetrics._height,this._compositeCtx.setTransform(1,0,0,1,-1*this._compositeCanvasMetrics._x,-1*this._compositeCanvasMetrics._y),null==this._redrawRegionMetrics?this._redrawRegionMetrics=this._compositeCanvasMetrics.clone():this._redrawRegionMetrics.mergeExpand(this._compositeCanvasMetrics)}};
CanvasElement.prototype._isCompositeElement=function(){if(this==this._manager)return!0;var a=this.getStyle("Alpha");return 0<a&&1>a||0!=CanvasElement.normalizeDegrees(this._rotateDegrees)||0<this.getStyle("ShadowSize")&&null!=this.getStyle("ShadowColor")||1==this.getStyle("CompositeLayer")?!0:!1};CanvasElement.prototype._updateRedrawRegion=function(a){null==a||0>=a._width||0>=a._height||(null==this._redrawRegionMetrics?this._redrawRegionMetrics=a.clone():this._redrawRegionMetrics.mergeExpand(a),this._invalidateCompositeRender())};
CanvasElement.prototype._primeShadow=function(){this._compositeCtx.beginPath();this._compositeCtx.moveTo(this._compositeCanvasMetrics._x-1,this._compositeCanvasMetrics._y-1);this._compositeCtx.moveTo(this._compositeCanvasMetrics._x,this._compositeCanvasMetrics._y-1);this._compositeCtx.moveTo(this._compositeCanvasMetrics._x,this._compositeCanvasMetrics._y);this._compositeCtx.moveTo(this._compositeCanvasMetrics._x-1,this._compositeCanvasMetrics._y);this._compositeCtx.closePath();this._compositeCtx.fillStyle=
"#000000";this._compositeCtx.fill()};
CanvasElement.prototype._renderRedrawRegion=function(a){if(0!=a._renderVisible){var b=!1;this!=a&&1==a._isCompositeElement()&&(b=!0);var c=null,d=null,e=null;1==b&&null!=a._transformDrawableMetrics?(e=a._transformVisibleMetrics,d=a._transformDrawableMetrics,c=a._compositeCanvas,this._compositeCtx.globalAlpha=a.getStyle("Alpha")):0<a._compositeMetrics.length&&0==a._graphicsClear&&(e=a._compositeMetrics[0].metrics,d=a._compositeMetrics[0].drawableMetrics,c=a._graphicsCanvas,this._compositeCtx.globalAlpha=
1);if(null!=c&&0<d._width&&0<d._height&&d._x<this._redrawRegionMetrics._x+this._redrawRegionMetrics._width&&d._x+d._width>this._redrawRegionMetrics._x&&d._y<this._redrawRegionMetrics._y+this._redrawRegionMetrics._height&&d._y+d._height>this._redrawRegionMetrics._y)if(1==b&&0!=CanvasElement.normalizeDegrees(a._rotateDegrees)){var f=d.clone();f.mergeReduce(this._redrawRegionMetrics);this._compositeCtx.save();this._compositeCtx.beginPath();this._compositeCtx.moveTo(f._x,f._y);this._compositeCtx.lineTo(f._x+
f._width,f._y);this._compositeCtx.lineTo(f._x+f._width,f._y+f._height);this._compositeCtx.lineTo(f._x,f._y+f._height);this._compositeCtx.closePath();this._compositeCtx.clip();for(f=a._parent;0==f._isCompositeElement();)this._compositeCtx.translate(f._x,f._y),f=f._parent;this._compositeCtx.translate(a._rotateCenterX,a._rotateCenterY);this._compositeCtx.rotate(CanvasElement.degreesToRadians(a._rotateDegrees));this._compositeCtx.translate(-a._rotateCenterX,-a._rotateCenterY);this._compositeCtx.translate(a._compositeCanvasMetrics._x,
a._compositeCanvasMetrics._y);if(0<a.getStyle("ShadowSize")&&null!=a.getStyle("ShadowColor")){this._primeShadow();this._compositeCtx.shadowBlur=a.getStyle("ShadowSize");this._compositeCtx.shadowColor=a.getStyle("ShadowColor");var g=a.getStyle("ShadowOffsetX"),k=a.getStyle("ShadowOffsetY"),f=Math.sqrt(g*g+k*k),g=360-a._rotateDegrees+CanvasElement.radiansToDegrees(Math.atan2(g,k));this._compositeCtx.shadowOffsetX=Math.sin(CanvasElement.degreesToRadians(g))*f;this._compositeCtx.shadowOffsetY=Math.cos(CanvasElement.degreesToRadians(g))*
f}this._compositeCtx.drawImage(c,0,0,a._compositeCanvasMetrics._width,a._compositeCanvasMetrics._height,a._x,a._y,a._compositeCanvasMetrics._width,a._compositeCanvasMetrics._height);this._compositeCtx.restore()}else if(1==b&&0<a.getStyle("ShadowSize")&&null!=a.getStyle("ShadowColor"))this._compositeCtx.save(),f=d.clone(),f.mergeReduce(this._redrawRegionMetrics),this._compositeCtx.beginPath(),this._compositeCtx.moveTo(f._x,f._y),this._compositeCtx.lineTo(f._x+f._width,f._y),this._compositeCtx.lineTo(f._x+
f._width,f._y+f._height),this._compositeCtx.lineTo(f._x,f._y+f._height),this._compositeCtx.closePath(),this._compositeCtx.clip(),this._primeShadow(),this._compositeCtx.shadowBlur=a.getStyle("ShadowSize"),this._compositeCtx.shadowColor=a.getStyle("ShadowColor"),this._compositeCtx.shadowOffsetX=a.getStyle("ShadowOffsetX"),this._compositeCtx.shadowOffsetY=a.getStyle("ShadowOffsetY"),f=e._x-(a._compositeVisibleMetrics._x-a._compositeCanvasMetrics._x),e=e._y-(a._compositeVisibleMetrics._y-a._compositeCanvasMetrics._y),
this._compositeCtx.drawImage(c,0,0,a._compositeCanvasMetrics._width,a._compositeCanvasMetrics._height,f,e,a._compositeCanvasMetrics._width,a._compositeCanvasMetrics._height),this._compositeCtx.restore();else{var m;d._x>=this._redrawRegionMetrics._x?(g=d._x-e._x,f=d._x,k=Math.min(d._width,this._redrawRegionMetrics._width-(d._x-this._redrawRegionMetrics._x))):(g=this._redrawRegionMetrics._x-e._x,f=this._redrawRegionMetrics._x,k=Math.min(this._redrawRegionMetrics._width,d._width-(this._redrawRegionMetrics._x-
d._x)));d._y>=this._redrawRegionMetrics._y?(m=d._y-e._y,e=d._y,d=Math.min(d._height,this._redrawRegionMetrics._height-(d._y-this._redrawRegionMetrics._y))):(m=this._redrawRegionMetrics._y-e._y,e=this._redrawRegionMetrics._y,d=Math.min(this._redrawRegionMetrics._height,d._height-(this._redrawRegionMetrics._y-d._y)));this._compositeCtx.drawImage(c,g,m,k,d,f,e,k,d)}if(0==b)for(b=0;b<a._children.length;b++)this._renderRedrawRegion(a._children[b])}};
CanvasElement.prototype._invalidateStyle=function(a){0==this._stylesInvalid&&(this._stylesInvalid=!0,null!=this._manager&&this._manager._updateStylesQueue.addNode(this._stylesValidateNode,this._displayDepth));this._stylesInvalidMap[a]=!0};CanvasElement.prototype._invalidateMeasure=function(){0==this._measureInvalid&&(this._measureInvalid=!0,null!=this._manager&&this._manager._updateMeasureQueue.addNode(this._measureValidateNode,this._displayDepth))};
CanvasElement.prototype._invalidateLayout=function(){0==this._layoutInvalid&&(this._layoutInvalid=!0,null!=this._manager&&this._manager._updateLayoutQueue.addNode(this._layoutValidateNode,this._displayDepth))};CanvasElement.prototype._invalidateRender=function(){0==this._renderInvalid&&(this._renderInvalid=!0,null!=this._manager&&this._manager._updateRenderQueue.addNode(this._renderValidateNode,this._displayDepth))};
CanvasElement.prototype._invalidateRedrawRegion=function(){null!=this._manager&&(this._manager._redrawRegionInvalid=!0)};CanvasElement.prototype._invalidateCompositeRender=function(){0==this._compositeRenderInvalid&&(this._compositeRenderInvalid=!0,null!=this._manager&&this._manager._compositeRenderQueue.addNode(this._compositeRenderValidateNode,this._displayDepth))};
CanvasElement.prototype._doStylesUpdated=function(a){null==this._parent||0!=this._parent._measureInvalid&&0!=this._parent._layoutInvalid||!("X"in a||"Y"in a||"Width"in a||"Height"in a||"PercentWidth"in a||"PercentHeight"in a||"MinWidth"in a||"MinHeight"in a||"MaxWidth"in a||"MaxHeight"in a||"Top"in a||"Left"in a||"Bottom"in a||"Right"in a||"HorizontalCenter"in a||"VerticalCenter"in a||"IncludeInLayout"in a||"RotateDegrees"in a||"RotateCenterX"in a||"RotateCenterY"in a)||(this._parent._invalidateMeasure(),
this._parent._invalidateLayout());if(0==this._measureInvalid||0==this._layoutInvalid)if("Padding"in a||"PaddingTop"in a||"PaddingBottom"in a||"PaddingLeft"in a||"PaddingRight"in a)this._invalidateMeasure(),this._invalidateLayout();("BorderThickness"in a||"BorderType"in a||"BorderColor"in a||"BackgroundColor"in a||"AutoGradientType"in a||"AutoGradientStart"in a||"AutoGradientStop"in a||1==this._renderFocusRing&&("FocusColor"in a||"FocusThickness"in a))&&this._invalidateRender();("Visible"in a||"ClipContent"in
a)&&this._invalidateRedrawRegion();if("Alpha"in a||"ShadowSize"in a)this._compositeEffectChanged=!0,this._invalidateRedrawRegion(),this._invalidateCompositeRender();if("BackgroundShape"in a){var b=this.getStyle("BackgroundShape");b!=this._backgroundShape&&(null!=this._backgroundShape&&this._backgroundShape.removeEventListener("stylechanged",this._onBackgroundShapeStyleChangedInstance),this._backgroundShape=b,null!=this._backgroundShape&&this._backgroundShape.addEventListener("stylechanged",this._onBackgroundShapeStyleChangedInstance),
this._invalidateRender())}"Cursor"in a&&(b=this.getStyle("Cursor"),null==b&&1==this.hasEventListener("rollover",this._onCanvasElementCursorOverOutInstance)?(this.removeEventListener("rollover",this._onCanvasElementCursorOverOutInstance),this.removeEventListener("rollout",this._onCanvasElementCursorOverOutInstance)):null!=b&&0==this.hasEventListener("rollover",this._onCanvasElementCursorOverOutInstance)&&(this.addEventListener("rollover",this._onCanvasElementCursorOverOutInstance),this.addEventListener("rollout",
this._onCanvasElementCursorOverOutInstance)),this._updateRolloverCursorDefinition());"Enabled"in a&&0==this.getStyle("Enabled")&&this._setRenderFocusRing(!1);if("Visible"in a||"MouseEnabled"in a)this._manager._rollOverInvalid=!0};
CanvasElement.prototype._updateRolloverCursorDefinition=function(){var a=this.getStyle("Cursor");null==this._rollOverCursorInstance||null!=a&&0!=this._mouseIsOver?1==this._mouseIsOver&&null!=a&&(null==this._rollOverCursorInstance?this._rollOverCursorInstance=this._manager.addCursor(a,0):this._rollOverCursorInstance.data!=a&&(this._manager.removeCursor(this._rollOverCursorInstance),this._rollOverCursorInstance=this._manager.addCursor(a,0))):(this._manager.removeCursor(this._rollOverCursorInstance),
this._rollOverCursorInstance=null)};CanvasElement.prototype._doMeasure=function(a,b){return{width:a,height:b}};CanvasElement.prototype._doLayout=function(a){};CanvasElement.prototype._doRender=function(){var a=this._getBorderMetrics();this._fillBackground(a);this._drawBorder(a)};CanvasElement.prototype._setListData=function(a,b){this._listData=a;this._itemData=b};CanvasElement.prototype._setListSelected=function(a){this._listSelected=a};
function TextFieldLineElement(){TextFieldLineElement.base.prototype.constructor.call(this);this._text="";this._highlightMaxIndex=this._highlightMinIndex=0;this._parentTextField=null;this._charMetricsEndIndex=this._charMetricsStartIndex=-1}TextFieldLineElement.prototype=Object.create(CanvasElement.prototype);TextFieldLineElement.prototype.constructor=TextFieldLineElement;TextFieldLineElement.base=CanvasElement;
TextFieldLineElement.prototype.setParentLineMetrics=function(a,b,c){this._parentTextField=a;this._charMetricsStartIndex=b;this._charMetricsEndIndex=c;a=a._text.substring(b,c);a!=this._text&&(this._text=a,this._invalidateRender())};
TextFieldLineElement.prototype.setParentSelection=function(a,b){var c=Math.min(a,b),d=Math.max(a,b);c<this._charMetricsStartIndex&&(c=this._charMetricsStartIndex);d>this._charMetricsEndIndex&&(d=this._charMetricsEndIndex);if(c>d||c==d)d=c=0;if(this._highlightMinIndex!=c||this._highlightMaxIndex!=d)this._highlightMinIndex=c,this._highlightMaxIndex=d,this._invalidateRender()};
TextFieldLineElement.prototype.getLineWidth=function(){return-1<this._charMetricsStartIndex&&-1<this._charMetricsEndIndex?this._parentTextField._charMetrics[this._charMetricsEndIndex].x-this._parentTextField._charMetrics[this._charMetricsStartIndex].x:0};
TextFieldLineElement.prototype._doStylesUpdated=function(a){TextFieldLineElement.base.prototype._doStylesUpdated.call(this,a);"TextStyle"in a||"TextFont"in a||"TextSize"in a||"TextColor"in a||"TextFillType"in a?this._invalidateRender():("TextHighlightedColor"in a||"TextHighlightedBackgroundColor"in a)&&this._highlightMinIndex!=this._highlightMaxIndex&&this._invalidateRender()};
TextFieldLineElement.prototype._doRender=function(){TextFieldLineElement.base.prototype._doRender.call(this);if(0!=this._text.length){var a=this._getPaddingMetrics(),b=this._getGraphicsCtx(),c=this.getStyle("TextFillType"),d=this.getStyle("TextColor"),e=this.getStyle("TextHighlightedColor"),f=this.getStyle("TextHighlightedBackgroundColor"),g=this._getFontString(),k=a.getX(),a=a.getY()+a.getHeight()/2;if(this._highlightMinIndex==this._highlightMaxIndex)"stroke"==c?CanvasElement._strokeText(b,this._text,
k,a,g,d,"middle"):CanvasElement._fillText(b,this._text,k,a,g,d,"middle");else for(var m=0;m<this._text.length;m++){var l=CanvasElement._measureText(this._text[m],g);this._highlightMinIndex<=m&&this._highlightMaxIndex>m?(b.fillStyle=f,b.beginPath(),b.moveTo(k,0),b.lineTo(k+l,0),b.lineTo(k+l,this._height),b.lineTo(k,this._height),b.closePath(),b.fill(),"stroke"==c?CanvasElement._strokeText(b,this._text[m],k,a,g,e,"middle"):CanvasElement._fillText(b,this._text[m],k,a,g,e,"middle")):"stroke"==c?CanvasElement._strokeText(b,
this._text[m],k,a,g,d,"middle"):CanvasElement._fillText(b,this._text[m],k,a,g,d,"middle");k+=l}}};
function TextFieldElement(){TextFieldElement.base.prototype.constructor.call(this);this._textCaret=null;this._caretIndex=this._textHighlightStartIndex=0;this._caretEnabled=!1;this._caretBlinkTime=0;this._caretBlinkVisible=!1;this._text="";this._spaceSpans=this._charMetrics=null;this._dragHighlightScrollCharacterDirection=this._dragHighlightScrollCharacterDuration=this._dragHighlightScrollCharacterTime=0;this._textLinesContainer=new CanvasElement;this._textLinesContainer.setStyle("ClipContent",!0);
this._addChild(this._textLinesContainer);var a=this;this._onTextFieldFocusEventInstance=function(b){"focusin"==b.getType()?a._onTextFieldFocusIn(b):a._onTextFieldFocusOut(b)};this._onTextFieldKeyDownInstance=function(b){a._onTextFieldKeyDown(b)};this._onTextFieldMouseEventInstance=function(b){"mousedown"==b.getType()?a._onTextFieldMouseDown(b):"mouseup"==b.getType()?a._onTextFieldMouseUp(b):"mousemoveex"==b.getType()&&a._onTextFieldCanvasMouseMoveEx(b)};this._onTextFieldEnterFrameInstance=function(b){a._onTextFieldEnterFrame(b)};
this._onTextFieldCopyPasteInstance=function(b){window.removeEventListener(b.type,a._onTextFieldCopyPasteInstance);try{return b.clipboardData&&("copy"==b.type?a._onTextFieldCopy(b.clipboardData):"paste"==b.type?a._onTextFieldPaste(b.clipboardData):a._onTextFieldCut(b.clipboardData)),b.preventDefault&&b.preventDefault(),!1}catch(c){}}}TextFieldElement.prototype=Object.create(CanvasElement.prototype);TextFieldElement.prototype.constructor=TextFieldElement;TextFieldElement.base=CanvasElement;
TextFieldElement._StyleTypes=Object.create(null);TextFieldElement._StyleTypes.Selectable={inheritable:!1};TextFieldElement._StyleTypes.MaxChars={inheritable:!1};TextFieldElement._StyleTypes.Multiline={inheritable:!1};TextFieldElement.StyleDefault=new StyleDefinition;TextFieldElement.StyleDefault.setStyle("Selectable",!1);TextFieldElement.StyleDefault.setStyle("MaxChars",0);TextFieldElement.StyleDefault.setStyle("Multiline",!1);TextFieldElement.StyleDefault.setStyle("Enabled",!1);
TextFieldElement.StyleDefault.setStyle("TabStop",0);TextFieldElement.StyleDefault.setStyle("Cursor","text");TextFieldElement.StyleDefault.setStyle("BorderType","none");TextFieldElement.StyleDefault.setStyle("PaddingTop",0);TextFieldElement.StyleDefault.setStyle("PaddingBottom",0);TextFieldElement.StyleDefault.setStyle("PaddingLeft",3);TextFieldElement.StyleDefault.setStyle("PaddingRight",2);TextFieldElement.StyleDefault.setStyle("BackgroundColor",null);
TextFieldElement.prototype.setText=function(a){null==a&&(a="");if("string"!==typeof a)try{a=a.toString()}catch(c){a=""}var b=this.getStyle("MaxChars");0<b&&a.length>b&&(a=a.substring(0,b));a!=this._text&&(this._text=a,this._charMetrics=null,this.setSelection(0,0),0<this._textLinesContainer._getNumChildren()&&0==this.getStyle("Multiline")&&this._textLinesContainer._getChildAt(0)._setActualPosition(0,0),this._invalidateMeasure(),this._invalidateLayout())};TextFieldElement.prototype.getText=function(){return this._text};
TextFieldElement.prototype.setSelection=function(a,b){0>a&&(a=0);a>this._text.length&&(a=this._text.length);0>b&&(b=0);b>this._text.length&&(b=this._text.length);if(a!=this._textHighlightStartIndex||b!=this._caretIndex)this._textHighlightStartIndex=a,this._caretIndex=b,1==this._caretEnabled&&a==b&&(this._caretBlinkVisible=!0,this._caretBlinkTime=Date.now()+800),this._updateEnterFrameListener(),this._updateCaretVisibility(),this._invalidateLayout()};
TextFieldElement.prototype.getSelection=function(){return{startIndex:this._textHighlightStartIndex,endIndex:this._caretIndex}};TextFieldElement.prototype._createTextCaret=function(){var a=new CanvasElement;a.setStyle("MouseEnabled",!1);a.setStyle("BackgroundColor","TextCaretColor");a.setStyle("AutoGradientStart",0);a.setStyle("AutoGradientStop",0);return a};
TextFieldElement.prototype._updateCaretVisibility=function(){1==this._caretEnabled&&1==this._caretBlinkVisible&&-1<this._caretIndex&&this._caretIndex<=this._text.length&&this._caretIndex==this._textHighlightStartIndex?(null==this._textCaret&&(this._textCaret=this._createTextCaret(),this._addChild(this._textCaret)),this._textCaret.setStyle("Visible",!0)):null!=this._textCaret&&this._textCaret.setStyle("Visible",!1)};
TextFieldElement.prototype._onTextFieldEnterFrame=function(a){a=Date.now();a>this._caretBlinkTime&&1==this._caretEnabled&&-1<this._caretIndex&&this._caretIndex<=this._text.length&&this._caretIndex==this._textHighlightStartIndex&&(this._caretBlinkTime=1==this._caretBlinkVisible?this._caretBlinkTime+400<a?a+400:this._caretBlinkTime+400:this._caretBlinkTime+800<a?a+800:this._caretBlinkTime+800,this._caretBlinkVisible=!this._caretBlinkVisible,this._updateCaretVisibility());if(a>this._dragHighlightScrollCharacterTime&&
0<this._dragHighlightScrollCharacterDuration&&(this._dragHighlightScrollCharacterTime+=this._dragHighlightScrollCharacterDuration,a=!1,"left"==this._dragHighlightScrollCharacterDirection&&0<this._caretIndex?(this.setSelection(this._textHighlightStartIndex,this._caretIndex-1),a=!0):"right"==this._dragHighlightScrollCharacterDirection&&this._caretIndex<this._text.length&&(this.setSelection(this._textHighlightStartIndex,this._caretIndex+1),a=!0),1==a)){a=this._textLinesContainer._width;var b=this._textLinesContainer._getChildAt(0),
c=this._charMetrics[this._caretIndex].x+b._x;1>c?b._setActualPosition(Math.min(0,-1*this._charMetrics[this._caretIndex].x+3),b._y):c>a-1&&b._setActualPosition(Math.max(a-b._width,-1*this._charMetrics[this._caretIndex].x+a-3),b._y)}};TextFieldElement.prototype._enableCaret=function(){1!=this._caretEnabled&&(this._caretEnabled=!0,this._updateEnterFrameListener(),this._updateCaretVisibility())};
TextFieldElement.prototype._disableCaret=function(){0!=this._caretEnabled&&(this._caretEnabled=!1,this._updateEnterFrameListener(),this._updateCaretVisibility())};TextFieldElement.prototype._onTextFieldFocusIn=function(a){1!=this._caretEnabled&&0!=this.getStyle("Enabled")&&(this._enableCaret(),this.setSelection(0,this._text.length))};TextFieldElement.prototype._onTextFieldFocusOut=function(a){this._disableCaret();this.setSelection(0,0)};
TextFieldElement.prototype._getCaretIndexFromMouse=function(a,b){if(null==this._charMetrics||0==this._charMetrics.length)return 0;var c=this._textLinesContainer._x,d=this._textLinesContainer._width;a+=2;for(var e=this._textLinesContainer._getChildAt(0),f,g,k=0,m=0;m<=this._text.length;m++)if(f=this._charMetrics[m].x+c+e._x,g=this._charMetrics[m].width,!(f<c)){if(f>c+d)break;k=m;if(a<=f+g/2)break}return k};
TextFieldElement.prototype._onTextFieldMouseDown=function(a){0==this.hasEventListener("mousemoveex",this._onTextFieldMouseEventInstance)&&this.addEventListener("mousemoveex",this._onTextFieldMouseEventInstance);a=this._getCaretIndexFromMouse(a.getX(),a.getY());1==this.getStyle("Enabled")&&this._enableCaret();this.setSelection(a,a)};
TextFieldElement.prototype._onTextFieldMouseUp=function(a){1==this.hasEventListener("mousemoveex",this._onTextFieldMouseEventInstance)&&this.removeEventListener("mousemoveex",this._onTextFieldMouseEventInstance);this._dragHighlightScrollCharacterDuration=0;this._updateEnterFrameListener()};
TextFieldElement.prototype._onTextFieldCanvasMouseMoveEx=function(a){a={x:a.getX(),y:a.getY()};this.translatePointFrom(a,this._manager);var b=this._textLinesContainer._x,c=this._textLinesContainer._width,d=0,e=this._getCaretIndexFromMouse(a.x,a.y);e==this._caretIndex?a.x<=b+2&&0<this._caretIndex?(a=3*Math.abs(b+2-a.x),d=Math.max(20,120-a),0==this._dragHighlightScrollCharacterDuration&&(this._dragHighlightScrollCharacterTime=Date.now()+d),this._dragHighlightScrollCharacterDirection="left"):a.x>=b+
c-2&&this._caretIndex<this._text.length&&(a=3*Math.abs(b+c-2-a.x),d=Math.max(20,120-a),0==this._dragHighlightScrollCharacterDuration&&(this._dragHighlightScrollCharacterTime=Date.now()+d),this._dragHighlightScrollCharacterDirection="right"):this.setSelection(this._textHighlightStartIndex,e);this._dragHighlightScrollCharacterDuration=d;this._updateEnterFrameListener()};
TextFieldElement.prototype._updateCharXPositions=function(a){if(null!=this._charMetrics&&0!=this._charMetrics.length&&!(a>this._charMetrics.length-2)){0>a&&(a=0,this._charMetrics[0].x=0);var b=this._charMetrics[a].x+this._charMetrics[a].width;for(a+=1;a<this._charMetrics.length;a++)this._charMetrics[a].x=b,b+=this._charMetrics[a].width}};
TextFieldElement.prototype._deleteHighlightChars=function(){if(this._textHighlightStartIndex!=this._caretIndex){var a=Math.min(this._caretIndex,this._textHighlightStartIndex),b=Math.max(this._caretIndex,this._textHighlightStartIndex);this._charMetrics.splice(a,b-a);this._updateCharXPositions(a-1);var c=this._text.substring(0,a),b=this._text.substring(b);this._text=c+b;this.setSelection(a,a)}};
TextFieldElement.prototype._onTextFieldKeyDown=function(a){if(1!=a.getDefaultPrevented()){var b=this.getStyle("Enabled"),c=a.getKey(),d=!1;if("c"==c&&1==a.getCtrl())this._textHighlightStartIndex==this._caretIndex?a.preventDefault():window.clipboardData?(this._onTextFieldCopy(window.clipboardData),a.preventDefault()):(window.addEventListener("copy",this._onTextFieldCopyPasteInstance),this._invalidateLayout());else{if("ArrowLeft"==c)1!=a.getShift()||this._textHighlightStartIndex==this._caretIndex&&
1!=b?1==b&&(this._textHighlightStartIndex!=this._caretIndex?this.setSelection(Math.min(this._caretIndex,this._textHighlightStartIndex),Math.min(this._caretIndex,this._textHighlightStartIndex)):this.setSelection(this._caretIndex-1,this._caretIndex-1)):this.setSelection(this._textHighlightStartIndex,this._caretIndex-1);else if("ArrowRight"==c)1!=a.getShift()||this._textHighlightStartIndex==this._caretIndex&&1!=b?1==b&&(this._textHighlightStartIndex!=this._caretIndex?this.setSelection(Math.max(this._caretIndex,
this._textHighlightStartIndex),Math.max(this._caretIndex,this._textHighlightStartIndex)):this.setSelection(this._caretIndex+1,this._caretIndex+1)):this.setSelection(this._textHighlightStartIndex,this._caretIndex+1);else if("End"==c)1!=a.getShift()||this._textHighlightStartIndex==this._caretIndex&&1!=b?1==b&&this.setSelection(this._text.length,this._text.length):this.setSelection(this._textHighlightStartIndex,this._text.length);else if("Home"==c)1!=a.getShift()||this._textHighlightStartIndex==this._caretIndex&&
1!=b?1==b&&this.setSelection(0,0):this.setSelection(this._textHighlightStartIndex,0);else{if(0==b)return;if("Backspace"==c){if(this._textHighlightStartIndex!=this._caretIndex)this._deleteHighlightChars();else{if(0==this._text.length||0==this._caretIndex){a.preventDefault();return}this._charMetrics.splice(this._caretIndex-1,1);this._updateCharXPositions(this._caretIndex-2);b=this._text.substring(0,this._caretIndex-1);d=this._text.substring(this._caretIndex);this._text=b+d;this.setSelection(this._caretIndex-
1,this._caretIndex-1)}d=!0}else if("Delete"==c){if(this._textHighlightStartIndex!=this._caretIndex)this._deleteHighlightChars();else{if(0==this._text.length||this._caretIndex==this._text.length){a.preventDefault();return}this._charMetrics.splice(this._caretIndex,1);this._updateCharXPositions(this._caretIndex-1);b=this._text.substring(0,this._caretIndex);d=this._text.substring(this._caretIndex+1);this._text=b+d}d=!0}else{if("v"==c&&1==a.getCtrl()){window.clipboardData?(this._onTextFieldPaste(window.clipboardData),
a.preventDefault()):(window.addEventListener("paste",this._onTextFieldCopyPasteInstance),this._invalidateLayout());return}if("x"==c&&1==a.getCtrl()){if(this._textHighlightStartIndex==this._caretIndex){a.preventDefault();return}window.clipboardData?(this._onTextFieldCut(window.clipboardData),a.preventDefault()):(window.addEventListener("cut",this._onTextFieldCopyPasteInstance),this._invalidateLayout());return}if(1==c.length){this._deleteHighlightChars();b=this.getStyle("MaxChars");if(0<b&&b<=this._text.length){a.preventDefault();
return}b={x:0,width:CanvasElement._measureText(c,this._getFontString())};this._charMetrics.splice(this._caretIndex,0,b);this._updateCharXPositions(this._caretIndex-1);b=this._text.substring(0,this._caretIndex);d=this._text.substring(this._caretIndex);this._text=b+c+d;this.setSelection(this._caretIndex+1,this._caretIndex+1);d=!0}else return}}this._scrollIfCaretOutOfBounds();this._invalidateLayout();1==d&&this._dispatchEvent(new ElementEvent("changed",!1));a.preventDefault()}}};
TextFieldElement.prototype._scrollIfCaretOutOfBounds=function(){var a=this._textLinesContainer._getChildAt(0),b=this._textLinesContainer._width,c=Math.min(Math.floor(.3*b),35),d=this._charMetrics[this._caretIndex].x+a._x;2>d?a._setActualPosition(-1*this._charMetrics[this._caretIndex].x+c,a._y):d>b-2&&a._setActualPosition(-1*this._charMetrics[this._caretIndex].x+b-c,a._y)};
TextFieldElement.prototype._onTextFieldCopy=function(a){var b=this._text.substring(Math.min(this._caretIndex,this._textHighlightStartIndex),Math.max(this._caretIndex,this._textHighlightStartIndex));a.setData("Text",b)};
TextFieldElement.prototype._onTextFieldPaste=function(a){a=a.getData("Text");if(null!=a&&0!=a.length){var b=this.getStyle("MaxChars");if(!(0<b&&this._text.length>=b&&this._caretIndex>=b)){this._deleteHighlightChars();for(var c=this._getFontString(),d=0;d<a.length;d++)this._charMetrics.splice(this._caretIndex+d,0,{x:0,width:CanvasElement._measureText(a[d],c)});this._updateCharXPositions(this._caretIndex-1);c=this._text.substring(0,this._caretIndex);d=this._text.substring(this._caretIndex);this._text=
c+a+d;this.setSelection(this._caretIndex+a.length,this._caretIndex+a.length);0<b&&this._text.length>b&&(this._text=this._text.subString(0,b),this._charMetrics.splice(0,this._text.length-b),this.setSelection(this._text.length,this._text.length));this._scrollIfCaretOutOfBounds();this._invalidateLayout();this._dispatchEvent(new ElementEvent("changed",!1))}}};
TextFieldElement.prototype._onTextFieldCut=function(a){var b=this._text.substring(Math.min(this._caretIndex,this._textHighlightStartIndex),Math.max(this._caretIndex,this._textHighlightStartIndex));a.setData("Text",b);this._deleteHighlightChars();this._scrollIfCaretOutOfBounds();this._invalidateLayout();this._dispatchEvent(new ElementEvent("changed",!1))};
TextFieldElement.prototype._onCanvasElementRemoved=function(a){TextFieldElement.base.prototype._onCanvasElementRemoved.call(this,a);this._disableCaret();1==this.hasEventListener("mousemoveex",this._onTextFieldMouseEventInstance)&&this.removeEventListener("mousemoveex",this._onTextFieldMouseEventInstance);1==this.hasEventListener("enterframe",this._onTextFieldEnterFrameInstance)&&this.removeEventListener("enterframe",this._onTextFieldEnterFrameInstance)};
TextFieldElement.prototype._updateEnterFrameListener=function(){0<this._dragHighlightScrollCharacterDuration||1==this._caretEnabled&&this._textHighlightStartIndex==this._caretIndex?0==this.hasEventListener("enterframe",this._onTextFieldEnterFrameInstance)&&this.addEventListener("enterframe",this._onTextFieldEnterFrameInstance):1==this.hasEventListener("enterframe",this._onTextFieldEnterFrameInstance)&&this.removeEventListener("enterframe",this._onTextFieldEnterFrameInstance)};
TextFieldElement.prototype._updateEventListeners=function(){var a=this.getStyle("Enabled");1==this.getStyle("Selectable")||1==a?(0==this.hasEventListener("keydown",this._onTextFieldKeyDownInstance)&&this.addEventListener("keydown",this._onTextFieldKeyDownInstance),0==this.hasEventListener("mousedown",this._onTextFieldMouseEventInstance)&&this.addEventListener("mousedown",this._onTextFieldMouseEventInstance),0==this.hasEventListener("mouseup",this._onTextFieldMouseEventInstance)&&this.addEventListener("mouseup",
this._onTextFieldMouseEventInstance),0==this.hasEventListener("focusin",this._onTextFieldFocusEventInstance)&&this.addEventListener("focusin",this._onTextFieldFocusEventInstance),0==this.hasEventListener("focusout",this._onTextFieldFocusEventInstance)&&this.addEventListener("focusout",this._onTextFieldFocusEventInstance)):(1==this.hasEventListener("keydown",this._onTextFieldKeyDownInstance)&&this.removeEventListener("keydown",this._onTextFieldKeyDownInstance),1==this.hasEventListener("mousedown",
this._onTextFieldMouseEventInstance)&&this.removeEventListener("mousedown",this._onTextFieldMouseEventInstance),1==this.hasEventListener("mouseup",this._onTextFieldMouseEventInstance)&&this.removeEventListener("mouseup",this._onTextFieldMouseEventInstance),1==this.hasEventListener("focusin",this._onTextFieldFocusEventInstance)&&this.removeEventListener("focusin",this._onTextFieldFocusEventInstance),1==this.hasEventListener("focusout",this._onTextFieldFocusEventInstance)&&this.removeEventListener("focusout",
this._onTextFieldFocusEventInstance));0==a&&this._disableCaret()};
TextFieldElement.prototype._doStylesUpdated=function(a){TextFieldElement.base.prototype._doStylesUpdated.call(this,a);"TextStyle"in a||"TextFont"in a||"TextSize"in a?(this._charMetrics=null,this._invalidateMeasure(),this._invalidateLayout()):"Multiline"in a||"TextLinePaddingTop"in a||"TextLinePaddingBottom"in a?(this._invalidateMeasure(),this._invalidateLayout()):("TextAlign"in a||"TextBaseline"in a||"TextLineSpacing"in a)&&this._invalidateLayout();"MaxChars"in a&&this.setText(this._text);"TextCaretColor"in
a&&null!=this._textCaret&&this._textCaret.setStyle("BackgroundColor",this.getStyle("TextCaretColor"));("Enabled"in a||"Selectable"in a)&&this._updateEventListeners();this._updateEnterFrameListener();this._updateCaretVisibility()};
TextFieldElement.prototype._createCharMetrics=function(){if(null==this._charMetrics){var a=0,b;this._charMetrics=[];this._spaceSpans=[];var c=null;if(0<this._text.length)for(var d=this._getFontString(),e=0;e<this._text.length;e++)b=CanvasElement._measureText(this._text[e],d),this._charMetrics.push({x:a,width:b})," "==this._text[e]?null==c?c={start:e,end:e,type:"space"}:c.end=e:null!=c&&(this._spaceSpans.push(c),c=null),"\n"==this._text[e]&&this._spaceSpans.push({start:e,end:e,type:"nline"}),a+=b;
null!=c&&this._spaceSpans.push(c);this._charMetrics.push({x:a,width:0});this._invalidateLayout()}};TextFieldElement.prototype._doMeasure=function(a,b){this._createCharMetrics();var c={width:0,height:0},d=this._charMetrics[this._text.length].x,e=this.getStyle("TextLinePaddingTop"),f=this.getStyle("TextLinePaddingBottom"),g=this.getStyle("TextSize");c.width=1+d+a;c.height=g+e+f+b;1==this.getStyle("Multiline")&&this._invalidateLayout();return c};
TextFieldElement.prototype._doLayout=function(a){TextFieldElement.base.prototype._doLayout.call(this,a);var b=a.getX(),c=a.getY(),d=a.getWidth(),e=a.getHeight();a=d-1;this._textLinesContainer._setActualPosition(b,c);this._textLinesContainer._setActualSize(a,e);for(var f=this.getStyle("Multiline"),g=this.getStyle("TextAlign"),k=this.getStyle("TextBaseline"),m=this.getStyle("TextSize"),l=this.getStyle("TextLineSpacing"),p=this.getStyle("TextLinePaddingTop"),q=this.getStyle("TextLinePaddingBottom"),
m=m+p+q,n=0,r=0,v,t,u=[],y=0,z;r<this._charMetrics.length;){t={charMetricsStartIndex:-1,charMetricsEndIndex:-1};if(0==f)t.charMetricsStartIndex=0,t.charMetricsEndIndex=this._charMetrics.length-1,y=0,r=this._charMetrics.length;else{t.charMetricsStartIndex=r;z=!1;for(var x=n;x<this._spaceSpans.length;x++)if(v="left"==g?this._spaceSpans[x].end:this._spaceSpans[x].start,this._charMetrics[v].x-this._charMetrics[t.charMetricsStartIndex].x<=a||-1==t.charMetricsEndIndex){if(t.charMetricsEndIndex=v,n++,r=
v+1,"nline"==this._spaceSpans[x].type){z=!0;break}}else break;if(-1==t.charMetricsEndIndex||this._charMetrics[this._charMetrics.length-1].x-this._charMetrics[t.charMetricsStartIndex].x<=a&&0==z)t.charMetricsEndIndex=this._charMetrics.length-1,r=this._charMetrics.length}u.push(t)}x=u.length*m+(u.length-1)*l;1==f&&this._setMeasuredSize(this._width,x+this._getPaddingSize().height);k="top"==k?0:"bottom"==k?e-x:Math.round(e/2-x/2);n=Math.max(u.length,this._textLinesContainer._getNumChildren());for(x=0;x<
n;x++)null==u[x]?this._textLinesContainer._removeChildAt(x):(e=this._textLinesContainer._getChildAt(x),null==e&&(e=new TextFieldLineElement,this._textLinesContainer._addChild(e)),e.setParentLineMetrics(this,u[x].charMetricsStartIndex,u[x].charMetricsEndIndex),e.setParentSelection(this._textHighlightStartIndex,this._caretIndex),e.setStyle("PaddingTop",p),e.setStyle("PaddingBottom",q),r=e.getLineWidth(),e._setActualSize(r,m),r=r<a||1==f?"right"==g?a-r:"center"==g?Math.round(a/2-r/2):0:0<e._x?0:e._x+
r<a?a-r:e._x,e._setActualPosition(r,k),k+=m+l);null!=this._textCaret&&(0>this._caretIndex||this._caretIndex>this._text.length?this._textCaret._setActualSize(0,m):(e=this._textLinesContainer._getChildAt(y),a=this._charMetrics[this._caretIndex].x+e._x+b,a>=b&&a<=b+d-1?(this._textCaret._setActualPosition(a,e._y+c),this._textCaret._setActualSize(1,m)):this._textCaret._setActualSize(0,m)));window.removeEventListener("copy",this._onTextFieldCopyPasteInstance);window.removeEventListener("paste",this._onTextFieldCopyPasteInstance);
window.removeEventListener("cut",this._onTextFieldCopyPasteInstance)};function TextElement(){TextElement.base.prototype.constructor.call(this);this._textField=new TextFieldElement;this._textField.setStyle("Multiline",!0);this._textField.setStyle("Cursor",null);this._textField.setStyle("TabStop",-1);this._addChild(this._textField)}TextElement.prototype=Object.create(CanvasElement.prototype);TextElement.prototype.constructor=TextElement;TextElement.base=CanvasElement;TextElement._StyleTypes=Object.create(null);
TextElement._StyleTypes.Text={inheritable:!1};TextElement._StyleTypes.Selectable={inheritable:!1};TextElement.StyleDefault=new StyleDefinition;TextElement.StyleDefault.setStyle("PaddingTop",2);TextElement.StyleDefault.setStyle("PaddingBottom",2);TextElement.StyleDefault.setStyle("PaddingLeft",2);TextElement.StyleDefault.setStyle("PaddingRight",2);TextElement.StyleDefault.setStyle("Text",null);TextElement.StyleDefault.setStyle("Selectable",!1);
TextElement.prototype._doStylesUpdated=function(a){TextElement.base.prototype._doStylesUpdated.call(this,a);"Text"in a&&this._textField.setText(this.getStyle("Text"));"Selectable"in a&&this._textField.setStyle("Selectable",this.getStyle("Selectable"));if("Padding"in a||"PaddingTop"in a||"PaddingBottom"in a||"PaddingLeft"in a||"PaddingRight"in a)a=this._getPaddingSize(),this._textField.setStyle("PaddingTop",a.paddingTop),this._textField.setStyle("PaddingBottom",a.paddingBottom),this._textField.setStyle("PaddingLeft",
a.paddingLeft),this._textField.setStyle("PaddingRight",a.paddingRight)};TextElement.prototype._doMeasure=function(a,b){return{width:this._textField._measuredWidth,height:this._textField._measuredHeight}};TextElement.prototype._doLayout=function(a){TextElement.base.prototype._doLayout.call(this,a);this._textField._setActualPosition(0,0);this._textField._setActualSize(this._width,this._height)};function ScrollButtonSkinElement(){ScrollButtonSkinElement.base.prototype.constructor.call(this)}
ScrollButtonSkinElement.prototype=Object.create(CanvasElement.prototype);ScrollButtonSkinElement.prototype.constructor=ScrollButtonSkinElement;ScrollButtonSkinElement.base=CanvasElement;ScrollButtonSkinElement._StyleTypes=Object.create(null);ScrollButtonSkinElement._StyleTypes.ArrowColor={inheritable:!1};ScrollButtonSkinElement._StyleTypes.ArrowDirection={inheritable:!1};ScrollButtonSkinElement.StyleDefault=new StyleDefinition;ScrollButtonSkinElement.StyleDefault.setStyle("ArrowColor","#000000");
ScrollButtonSkinElement.StyleDefault.setStyle("ArrowDirection","up");ScrollButtonSkinElement.prototype._doStylesUpdated=function(a){ScrollButtonSkinElement.base.prototype._doStylesUpdated.call(this,a);("ArrowColor"in a||"ArrowDirection"in a)&&this._invalidateRender()};
ScrollButtonSkinElement.prototype._doRender=function(){ScrollButtonSkinElement.base.prototype._doRender.call(this);var a=this._getGraphicsCtx(),b=this.getStyle("ArrowDirection"),c=this.getStyle("ArrowColor"),d=this._getBorderThickness(),e=this._width-2*d,f=this._height-2*d;a.beginPath();"up"==b?(a.moveTo(d+e/2,d+.35*f),a.lineTo(d+.8*e,d+.65*f),a.lineTo(d+.2*e,d+.65*f)):"down"==b?(a.moveTo(d+e/2,d+.65*f),a.lineTo(d+.8*e,d+.35*f),a.lineTo(d+.2*e,d+.35*f)):"left"==b?(a.moveTo(d+.35*e,d+f/2),a.lineTo(d+
.65*e,d+.2*f),a.lineTo(d+.65*e,d+.8*f)):"right"==b&&(a.moveTo(d+.65*e,d+f/2),a.lineTo(d+.35*e,d+.2*f),a.lineTo(d+.35*e,d+.8*f));a.closePath();a.fillStyle=c;a.fill()};function RadioButtonSkinElement(){RadioButtonSkinElement.base.prototype.constructor.call(this)}RadioButtonSkinElement.prototype=Object.create(CanvasElement.prototype);RadioButtonSkinElement.prototype.constructor=RadioButtonSkinElement;RadioButtonSkinElement.base=CanvasElement;RadioButtonSkinElement._StyleTypes=Object.create(null);
RadioButtonSkinElement._StyleTypes.CheckColor={inheritable:!1};RadioButtonSkinElement._StyleTypes.CheckSize={inheritable:!1};RadioButtonSkinElement.StyleDefault=new StyleDefinition;RadioButtonSkinElement.StyleDefault.setStyle("CheckColor","#000000");RadioButtonSkinElement.StyleDefault.setStyle("CheckSize",.35);RadioButtonSkinElement.prototype._doStylesUpdated=function(a){RadioButtonSkinElement.base.prototype._doStylesUpdated.call(this,a);("SkinState"in a||"CheckColor"in a)&&this._invalidateRender()};
RadioButtonSkinElement.prototype._doMeasure=function(a,b){return{width:14,height:14}};
RadioButtonSkinElement.prototype._doRender=function(){RadioButtonSkinElement.base.prototype._doRender.call(this);if(0==this.getStyle("SkinState").indexOf("selected")){var a=this._getGraphicsCtx(),b=this.getStyle("CheckSize"),c=new DrawMetrics;c._width=this._width*b;c._height=this._height*b;c._x=(this._width-c._width)/2;c._y=(this._height-c._height)/2;0>=c._width||0>=c._height||(a.beginPath(),this._drawBackgroundShape(a,c),a.fillStyle=this.getStyle("CheckColor"),a.fill())}};
function DropdownArrowButtonSkinElement(){DropdownArrowButtonSkinElement.base.prototype.constructor.call(this)}DropdownArrowButtonSkinElement.prototype=Object.create(CanvasElement.prototype);DropdownArrowButtonSkinElement.prototype.constructor=DropdownArrowButtonSkinElement;DropdownArrowButtonSkinElement.base=CanvasElement;DropdownArrowButtonSkinElement._StyleTypes=Object.create(null);DropdownArrowButtonSkinElement._StyleTypes.ArrowColor={inheritable:!1};
DropdownArrowButtonSkinElement._StyleTypes.LineColor={inheritable:!1};DropdownArrowButtonSkinElement.StyleDefault=new StyleDefinition;DropdownArrowButtonSkinElement.StyleDefault.setStyle("ArrowColor","#000000");DropdownArrowButtonSkinElement.StyleDefault.setStyle("LineColor","#000000");DropdownArrowButtonSkinElement.prototype._doStylesUpdated=function(a){DropdownArrowButtonSkinElement.base.prototype._doStylesUpdated.call(this,a);("ArrowColor"in a||"LineColor"in a)&&this._invalidateRender()};
DropdownArrowButtonSkinElement.prototype._doRender=function(){DropdownArrowButtonSkinElement.base.prototype._doRender.call(this);var a=this._getGraphicsCtx(),b=this._getPaddingMetrics(),c=this.getStyle("LineColor"),d=this.getStyle("ArrowColor"),e=b.getX(),f=b.getY(),g=b.getWidth(),b=b.getHeight();a.beginPath();a.moveTo(e+g/2,f+.6*b);a.lineTo(e+.7*g,f+.4*b);a.lineTo(e+.3*g,f+.4*b);a.closePath();a.fillStyle=d;a.fill();d=.65*b;a.beginPath();a.moveTo(e,f+b/2-d/2);a.lineTo(e,f+b/2+d/2);a.lineTo(e+1,f+
b/2+d/2);a.lineTo(e+1,f+b/2-d/2);a.closePath();a.fillStyle=c;a.fill()};function DataGridHeaderColumnDividerSkinElement(){DataGridHeaderColumnDividerSkinElement.base.prototype.constructor.call(this)}DataGridHeaderColumnDividerSkinElement.prototype=Object.create(CanvasElement.prototype);DataGridHeaderColumnDividerSkinElement.prototype.constructor=DataGridHeaderColumnDividerSkinElement;DataGridHeaderColumnDividerSkinElement.base=CanvasElement;DataGridHeaderColumnDividerSkinElement._StyleTypes=Object.create(null);
DataGridHeaderColumnDividerSkinElement._StyleTypes.DividerLineColor={inheritable:!1};DataGridHeaderColumnDividerSkinElement._StyleTypes.DividerArrowColor={inheritable:!1};DataGridHeaderColumnDividerSkinElement.StyleDefault=new StyleDefinition;DataGridHeaderColumnDividerSkinElement.StyleDefault.setStyle("DividerLineColor","#777777");DataGridHeaderColumnDividerSkinElement.StyleDefault.setStyle("DividerArrowColor","#444444");
DataGridHeaderColumnDividerSkinElement.prototype._doStylesUpdated=function(a){DataGridHeaderColumnDividerSkinElement.base.prototype._doStylesUpdated.call(this,a);("DividerLineColor"in a||"DividerArrowColor"in a)&&this._invalidateRender()};
DataGridHeaderColumnDividerSkinElement.prototype._doRender=function(){DataGridHeaderColumnDividerSkinElement.base.prototype._doRender.call(this);var a=this._getGraphicsCtx(),b=this.getStyle("DividerLineColor"),c=this.getStyle("DividerArrowColor"),d=this.getStyle("SkinState"),e=this._width,f=this._height;a.beginPath();a.moveTo(0+e/2-.5,0);a.lineTo(0+e/2-.5,0+f);a.lineTo(e/2+.5,0+f);a.lineTo(e/2+.5,0);a.closePath();a.fillStyle=b;a.fill();if("over"==d||"down"==d)b=f/2,a.fillStyle=c,a.beginPath(),a.moveTo(0+
e/2-.5-1,f/2-b/2),a.lineTo(0+e/2-.5-1,f/2+b/2),a.lineTo(0,0+f/2),a.closePath(),a.fill(),a.beginPath(),a.moveTo(e/2+1.5,f/2-b/2),a.lineTo(e/2+1.5,f/2+b/2),a.lineTo(0+e,0+f/2),a.closePath(),a.fill()};function CheckboxSkinElement(){CheckboxSkinElement.base.prototype.constructor.call(this)}CheckboxSkinElement.prototype=Object.create(CanvasElement.prototype);CheckboxSkinElement.prototype.constructor=CheckboxSkinElement;CheckboxSkinElement.base=CanvasElement;CheckboxSkinElement._StyleTypes=Object.create(null);
CheckboxSkinElement._StyleTypes.CheckColor={inheritable:!1};CheckboxSkinElement.StyleDefault=new StyleDefinition;CheckboxSkinElement.StyleDefault.setStyle("CheckColor","#000000");CheckboxSkinElement.prototype._doStylesUpdated=function(a){CheckboxSkinElement.base.prototype._doStylesUpdated.call(this,a);("SkinState"in a||"CheckColor"in a)&&this._invalidateRender()};CheckboxSkinElement.prototype._doMeasure=function(a,b){return{width:14,height:14}};
CheckboxSkinElement.prototype._doRender=function(){CheckboxSkinElement.base.prototype._doRender.call(this);var a=this.getStyle("SkinState");if(0==a.indexOf("selected")||0==a.indexOf("half")){var b=this._getGraphicsCtx(),c=this._getBorderThickness(),d=this.getStyle("CheckColor"),e=this._width-2*c,f=this._height-2*c;0==a.indexOf("selected")?(b.beginPath(),b.moveTo(c+.1*e,c+.6*f),b.lineTo(c+.4*e,c+.9*f),b.lineTo(c+.9*e,c+.26*f),b.lineTo(c+.78*e,c+.1*f),b.lineTo(c+.38*e,c+.65*f),b.lineTo(c+.2*e,c+.45*
f)):(b.beginPath(),b.moveTo(c+.12*e,c+.42*f),b.lineTo(c+.12*e,c+.58*f),b.lineTo(c+.88*e,c+.58*f),b.lineTo(c+.88*e,c+.42*f));b.closePath();b.fillStyle=d;b.fill()}};function SkinnableElement(){SkinnableElement.base.prototype.constructor.call(this);this._skins=Object.create(null);this._currentSkin=null;this._currentSkinState=""}SkinnableElement.prototype=Object.create(CanvasElement.prototype);SkinnableElement.prototype.constructor=SkinnableElement;SkinnableElement.base=CanvasElement;
SkinnableElement._SkinProxyMap=Object.create(null);SkinnableElement._SkinProxyMap.BorderType=!0;SkinnableElement._SkinProxyMap.BorderColor=!0;SkinnableElement._SkinProxyMap.BorderThickness=!0;SkinnableElement._SkinProxyMap.BackgroundColor=!0;SkinnableElement._SkinProxyMap.AutoGradientType=!0;SkinnableElement._SkinProxyMap.AutoGradientStart=!0;SkinnableElement._SkinProxyMap.AutoGradientStop=!0;SkinnableElement._SkinProxyMap.BackgroundShape=!0;SkinnableElement._SkinProxyMap._Arbitrary=!0;
SkinnableElement.prototype._getSkinClass=function(a){return null};SkinnableElement.prototype._getSkinStyleDefinitions=function(a){return null};SkinnableElement.prototype._getSkinStyleDefinitionDefault=function(a){return null};SkinnableElement.prototype._getSkinStyleProxyMap=function(){return SkinnableElement._SkinProxyMap};SkinnableElement.prototype._updateSkinStyleDefinitions=function(a){var b=this._skins[a];null!=b&&b.setStyleDefinitions(this._getSkinStyleDefinitions(a))};
SkinnableElement.prototype._updateSkinClass=function(a){if(null!=this._skins[a]||a==this._currentSkinState){var b=this._getSkinClass(a),c=null;null!=this._skins[a]&&(c=this._skins[a].constructor);b!=c&&(null!=this._skins[a]&&(this._removeChild(this._skins[a]),this._skins[a]=null),this._currentSkinState==a&&(this._currentSkin=a=this._createSkin(a),null!=a&&a.setStyle("Visible",!0)))}};
SkinnableElement.prototype._createSkin=function(a){var b=this._getSkinClass(a);if(null==b)return this._skins[a]=null;b=new b;this._skins[a]=b;b._setStyleDefinitionDefault(this._getSkinStyleDefinitionDefault(a));b._setStyleProxy(new StyleProxy(this,this._getSkinStyleProxyMap()));b.setStyle("MouseEnabled",!1);b.setStyle("SkinState",a);this._updateSkinStyleDefinitions(a);this._addChildAt(b,0);return b};
SkinnableElement.prototype._changeState=function(a){if(this._currentSkinState==a||""==a||null==a)return!1;this._currentSkinState=a;var b=!1,c;for(c in this._skins)null!=this._skins[c]&&(c==a?(this._currentSkin=this._skins[c],this._skins[c].setStyle("Visible",!0),b=!0):this._skins[c].setStyle("Visible",!1));0==b&&(this._currentSkin=this._createSkin(a),null!=this._currentSkin&&this._currentSkin.setStyle("Visible",!0));return!0};
SkinnableElement.prototype._doStylesUpdated=function(a){SkinnableElement.base.prototype._doStylesUpdated.call(this,a);"SkinState"in a&&this._changeState(this.getStyle("SkinState"))};SkinnableElement.prototype._doLayout=function(a){SkinnableElement.base.prototype._doLayout.call(this,a);for(var b in this._skins)null!=this._skins[b]&&(this._skins[b]._setActualSize(this._width,this._height),this._skins[b]._setActualPosition(0,0))};SkinnableElement.prototype._doRender=function(){};
function TextInputElement(){TextInputElement.base.prototype.constructor.call(this);this._textField=new TextFieldElement;this._textField.setStyle("Selectable",!0);this._textField.setStyle("Cursor",null);this._textField.setStyle("TabStop",-1);this._addChild(this._textField);var a=this;this._onTextInputFocusEventInstance=function(b){"focusin"==b.getType()?a._onTextInputFocusIn(b):a._onTextInputFocusOut(b)};this._onTextInputKeyDownInstance=function(b){a._onTextInputKeyDown(b)};this._onTextInputTextFieldChangedInstance=
function(b){a._onTextInputTextFieldChanged(b)};this.addEventListener("focusin",this._onTextInputFocusEventInstance);this.addEventListener("focusout",this._onTextInputFocusEventInstance)}TextInputElement.prototype=Object.create(SkinnableElement.prototype);TextInputElement.prototype.constructor=TextInputElement;TextInputElement.base=SkinnableElement;TextInputElement._StyleTypes=Object.create(null);TextInputElement._StyleTypes.MaxChars={inheritable:!1};TextInputElement._StyleTypes.SkinClass={inheritable:!1};
TextInputElement._StyleTypes.UpSkinClass={inheritable:!1};TextInputElement._StyleTypes.UpSkinStyle={inheritable:!1};TextInputElement._StyleTypes.UpTextColor={inheritable:!1};TextInputElement._StyleTypes.UpTextHighlightedColor={inheritable:!1};TextInputElement._StyleTypes.UpTextHighlightedBackgroundColor={inheritable:!1};TextInputElement._StyleTypes.DisabledSkinClass={inheritable:!1};TextInputElement._StyleTypes.DisabledSkinStyle={inheritable:!1};TextInputElement._StyleTypes.DisabledTextColor={inheritable:!1};
TextInputElement._StyleTypes.DisabledTextHighlightedColor={inheritable:!1};TextInputElement._StyleTypes.DisabledTextHighlightedBackgroundColor={inheritable:!1};TextInputElement.StyleDefault=new StyleDefinition;TextInputElement.StyleDefault.setStyle("MaxChars",0);TextInputElement.StyleDefault.setStyle("Enabled",!0);TextInputElement.StyleDefault.setStyle("UpTextColor","#000000");TextInputElement.StyleDefault.setStyle("UpTextHighlightedColor","#FFFFFF");
TextInputElement.StyleDefault.setStyle("UpTextHighlightedBackgroundColor","#000000");TextInputElement.StyleDefault.setStyle("DisabledTextColor","#888888");TextInputElement.StyleDefault.setStyle("DisabledTextHighlightedColor","#FFFFFF");TextInputElement.StyleDefault.setStyle("DisabledTextHighlightedBackgroundColor","#000000");TextInputElement.StyleDefault.setStyle("PaddingTop",3);TextInputElement.StyleDefault.setStyle("PaddingBottom",3);TextInputElement.StyleDefault.setStyle("PaddingLeft",3);
TextInputElement.StyleDefault.setStyle("PaddingRight",3);TextInputElement.StyleDefault.setStyle("TabStop",0);TextInputElement.StyleDefault.setStyle("Cursor","text");TextInputElement.StyleDefault.setStyle("SkinClass",CanvasElement);TextInputElement.StyleDefault.setStyle("UpSkinClass",CanvasElement);TextInputElement.StyleDefault.setStyle("DisabledSkinClass",CanvasElement);TextInputElement.DisabledSkinStyleDefault=new StyleDefinition;TextInputElement.DisabledSkinStyleDefault.setStyle("BorderType","inset");
TextInputElement.DisabledSkinStyleDefault.setStyle("BorderThickness",1);TextInputElement.DisabledSkinStyleDefault.setStyle("BorderColor","#999999");TextInputElement.DisabledSkinStyleDefault.setStyle("BackgroundColor","#ECECEC");TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientType","linear");TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart",.05);TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop",-.05);TextInputElement.UpSkinStyleDefault=new StyleDefinition;
TextInputElement.UpSkinStyleDefault.setStyle("BorderType","inset");TextInputElement.UpSkinStyleDefault.setStyle("BorderThickness",1);TextInputElement.UpSkinStyleDefault.setStyle("BorderColor","#606060");TextInputElement.UpSkinStyleDefault.setStyle("BackgroundColor","#F5F5F5");TextInputElement.StyleDefault.setStyle("UpSkinStyle",TextInputElement.UpSkinStyleDefault);TextInputElement.StyleDefault.setStyle("DisabledSkinStyle",TextInputElement.DisabledSkinStyleDefault);
TextInputElement.prototype.setText=function(a){this._textField.setText(a)};TextInputElement.prototype.getText=function(){return this._textField.getText()};TextInputElement.prototype._onTextInputTextFieldChanged=function(a){1==this.hasEventListener("changed",null)&&this._dispatchEvent(new ElementEvent("changed",!1))};
TextInputElement.prototype._onTextInputKeyDown=function(a){if(1!=a.getDefaultPrevented()){var b=a.clone();b._bubbles=!1;this._textField._dispatchEvent(b);1==b.getIsCanceled()&&a.cancelEvent();1==b.getDefaultPrevented()&&a.preventDefault()}};TextInputElement.prototype._onTextInputFocusIn=function(a){this._textField._dispatchEvent(a.clone())};TextInputElement.prototype._onTextInputFocusOut=function(a){this._textField._dispatchEvent(a.clone())};
TextInputElement.prototype._getSkinClass=function(a){var b=null;"up"==a?b=this.getStyleData("UpSkinClass"):"disabled"==a&&(b=this.getStyleData("DisabledSkinClass"));a=this.getStyleData("SkinClass");return null==b||0<a.comparePriority(b)?a.value:b.value};TextInputElement.prototype._getSkinStyleDefinitions=function(a){return"up"==a?this.getStyle("UpSkinStyle"):"disabled"==a?this.getStyle("DisabledSkinStyle"):TextInputElement.base.prototype._getSkinStyleDefinitions.call(this,a)};
TextInputElement.prototype._getSkinStyleDefinitionDefault=function(a){return"up"==a?this._getDefaultStyle("UpSkinStyle"):"disabled"==a?this._getDefaultStyle("DisabledSkinStyle"):TextInputElement.base.prototype._getSkinStyleDefinitionDefault.call(this,a)};TextInputElement.prototype._updateState=function(){var a="up";0==this.getStyle("Enabled")&&(a="disabled");this.setStyle("SkinState",a)};
TextInputElement.prototype._changeState=function(a){TextInputElement.base.prototype._changeState.call(this,a);this._updateTextColors()};TextInputElement.prototype._updateTextColors=function(){this._textField.setStyle("TextColor",this._getTextColor(this._currentSkinState));this._textField.setStyle("TextHighlightedColor",this._getTextHighlightedColor(this._currentSkinState));this._textField.setStyle("TextHighlightedBackgroundColor",this._getTextHighlightedBackgroundColor(this._currentSkinState))};
TextInputElement.prototype._getTextColor=function(a){var b=null;"up"==a?b=this.getStyleData("UpTextColor"):"disabled"==a&&(b=this.getStyleData("DisabledTextColor"));a=this.getStyleData("TextColor");return null==b||0<a.comparePriority(b)?a.value:b.value};
TextInputElement.prototype._getTextHighlightedColor=function(a){var b=null;"up"==a?b=this.getStyleData("UpTextHighlightedColor"):"disabled"==a&&(b=this.getStyleData("DisabledTextHighlightedColor"));a=this.getStyleData("TextHighlightedColor");return null==b||0<a.comparePriority(b)?a.value:b.value};
TextInputElement.prototype._getTextHighlightedBackgroundColor=function(a){var b=null;"up"==a?b=this.getStyleData("UpTextHighlightedBackgroundColor"):"disabled"==a&&(b=this.getStyleData("DisabledTextHighlightedBackgroundColor"));a=this.getStyleData("TextHighlightedBackgroundColor");return null==b||0<a.comparePriority(b)?a.value:b.value};
TextInputElement.prototype._doStylesUpdated=function(a){TextInputElement.base.prototype._doStylesUpdated.call(this,a);"MaxChars"in a&&this._textField.setStyle("MaxChars",this.getStyle("MaxChars"));if("Enabled"in a){var b=this.getStyle("Enabled");this._textField.setStyle("Enabled",b);1==b?(0==this.hasEventListener("keydown",this._onTextInputKeyDownInstance)&&this.addEventListener("keydown",this._onTextInputKeyDownInstance),0==this._textField.hasEventListener("changed",this._onTextInputTextFieldChangedInstance)&&
this._textField.addEventListener("changed",this._onTextInputTextFieldChangedInstance)):(1==this.hasEventListener("keydown",this._onTextInputKeyDownInstance)&&this.removeEventListener("keydown",this._onTextInputKeyDownInstance),1==this._textField.hasEventListener("changed",this._onTextInputTextFieldChangedInstance)&&this._textField.removeEventListener("changed",this._onTextInputTextFieldChangedInstance))}("TextLinePaddingTop"in a||"TextLinePaddingBottom"in a)&&this._invalidateMeasure();if("Padding"in
a||"PaddingTop"in a||"PaddingBottom"in a||"PaddingLeft"in a||"PaddingRight"in a)a=this._getPaddingSize(),this._textField.setStyle("PaddingTop",a.paddingTop),this._textField.setStyle("PaddingBottom",a.paddingBottom),this._textField.setStyle("PaddingLeft",a.paddingLeft),this._textField.setStyle("PaddingRight",a.paddingRight),this._invalidateMeasure();this._updateSkinClass("up");this._updateSkinStyleDefinitions("up");this._updateSkinClass("disabled");this._updateSkinStyleDefinitions("disabled");this._updateState();
this._updateTextColors()};TextInputElement.prototype._doMeasure=function(a,b){var c={width:0,height:this.getStyle("TextSize")+this.getStyle("TextLinePaddingTop")+this.getStyle("TextLinePaddingBottom")};c.width=10*c.height;c.width+=a;c.height+=b;return c};TextInputElement.prototype._doLayout=function(a){TextInputElement.base.prototype._doLayout.call(this,a);this._textField._setActualPosition(0,0);this._textField._setActualSize(this._width,this._height)};
function LabelElement(){LabelElement.base.prototype.constructor.call(this);this._truncateStringWidth=this._textHeight=this._textWidth=null}LabelElement.prototype=Object.create(CanvasElement.prototype);LabelElement.prototype.constructor=LabelElement;LabelElement.base=CanvasElement;LabelElement._StyleTypes=Object.create(null);LabelElement._StyleTypes.Text={inheritable:!1};LabelElement._StyleTypes.TruncateToFit={inheritable:!1};LabelElement.StyleDefault=new StyleDefinition;
LabelElement.StyleDefault.setStyle("PaddingTop",2);LabelElement.StyleDefault.setStyle("PaddingBottom",2);LabelElement.StyleDefault.setStyle("PaddingLeft",2);LabelElement.StyleDefault.setStyle("PaddingRight",2);LabelElement.StyleDefault.setStyle("Text",null);LabelElement.StyleDefault.setStyle("TruncateToFit","...");
LabelElement.prototype._doStylesUpdated=function(a){LabelElement.base.prototype._doStylesUpdated.call(this,a);if("TextStyle"in a||"TextFont"in a||"TextSize"in a||"Text"in a||"TextLinePaddingTop"in a||"TextLinePaddingBottom"in a)this._textHeight=this._textWidth=null,this._invalidateMeasure(),this._invalidateRender();"TruncateToFit"in a&&(this._truncateStringWidth=null,this._invalidateRender());("TextAlign"in a||"TextBaseline"in a||"TextColor"in a||"TextFillType"in a)&&this._invalidateRender()};
LabelElement.prototype._doMeasure=function(a,b){if(null==this._textWidth||null==this._textHeight){var c=this.getStyle("Text");null==c&&(c="");this._textHeight=this.getStyle("TextSize")+this.getStyle("TextLinePaddingTop")+this.getStyle("TextLinePaddingBottom");this._textWidth=CanvasElement._measureText(c,this._getFontString())}return{width:this._textWidth+a,height:this._textHeight+b}};
LabelElement.prototype._doRender=function(){LabelElement.base.prototype._doRender.call(this);var a=this.getStyle("Text");if(null!=a&&0!=a.length){var b=this._getGraphicsCtx(),c=this._getPaddingMetrics(),d=c.getX(),e=c.getY(),f=c.getWidth(),g=c.getHeight(),c=this._getFontString(),k=this._textWidth;if(k>f){var m=this.getStyle("TruncateToFit"),l=0;null!=m&&(l=m.length);null==this._truncateStringWidth&&(this._truncateStringWidth=null==m?0:CanvasElement._measureText(m,c));for(var p,q=a.length,k=this._textWidth+
this._truncateStringWidth;0<q&&k>f;)p=CanvasElement._measureText(a[q-1],c),q--,k-=p;for(;0<l&&k>f;)p=CanvasElement._measureText(m[l-1],c),l--,k-=p;a=a.substring(0,q)+m.substring(0,l)}var q=this.getStyle("TextLinePaddingTop"),n=this.getStyle("TextLinePaddingBottom"),m=this.getStyle("TextBaseline"),r=this.getStyle("TextAlign"),l=this.getStyle("TextFillType");p=this.getStyle("TextColor");d="left"==r?d:d+f-k;e="top"==m?e+q:"bottom"==m?e+g-n:Math.round(e+g/2+q/2-n/2);"stroke"==l?CanvasElement._strokeText(b,
a,d,e,c,p,m):CanvasElement._fillText(b,a,d,e,c,p,m)}};function ImageElement(){ImageElement.base.prototype.constructor.call(this);this._imageSource=this._imageLoader=null;this._imageLoadComplete=!1;var a=this;this._onImageElementLoadCompleteInstance=function(b){a._imageLoader.removeEventListener("load",a._onImageElementLoadCompleteInstance);a._imageLoadComplete=!0;a._invalidateMeasure();a._invalidateLayout();a._invalidateRender()}}ImageElement.prototype=Object.create(CanvasElement.prototype);
ImageElement.prototype.constructor=ImageElement;ImageElement.base=CanvasElement;ImageElement._StyleTypes=Object.create(null);ImageElement._StyleTypes.ImageSource={inheritable:!1};ImageElement._StyleTypes.ImageSourceClipX={inheritable:!1};ImageElement._StyleTypes.ImageSourceClipY={inheritable:!1};ImageElement._StyleTypes.ImageSourceClipWidth={inheritable:!1};ImageElement._StyleTypes.ImageSourceClipHeight={inheritable:!1};ImageElement._StyleTypes.ImageScaleType={inheritable:!1};
ImageElement._StyleTypes.ImageVerticalAlign={inheritable:!1};ImageElement._StyleTypes.ImageHorizontalAlign={inheritable:!1};ImageElement.StyleDefault=new StyleDefinition;ImageElement.StyleDefault.setStyle("ImageSource",null);ImageElement.StyleDefault.setStyle("ImageSourceClipX",null);ImageElement.StyleDefault.setStyle("ImageSourceClipY",null);ImageElement.StyleDefault.setStyle("ImageSourceClipWidth",null);ImageElement.StyleDefault.setStyle("ImageSourceClipHeight",null);
ImageElement.StyleDefault.setStyle("ImageScaleType","stretch");ImageElement.StyleDefault.setStyle("ImageHorizontalAlign","left");ImageElement.StyleDefault.setStyle("ImageVerticalAlign","top");
ImageElement.prototype._doStylesUpdated=function(a){ImageElement.base.prototype._doStylesUpdated.call(this,a);"ImageSource"in a?(a=this.getStyle("ImageSource"),this._imageSource!=a&&(null!=this._imageLoader&&0==this._imageLoadComplete&&this._imageLoader.removeEventListener("load",this._onImageElementLoadCompleteInstance),this._imageLoader=null,this._imageLoadComplete=!1,this._imageSource=a,this._imageSource instanceof HTMLImageElement?(this._imageLoader=this._imageSource,this._imageLoadComplete=this._imageSource.complete,
0==this._imageLoadComplete&&this._imageLoader.addEventListener("load",this._onImageElementLoadCompleteInstance,!1)):(this._imageLoader=new Image,this._imageLoader.addEventListener("load",this._onImageElementLoadCompleteInstance,!1),this._imageLoader.src=this._imageSource),this._invalidateMeasure(),this._invalidateRender())):"ImageSourceClipX"in a||"ImageSourceClipY"in a||"ImageSourceClipWidth"in a||"ImageSourceClipHeight"in a?(this._invalidateMeasure(),this._invalidateRender()):("ImageScaleType"in
a||"ImageVerticalAlign"in a||"ImageHorizontalAlign"in a)&&this._invalidateRender()};
ImageElement.prototype._doMeasure=function(a,b){var c={width:a,height:b},d=this.getStyle("ImageSourceClipX"),e=this.getStyle("ImageSourceClipY"),f=this.getStyle("ImageSourceClipWidth"),g=this.getStyle("ImageSourceClipHeight");null==d&&(d=0);null==e&&(e=0);null!=f?c.width+=f:1==this._imageLoadComplete&&(c.width+=this._imageLoader.naturalWidth-d);null!=g?c.height+=g:1==this._imageLoadComplete&&(c.height+=this._imageLoader.naturalHeight-e);return c};
ImageElement.prototype._doRender=function(){ImageElement.base.prototype._doRender.call(this);if(0!=this._imageLoadComplete){var a=this._getPaddingMetrics(),b=this._getGraphicsCtx(),c=a.getX(),d=a.getY(),e=a.getWidth(),f=a.getHeight();if(!(0>=e||0>=f)){var a=this.getStyle("ImageSourceClipX"),g=this.getStyle("ImageSourceClipY"),k=this.getStyle("ImageSourceClipWidth"),m=this.getStyle("ImageSourceClipHeight"),l=this.getStyle("ImageScaleType");null==a&&(a=0);null==g&&(g=0);null==k&&(k=this._imageLoader.naturalWidth-
a);null==m&&(m=this._imageLoader.naturalHeight-g);if(!(0>=k||0>=m))if("stretch"==l)b.drawImage(this._imageLoader,a,g,k,m,c,d,e,f);else if("tile"==l)for(var p=c,q=d,n,r;!(n=Math.min(k,c+e-p),r=Math.min(m,d+f-q),b.drawImage(this._imageLoader,a,g,n,r,p,q,n,r),p+=n,p>=c+e&&(p=c,q+=r,q>=d+f)););else if("tilefit"==l)if(l=k/m,e/f>l)for(p=c,r=f,n=f*l;;)if(p+n>c+e){e=(c+e-p)/n;b.drawImage(this._imageLoader,a,g,k*e,m,p,d,n*e,r);break}else{if(b.drawImage(this._imageLoader,a,g,k,m,p,d,n,r),p+=n,p==c+e)break}else for(q=
d,n=e,r=e/l;;)if(q+r>d+f){d=(d+f-q)/r;b.drawImage(this._imageLoader,a,g,k,m*d,c,q,n,r*d);break}else{if(b.drawImage(this._imageLoader,a,g,k,m,c,q,n,r),q+=r,q==d+f)break}else if("fit"==l||"none"==l)p=this.getStyle("ImageVerticalAlign"),q=this.getStyle("ImageHorizontalAlign"),n=k,r=m,"fit"==l?(l=k/m,e/f>l?(r=f,n=f*l):(n=e,r=e/l)):(e<k&&("right"==q?a+=k-e:"center"==q&&(a+=(k-e)/2),n=k=e),f<m&&("bottom"==p?g+=m-f:"middle"==p&&(g+=(m-f)/2),r=m=f)),"right"==q?c+=e-n:"center"==q&&(c+=(e-n)/2),"bottom"==p?
d+=f-r:"middle"==p&&(d+=(f-r)/2),b.drawImage(this._imageLoader,a,g,k,m,c,d,n,r)}}};function DataRendererBaseElement(){DataRendererBaseElement.base.prototype.constructor.call(this);var a=this;this._onDataRendererBaseEventInstance=function(b){"rollover"==b.getType()?a._onDataRendererRollover(b):"rollout"==b.getType()&&a._onDataRendererRollout(b)};this.addEventListener("rollover",this._onDataRendererBaseEventInstance);this.addEventListener("rollout",this._onDataRendererBaseEventInstance)}
DataRendererBaseElement.prototype=Object.create(SkinnableElement.prototype);DataRendererBaseElement.prototype.constructor=DataRendererBaseElement;DataRendererBaseElement.base=SkinnableElement;DataRendererBaseElement._StyleTypes=Object.create(null);DataRendererBaseElement._StyleTypes.SkinClass={inheritable:!1};DataRendererBaseElement._StyleTypes.UpSkinClass={inheritable:!1};DataRendererBaseElement._StyleTypes.UpSkinStyle={inheritable:!1};DataRendererBaseElement._StyleTypes.AltSkinClass={inheritable:!1};
DataRendererBaseElement._StyleTypes.AltSkinStyle={inheritable:!1};DataRendererBaseElement._StyleTypes.OverSkinClass={inheritable:!1};DataRendererBaseElement._StyleTypes.OverSkinStyle={inheritable:!1};DataRendererBaseElement._StyleTypes.SelectedSkinClass={inheritable:!1};DataRendererBaseElement._StyleTypes.SelectedSkinStyle={inheritable:!1};DataRendererBaseElement._StyleTypes.Selectable={inheritable:!1};DataRendererBaseElement.StyleDefault=new StyleDefinition;
DataRendererBaseElement.OverSkinStyleDefault=new StyleDefinition;DataRendererBaseElement.OverSkinStyleDefault.setStyle("BackgroundColor","#E0E0E0");DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientType","linear");DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientStart",.03);DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientStop",-.03);DataRendererBaseElement.SelectedSkinStyleDefault=new StyleDefinition;
DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("BackgroundColor","#CDCDCD");DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientType","linear");DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientStart",.03);DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientStop",-.03);DataRendererBaseElement.StyleDefault.setStyle("Selectable",!0);DataRendererBaseElement.StyleDefault.setStyle("SkinClass",CanvasElement);
DataRendererBaseElement.StyleDefault.setStyle("UpSkinClass",CanvasElement);DataRendererBaseElement.StyleDefault.setStyle("AltSkinClass",CanvasElement);DataRendererBaseElement.StyleDefault.setStyle("OverSkinClass",CanvasElement);DataRendererBaseElement.StyleDefault.setStyle("SelectedSkinClass",CanvasElement);DataRendererBaseElement.StyleDefault.setStyle("UpSkinStyle",null);DataRendererBaseElement.StyleDefault.setStyle("AltSkinStyle",null);
DataRendererBaseElement.StyleDefault.setStyle("OverSkinStyle",DataRendererBaseElement.OverSkinStyleDefault);DataRendererBaseElement.StyleDefault.setStyle("SelectedSkinStyle",DataRendererBaseElement.SelectedSkinStyleDefault);DataRendererBaseElement.prototype._updateState=function(){var a;a=1==this._listSelected?"selected":1==this._mouseIsOver&&1==this.getStyle("Selectable")?"over":null==this._listData||0==this._listData._itemIndex%2?"up":"alt";this.setStyle("SkinState",a)};
DataRendererBaseElement.prototype._getSkinClass=function(a){var b=null;"up"==a?b=this.getStyleData("UpSkinClass"):"alt"==a?b=this.getStyleData("AltSkinClass"):"over"==a?b=this.getStyleData("OverSkinClass"):"selected"==a&&(b=this.getStyleData("SelectedSkinClass"));a=this.getStyleData("SkinClass");return null==b||0<a.comparePriority(b)?a.value:b.value};
DataRendererBaseElement.prototype._getSkinStyleDefinitions=function(a){return"up"==a?this.getStyle("UpSkinStyle"):"alt"==a?this.getStyle("AltSkinStyle"):"over"==a?this.getStyle("OverSkinStyle"):"selected"==a?this.getStyle("SelectedSkinStyle"):DataRendererBaseElement.base.prototype._getSkinStyleDefinitions.call(this,a)};
DataRendererBaseElement.prototype._getSkinStyleDefinitionDefault=function(a){return"up"==a?this._getDefaultStyle("UpSkinStyle"):"alt"==a?this._getDefaultStyle("AltSkinStyle"):"over"==a?this._getDefaultStyle("OverSkinStyle"):"selected"==a?this._getDefaultStyle("SelectedSkinStyle"):DataRendererBaseElement.base.prototype._getSkinStyleDefinitionDefault.call(this,a)};DataRendererBaseElement.prototype._onDataRendererRollover=function(a){this._updateState()};
DataRendererBaseElement.prototype._onDataRendererRollout=function(a){this._updateState()};DataRendererBaseElement.prototype._setListSelected=function(a){DataRendererBaseElement.base.prototype._setListSelected.call(this,a);this._updateState()};DataRendererBaseElement.prototype._setListData=function(a,b){DataRendererBaseElement.base.prototype._setListData.call(this,a,b);this._updateState()};
DataRendererBaseElement.prototype._doStylesUpdated=function(a){DataRendererBaseElement.base.prototype._doStylesUpdated.call(this,a);this._updateSkinClass("up");this._updateSkinStyleDefinitions("up");this._updateSkinClass("alt");this._updateSkinStyleDefinitions("alt");this._updateSkinClass("over");this._updateSkinStyleDefinitions("over");this._updateSkinClass("selected");this._updateSkinStyleDefinitions("selected");"Selectable"in a&&this._updateState()};
function DataRendererLabelElement(){DataRendererLabelElement.base.prototype.constructor.call(this);this._labelElement=new LabelElement;this._labelElement.setStyle("Padding",0);this._addChild(this._labelElement)}DataRendererLabelElement.prototype=Object.create(DataRendererBaseElement.prototype);DataRendererLabelElement.prototype.constructor=DataRendererLabelElement;DataRendererLabelElement.base=DataRendererBaseElement;DataRendererLabelElement._StyleTypes=Object.create(null);
DataRendererLabelElement._StyleTypes.UpTextColor={inheritable:!1};DataRendererLabelElement._StyleTypes.AltTextColor={inheritable:!1};DataRendererLabelElement._StyleTypes.OverTextColor={inheritable:!1};DataRendererLabelElement._StyleTypes.SelectedTextColor={inheritable:!1};DataRendererLabelElement.StyleDefault=new StyleDefinition;DataRendererLabelElement.StyleDefault.setStyle("PaddingTop",4);DataRendererLabelElement.StyleDefault.setStyle("PaddingBottom",4);
DataRendererLabelElement.StyleDefault.setStyle("PaddingLeft",4);DataRendererLabelElement.StyleDefault.setStyle("PaddingRight",4);DataRendererLabelElement.StyleDefault.setStyle("BorderType","none");DataRendererLabelElement.StyleDefault.setStyle("UpTextColor","#000000");DataRendererLabelElement.StyleDefault.setStyle("AltTextColor","#000000");DataRendererLabelElement.StyleDefault.setStyle("OverTextColor","#000000");DataRendererLabelElement.StyleDefault.setStyle("SelectedTextColor","#000000");
DataRendererLabelElement.prototype._changeState=function(a){DataRendererLabelElement.base.prototype._changeState.call(this,a);this._updateLabelTextColor()};
DataRendererLabelElement.prototype._getTextColor=function(a){var b=null;"up"==a?b=this.getStyleData("UpTextColor"):"alt"==a?b=this.getStyleData("AltTextColor"):"over"==a?b=this.getStyleData("OverTextColor"):"selected"==a&&(b=this.getStyleData("SelectedTextColor"));a=this.getStyleData("TextColor");return null==b||0<a.comparePriority(b)?a.value:b.value};
DataRendererLabelElement.prototype._updateLabelTextColor=function(){var a=this._getTextColor(this._currentSkinState);null!=a&&this._labelElement.setStyle("TextColor",a)};DataRendererLabelElement.prototype._updateLabelText=function(){if(null==this._itemData)this._labelElement.setStyle("Text","");else{var a=this._listData._parentList.getStyle("ItemLabelFunction");this._labelElement.setStyle("Text",a(this._itemData))}};
DataRendererLabelElement.prototype._setListData=function(a,b){DataRendererLabelElement.base.prototype._setListData.call(this,a,b);this._updateLabelText()};DataRendererLabelElement.prototype._doStylesUpdated=function(a){DataRendererLabelElement.base.prototype._doStylesUpdated.call(this,a);this._updateLabelTextColor()};DataRendererLabelElement.prototype._doMeasure=function(a,b){return{width:this._labelElement._getStyledOrMeasuredWidth()+a,height:this._labelElement._getStyledOrMeasuredHeight()+b}};
DataRendererLabelElement.prototype._doLayout=function(a){DataRendererLabelElement.base.prototype._doLayout.call(this,a);this._labelElement._setActualPosition(a.getX(),a.getY());this._labelElement._setActualSize(a.getWidth(),a.getHeight())};
function DataListElement(){DataListElement.base.prototype.constructor.call(this);this._listCollection=null;this._contentSize=0;this._scrollBar=null;this._scrollIndex=0;this._selectedIndex=-1;this._selectedItem=null;this._contentPane=new CanvasElement;this._contentPane.setStyle("ClipContent",!0);this._addChild(this._contentPane);var a=this;this._onDataListCollectionChangedInstance=function(b){a._onDataListCollectionChanged(b)};this._onDataListScrollBarChangedInstance=function(b){a._onDataListScrollBarChanged(b)};
this._onDataListMouseWheelEventInstance=function(b){a._onDataListMouseWheelEvent(b)};this._onDataListRendererClickInstance=function(b){a._onDataListRendererClick(b)};this.addEventListener("wheel",this._onDataListMouseWheelEventInstance)}DataListElement.prototype=Object.create(CanvasElement.prototype);DataListElement.prototype.constructor=DataListElement;DataListElement.base=CanvasElement;
DataListElement.DefaultItemLabelFunction=function(a){return null==a?"":"string"===typeof a||a instanceof String?a:"label"in a?a.label:a.toString()};DataListElement._StyleTypes=Object.create(null);DataListElement._StyleTypes.ListDirection={inheritable:!1};DataListElement._StyleTypes.ListAlign={inheritable:!1};DataListElement._StyleTypes.Selectable={inheritable:!1};DataListElement._StyleTypes.ScrollBarDisplay={inheritable:!1};DataListElement._StyleTypes.ScrollBarPlacement={inheritable:!1};
DataListElement._StyleTypes.ScrollBarStyle={inheritable:!1};DataListElement._StyleTypes.ItemLabelFunction={inheritable:!1};DataListElement._StyleTypes.ListItemClass={inheritable:!1};DataListElement._StyleTypes.ListItemStyle={inheritable:!1};DataListElement.StyleDefault=new StyleDefinition;DataListElement.StyleDefault.setStyle("ListDirection","vertical");DataListElement.StyleDefault.setStyle("ListAlign","top");DataListElement.StyleDefault.setStyle("ItemLabelFunction",DataListElement.DefaultItemLabelFunction);
DataListElement.StyleDefault.setStyle("ListItemClass",DataRendererLabelElement);DataListElement.StyleDefault.setStyle("ListItemStyle",null);DataListElement.StyleDefault.setStyle("Selectable",!0);DataListElement.StyleDefault.setStyle("ScrollBarDisplay","auto");DataListElement.StyleDefault.setStyle("ScrollBarPlacement","right");DataListElement.StyleDefault.setStyle("ScrollBarStyle",null);DataListElement._DataRendererProxyMap=Object.create(null);DataListElement._DataRendererProxyMap.Selectable=!0;
DataListElement._DataRendererProxyMap._Arbitrary=!0;
DataListElement.prototype.setSelectedIndex=function(a){if(this._selectedIndex==a)return!0;if(a>this._listCollection.length-1)return!1;-1>a&&(a=-1);var b=this._selectedIndex;this._selectedIndex=a;this._selectedItem=this._listCollection.getItemAt(a);if(0<this._contentPane._children.length){var c=this._contentPane._children[0]._listData._itemIndex,d=this._contentPane._children[this._contentPane._children.length-1]._listData._itemIndex;null!=a&&a>=c&&a<=d&&this._contentPane._children[a-c]._setListSelected(!0);
null!=b&&b>=c&&b<=d&&this._contentPane._children[b-c]._setListSelected(!1)}return!0};DataListElement.prototype.getSelectedIndex=function(){return this._selectedIndex};DataListElement.prototype.setSelectedItem=function(a){a=this._listCollection.getItemIndex(a);this.setSelectedIndex(a)};DataListElement.prototype.getSelectedItem=function(){return this._selectedItem};
DataListElement.prototype.setScrollIndex=function(a){this._invalidateLayout();if(0==this._contentPane._children.length||null==this._listCollection)for(this._scrollIndex=0;0<this._contentPane._children.length;)this._contentPane._removeChildAt(0);else{a>=this._listCollection.getLength()&&(a=this._listCollection.getLength()-1);0>a&&(a=0);this._scrollIndex=a;a=Math.floor(a);var b=this._contentPane._children[0]._listData._itemIndex;if(a==b-1)b=this._contentPane._children[this._contentPane._children.length-
1],this._contentPane._setChildIndex(b,0),this._updateRendererData(b,a);else if(a==b+1)this._listCollection.getLength()>=a+this._contentPane._children.length?(b=this._contentPane._children[0],this._contentPane._setChildIndex(b,this._contentPane._children.length-1),this._updateRendererData(b,a+this._contentPane._children.length-1)):this._contentPane._removeChildAt(0);else for(var c=0;c<this._contentPane._children.length;c++)if(this._listCollection.getLength()>a+c)b=this._contentPane._children[c],this._updateRendererData(b,
a+c);else for(;this._contentPane._children.length>c;)this._contentPane._removeChildAt(c)}};
DataListElement.prototype.setListCollection=function(a){this._listCollection!=a&&(null==this._manager?this._listCollection=a:(null!=this._listCollection&&this._listCollection.removeEventListener("collectionchanged",this._onDataListCollectionChangedInstance),this._listCollection=a,null!=this._listCollection&&this._listCollection.addEventListener("collectionchanged",this._onDataListCollectionChangedInstance)),null==this._listCollection?(this._selectedIndex=-1,this._selectedItem=null):null!=this._selectedItem&&
(this._selectedIndex=this._listCollection.getItemIndex(this._selectedItem),-1==this._selectedIndex&&(this._selectedItem=null)),this.setScrollIndex(this._scrollIndex),this._invalidateLayout())};DataListElement.prototype.getListCollection=function(){return this._listCollection};DataListElement.prototype._getContentSize=function(){var a=this._getPaddingSize();return"vertical"==this.getStyle("ListDirection")?this._contentSize+a.height:this._contentSize+a.width};
DataListElement.prototype._getNumRenderers=function(){return this._contentPane._children.length};
DataListElement.prototype._onDataListMouseWheelEvent=function(a){if(1!=a.getDefaultPrevented()&&0!=this._contentPane._children.length&&0!=this._listCollection.getLength()){var b;b=this.getStyle("ListDirection");var c=!1,d=!1,e=this._contentPane._children[0],f=this._contentPane._children[this._contentPane._children.length-1];if("horizontal"==b){b=a.getDeltaX();if(0==b)return;0==e._listData._itemIndex&&0<=e._x&&(c=!0);if(1==c&&0>b)return;f._listData._itemIndex==this._listCollection.getLength()-1&&f._x<=
this._contentPane._width-f._width&&(d=!0)}else{b=a.getDeltaY();if(0==b)return;0==e._listData._itemIndex&&0<=e._y&&(c=!0);if(1==c&&0>b)return;f._listData._itemIndex==this._listCollection.getLength()-1&&f._y<=this._contentPane._height-f._height&&(d=!0)}1==d&&0<b||(null!=this._scrollBar?(c=this._scrollBar.getTweenToValue(),null==c&&(c=this._scrollIndex),this._scrollBar.startScrollTween(c+b)):this.setScrollIndex(this._scrollIndex+b),a.preventDefault())}};
DataListElement.prototype._onDataListScrollBarChanged=function(a){a=this._scrollBar.getScrollValue();var b=this._scrollBar.getScrollPageSize(),c=this._scrollBar.getScrollViewSize();a==b-c&&1>a-this._scrollIndex&&(a=this._scrollIndex+1);this.setScrollIndex(a)};
DataListElement.prototype._onDataListCollectionChanged=function(a){var b=a.getKind();a=a.getIndex();this._invalidateLayout();if(0!=this._contentPane._children.length)if("reset"==b)null!=this._selectedItem&&(this._selectedIndex=this._listCollection.getItemIndex(this._selectedItem),-1==this._selectedIndex&&(this._selectedItem=null)),this.setScrollIndex(this._scrollIndex);else{var c=0,d=0;0<this._contentPane._children.length&&(c=this._contentPane._children[0]._listData._itemIndex,d=this._contentPane._children[this._contentPane._children.length-
1]._listData._itemIndex);this._selectedIndex==a&&"remove"==b&&(this._selectedIndex=-1,this._selectedItem=null);if(a<=d&&("add"==b||"remove"==b))if(a<=this._selectedIndex&&("add"==b?this._selectedIndex++:this._selectedIndex--),a<c)for(c="add"==b?1:-1,this._scrollIndex+=c,b=0;b<this._contentPane._children.length;b++)a=this._contentPane._children[b]._listData._itemIndex+c,this._updateRendererData(this._contentPane._children[b],a);else for("add"==b?(b=this._createRenderer(a),this._contentPane._addChildAt(b,
a-c),a++):this._contentPane._removeChildAt(a-c),b=a-c;b<this._contentPane._children.length;b++)this._updateRendererData(this._contentPane._children[b],a),a++;else"update"==b&&a>=c&&a<=d&&this._updateRendererData(this._contentPane._children[a-c],a)}};DataListElement.prototype._onCanvasElementAdded=function(a){DataListElement.base.prototype._onCanvasElementAdded.call(this,a);null!=this._listCollection&&this._listCollection.addEventListener("collectionchanged",this._onDataListCollectionChangedInstance)};
DataListElement.prototype._onCanvasElementRemoved=function(a){DataListElement.base.prototype._onCanvasElementRemoved.call(this,a);null!=this._listCollection&&this._listCollection.removeEventListener("collectionchanged",this._onDataListCollectionChangedInstance)};DataListElement.prototype._invalidateListRenderersLayout=function(){for(var a=0;a<this._contentPane._children.length;a++)this._contentPane._children[a]._invalidateLayout()};
DataListElement.prototype._invalidateListRenderersMeasure=function(){for(var a=0;a<this._contentPane._children.length;a++)this._contentPane._children[a]._invalidateMeasure()};
DataListElement.prototype._doStylesUpdated=function(a){DataListElement.base.prototype._doStylesUpdated.call(this,a);if("ListItemClass"in a){if(0<this._contentPane._children.length&&this._contentPane._children[0].constructor!=this.getStyle("ListItemClass")){for(;0<this._contentPane._children.length;)this._contentPane._removeChildAt(0);this._invalidateLayout()}}else if("ListItemStyle"in a){for(var b=this.getStyle("ListItemStyle"),c=0;c<this._contentPane._children.length;c++)this._contentPane._children[c].setStyleDefinitions(b);
this._invalidateLayout()}"ListDirection"in a?(this._invalidateMeasure(),this._invalidateLayout()):("ScrollBarPlacement"in a||"ScrollBarDisplay"in a||"ListAlign"in a)&&this._invalidateLayout();"ScrollBarStyle"in a&&null!=this._scrollBar&&this._scrollBar.setStyleDefinitions(this.getStyle("ScrollBarStyle"));"ItemLabelFunction"in a&&this.setScrollIndex(this._scrollIndex)};DataListElement.prototype._doMeasure=function(a,b){return{width:16,height:16}};
DataListElement.prototype._onDataListRendererClick=function(a){var b=a.getCurrentTarget()._listData._itemIndex;a=a.getCurrentTarget()._itemData;var c=!1;1==this.getStyle("Selectable")&&1==this.setSelectedIndex(b)&&(c=!0);this._dispatchEvent(new ElementListItemClickEvent(a,b));1==c&&this._dispatchEvent(new ElementEvent("changed",!1))};
DataListElement.prototype._createRenderer=function(a){var b=new (this.getStyle("ListItemClass"));b._setStyleDefinitionDefault(this._getDefaultStyle("ListItemStyle"));b._setStyleProxy(new StyleProxy(this,DataListElement._DataRendererProxyMap));b.setStyleDefinitions(this.getStyle("ListItemStyle"));this._updateRendererData(b,a);b.addEventListener("click",this._onDataListRendererClickInstance);return b};
DataListElement.prototype._updateRendererData=function(a,b){var c;c=null!=a._listData&&a._listData._itemIndex==b?a._listData:new DataListData(this,b);a._setListData(c,this._listCollection.getItemAt(b));this._selectedIndex==b?a._setListSelected(!0):a._setListSelected(!1)};
DataListElement.prototype._doLayout=function(a){DataListElement.base.prototype._doLayout.call(this,a);var b=a.getX(),c=a.getY(),d=a.getWidth(),e=a.getHeight(),f,g;a=this.getStyle("ListDirection");var k=Math.floor(this._scrollIndex),m=0;null!=this._listCollection&&(m=this._listCollection.getLength());0==m?this._scrollIndex=k=0:k>m-1&&(this._scrollIndex=k=m-1);var l=0,p=0;this._contentSize=0;var q;for(g=0;g<this._contentPane._children.length;g++)if(f=this._contentPane._children[g],q="horizontal"==a?
f._getStyledOrMeasuredWidth():f._getStyledOrMeasuredHeight(),this._contentSize+=q,f._listData._itemIndex<=k&&(l=f._listData._itemIndex<k?l+q:l+q*(this._scrollIndex-k)),this._contentSize-l>=e)for(p=this._contentSize-l-e;this._contentPane._children.length-1>g;)this._contentPane._removeChildAt(this._contentPane._children.length-1);0<this._contentPane._children.length&&this._contentPane._children[0]._listData._itemIndex<k&&(l+=p,p=0,k=this._contentPane._children[0]._listData._itemIndex,this._scrollIndex=
"horizontal"==a?k+l/this._contentPane._children[0]._getStyledOrMeasuredWidth():k+l/this._contentPane._children[0]._getStyledOrMeasuredHeight(),this._scrollIndex=CanvasElement.roundToPrecision(this._scrollIndex,3));if(this._contentSize-l-p<e){if(k+this._contentPane._children.length<m){a=this._createRenderer(k+this._contentPane._children.length);this._contentPane._addChild(a);this._invalidateLayout();return}f=e-(this._contentSize-l-p);if(l>=f)l-=f,this._scrollIndex="horizontal"==a?k+l/this._contentPane._children[0]._getStyledOrMeasuredWidth():
k+l/this._contentPane._children[0]._getStyledOrMeasuredHeight(),this._scrollIndex=CanvasElement.roundToPrecision(this._scrollIndex,3);else if(0<l&&m==this._contentPane._children.length)this._scrollIndex=l=0;else if(m>this._contentPane._children.length){a=this._createRenderer(k-1);this._contentPane._addChildAt(a,0);this._invalidateLayout();return}}f=!1;g=this.getStyle("ScrollBarDisplay");if("on"==g||"auto"==g&&0<e&&(this._contentSize>e||this._contentPane._children.length<m))f=!0;if(1==f&&null==this._scrollBar)this._scrollBar=
new ScrollBarElement,this._scrollBar._setStyleDefinitionDefault(this._getDefaultStyle("ScrollBarStyle")),this._scrollBar.setStyleDefinitions(this.getStyle("ScrollBarStyle")),this._scrollBar.setStyle("ScrollBarDirection",a),this._scrollBar.setScrollLineSize(1),this._scrollBar.addEventListener("changed",this._onDataListScrollBarChangedInstance),this._addChild(this._scrollBar);else if(0==f&&null!=this._scrollBar)this._removeChild(this._scrollBar),this._scrollBar=null;else{null!=this._scrollBar?(f=this.getStyle("ScrollBarPlacement"),
"horizontal"==a?(this._scrollBar._setActualSize(d,this._scrollBar._getStyledOrMeasuredHeight()),this._contentPane._setActualSize(d,e-this._scrollBar._height),"top"==f||"left"==f?(this._contentPane._setActualPosition(b,c+this._scrollBar._height),this._scrollBar._setActualPosition(b,c)):(this._contentPane._setActualPosition(b,c),this._scrollBar._setActualPosition(b,c+this._contentPane._height))):(this._scrollBar._setActualSize(this._scrollBar._getStyledOrMeasuredWidth(),e),this._contentPane._setActualSize(d-
this._scrollBar._width,e),"top"==f||"left"==f?(this._scrollBar._setActualPosition(b,c),this._contentPane._setActualPosition(b+this._scrollBar._width,c)):(this._scrollBar._setActualPosition(b+this._contentPane._width,c),this._contentPane._setActualPosition(b,c)))):(this._contentPane._setActualPosition(b,c),this._contentPane._setActualSize(d,e));b=-1*l;this._contentSize<e&&(b=this.getStyle("ListAlign"),b="top"==b||"left"==b?0:"center"==b||"middle"==b?e/2-this._contentSize/2:e-this._contentSize);for(g=
0;g<this._contentPane._children.length;g++)f=this._contentPane._children[g],"horizontal"==a?(f._setActualSize(f._getStyledOrMeasuredWidth(),this._contentPane._height),f._setActualPosition(b,0),b+=f._width):(f._setActualSize(this._contentPane._width,f._getStyledOrMeasuredHeight()),f._setActualPosition(0,b),b+=f._height);if(null!=this._scrollBar){if(e=this._contentPane._children.length)"horizontal"==a?(e-=l/this._contentPane._children[0]._width,e-=p/this._contentPane._children[this._contentPane._children.length-
1]._width):(e-=l/this._contentPane._children[0]._height,e-=p/this._contentPane._children[this._contentPane._children.length-1]._height);this._scrollBar.setScrollPageSize(m);this._scrollBar.setScrollViewSize(e);this._scrollBar.getScrollValue()!=this._scrollIndex&&(this._scrollBar.endScrollTween(),this._scrollBar.setScrollValue(this._scrollIndex))}}};function DataGridLabelItemRenderer(){DataGridLabelItemRenderer.base.prototype.constructor.call(this)}DataGridLabelItemRenderer.prototype=Object.create(LabelElement.prototype);
DataGridLabelItemRenderer.prototype.constructor=DataGridLabelItemRenderer;DataGridLabelItemRenderer.base=LabelElement;DataGridLabelItemRenderer.StyleDefault=new StyleDefinition;DataGridLabelItemRenderer.StyleDefault.setStyle("Padding",5);DataGridLabelItemRenderer.prototype._setListData=function(a,b){DataGridLabelItemRenderer.base.prototype._setListData.call(this,a,b);this._updateLabelText()};
DataGridLabelItemRenderer.prototype._updateLabelText=function(){if(null==this._itemData||null==this._listData)this.setStyle("Text","");else{var a=this._listData._parentGrid._gridColumns[this._listData._columnIndex].getStyle("RowItemLabelFunction");this.setStyle("Text",a(this._itemData,this._listData._columnIndex))}};
function DataGridDataRenderer(){DataGridDataRenderer.base.prototype.constructor.call(this);this._itemRenderersContainer=new CanvasElement;this._addChild(this._itemRenderersContainer)}DataGridDataRenderer.prototype=Object.create(DataRendererBaseElement.prototype);DataGridDataRenderer.prototype.constructor=DataGridDataRenderer;DataGridDataRenderer.base=DataRendererBaseElement;DataGridDataRenderer.StyleDefault=new StyleDefinition;DataGridDataRenderer.UpSkinStyleDefault=new StyleDefinition;
DataGridDataRenderer.UpSkinStyleDefault.setStyle("BackgroundColor","#FFFFFF");DataGridDataRenderer.UpSkinStyleDefault.setStyle("AutoGradientType","none");DataGridDataRenderer.AltSkinStyleDefault=new StyleDefinition;DataGridDataRenderer.AltSkinStyleDefault.setStyle("BackgroundColor","#F0F0F0");DataGridDataRenderer.AltSkinStyleDefault.setStyle("AutoGradientType","none");DataGridDataRenderer.StyleDefault.setStyle("UpSkinStyle",DataGridDataRenderer.UpSkinStyleDefault);
DataGridDataRenderer.StyleDefault.setStyle("AltSkinStyle",DataGridDataRenderer.AltSkinStyleDefault);
DataGridDataRenderer.prototype._setListData=function(a,b){DataGridDataRenderer.base.prototype._setListData.call(this,a,b);for(var c,d=0;d<a._parentList._gridColumns.length;d++)c=this._itemRenderersContainer._getChildAt(d),null==c?(c=a._parentList._createRowItemRenderer(a._itemIndex,d),this._itemRenderersContainer._addChildAt(c,d)):(columnDef=a._parentList._gridColumns[d],c.constructor!=columnDef.getStyle("RowItemClass")?(this._itemRenderersContainer._removeChildAt(d),c=a._parentList._createRowItemRenderer(a._itemIndex,
d),this._itemRenderersContainer._addChildAt(c,d)):a._parentList._updateRowItemRendererData(c,a._itemIndex,d));for(;this._itemRenderersContainer._children.length>this._listData._parentList._gridColumns.length;)this._itemRenderersContainer._removeChildAt(this._itemRenderersContainer._children.length-1);this._invalidateMeasure();this._invalidateLayout()};
DataGridDataRenderer.prototype._doMeasure=function(a,b){for(var c={width:0,height:0},d,e=0;e<this._itemRenderersContainer._children.length;e++)d=this._itemRenderersContainer._children[e]._getStyledOrMeasuredHeight(),c.height<d&&(c.height=d),c.width+=this._itemRenderersContainer._children[e]._getStyledOrMeasuredWidth();c.width+=a;c.height+=b;return c};
DataGridDataRenderer.prototype._doLayout=function(a){DataGridDataRenderer.base.prototype._doLayout.call(this,a);if(null!=this._listData){this._itemRenderersContainer._setActualPosition(a.getX(),a.getY());this._itemRenderersContainer._setActualSize(a.getWidth(),a.getHeight());a=this._listData._parentList;for(var b,c=0,d,e=this._getPaddingSize(),f=0;f<a._columnSizes.length;f++)b=this._itemRenderersContainer._children[f],d=a._columnSizes[f],0==f?d-=e.paddingLeft:f==a._columnSizes.length-1&&(d=this._itemRenderersContainer._width-
c),b._setActualPosition(c,0),b._setActualSize(d,this._itemRenderersContainer._height),c+=d}};function ContainerBaseElement(){ContainerBaseElement.base.prototype.constructor.call(this);this._elements=[];this._overlayChildren=[]}ContainerBaseElement.prototype=Object.create(CanvasElement.prototype);ContainerBaseElement.prototype.constructor=ContainerBaseElement;ContainerBaseElement.base=CanvasElement;ContainerBaseElement.StyleDefault=new StyleDefinition;
ContainerBaseElement.StyleDefault.setStyle("ClipContent",!0);ContainerBaseElement.prototype.addElement=function(a){return this.addElementAt(a,this._elements.length)};ContainerBaseElement.prototype.addElementAt=function(a,b){if(!(a instanceof CanvasElement)||0>b||b>this._elements.length)return null;var c=this._children.length-this._overlayChildren.length-this._elements.length+b;this._elements.splice(b,0,a);ContainerBaseElement.base.prototype._addChildAt.call(this,a,c);return a};
ContainerBaseElement.prototype.removeElement=function(a){a=this._elements.indexOf(a);return this.removeElementAt(a)};ContainerBaseElement.prototype.removeElementAt=function(a){if(0>a||a>=this._elements.length)return null;var b=this._children.length-this._overlayChildren.length-this._elements.length+a;this._elements.splice(a,1);return ContainerBaseElement.base.prototype._removeChildAt.call(this,b)};ContainerBaseElement.prototype.getElementAt=function(a){return 0>a||a>=this._elements.length?null:this._elements[a]};
ContainerBaseElement.prototype.getElementIndex=function(a){return this._elements.indexOf(a)};ContainerBaseElement.prototype.setElementIndex=function(a,b){if(0>b||b>=this._elements.length)return!1;var c=this._elements.indexOf(a);if(-1==c||c==b)return!1;var d=this._children.length-this._overlayChildren.length-this._elements.length+b;this._elements.splice(b,0,this._elements.splice(c,1)[0]);ContainerBaseElement.base.prototype._setChildIndex.call(this,a,d);return!0};
ContainerBaseElement.prototype.getNumElements=function(){return this._elements.length};ContainerBaseElement.prototype._addOverlayChild=function(a){return this._addOverlayChildAt(a,this._overlayChildren.length)};
ContainerBaseElement.prototype._addOverlayChildAt=function(a,b){if(!(a instanceof CanvasElement)||0>b||b>this._overlayChildren.length)return null;var c=this._children.length-this._overlayChildren.length+b;this._overlayChildren.splice(b,0,a);ContainerBaseElement.base.prototype._addChildAt.call(this,a,c);return a};ContainerBaseElement.prototype._removeOverlayChild=function(a){a=this._overlayChildren.indexOf(a);return this._removeOverlayChildAt(a)};
ContainerBaseElement.prototype._removeOverlayChildAt=function(a){if(0>a||a>=this._overlayChildren.length)return null;var b=this._children.length-this._overlayChildren.length+a;this._overlayChildren.splice(a,1);return ContainerBaseElement.base.prototype._removeChildAt.call(this,b)};ContainerBaseElement.prototype._getOverlayChildAt=function(a){return 0>a||a>=this._overlayChildren.length?null:this._overlayChildren[a]};ContainerBaseElement.prototype._getOverlayChildIndex=function(a){return this._overlayChildren.indexOf(a)};
ContainerBaseElement.prototype._setOverlayChildIndex=function(a,b){if(0>b||b>=this._overlayChildren.length)return!1;var c=this._overlayChildren.indexOf(a);if(0>c||c==b)return!1;var d=this._children.length-this._overlayChildren.length+b;this._overlayChildren.splice(b,0,this._overlayChildren.splice(c,1)[0]);ContainerBaseElement.base.prototype._setChildIndex.call(this,a,d);return!0};ContainerBaseElement.prototype._getNumOverlayChildren=function(){return this._overlayChildren.length};
ContainerBaseElement.prototype._addChild=function(a){return ContainerBaseElement.base.prototype._addChildAt.call(this,a,this._children.length-this._elements.length-this._overlayChildren.length)};ContainerBaseElement.prototype._addChildAt=function(a,b){var c=this._children.length-this._elements.length-this._overlayChildren.length;return 0>b||b>c?null:ContainerBaseElement.base.prototype._addChildAt.call(this,a,b)};
ContainerBaseElement.prototype._removeChildAt=function(a){if(0>a||a>=this._children.length)return null;var b=this._children.splice(a,1)[0],c=this._elements.indexOf(b);if(0<=c)return this.removeElementAt(c);c=this._overlayChildren.indexOf(b);return 0<=c?this._removeOverlayChildAt(c):ContainerBaseElement.base.prototype._removeChildAt.call(this,a)};
ContainerBaseElement.prototype._setChildIndex=function(a,b){var c=this._children.length-this._elements.length-this._overlayChildren.length;if(0>b||b>=c)return!1;var d=this._getChildIndex(a);return 0>d||d>=c||d==b?!1:ContainerBaseElement.base.prototype._setChildIndex.call(this,a,b)};function ListContainerElement(){ListContainerElement.base.prototype.constructor.call(this)}ListContainerElement.prototype=Object.create(ContainerBaseElement.prototype);ListContainerElement.prototype.constructor=ListContainerElement;
ListContainerElement.base=ContainerBaseElement;ListContainerElement._StyleTypes=Object.create(null);ListContainerElement._StyleTypes.LayoutDirection={inheritable:!1};ListContainerElement._StyleTypes.LayoutGap={inheritable:!1};ListContainerElement._StyleTypes.LayoutVerticalAlign={inheritable:!1};ListContainerElement._StyleTypes.LayoutHorizontalAlign={inheritable:!1};ListContainerElement.StyleDefault=new StyleDefinition;ListContainerElement.StyleDefault.setStyle("LayoutDirection","vertical");
ListContainerElement.StyleDefault.setStyle("LayoutGap",0);ListContainerElement.StyleDefault.setStyle("LayoutVerticalAlign","top");ListContainerElement.StyleDefault.setStyle("LayoutHorizontalAlign","left");ListContainerElement.prototype._doStylesUpdated=function(a){ListContainerElement.base.prototype._doStylesUpdated.call(this,a);"LayoutDirection"in a||"LayoutGap"in a?(this._invalidateMeasure(),this._invalidateLayout()):"LayoutAlign"in a&&this._invalidateLayout()};
ListContainerElement.prototype._doMeasure=function(a,b){for(var c={width:0,height:0},d=this.getStyle("LayoutGap"),e=this.getStyle("LayoutDirection"),f,g,k,m,l,p,q,n,r,v=!1,t=0;t<this._elements.length;t++)f=this._elements[t],0!=f.getStyle("IncludeInLayout")&&(g=f.getStyle("Width"),k=f.getStyle("Height"),p=f.getStyle("MaxWidth"),q=f.getStyle("MaxHeight"),n=f.getStyle("MinWidth"),r=f.getStyle("MinHeight"),m=f.getStyle("RotateDegrees"),null==n&&(n=0),null==r&&(r=0),null==p&&(p=Number.MAX_VALUE),null==
q&&(q=Number.MAX_VALUE),0!=m?(null==g&&(g=f._measuredWidth,g=Math.min(g,p),g=Math.max(g,n)),null==k&&(k=f._measuredHeight,k=Math.min(k,q),k=Math.max(k,r)),p=f._width,q=f._height,n=f._rotateDegrees,f._width=g,f._height=k,f._rotateDegrees=m,rotatedMetrics=f.getMetrics(this),f._width=p,f._height=q,f._rotateDegrees=n,g=Math.ceil(rotatedMetrics.getWidth()),k=Math.ceil(rotatedMetrics.getHeight())):(m=f.getStyle("PercentWidth"),l=f.getStyle("PercentHeight"),null==g&&(null==m?(g=f._measuredWidth,g=Math.min(g,
p),g=Math.max(g,n)):g=n),null==k&&(null==l?(k=f._measuredHeight,k=Math.min(k,q),k=Math.max(k,r)):k=r)),"horizontal"==e?(c.width+=g,k>c.height&&(c.height=k)):(c.height+=k,g>c.width&&(c.width=g)),1==v?"horizontal"==e?c.width+=d:c.height+=d:v=!0);c.width+=a;c.height+=b;return c};
ListContainerElement.prototype._doLayout=function(a){ListContainerElement.base.prototype._doLayout.call(this,a);var b=this.getStyle("LayoutGap"),c=this.getStyle("LayoutDirection"),d=this.getStyle("LayoutVerticalAlign"),e=this.getStyle("LayoutHorizontalAlign"),f=a.getX(),g=a.getY(),k=a.getWidth();a=a.getHeight();var m,l,p=[],q=0,n=0;for(m=0;m<this._elements.length;m++)if(l=this._elements[m],0!=l.getStyle("IncludeInLayout")){n++;var r={element:l,width:null,height:null,pWidth:null,pHeight:null,maxWidth:null,
maxHeight:null,minWidth:null,minHeight:null,rotateDegrees:null};r.rotateDegrees=l.getStyle("RotateDegrees");r.width=l.getStyle("Width");null==r.width&&(0==r.rotateDegrees&&(r.pWidth=l.getStyle("PercentWidth")),r.minWidth=l.getStyle("MinWidth"),r.maxWidth=l.getStyle("MaxWidth"),null!=r.pWidth&&"horizontal"==c&&(q+=r.pWidth));r.height=l.getStyle("Height");null==r.height&&(0==r.rotateDegrees&&(r.pHeight=l.getStyle("PercentHeight")),r.minHeight=l.getStyle("MinHeight"),r.maxHeight=l.getStyle("MaxHeight"),
null!=r.pHeight&&"vertical"==c&&(q+=r.pHeight));null==r.minWidth&&(r.minWidth=0);null==r.minHeight&&(r.minHeight=0);null==r.maxWidth&&(r.maxWidth=Number.MAX_VALUE);null==r.maxHeight&&(r.maxHeight=Number.MAX_VALUE);p.push(r)}r=0;1<n&&(r=(n-1)*b);var n="horizontal"==c?k-r:a-r,v,t=[];for(m=0;m<p.length;m++)l=p[m],l.element._setActualRotation(l.rotateDegrees,0,0),"horizontal"==c&&null==p[m].width&&null!=p[m].pWidth?(l.percentSize=l.pWidth,l.minSize=l.minWidth,l.maxSize=l.maxWidth,t.push(l),null==l.height&&
(l.height=null!=l.pHeight?Math.round(l.pHeight/100*a):l.element._measuredHeight,l.height=Math.min(l.maxHeight,l.height),l.height=Math.max(l.minHeight,l.height))):"vertical"==c&&null==p[m].height&&null!=p[m].pHeight?(l.percentSize=l.pHeight,l.minSize=l.minHeight,l.maxSize=l.maxHeight,t.push(l),null==l.width&&(l.width=null!=l.pWidth?Math.round(l.pWidth/100*k):l.element._measuredWidth,l.width=Math.min(l.maxWidth,l.width),l.width=Math.max(l.minWidth,l.width))):(null==l.width&&(l.width=null!=l.pWidth?
Math.round(l.pWidth/100*k):l.element._measuredWidth,l.width=Math.min(l.maxWidth,l.width),l.width=Math.max(l.minWidth,l.width)),null==l.height&&(l.height=null!=l.pHeight?Math.round(l.pHeight/100*a):l.element._measuredHeight,l.height=Math.min(l.maxHeight,l.height),l.height=Math.max(l.minHeight,l.height)),l.element._setActualSize(l.width,l.height),0!=l.rotateDegrees&&(v=l.element.getMetrics(this),l.width=Math.ceil(v.getWidth()),l.height=Math.ceil(v.getHeight())),n="horizontal"==c?n-l.width:n-l.height);
100>q&&(n=Math.round(q/100*n));CanvasElement._calculateMinMaxPercentSizes(t,n);for(m=0;m<t.length;m++)l=t[m],"horizontal"==c?l.width=l.actualSize:l.height=l.actualSize,l.element._setActualSize(l.width,l.height);l=r;for(m=0;m<p.length;m++)l="horizontal"==c?l+p[m].width:l+p[m].height;q=f;r=g;"horizontal"==c&&l!=k?"center"==e?q+=Math.round(k/2-l/2):"right"==e&&(q+=k-l):"vertical"==c&&l!=a&&("middle"==d?r+=Math.round(a/2-l/2):"bottom"==d&&(r+=a-l));n=!1;for(m=0;m<p.length;m++)l=p[m],"horizontal"==c?(1==
n?q+=b:n=!0,r="top"==d?g:"bottom"==d?g+a-l.height:Math.round(g+a/2-l.height/2),0==l.rotateDegees?l.element._setActualPosition(q,r):l.element._setRelativePosition(q,r,this),q+=l.width):(1==n?r+=b:n=!0,q="left"==e?f:"right"==e?f+k-l.width:Math.round(f+k/2-l.width/2),0==l.rotateDegrees?l.element._setActualPosition(q,r):l.element._setRelativePosition(q,r,this),r+=l.height)};
function ButtonElement(){ButtonElement.base.prototype.constructor.call(this);var a=this;this._labelElement=null;this._onButtonEventInstance=function(b){"mousedown"==b.getType()?a._onButtonMouseDown(b):"mouseup"==b.getType()?a._onButtonMouseUp(b):"click"==b.getType()?a._onButtonClick(b):"rollover"==b.getType()?a._onButtonRollover(b):"rollout"==b.getType()&&a._onButtonRollout(b)};this.addEventListener("mousedown",this._onButtonEventInstance);this.addEventListener("mouseup",this._onButtonEventInstance);
this.addEventListener("rollover",this._onButtonEventInstance);this.addEventListener("rollout",this._onButtonEventInstance);this.addEventListener("click",this._onButtonEventInstance)}ButtonElement.prototype=Object.create(SkinnableElement.prototype);ButtonElement.prototype.constructor=ButtonElement;ButtonElement.base=SkinnableElement;ButtonElement._StyleTypes=Object.create(null);ButtonElement._StyleTypes.Text={inheritable:!1};ButtonElement._StyleTypes.SkinClass={inheritable:!1};
ButtonElement._StyleTypes.UpSkinClass={inheritable:!1};ButtonElement._StyleTypes.UpSkinStyle={inheritable:!1};ButtonElement._StyleTypes.UpTextColor={inheritable:!1};ButtonElement._StyleTypes.OverSkinClass={inheritable:!1};ButtonElement._StyleTypes.OverSkinStyle={inheritable:!1};ButtonElement._StyleTypes.OverTextColor={inheritable:!1};ButtonElement._StyleTypes.DownSkinClass={inheritable:!1};ButtonElement._StyleTypes.DownSkinStyle={inheritable:!1};ButtonElement._StyleTypes.DownTextColor={inheritable:!1};
ButtonElement._StyleTypes.DisabledSkinClass={inheritable:!1};ButtonElement._StyleTypes.DisabledSkinStyle={inheritable:!1};ButtonElement._StyleTypes.DisabledTextColor={inheritable:!1};ButtonElement._StyleTypes.TextAlign={inheritable:!1};ButtonElement._StyleTypes.TextBaseline={inheritable:!1};ButtonElement.StyleDefault=new StyleDefinition;ButtonElement.StyleDefault.setStyle("PaddingTop",2);ButtonElement.StyleDefault.setStyle("PaddingBottom",2);ButtonElement.StyleDefault.setStyle("PaddingLeft",3);
ButtonElement.StyleDefault.setStyle("PaddingRight",3);ButtonElement.StyleDefault.setStyle("TextAlign","center");ButtonElement.StyleDefault.setStyle("TextBaseline","middle");ButtonElement.StyleDefault.setStyle("TabStop",0);ButtonElement.StyleDefault.setStyle("Text",null);ButtonElement.StyleDefault.setStyle("SkinClass",CanvasElement);ButtonElement.StyleDefault.setStyle("UpSkinClass",CanvasElement);ButtonElement.StyleDefault.setStyle("OverSkinClass",CanvasElement);
ButtonElement.StyleDefault.setStyle("DownSkinClass",CanvasElement);ButtonElement.StyleDefault.setStyle("DisabledSkinClass",CanvasElement);ButtonElement.StyleDefault.setStyle("UpTextColor","#000000");ButtonElement.StyleDefault.setStyle("OverTextColor","#000000");ButtonElement.StyleDefault.setStyle("DownTextColor","#000000");ButtonElement.StyleDefault.setStyle("DisabledTextColor","#888888");ButtonElement.UpSkinStyleDefault=new StyleDefinition;ButtonElement.UpSkinStyleDefault.setStyle("BorderType","solid");
ButtonElement.UpSkinStyleDefault.setStyle("BorderThickness",1);ButtonElement.UpSkinStyleDefault.setStyle("BorderColor","#333333");ButtonElement.UpSkinStyleDefault.setStyle("BackgroundColor","#EBEBEB");ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientType","linear");ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStart",.05);ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStop",-.05);ButtonElement.OverSkinStyleDefault=new StyleDefinition;
ButtonElement.OverSkinStyleDefault.setStyle("BorderType","solid");ButtonElement.OverSkinStyleDefault.setStyle("BorderThickness",1);ButtonElement.OverSkinStyleDefault.setStyle("BorderColor","#333333");ButtonElement.OverSkinStyleDefault.setStyle("BackgroundColor","#DDDDDD");ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientType","linear");ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStart",.05);ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStop",-.05);
ButtonElement.DownSkinStyleDefault=new StyleDefinition;ButtonElement.DownSkinStyleDefault.setStyle("BorderType","solid");ButtonElement.DownSkinStyleDefault.setStyle("BorderThickness",1);ButtonElement.DownSkinStyleDefault.setStyle("BorderColor","#333333");ButtonElement.DownSkinStyleDefault.setStyle("BackgroundColor","#CCCCCC");ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientType","linear");ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStart",-.06);
ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStop",.02);ButtonElement.DisabledSkinStyleDefault=new StyleDefinition;ButtonElement.DisabledSkinStyleDefault.setStyle("BorderType","solid");ButtonElement.DisabledSkinStyleDefault.setStyle("BorderThickness",1);ButtonElement.DisabledSkinStyleDefault.setStyle("BorderColor","#999999");ButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundColor","#ECECEC");ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientType","linear");
ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart",.05);ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop",-.05);ButtonElement.DisabledSkinStyleDefault.setStyle("ArrowColor","#777777");ButtonElement.StyleDefault.setStyle("UpSkinStyle",ButtonElement.UpSkinStyleDefault);ButtonElement.StyleDefault.setStyle("OverSkinStyle",ButtonElement.OverSkinStyleDefault);ButtonElement.StyleDefault.setStyle("DownSkinStyle",ButtonElement.DownSkinStyleDefault);
ButtonElement.StyleDefault.setStyle("DisabledSkinStyle",ButtonElement.DisabledSkinStyleDefault);ButtonElement.prototype._updateState=function(){var a="up";0==this.getStyle("Enabled")?a="disabled":1==this._mouseIsDown?a="down":1==this._mouseIsOver&&(a="over");this.setStyle("SkinState",a)};ButtonElement.prototype._onButtonMouseDown=function(a){this._updateState()};ButtonElement.prototype._onButtonMouseUp=function(a){this._updateState()};ButtonElement.prototype._onButtonRollover=function(a){this._updateState()};
ButtonElement.prototype._onButtonRollout=function(a){this._updateState()};ButtonElement.prototype._onButtonClick=function(a){0==this.getStyle("Enabled")&&a.cancelEvent()};
ButtonElement.prototype._getSkinClass=function(a){var b=null;"up"==a?b=this.getStyleData("UpSkinClass"):"over"==a?b=this.getStyleData("OverSkinClass"):"down"==a?b=this.getStyleData("DownSkinClass"):"disabled"==a&&(b=this.getStyleData("DisabledSkinClass"));a=this.getStyleData("SkinClass");return null==b||0<a.comparePriority(b)?a.value:b.value};
ButtonElement.prototype._getSkinStyleDefinitions=function(a){return"up"==a?this.getStyle("UpSkinStyle"):"over"==a?this.getStyle("OverSkinStyle"):"down"==a?this.getStyle("DownSkinStyle"):"disabled"==a?this.getStyle("DisabledSkinStyle"):ButtonElement.base.prototype._getSkinStyleDefinitions.call(this,a)};
ButtonElement.prototype._getSkinStyleDefinitionDefault=function(a){return"up"==a?this._getDefaultStyle("UpSkinStyle"):"over"==a?this._getDefaultStyle("OverSkinStyle"):"down"==a?this._getDefaultStyle("DownSkinStyle"):"disabled"==a?this._getDefaultStyle("DisabledSkinStyle"):ButtonElement.base.prototype._getSkinStyleDefinitionDefault.call(this,a)};ButtonElement.prototype._changeState=function(a){ButtonElement.base.prototype._changeState.call(this,a);this._updateTextColor()};
ButtonElement.prototype._getTextColor=function(a){var b=null;"up"==a?b=this.getStyleData("UpTextColor"):"over"==a?b=this.getStyleData("OverTextColor"):"down"==a?b=this.getStyleData("DownTextColor"):"disabled"==a&&(b=this.getStyleData("DisabledTextColor"));a=this.getStyleData("TextColor");return null==b||0<a.comparePriority(b)?a.value:b.value};ButtonElement.prototype._updateTextColor=function(){null!=this._labelElement&&this._labelElement.setStyle("TextColor",this._getTextColor(this._currentSkinState))};
ButtonElement.prototype._updateText=function(){var a=this.getStyle("Text");null==a||""==a?null!=this._labelElement&&(this._removeChild(this._labelElement),this._labelElement=null):(null==this._labelElement&&(this._labelElement=this._createLabel(),null!=this._labelElement&&(this._updateTextColor(),this._addChild(this._labelElement))),null!=this._labelElement&&this._labelElement.setStyle("Text",a))};
ButtonElement.prototype._doStylesUpdated=function(a){ButtonElement.base.prototype._doStylesUpdated.call(this,a);this._updateSkinClass("up");this._updateSkinStyleDefinitions("up");this._updateSkinClass("over");this._updateSkinStyleDefinitions("over");this._updateSkinClass("down");this._updateSkinStyleDefinitions("down");this._updateSkinClass("disabled");this._updateSkinStyleDefinitions("disabled");"Text"in a&&this._updateText();"Enabled"in a&&1==this.getStyle("MouseEnabled")&&this._updateState();"TextAlign"in
a&&null!=this._labelElement&&this._labelElement.setStyle("TextAlign",this.getStyle("TextAlign"));"TextBaseline"in a&&null!=this._labelElement&&this._labelElement.setStyle("TextBaseline",this.getStyle("TextBaseline"));this._updateTextColor()};ButtonElement.prototype._createLabel=function(){var a=new LabelElement;a.setStyle("MouseEnabled",!1);a.setStyle("TextAlign",this.getStyle("TextAlign"));a.setStyle("TextBaseline",this.getStyle("TextBaseline"));a.setStyle("Padding",0);return a};
ButtonElement.prototype._doMeasure=function(a,b){var c;if(null!=this._labelElement){c=this._labelElement._getStyledOrMeasuredWidth();var d=this._labelElement._getStyledOrMeasuredHeight();c={width:c+a,height:d+b}}else c=ButtonElement.base.prototype._doMeasure.call(this,a,b);return c};
ButtonElement.prototype._doLayout=function(a){ButtonElement.base.prototype._doLayout.call(this,a);null!=this._labelElement&&(this._labelElement._setActualPosition(a.getX(),a.getY()),this._labelElement._setActualSize(a.getWidth(),a.getHeight()))};function ToggleButtonElement(){ToggleButtonElement.base.prototype.constructor.call(this);this._isSelected=!1}ToggleButtonElement.prototype=Object.create(ButtonElement.prototype);ToggleButtonElement.prototype.constructor=ToggleButtonElement;
ToggleButtonElement.base=ButtonElement;ToggleButtonElement._StyleTypes=Object.create(null);ToggleButtonElement._StyleTypes.AllowDeselect={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedUpSkinClass={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedUpSkinStyle={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedUpTextColor={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedOverSkinClass={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedOverSkinStyle={inheritable:!1};
ToggleButtonElement._StyleTypes.SelectedOverTextColor={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedDownSkinClass={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedDownSkinStyle={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedDownTextColor={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedDisabledSkinClass={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedDisabledSkinStyle={inheritable:!1};ToggleButtonElement._StyleTypes.SelectedDisabledTextColor={inheritable:!1};
ToggleButtonElement.StyleDefault=new StyleDefinition;ToggleButtonElement.StyleDefault.setStyle("AllowDeselect",!0);ToggleButtonElement.StyleDefault.setStyle("SelectedUpSkinClass",CanvasElement);ToggleButtonElement.StyleDefault.setStyle("SelectedOverSkinClass",CanvasElement);ToggleButtonElement.StyleDefault.setStyle("SelectedDownSkinClass",CanvasElement);ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledSkinClass",CanvasElement);
ToggleButtonElement.StyleDefault.setStyle("SelectedOverTextColor","#000000");ToggleButtonElement.StyleDefault.setStyle("SelectedUpTextColor","#000000");ToggleButtonElement.StyleDefault.setStyle("SelectedDownTextColor","#000000");ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledTextColor","#888888");ToggleButtonElement.SelectedUpSkinStyleDefault=new StyleDefinition;ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderType","solid");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderThickness",1);ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderColor","#333333");ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BackgroundColor","#CCCCCC");ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientType","linear");ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientStart",-.06);ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientStop",.02);
ToggleButtonElement.SelectedOverSkinStyleDefault=new StyleDefinition;ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderType","solid");ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderThickness",1);ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderColor","#333333");ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BackgroundColor","#BDBDBD");ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientType","linear");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientStart",-.08);ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientStop",.05);ToggleButtonElement.SelectedDownSkinStyleDefault=new StyleDefinition;ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderType","solid");ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderThickness",1);ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderColor","#333333");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BackgroundColor","#B0B0B0");ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientType","linear");ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientStart",-.08);ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientStop",.05);ToggleButtonElement.SelectedDisabledSkinStyleDefault=new StyleDefinition;ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderType","solid");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderThickness",1);ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderColor","#777777");ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BackgroundColor","#C7C7C7");ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientType","linear");ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientStart",-.08);
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientStop",.05);ToggleButtonElement.StyleDefault.setStyle("SelectedUpSkinStyle",ToggleButtonElement.SelectedUpSkinStyleDefault);ToggleButtonElement.StyleDefault.setStyle("SelectedOverSkinStyle",ToggleButtonElement.SelectedOverSkinStyleDefault);ToggleButtonElement.StyleDefault.setStyle("SelectedDownSkinStyle",ToggleButtonElement.SelectedDownSkinStyleDefault);ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledSkinStyle",ToggleButtonElement.SelectedDisabledSkinStyleDefault);
ToggleButtonElement.prototype.setSelected=function(a){this._isSelected!=a&&(this._isSelected=a,this._updateState())};ToggleButtonElement.prototype.getSelected=function(){return this._isSelected};
ToggleButtonElement.prototype._updateState=function(){if(0==this._isSelected)ToggleButtonElement.base.prototype._updateState.call(this);else{var a="selectedUp";0==this.getStyle("Enabled")?a="selectedDisabled":1==this.getStyle("AllowDeselect")&&(1==this._mouseIsDown?a="selectedDown":1==this._mouseIsOver&&(a="selectedOver"));this.setStyle("SkinState",a)}};
ToggleButtonElement.prototype._onButtonClick=function(a){if(0==this.getStyle("Enabled"))a.cancelEvent();else if(0==this._isSelected||1==this.getStyle("AllowDeselect"))this._isSelected=!this._isSelected,this._updateState(),1==this.hasEventListener("changed",null)&&this._dispatchEvent(new ElementEvent("changed",!1))};
ToggleButtonElement.prototype._getSkinClass=function(a){if("selectedUp"==a)a=this.getStyleData("SelectedUpSkinClass");else if("selectedOver"==a)a=this.getStyleData("SelectedOverSkinClass");else if("selectedDown"==a)a=this.getStyleData("SelectedDownSkinClass");else if("selectedDisabled"==a)a=this.getStyleData("SelectedDisabledSkinClass");else return ToggleButtonElement.base.prototype._getSkinClass.call(this,a);var b=this.getStyleData("SkinClass");return 0<b.comparePriority(a)?b.value:a.value};
ToggleButtonElement.prototype._getSkinStyleDefinitions=function(a){return"selectedUp"==a?this.getStyle("SelectedUpSkinStyle"):"selectedOver"==a?this.getStyle("SelectedOverSkinStyle"):"selectedDown"==a?this.getStyle("SelectedDownSkinStyle"):"selectedDisabled"==a?this.getStyle("SelectedDisabledSkinStyle"):ToggleButtonElement.base.prototype._getSkinStyleDefinitions.call(this,a)};
ToggleButtonElement.prototype._getSkinStyleDefinitionDefault=function(a){return"selectedUp"==a?this._getDefaultStyle("SelectedUpSkinStyle"):"selectedOver"==a?this._getDefaultStyle("SelectedOverSkinStyle"):"selectedDown"==a?this._getDefaultStyle("SelectedDownSkinStyle"):"selectedDisabled"==a?this._getDefaultStyle("SelectedDisabledSkinStyle"):ToggleButtonElement.base.prototype._getSkinStyleDefinitionDefault.call(this,a)};
ToggleButtonElement.prototype._getTextColor=function(a){if("selectedUp"==a)a=this.getStyleData("SelectedUpTextColor");else if("selectedOver"==a)a=this.getStyleData("SelectedOverTextColor");else if("selectedDown"==a)a=this.getStyleData("SelectedDownTextColor");else if("selectedDisabled"==a)a=this.getStyleData("SelectedDisabledTextColor");else return ToggleButtonElement.base.prototype._getTextColor.call(this,a);var b=this.getStyleData("TextColor");return 0<b.comparePriority(a)?b.value:a.value};
ToggleButtonElement.prototype._doStylesUpdated=function(a){ToggleButtonElement.base.prototype._doStylesUpdated.call(this,a);this._updateSkinClass("selectedUp");this._updateSkinStyleDefinitions("selectedUp");this._updateSkinClass("selectedOver");this._updateSkinStyleDefinitions("selectedOver");this._updateSkinClass("selectedDown");this._updateSkinStyleDefinitions("selectedDown");this._updateSkinClass("selectedDisabled");this._updateSkinStyleDefinitions("selectedDisabled");"AllowDeselect"in a&&this._updateState()};
function ScrollBarElement(){ScrollBarElement.base.prototype.constructor.call(this);this._buttonTab=this._buttonTrack=this._buttonDecrement=this._buttonIncrement=null;this._scrollViewSize=this._scrollPageSize=0;this._scrollLineSize=1;this._scrollValue=0;this._scrollTween=null;var a=this;this._onScrollButtonClickInstance=function(b){a._onScrollButtonClick(b)};this._onScrollTabDragInstance=function(b){a._onScrollTabDrag(b)};this._onScrollBarEnterFrameInstance=function(b){a._onScrollBarEnterFrame(b)}}
ScrollBarElement.prototype=Object.create(CanvasElement.prototype);ScrollBarElement.prototype.constructor=ScrollBarElement;ScrollBarElement.base=CanvasElement;ScrollBarElement._StyleTypes=Object.create(null);ScrollBarElement._StyleTypes.ScrollBarDirection={inheritable:!1};ScrollBarElement._StyleTypes.ScrollTweenDuration={inheritable:!1};ScrollBarElement._StyleTypes.ScrollButtonIncrementStyle={inheritable:!1};ScrollBarElement._StyleTypes.ScrollButtonDecrementStyle={inheritable:!1};
ScrollBarElement._StyleTypes.ButtonTrackStyle={inheritable:!1};ScrollBarElement._StyleTypes.ButtonTabStyle={inheritable:!1};ScrollBarElement.StyleDefault=new StyleDefinition;ScrollBarElement.ButtonTrackStyleDefault=new StyleDefinition;ScrollBarElement.ButtonTrackStyleDefault.setStyle("BorderType","none");ScrollBarElement.ButtonTrackStyleDefault.setStyle("UpSkinStyle",ButtonElement.UpSkinStyleDefault);ScrollBarElement.ButtonTrackStyleDefault.setStyle("OverSkinStyle",ButtonElement.UpSkinStyleDefault);
ScrollBarElement.ButtonTrackStyleDefault.setStyle("DownSkinStyle",ButtonElement.UpSkinStyleDefault);ScrollBarElement.ButtonTrackStyleDefault.setStyle("DisabledSkinStyle",ButtonElement.DisabledSkinStyleDefault);ScrollBarElement.ButtonTabStyleDefault=new StyleDefinition;ScrollBarElement.ButtonTabStyleDefault.setStyle("UpSkinStyle",ButtonElement.UpSkinStyleDefault);ScrollBarElement.ButtonTabStyleDefault.setStyle("OverSkinStyle",ButtonElement.OverSkinStyleDefault);
ScrollBarElement.ButtonTabStyleDefault.setStyle("DownSkinStyle",ButtonElement.DownSkinStyleDefault);ScrollBarElement.ButtonTabStyleDefault.setStyle("DisabledSkinStyle",ButtonElement.DisabledSkinStyleDefault);ScrollBarElement.ButtonScrollArrowIncStyleDefault=new StyleDefinition;ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("SkinClass",ScrollButtonSkinElement);ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("ArrowColor","#000000");
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("UpSkinStyle",ButtonElement.UpSkinStyleDefault);ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("OverSkinStyle",ButtonElement.OverSkinStyleDefault);ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("DownSkinStyle",ButtonElement.DownSkinStyleDefault);ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("DisabledSkinStyle",ButtonElement.DisabledSkinStyleDefault);ScrollBarElement.ButtonScrollArrowDecStyleDefault=new StyleDefinition;
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("SkinClass",ScrollButtonSkinElement);ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("ArrowColor","#000000");ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("UpSkinStyle",ButtonElement.UpSkinStyleDefault);ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("OverSkinStyle",ButtonElement.OverSkinStyleDefault);ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("DownSkinStyle",ButtonElement.DownSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("DisabledSkinStyle",ButtonElement.DisabledSkinStyleDefault);ScrollBarElement.StyleDefault.setStyle("ScrollButtonIncrementStyle",ScrollBarElement.ButtonScrollArrowIncStyleDefault);ScrollBarElement.StyleDefault.setStyle("ScrollButtonDecrementStyle",ScrollBarElement.ButtonScrollArrowDecStyleDefault);ScrollBarElement.StyleDefault.setStyle("ButtonTrackStyle",ScrollBarElement.ButtonTrackStyleDefault);
ScrollBarElement.StyleDefault.setStyle("ButtonTabStyle",ScrollBarElement.ButtonTabStyleDefault);ScrollBarElement.StyleDefault.setStyle("ScrollTweenDuration",180);ScrollBarElement.StyleDefault.setStyle("ScrollBarDirection","vertical");ScrollBarElement.prototype.setScrollPageSize=function(a){this._scrollPageSize!=a&&(this._scrollPageSize=a,this._invalidateLayout())};ScrollBarElement.prototype.getScrollPageSize=function(){return this._scrollPageSize};
ScrollBarElement.prototype.setScrollViewSize=function(a){this._scrollViewSize!=a&&(this._scrollViewSize=a,this._invalidateLayout())};ScrollBarElement.prototype.getScrollViewSize=function(){return this._scrollViewSize};ScrollBarElement.prototype.setScrollLineSize=function(a){this._scrollLineSize=a};ScrollBarElement.prototype.getScrollLineSize=function(){return this._scrollLineSize};ScrollBarElement.prototype.setScrollValue=function(a){this._scrollValue!=a&&(this._scrollValue=a,this._invalidateLayout())};
ScrollBarElement.prototype.getScrollValue=function(){return this._scrollValue};
ScrollBarElement.prototype.startScrollTween=function(a){var b=this.getStyle("ScrollTweenDuration");0<b?null==this._scrollTween?(this._scrollTween=new Tween,this._scrollTween.startVal=this._scrollValue,this._scrollTween.endVal=a,this._scrollTween.duration=b,this._scrollTween.startTime=Date.now(),this._scrollTween.easingFunction=Tween.easeInOutSine,this.addEventListener("enterframe",this._onScrollBarEnterFrameInstance)):(this._scrollTween.startVal=this._scrollValue,this._scrollTween.endVal=a,this._scrollTween.startTime=
Date.now(),this._scrollTween.easingFunction=Tween.easeOutSine):(this.endScrollTween(),this.setScrollValue(a),this._dispatchEvent(new ElementEvent("changed",!1)))};ScrollBarElement.prototype.endScrollTween=function(){null!=this._scrollTween&&(this.setScrollValue(this._scrollTween.endVal),this.removeEventListener("enterframe",this._onScrollBarEnterFrameInstance),this._scrollTween=null)};ScrollBarElement.prototype.getTweenToValue=function(){return null==this._scrollTween?null:this._scrollTween.endVal};
ScrollBarElement.prototype._onScrollBarEnterFrame=function(a){a=this._scrollTween.getValue(Date.now());a==this._scrollTween.endVal?this.endScrollTween():this.setScrollValue(a);this._dispatchEvent(new ElementEvent("changed",!1))};ScrollBarElement.prototype._onCanvasElementRemoved=function(a){ScrollBarElement.base.prototype._onCanvasElementRemoved.call(this,a);this.endScrollTween()};
ScrollBarElement.prototype._onScrollButtonClick=function(a){var b=null,c=this._scrollValue;null!=this._scrollTween&&(c=this._scrollTween.endVal);c=Math.min(this._scrollPageSize-this._scrollViewSize,c);c=Math.max(0,c);a.getTarget()==this._buttonIncrement||a.getTarget()==this._buttonDecrement?(b=this.getScrollLineSize(),a.getTarget()==this._buttonDecrement&&(b*=-1)):a.getTarget()==this._buttonTrack&&(b=.75*this._scrollViewSize,"horizontal"==this.getStyle("ScrollBarDirection")?a.getX()<=this._buttonTab._x+
this._buttonTab._width/2&&(b*=-1):a.getY()<=this._buttonTab._y+this._buttonTab._height/2&&(b*=-1));a=Math.min(this._scrollPageSize-this._scrollViewSize,c+b);a=Math.max(0,a);a!=c&&this.startScrollTween(a)};
ScrollBarElement.prototype._onScrollTabDrag=function(a){var b,c,d;b=this.getStyle("ScrollBarDirection");a=this._scrollValue;"horizontal"==b?(c=this._buttonTrack._width,b=this._buttonTab._x-this._buttonTrack._x,d=this._buttonTab._width):(c=this._buttonTrack._height,b=this._buttonTab._y-this._buttonTrack._y,d=this._buttonTab._height);b>c-d&&(b=c-d);0>b&&(b=0);b/=(c-d)/(this._scrollPageSize-this._scrollViewSize);a!=b&&(this.setScrollValue(b),this._dispatchEvent(new ElementEvent("changed",!1)));this._invalidateLayout()};
ScrollBarElement.prototype._createChildren=function(){this._buttonIncrement=new ButtonElement;this._buttonIncrement._setStyleDefinitionDefault(this._getDefaultStyle("ScrollButtonIncrementStyle"));this._buttonIncrement.addEventListener("click",this._onScrollButtonClickInstance);this._addChild(this._buttonIncrement);this._buttonDecrement=new ButtonElement;this._buttonDecrement._setStyleDefinitionDefault(this._getDefaultStyle("ScrollButtonDecrementStyle"));this._buttonDecrement.addEventListener("click",
this._onScrollButtonClickInstance);this._addChild(this._buttonDecrement);this._buttonTrack=new ButtonElement;this._buttonTrack._setStyleDefinitionDefault(this._getDefaultStyle("ButtonTrackStyle"));this._buttonTrack.addEventListener("click",this._onScrollButtonClickInstance);this._addChild(this._buttonTrack);this._buttonTab=new ButtonElement;this._buttonTab._setStyleDefinitionDefault(this._getDefaultStyle("ButtonTabStyle"));this._buttonTab.setStyle("Draggable",!0);this._buttonTab.addEventListener("dragging",
this._onScrollTabDragInstance);this._addChild(this._buttonTab)};
ScrollBarElement.prototype._doStylesUpdated=function(a){ScrollBarElement.base.prototype._doStylesUpdated.call(this,a);null==this._buttonIncrement&&this._createChildren();"ScrollButtonIncrementStyle"in a&&this._buttonIncrement.setStyleDefinitions(this.getStyle("ScrollButtonIncrementStyle"));"ScrollButtonDecrementStyle"in a&&this._buttonDecrement.setStyleDefinitions(this.getStyle("ScrollButtonDecrementStyle"));"ButtonTrackStyle"in a&&this._buttonTrack.setStyleDefinitions(this.getStyle("ButtonTrackStyle"));"ButtonTabStyle"in
a&&this._buttonTab.setStyleDefinitions(this.getStyle("ButtonTabStyle"));"ScrollBarDirection"in a&&("horizontal"==this.getStyle("ScrollBarDirection")?(this._buttonIncrement.setStyle("ArrowDirection","right"),this._buttonDecrement.setStyle("ArrowDirection","left")):(this._buttonIncrement.setStyle("ArrowDirection","down"),this._buttonDecrement.setStyle("ArrowDirection","up")),this._invalidateMeasure(),this._invalidateLayout());"ScrollTweenDuration"in a&&0==this.getStyle("ScrollTweenDuration")&&this.endScrollTween()};
ScrollBarElement.prototype._doMeasure=function(a,b){var c=0;if("horizontal"==this.getStyle("ScrollBarDirection")){var d=this._buttonDecrement.getStyle("Height"),e=this._buttonIncrement.getStyle("Height"),f=this._buttonTrack.getStyle("Height"),g=this._buttonTab.getStyle("Height"),c=Math.max(c,d),c=Math.max(c,e),c=Math.max(c,f),c=Math.max(c,g);0==c&&(c=15);var f=this._buttonDecrement.getStyle("Width"),k=this._buttonIncrement.getStyle("Width"),d=this._buttonTab.getStyle("Width");null==f&&(f=c);null==
k&&(k=c);null==d&&(d=f+k);return{width:a+f+k+2*d,height:b+c}}f=this._buttonDecrement.getStyle("Width");k=this._buttonIncrement.getStyle("Width");e=this._buttonTrack.getStyle("Width");d=this._buttonTab.getStyle("Width");c=Math.max(c,f);c=Math.max(c,k);c=Math.max(c,e);c=Math.max(c,d);0==c&&(c=15);d=this._buttonDecrement.getStyle("Height");e=this._buttonIncrement.getStyle("Height");g=this._buttonTab.getStyle("Height");null==d&&(d=c);null==e&&(e=c);null==g&&(g=f+k);return{width:a+c,height:b+d+e+2*g}};
ScrollBarElement.prototype._doLayout=function(a){ScrollBarElement.base.prototype._doLayout.call(this,a);var b=this.getStyle("ScrollBarDirection");this._scrollValue=Math.min(this._scrollValue,this._scrollPageSize-this._scrollViewSize);this._scrollValue=Math.max(this._scrollValue,0);this._scrollViewSize>=this._scrollPageSize?(this._buttonIncrement.setStyle("Enabled",!1),this._buttonDecrement.setStyle("Enabled",!1),this._buttonTrack.setStyle("Enabled",!1),this._buttonTab.setStyle("Visible",!1)):(this._buttonIncrement.setStyle("Enabled",
!0),this._buttonDecrement.setStyle("Enabled",!0),this._buttonTrack.setStyle("Enabled",!0),this._buttonTab.setStyle("Visible",!0));var c=a.getX(),d=a.getY(),e=a.getWidth();a=a.getHeight();var f=this._buttonDecrement.getStyle("Width"),g=this._buttonDecrement.getStyle("Height"),k=this._buttonIncrement.getStyle("Width"),m=this._buttonIncrement.getStyle("Height"),l=this._buttonTab.getStyle("Width"),p=this._buttonTab.getStyle("Height");"horizontal"==b?(null==f&&(f=a),null==g&&(g=a),null==k&&(k=a),null==
m&&(m=a),b=this._buttonTrack.getStyle("Height"),null==b&&(b=a),this._buttonDecrement._setActualPosition(c,d+a/2-g/2),this._buttonDecrement._setActualSize(f,g),this._buttonIncrement._setActualPosition(c+e-k,d+a/2-m/2),this._buttonIncrement._setActualSize(k,m),this._buttonTrack._setActualPosition(c+f,d+a/2-b/2),this._buttonTrack._setActualSize(e-f-k,b),null==p&&(p=a),null==l&&(l=0<this._scrollPageSize?this._scrollViewSize/this._scrollPageSize*this._buttonTrack._width:0,l=Math.max(f+k,l)),k=this._buttonTrack._width-
l,k/=this._scrollPageSize-this._scrollViewSize,this._buttonTab._setActualPosition(c+f+this._scrollValue*k,d+a/2-p/2)):(null==f&&(f=e),null==g&&(g=e),null==k&&(k=e),null==m&&(m=e),b=this._buttonTrack.getStyle("Width"),null==b&&(b=e),this._buttonDecrement._setActualPosition(c+e/2-f/2,d),this._buttonDecrement._setActualSize(f,g),this._buttonIncrement._setActualPosition(c+e/2-k/2,d+a-m),this._buttonIncrement._setActualSize(k,m),this._buttonTrack._setActualPosition(c+e/2-b/2,d+g),this._buttonTrack._setActualSize(b,
a-g-m),null==l&&(l=e),null==p&&(p=0<this._scrollPageSize?this._scrollViewSize/this._scrollPageSize*this._buttonTrack._height:0,p=Math.max(g+m,p)),k=this._buttonTrack._height-p,k/=this._scrollPageSize-this._scrollViewSize,this._buttonTab._setActualPosition(c+e/2-l/2,d+g+this._scrollValue*k));this._buttonTab._setActualSize(l,p)};function RadioButtonElement(){RadioButtonElement.base.prototype.constructor.call(this)}RadioButtonElement.prototype=Object.create(ToggleButtonElement.prototype);
RadioButtonElement.prototype.constructor=RadioButtonElement;RadioButtonElement.base=ToggleButtonElement;RadioButtonElement._StyleTypes=Object.create(null);RadioButtonElement._StyleTypes.LabelPlacement={inheritable:!1};RadioButtonElement._StyleTypes.LabelGap={inheritable:!1};RadioButtonElement.StyleDefault=new StyleDefinition;RadioButtonElement.StyleDefault.setStyle("LabelPlacement","right");RadioButtonElement.StyleDefault.setStyle("LabelGap",5);
RadioButtonElement.StyleDefault.setStyle("AllowDeselect",!1);RadioButtonElement.StyleDefault.setStyle("PaddingTop",0);RadioButtonElement.StyleDefault.setStyle("PaddingBottom",0);RadioButtonElement.StyleDefault.setStyle("PaddingLeft",0);RadioButtonElement.StyleDefault.setStyle("PaddingRight",0);RadioButtonElement.StyleDefault.setStyle("TextAlign","left");RadioButtonElement.StyleDefault.setStyle("TextBaseline","middle");RadioButtonElement.StyleDefault.setStyle("SkinClass",RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("UpSkinClass",RadioButtonSkinElement);RadioButtonElement.StyleDefault.setStyle("OverSkinClass",RadioButtonSkinElement);RadioButtonElement.StyleDefault.setStyle("DownSkinClass",RadioButtonSkinElement);RadioButtonElement.StyleDefault.setStyle("DisabledSkinClass",RadioButtonSkinElement);RadioButtonElement.StyleDefault.setStyle("SelectedUpSkinClass",RadioButtonSkinElement);RadioButtonElement.StyleDefault.setStyle("SelectedOverSkinClass",RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("SelectedDownSkinClass",RadioButtonSkinElement);RadioButtonElement.StyleDefault.setStyle("SelectedDisabledSkinClass",RadioButtonSkinElement);RadioButtonElement.UpSkinStyleDefault=new StyleDefinition;RadioButtonElement.UpSkinStyleDefault.setStyle("BackgroundShape",new EllipseShape);RadioButtonElement.UpSkinStyleDefault.setStyle("BorderType","solid");RadioButtonElement.UpSkinStyleDefault.setStyle("BorderThickness",1);
RadioButtonElement.UpSkinStyleDefault.setStyle("BorderColor","#333333");RadioButtonElement.UpSkinStyleDefault.setStyle("BackgroundColor","#EBEBEB");RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientType","linear");RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStart",.05);RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStop",-.05);RadioButtonElement.UpSkinStyleDefault.setStyle("CheckColor","#000000");RadioButtonElement.OverSkinStyleDefault=new StyleDefinition;
RadioButtonElement.OverSkinStyleDefault.setStyle("BackgroundShape",new EllipseShape);RadioButtonElement.OverSkinStyleDefault.setStyle("BorderType","solid");RadioButtonElement.OverSkinStyleDefault.setStyle("BorderThickness",1);RadioButtonElement.OverSkinStyleDefault.setStyle("BorderColor","#333333");RadioButtonElement.OverSkinStyleDefault.setStyle("BackgroundColor","#DDDDDD");RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientType","linear");
RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStart",.05);RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStop",-.05);RadioButtonElement.OverSkinStyleDefault.setStyle("CheckColor","#000000");RadioButtonElement.DownSkinStyleDefault=new StyleDefinition;RadioButtonElement.DownSkinStyleDefault.setStyle("BackgroundShape",new EllipseShape);RadioButtonElement.DownSkinStyleDefault.setStyle("BorderType","solid");
RadioButtonElement.DownSkinStyleDefault.setStyle("BorderThickness",1);RadioButtonElement.DownSkinStyleDefault.setStyle("BorderColor","#333333");RadioButtonElement.DownSkinStyleDefault.setStyle("BackgroundColor","#CCCCCC");RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientType","linear");RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStart",-.06);RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStop",.02);
RadioButtonElement.DownSkinStyleDefault.setStyle("CheckColor","#000000");RadioButtonElement.DisabledSkinStyleDefault=new StyleDefinition;RadioButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundShape",new EllipseShape);RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderType","solid");RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderThickness",1);RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderColor","#999999");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundColor","#ECECEC");RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientType","linear");RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart",.05);RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop",-.05);RadioButtonElement.DisabledSkinStyleDefault.setStyle("CheckColor","#777777");RadioButtonElement.StyleDefault.setStyle("UpSkinStyle",RadioButtonElement.UpSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("OverSkinStyle",RadioButtonElement.OverSkinStyleDefault);RadioButtonElement.StyleDefault.setStyle("DownSkinStyle",RadioButtonElement.DownSkinStyleDefault);RadioButtonElement.StyleDefault.setStyle("DisabledSkinStyle",RadioButtonElement.DisabledSkinStyleDefault);RadioButtonElement.StyleDefault.setStyle("SelectedUpSkinStyle",RadioButtonElement.UpSkinStyleDefault);RadioButtonElement.StyleDefault.setStyle("SelectedOverSkinStyle",RadioButtonElement.OverSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("SelectedDownSkinStyle",RadioButtonElement.DownSkinStyleDefault);RadioButtonElement.StyleDefault.setStyle("SelectedDisabledSkinStyle",RadioButtonElement.DisabledSkinStyleDefault);
RadioButtonElement.prototype._doMeasure=function(a,b){var c={width:a,height:b};if(null!=this._labelElement){var d=this._labelElement._getStyledOrMeasuredWidth(),e=this._labelElement._getStyledOrMeasuredHeight();c.height=b+e;c.width=c.height+a+d+this.getStyle("LabelGap")}else c.height=b+14,c.width=a+14;return c};
RadioButtonElement.prototype._doLayout=function(a){if(null!=this._labelElement){var b=this.getStyle("LabelPlacement"),c=this.getStyle("LabelGap"),d;for(d in this._skins)this._skins[d]._setActualSize(this._height,this._height),"left"==b?this._skins[d]._setActualPosition(this._width-this._height,0):this._skins[d]._setActualPosition(0,0);"left"==b?this._labelElement._setActualPosition(a.getX(),a.getY()):this._labelElement._setActualPosition(this._height+c+a.getX(),a.getY());this._labelElement._setActualSize(a.getWidth()-
c-this._height,a.getHeight())}else for(d in this._skins)this._skins[d]._setActualSize(this._width,this._height),this._skins[d]._setActualPosition(0,0)};
function DropdownElement(){DropdownElement.base.prototype.constructor.call(this);this._arrowButton=this._listCollection=null;this._selectedIndex=-1;this._selectedItem=null;this._dataListPopupClipContainer=new CanvasElement;this._dataListPopupClipContainer.setStyle("ClipContent",!0);this._openCloseTween=this._sampledTextWidth=this._dropdownManagerMetrics=this._openHeight=this._openDirection=this._dataListPopup=null;var a=this;this._onDropdownListCollectionChangedInstance=function(b){a._onDropdownListCollectionChanged(b)};
this._onDropdownDataListPopupChangedInstance=function(b){a._onDropdownDataListPopupChanged(b)};this._onDropdownDataListPopupLayoutCompleteInstance=function(b){a._onDropdownDataListPopupLayoutComplete(b)};this._onDropdownManagerCaptureEventInstance=function(b){a._onDropdownManagerCaptureEvent(b)};this._onDropdownManagerResizeEventInstance=function(b){a._onDropdownManagerResizeEvent(b)};this._onDropDownEnterFrameInstance=function(b){a._onDropDownEnterFrame(b)}}DropdownElement.prototype=Object.create(ButtonElement.prototype);
DropdownElement.prototype.constructor=DropdownElement;DropdownElement.base=ButtonElement;DropdownElement._StyleTypes=Object.create(null);DropdownElement._StyleTypes.ItemLabelFunction={inheritable:!1};DropdownElement._StyleTypes.PopupDataListClass={inheritable:!1};DropdownElement._StyleTypes.PopupDataListStyle={inheritable:!1};DropdownElement._StyleTypes.MaxPopupHeight={inheritable:!1};DropdownElement._StyleTypes.ArrowButtonClass={inheritable:!1};DropdownElement._StyleTypes.ArrowButtonStyle={inheritable:!1};
DropdownElement._StyleTypes.OpenCloseTweenDuration={inheritable:!1};DropdownElement._StyleTypes.OpenCloseTweenEasingFunction={inheritable:!1};DropdownElement._StyleTypes.PopupDataListClipTopOrBottom={inheritable:!1};DropdownElement.ArrowButtonStyleDefault=new StyleDefinition;DropdownElement.ArrowButtonStyleDefault.setStyle("BorderType","none");DropdownElement.ArrowButtonStyleDefault.setStyle("BackgroundColor",null);DropdownElement.ArrowButtonStyleDefault.setStyle("SkinClass",DropdownArrowButtonSkinElement);
DropdownElement.ArrowButtonStyleDefault.setStyle("MouseEnabled",!1);DropdownElement.ArrowButtonStyleDefault.setStyle("UpSkinStyle",null);DropdownElement.ArrowButtonStyleDefault.setStyle("OverSkinStyle",null);DropdownElement.ArrowButtonStyleDefault.setStyle("DownSkinStyle",null);DropdownElement.ArrowButtonStyleDefault.setStyle("DisabledSkinStyle",null);DropdownElement.DataListScrollBarStyleDefault=new StyleDefinition;DropdownElement.DataListScrollBarStyleDefault.setStyle("Padding",-1);
DropdownElement.DataListItemStyleDefault=new StyleDefinition;DropdownElement.DataListItemStyleDefault.setStyle("UpSkinStyle",DataGridDataRenderer.UpSkinStyleDefault);DropdownElement.DataListItemStyleDefault.setStyle("AltSkinStyle",DataGridDataRenderer.AltSkinStyleDefault);DropdownElement.DataListStyleDefault=new StyleDefinition;DropdownElement.DataListStyleDefault.setStyle("ScrollBarStyle",DropdownElement.DataListScrollBarStyleDefault);
DropdownElement.DataListStyleDefault.setStyle("ListItemClass",DataRendererLabelElement);DropdownElement.DataListStyleDefault.setStyle("ListItemStyle",DropdownElement.DataListItemStyleDefault);DropdownElement.DataListStyleDefault.setStyle("BorderType","solid");DropdownElement.DataListStyleDefault.setStyle("BorderThickness",1);DropdownElement.DataListStyleDefault.setStyle("PaddingTop",1);DropdownElement.DataListStyleDefault.setStyle("PaddingBottom",1);
DropdownElement.DataListStyleDefault.setStyle("PaddingLeft",1);DropdownElement.DataListStyleDefault.setStyle("PaddingRight",1);DropdownElement.StyleDefault=new StyleDefinition;DropdownElement.StyleDefault.setStyle("PaddingTop",4);DropdownElement.StyleDefault.setStyle("PaddingBottom",4);DropdownElement.StyleDefault.setStyle("PaddingRight",4);DropdownElement.StyleDefault.setStyle("PaddingLeft",4);DropdownElement.StyleDefault.setStyle("PopupDataListClass",DataListElement);
DropdownElement.StyleDefault.setStyle("PopupDataListStyle",DropdownElement.DataListStyleDefault);DropdownElement.StyleDefault.setStyle("ArrowButtonClass",ButtonElement);DropdownElement.StyleDefault.setStyle("ArrowButtonStyle",DropdownElement.ArrowButtonStyleDefault);DropdownElement.StyleDefault.setStyle("TextAlign","left");DropdownElement.StyleDefault.setStyle("MaxPopupHeight",200);DropdownElement.StyleDefault.setStyle("OpenCloseTweenDuration",300);
DropdownElement.StyleDefault.setStyle("OpenCloseTweenEasingFunction",Tween.easeInOutSine);DropdownElement.StyleDefault.setStyle("PopupDataListClipTopOrBottom",1);DropdownElement.StyleDefault.setStyle("ItemLabelFunction",DataListElement.DefaultItemLabelFunction);DropdownElement._PopupDataListProxyMap=Object.create(null);DropdownElement._PopupDataListProxyMap.ItemLabelFunction=!0;DropdownElement._PopupDataListProxyMap._Arbitrary=!0;DropdownElement._ArrowButtonProxyMap=Object.create(null);
DropdownElement._ArrowButtonProxyMap.SkinState=!0;DropdownElement._ArrowButtonProxyMap._Arbitrary=!0;DropdownElement.prototype.setSelectedIndex=function(a){if(this._selectedIndex==a||null==this._listCollection||a>this._listCollection.length-1)return!1;-1>a&&(a=-1);null!=this._dataListPopup&&this._dataListPopup.setSelectedIndex(a);this._selectedIndex=a;this._selectedItem=this._listCollection.getItemAt(a);this._updateText();return!0};DropdownElement.prototype.getSelectedIndex=function(){return this._selectedIndex};
DropdownElement.prototype.setSelectedItem=function(a){a=this._listCollection.getItemIndex(a);this._setSelectedIndex(a)};DropdownElement.prototype.getSelectedItem=function(){return this._selectedItem};
DropdownElement.prototype.setListCollection=function(a){this._listCollection!=a&&(null==this._manager?this._listCollection=a:(null!=this._listCollection&&this._listCollection.removeEventListener("collectionchanged",this._onDropdownListCollectionChangedInstance),this._listCollection=a,null!=this._listCollection&&this._listCollection.addEventListener("collectionchanged",this._onDropdownListCollectionChangedInstance)),null==this._listCollection?(this._selectedIndex=-1,this._selectedItem=null):null!=
this._selectedItem&&(this._selectedIndex=this._listCollection.getItemIndex(this._selectedItem),-1==this._selectedIndex&&(this._selectedItem=null)),this._updateText(),this._sampledTextWidth=null,this._invalidateMeasure(),null!=this._dataListPopup&&this._dataListPopup.setListCollection(a))};
DropdownElement.prototype.open=function(a){if(null!=this._manager&&null!=this._listCollection&&0!=this._listCollection.getLength()){null==this._dataListPopup&&(this._dataListPopup=this._createDataListPopup(),this._dataListPopupClipContainer._addChild(this._dataListPopup));null==this._dropdownManagerMetrics&&(this._dropdownManagerMetrics=this.getMetrics(this._manager));this._addDataListPopup();var b=this.getStyle("OpenCloseTweenDuration");0==a||0>=b?null!=this._openCloseTween&&null!=this._openHeight&&
(this._endOpenCloseTween(),this._updateTweenPosition(this._openHeight)):null!=this._openCloseTween?0!=this._openCloseTween.startVal&&this._reverseTween():null==this._openHeight&&(this._openCloseTween=new Tween,this._openCloseTween.startVal=0,this._openCloseTween.endVal=null,this._openCloseTween.duration=b,this._openCloseTween.startTime=Date.now(),this._openCloseTween.easingFunction=this.getStyle("OpenCloseTweenEasingFunction"),this.addEventListener("enterframe",this._onDropDownEnterFrameInstance))}};
DropdownElement.prototype.close=function(a){var b=this.getStyle("OpenCloseTweenDuration");0==a||0>=b?(this._endOpenCloseTween(),this._removeDataListPopup()):null!=this._openCloseTween?0==this._openCloseTween.startVal&&this._reverseTween():null!=this._openHeight&&(this._openCloseTween=new Tween,this._openCloseTween.startVal=this._openHeight-this.getStyle("PopupDataListClipTopOrBottom"),this._openCloseTween.endVal=0,this._openCloseTween.duration=b,this._openCloseTween.startTime=Date.now(),this._openCloseTween.easingFunction=
this.getStyle("OpenCloseTweenEasingFunction"),this.addEventListener("enterframe",this._onDropDownEnterFrameInstance))};
DropdownElement.prototype._removeDataListPopup=function(){null!=this._dataListPopupClipContainer._parent&&(this._dataListPopupClipContainer._manager.removeCaptureListener("wheel",this._onDropdownManagerCaptureEventInstance),this._dataListPopupClipContainer._manager.removeCaptureListener("mousedown",this._onDropdownManagerCaptureEventInstance),this._dataListPopupClipContainer._manager.removeEventListener("resize",this._onDropdownManagerResizeEventInstance),this._dataListPopupClipContainer._manager.removeElement(this._dataListPopupClipContainer),
this._openHeight=this._openDirection=this._dropdownManagerMetrics=null)};
DropdownElement.prototype._addDataListPopup=function(){if(null==this._dataListPopupClipContainer._parent){var a=this.getStyle("MaxPopupHeight");this._dataListPopupClipContainer.setStyle("Width",this._dropdownManagerMetrics._width);this._dataListPopupClipContainer.setStyle("Height",a);this._dataListPopupClipContainer.setStyle("X",this._dropdownManagerMetrics._x);this._dataListPopupClipContainer.setStyle("Y",this._dropdownManagerMetrics._y+this._dropdownManagerMetrics._height);this._dataListPopup._setActualPosition(0,
0);this._dataListPopup._setActualSize(this._dropdownManagerMetrics._width,a);this._manager.addElement(this._dataListPopupClipContainer);this._dataListPopupClipContainer._manager.addCaptureListener("wheel",this._onDropdownManagerCaptureEventInstance);this._dataListPopupClipContainer._manager.addCaptureListener("mousedown",this._onDropdownManagerCaptureEventInstance);this._dataListPopupClipContainer._manager.addEventListener("resize",this._onDropdownManagerResizeEventInstance)}};
DropdownElement.prototype._onDropDownEnterFrame=function(a){null!=this._openCloseTween.endVal&&(a=this._openCloseTween.getValue(Date.now()),this._updateTweenPosition(a),a==this._openCloseTween.endVal&&(0==a?this.close(!1):this._endOpenCloseTween()))};DropdownElement.prototype._endOpenCloseTween=function(){null!=this._openCloseTween&&(this.removeEventListener("enterframe",this._onDropDownEnterFrameInstance),this._openCloseTween=null)};
DropdownElement.prototype._updateTweenPosition=function(a){this._dataListPopupClipContainer.setStyle("Height",a);"up"==this._openDirection?this._dataListPopupClipContainer.setStyle("Y",this._dropdownManagerMetrics._y-a):this._dataListPopup._setActualPosition(0,a-this._dataListPopup._height)};DropdownElement.prototype._onDropdownManagerCaptureEvent=function(a){for(var b=a.getTarget();null!=b;){if(b==this._dataListPopup||"mousedown"==a.getType()&&b==this)return;b=b._parent}this.close(!1)};
DropdownElement.prototype._onDropdownManagerResizeEvent=function(a){this.close(!1)};
DropdownElement.prototype._onDropdownDataListPopupLayoutComplete=function(a){a=this.getStyle("MaxPopupHeight");if("horizontal"!=this._dataListPopup.getStyle("ListDirection")){var b=this._dataListPopup._getContentSize();a=b<a?null!=this._listCollection&&this._dataListPopup._getNumRenderers()<this._listCollection.getLength()?a:b:a}b=this._manager._height-(this._dropdownManagerMetrics._y+this._dropdownManagerMetrics._height);if(b>=a)this._openDirection="down",this._openHeight=a;else{var c=this._dropdownManagerMetrics._y;
c>=a?(this._openDirection="up",this._openHeight=a):b>=c?(this._openDirection="down",this._openHeight=b):(this._openDirection="up",this._openHeight=c)}this._dataListPopup._setActualSize(this._dataListPopup._width,this._openHeight);this._dataListPopupClipContainer.setStyle("Height",this._openHeight);a=this.getStyle("PopupDataListClipTopOrBottom");null!=this._openCloseTween?(0==this._openCloseTween.startVal?this._openCloseTween.endVal=this._openHeight-a:this._openCloseTween.startVal=this._openHeight-
a,this._onDropDownEnterFrame(null)):this._updateTweenPosition(this._openHeight-a)};DropdownElement.prototype._onDropdownDataListPopupChanged=function(a){this.setSelectedIndex(this._dataListPopup.getSelectedIndex());this.close(!0);this._dispatchEvent(new ElementEvent("changed",!1))};
DropdownElement.prototype._createDataListPopup=function(){var a=new DataListElement;a._setStyleDefinitionDefault(this._getDefaultStyle("PopupDataListStyle"));a._setStyleProxy(new StyleProxy(this,DropdownElement._PopupDataListProxyMap));a.setStyleDefinitions(this.getStyle("PopupDataListStyle"));a.setListCollection(this._listCollection);a.setSelectedIndex(this._selectedIndex);a.addEventListener("changed",this._onDropdownDataListPopupChangedInstance);a.addEventListener("layoutcomplete",this._onDropdownDataListPopupLayoutCompleteInstance);
return a};
DropdownElement.prototype._updateText=function(){var a;a=this.getStyle("ItemLabelFunction");a=null==this._selectedItem||null==a?this.getStyle("Text"):a(this._selectedItem);null==a||""==a?null!=this._labelElement&&(this._removeChild(this._labelElement),this._labelElement=null):(null==this._labelElement&&(this._labelElement=this._createLabel(),null!=this._labelElement&&(this._updateTextColor(),this._addChild(this._labelElement))),null!=this._labelElement&&this._labelElement.setStyle("Text",a))};
DropdownElement.prototype._onDropdownListCollectionChanged=function(a){null!=this._selectedItem&&(this._selectedIndex=this._listCollection.getItemIndex(this._selectedItem),-1==this._selectedIndex&&(this._selectedItem=null));this._updateText();this._sampledTextWidth=null;this._invalidateMeasure()};
DropdownElement.prototype._onCanvasElementAdded=function(a){DropdownElement.base.prototype._onCanvasElementAdded.call(this,a);null!=this._listCollection&&0==this._listCollection.hasEventListener("collectionchanged",this._onDropdownListCollectionChangedInstance)&&this._listCollection.addEventListener("collectionchanged",this._onDropdownListCollectionChangedInstance)};
DropdownElement.prototype._onCanvasElementRemoved=function(a){DropdownElement.base.prototype._onCanvasElementRemoved.call(this,a);null!=this._listCollection&&1==this._listCollection.hasEventListener("collectionchanged",this._onDropdownListCollectionChangedInstance)&&this._listCollection.removeEventListener("collectionchanged",this._onDropdownListCollectionChangedInstance);this.close(!1)};
DropdownElement.prototype._reverseTween=function(){var a=this._openCloseTween.startVal,b=this._openCloseTween.endVal,c=Date.now(),d=c-this._openCloseTween.startTime;this._openCloseTween.startVal=b;this._openCloseTween.endVal=a;this._openCloseTween.startTime=c+d-this._openCloseTween.duration};
DropdownElement.prototype._onButtonClick=function(a){DropdownElement.base.prototype._onButtonClick.call(this,a);1!=a.getIsCanceled()&&(null!=this._openCloseTween?this._reverseTween():null==this._openHeight?this.open(!0):this.close(!0))};
DropdownElement.prototype._createArrowButton=function(a){a=new a;a._setStyleDefinitionDefault(this._getDefaultStyle("ArrowButtonStyle"));a._setStyleProxy(new StyleProxy(this,DropdownElement._ArrowButtonProxyMap));a.setStyleDefinitions(this.getStyle("ArrowButtonStyle"));return a};
DropdownElement.prototype._updateArrowButton=function(){var a=this.getStyle("ArrowButtonClass");null==a?null!=this._arrowButton&&(this._removeChild(this._arrowButton),this._arrowButton=null):null==this._arrowButton?(this._arrowButton=this._createArrowButton(a),this._addChild(this._arrowButton)):this._arrowButton.constructor!=a?(this._removeChild(this._arrowButton),this._arrowButton=this._createArrowButton(a),this._addChild(this._arrowButton)):this._arrowButton.setStyleDefinitions(this.getStyle("ArrowButtonStyle"))};
DropdownElement.prototype._doStylesUpdated=function(a){DropdownElement.base.prototype._doStylesUpdated.call(this,a);"ItemLabelFunction"in a&&(this._sampledTextWidth=null,this._invalidateMeasure(),this._updateText());"PopupDataListStyle"in a&&null!=this._dataListPopup&&this._dataListPopup.setStyleDefinitions(this.getStyle("PopupListStyle"));("ArrowButtonClass"in a||"ArrowButtonStyle"in a)&&this._updateArrowButton();if("TextStyle"in a||"TextFont"in a||"TextSize"in a||"TextAlign"in a||"TextBaseline"in
a||"Text"in a)this._sampledTextWidth=null,this._invalidateMeasure()};DropdownElement.prototype._sampleTextWidths=function(){var a=this._getFontString(),b=this.getStyle("Text");null==b&&(b="");var b=CanvasElement._measureText(b,a),c=this.getStyle("ItemLabelFunction");if(null!=this._listCollection&&null!=c)for(var d,e=0;10>e&&e!=this._listCollection.getLength();e++)d=CanvasElement._measureText(c(this._listCollection.getItemAt(e)),a),d>b&&(b=d);return b};
DropdownElement.prototype._doMeasure=function(a,b){null==this._sampledTextWidth&&(this._sampledTextWidth=this._sampleTextWidths());var c=this.getStyle("TextSize")+this.getStyle("TextLinePaddingTop")+this.getStyle("TextLinePaddingBottom"),c={width:this._sampledTextWidth+a,height:c+b};c.width+=20;if(null!=this._arrowButton){var d=this._arrowButton.getStyle("Width"),e=this._arrowButton.getStyle("Height");null!=e&&e>c.height&&(c.height=e);c.width=null!=d?c.width+d:c.width+Math.round(.85*c.height)}return c};
DropdownElement.prototype._doLayout=function(a){DropdownElement.base.prototype._doLayout.call(this,a);null!=this._openDirection&&(this._dropdownManagerMetrics=this.getMetrics(this._manager),this._dataListPopupClipContainer.setStyle("Width",this._dropdownManagerMetrics._width),this._dataListPopup._setActualSize(this._dropdownManagerMetrics._width,this._dataListPopup._height));if(null!=this._arrowButton){var b=a.getX(),c=a.getY(),d=a.getWidth();a=a.getHeight();var e=this._arrowButton.getStyle("Width"),
f=this._arrowButton.getStyle("Height");null==f&&(f=this._height);null==e&&(e=.85*this._height);this._width<e?(this._arrowButton._setActualSize(0,0),this._labelElement._setActualSize(0,0)):(null!=this._labelElement&&(this._labelElement._setActualPosition(b,c),this._labelElement._setActualSize(d-e,a)),this._arrowButton._setActualPosition(this._width-e,c+a/2-f/2),this._arrowButton._setActualSize(e,f))}};
function DataGridHeaderItemRenderer(){DataGridHeaderItemRenderer.base.prototype.constructor.call(this);this._currentSortDirection=this._sortDescIcon=this._sortAscIcon=null}DataGridHeaderItemRenderer.prototype=Object.create(ButtonElement.prototype);DataGridHeaderItemRenderer.prototype.constructor=DataGridHeaderItemRenderer;DataGridHeaderItemRenderer.base=ButtonElement;DataGridHeaderItemRenderer._StyleTypes=Object.create(null);DataGridHeaderItemRenderer._StyleTypes.SortAscIconClass={inheritable:!1};
DataGridHeaderItemRenderer._StyleTypes.SortAscIconStyle={inheritable:!1};DataGridHeaderItemRenderer._StyleTypes.SortDescIconClass={inheritable:!1};DataGridHeaderItemRenderer._StyleTypes.SortDescIconStyle={inheritable:!1};DataGridHeaderItemRenderer._StyleTypes.IconGap={inheritable:!1};DataGridHeaderItemRenderer._StyleTypes.IconPlacement={inheritable:!1};DataGridHeaderItemRenderer.StyleDefault=new StyleDefinition;DataGridHeaderItemRenderer.StyleDefault.setStyle("DisabledSkinStyle",ButtonElement.UpSkinStyleDefault);
DataGridHeaderItemRenderer.StyleDefault.setStyle("DisabledTextColor",null);DataGridHeaderItemRenderer.StyleDefault.setStyle("BorderType","none");DataGridHeaderItemRenderer.StyleDefault.setStyle("TextSize",12);DataGridHeaderItemRenderer.StyleDefault.setStyle("TextAlign","left");DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingTop",3);DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingBottom",3);DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingLeft",8);
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingRight",8);DataGridHeaderItemRenderer.SortAscIconBgShapeDefault=new ArrowShape;DataGridHeaderItemRenderer.SortAscIconBgShapeDefault.setStyle("Direction","up");DataGridHeaderItemRenderer.SortAscIconStyleDefault=new StyleDefinition;DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BorderType","none");DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BackgroundColor","#444444");
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BackgroundShape",DataGridHeaderItemRenderer.SortAscIconBgShapeDefault);DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("MouseEnabled",!1);DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("UpSkinStyle",null);DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("OverSkinStyle",null);DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("DownSkinStyle",null);
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("DisabledSkinStyle",null);DataGridHeaderItemRenderer.SortDescIconBgShapeDefault=new ArrowShape;DataGridHeaderItemRenderer.SortDescIconBgShapeDefault.setStyle("Direction","down");DataGridHeaderItemRenderer.SortDescIconStyleDefault=new StyleDefinition;DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BorderType","none");DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BackgroundColor","#444444");
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BackgroundShape",DataGridHeaderItemRenderer.SortDescIconBgShapeDefault);DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("MouseEnabled",!1);DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("UpSkinStyle",null);DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("OverSkinStyle",null);DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("DownSkinStyle",null);
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("DisabledSkinStyle",null);DataGridHeaderItemRenderer.StyleDefault.setStyle("SortAscIconClass",ButtonElement);DataGridHeaderItemRenderer.StyleDefault.setStyle("SortAscIconStyle",DataGridHeaderItemRenderer.SortAscIconStyleDefault);DataGridHeaderItemRenderer.StyleDefault.setStyle("SortDescIconClass",ButtonElement);DataGridHeaderItemRenderer.StyleDefault.setStyle("SortDescIconStyle",DataGridHeaderItemRenderer.SortDescIconStyleDefault);
DataGridHeaderItemRenderer.StyleDefault.setStyle("IconGap",3);DataGridHeaderItemRenderer.StyleDefault.setStyle("IconPlacement","right");DataGridHeaderItemRenderer._SortIconProxyMap=Object.create(null);DataGridHeaderItemRenderer._SortIconProxyMap.SkinState=!0;
DataGridHeaderItemRenderer.prototype._createSortIcon=function(a){var b,c;1==a?(b=this.getStyle("SortDescIconClass"),a=this._getDefaultStyle("SortDescIconStyle"),c=this.getStyle("SortDescIconStyle")):(b=this.getStyle("SortAscIconClass"),a=this._getDefaultStyle("SortAscIconStyle"),c=this.getStyle("SortAscIconStyle"));b=new b;b._setStyleDefinitionDefault(a);b._setStyleProxy(new StyleProxy(this,DataGridHeaderItemRenderer._SortIconProxyMap));b.setStyleDefinitions(c);return b};
DataGridHeaderItemRenderer.prototype._updateSortIcons=function(){if(null!=this._listData){var a=this._listData,b=a._parentGrid._listCollection,c=null;null!=b&&null!=b._collectionSort&&b._collectionSort==a._parentGrid._gridColumns[a._columnIndex].getStyle("CollectionSort")&&(c=1==b._collectionSort._isDecending?"down":"up");this._currentSortDirection!=c&&(this._currentSortDirection=c,this._invalidateLayout());null==c?(null!=this._sortAscIcon&&this._sortAscIcon.setStyle("Visible",!1),null!=this._sortDescIcon&&
this._sortDescIcon.setStyle("Visible",!1)):"up"==c?(a=this.getStyle("SortAscIconClass"),null==a?null!=this._sortAscIcon&&(this._removeChild(this._sortAscIcon),this._sortAscIcon=null):(null==this._sortAscIcon?(this._sortAscIcon=this._createSortIcon(!1),this._addChild(this._sortAscIcon)):this._sortAscIcon.constructor!=a?(this._removeChild(this._sortAscIcon),this._sortAscIcon=this._createSortIcon(!1),this._addChild(this._sortAscIcon)):this._sortAscIcon.setStyleDefinitions(this.getStyle("SortAscIconStyle")),
null!=this._sortDescIcon&&this._sortDescIcon.setStyle("Visible",!1),this._sortAscIcon.setStyle("Visible",!0))):"down"==c&&(a=this.getStyle("SortDescIconClass"),null==a?null!=this._sortDescIcon&&(this._removeChild(this._sortDescIcon),this._sortDescIcon=null):(null==this._sortDescIcon?(this._sortDescIcon=this._createSortIcon(!0),this._addChild(this._sortDescIcon)):this._sortDescIcon.constructor!=a?(this._removeChild(this._sortDescIcon),this._sortDescIcon=this._createSortIcon(!0),this._addChild(this._sortDescIcon)):
this._sortDescIcon.setStyleDefinitions(this.getStyle("SortDescIconStyle")),null!=this._sortAscIcon&&this._sortAscIcon.setStyle("Visible",!1),this._sortDescIcon.setStyle("Visible",!0)))}};DataGridHeaderItemRenderer.prototype._setListData=function(a,b){DataGridHeaderItemRenderer.base.prototype._setListData.call(this,a,b);null!=a&&(this.setStyle("Text",a._parentGrid._gridColumns[a._columnIndex].getStyle("HeaderLabel")),this._updateSortIcons())};
DataGridHeaderItemRenderer.prototype._doStylesUpdated=function(a){DataGridHeaderItemRenderer.base.prototype._doStylesUpdated.call(this,a);("SortAscIconClass"in a||"SortAscIconStyle"in a||"SortDescIconClass"in a||"SortDescIconStyle"in a)&&this._updateSortIcons();("IconGap"in a||"IconPlacement"in a)&&this._invalidateLayout()};
DataGridHeaderItemRenderer.prototype._doLayout=function(a){DataGridHeaderItemRenderer.base.prototype._doLayout.call(this,a);if(null!=this._labelElement&&null!=this._currentSortDirection){var b;b="up"==this._currentSortDirection?this._sortAscIcon:this._sortDescIcon;if(null!=b){var c=a.getX(),d=a.getY(),e=a.getWidth(),f=a.getHeight(),g=b.getStyle("Width"),k=b.getStyle("Height");null==k&&(k=.35*a.getHeight());null==g&&(g=1.5*k);e<g?(b._setActualSize(0,0),this._labelElement._setActualSize(0,0)):(a=this.getStyle("IconGap"),
"left"==this.getStyle("IconPlacement")?(this._labelElement._setActualPosition(c+g+a,d),this._labelElement._setActualSize(e-g-a,f),b._setActualPosition(c,d+f/2-k/2)):(this._labelElement._setActualPosition(c,d),this._labelElement._setActualSize(e-g-a,f),b._setActualPosition(c+e-g,d+f/2-k/2)),b._setActualSize(g,k))}}};function DataGridHeaderElement(){DataGridHeaderElement.base.prototype.constructor.call(this);var a=this;this._onColumnDividerDragInstance=function(b){a._onColumnDividerDrag(b)}}
DataGridHeaderElement.prototype=Object.create(DataGridDataRenderer.prototype);DataGridHeaderElement.prototype.constructor=DataGridHeaderElement;DataGridHeaderElement.base=DataGridDataRenderer;DataGridHeaderElement._StyleTypes=Object.create(null);DataGridHeaderElement._StyleTypes.ColumnDividerClass={inheritable:!1};DataGridHeaderElement._StyleTypes.ColumnDividerStyle={inheritable:!1};DataGridHeaderElement._StyleTypes.DraggableColumns={inheritable:!1};DataGridHeaderElement.StyleDefault=new StyleDefinition;
DataGridHeaderElement.StyleDefault.setStyle("BorderType","solid");DataGridHeaderElement.StyleDefault.setStyle("BorderThickness",1);DataGridHeaderElement.StyleDefault.setStyle("PaddingBottom",1);DataGridHeaderElement.ColumnDividerStyleDefault=new StyleDefinition;DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("SkinClass",DataGridHeaderColumnDividerSkinElement);DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("DividerLineColor","#777777");
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("DividerArrowColor","#444444");DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("BorderType","none");DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("BackgroundColor",null);DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("Width",11);DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("TabStop",-1);DataGridHeaderElement.StyleDefault.setStyle("ColumnDividerClass",ButtonElement);
DataGridHeaderElement.StyleDefault.setStyle("ColumnDividerStyle",DataGridHeaderElement.ColumnDividerStyleDefault);DataGridHeaderElement.StyleDefault.setStyle("DraggableColumns",!0);
DataGridHeaderElement.prototype._onColumnDividerDrag=function(a){if(null!=this._listData){var b=this._listData._parentList,c,d=0,e=0,f=0,g,k=[];for(g=0;g<b._gridColumns.length;g++)k.push({actualSize:b._columnSizes[g],percentSize:b._columnPercents[g],oldPercentSize:b._columnPercents[g],minSize:b._gridColumns[g].getStyle("MinSize"),minPercent:0}),e+=k[g].actualSize,f+=k[g].percentSize;for(g=0;g<k.length;g++)k[g].minPercent=k[g].minSize/e*f;var m;for(g=k.length;g<this._itemRenderersContainer._children.length;g++)if(c=
this._itemRenderersContainer._children[g],m=g-k.length,d+=k[m].actualSize,c==a.getCurrentTarget()){var l=d=Math.round(d-c._width/2),p=d;g=a=0;for(var q=[],n=m+1;n<k.length;n++)q.push(k[n]),a+=k[n].percentSize,g+=k[n].actualSize,p+=k[n].actualSize-k[m].minSize;for(n=m;0<=n;n--)l-=k[n].actualSize-k[n].minSize;n=c._x;n<l&&(n=l);n>p&&(n=p);c=0;d=n-d;g-=d;for(n=m;0<=n&&(k[n].actualSize+d<k[n].minSize?(d-=k[n].actualSize-k[n].minSize,k[n].actualSize=k[n].minSize):(k[n].actualSize+=d,d=0),k[n].percentSize=
k[n].actualSize/e*f,c+=k[n].percentSize-k[n].oldPercentSize,0!=d);n--);e=q.slice();for(f=!1;0==f;)for(f=!0,n=0;n<e.length;n++)if(m=e[n].oldPercentSize/a*c,e[n].oldPercentSize-m<e[n].minPercent){e[n].percentSize=e[n].minPercent;a-=e[n].minPercent;c-=e[n].oldPercentSize-e[n].percentSize;e.splice(n,1);f=!1;break}else e[n].percentSize=e[n].oldPercentSize-m;CanvasElement._calculateMinMaxPercentSizes(q,g);break}for(g=0;g<k.length;g++)b._columnSizes[g]=k[g].actualSize,b._columnPercents[g]=k[g].percentSize;
this._invalidateLayout();b._invalidateLayout();b._invalidateListRenderersLayout()}};
DataGridHeaderElement.prototype._doStylesUpdated=function(a){DataGridHeaderElement.base.prototype._doStylesUpdated.call(this,a);("ColumnDividerClass"in a||"ColumnDividerStyle"in a)&&this._setListData(this._listData,this._itemData);if("DraggableColumns"in a&&null!=this._listData){var b=this._listData._parentList;a=this.getStyle("DraggableColumns");for(var c,d=b._gridColumns.length;d<this._itemRenderersContainer._children.length;d++)b=this._itemRenderersContainer._children[d],b.setStyle("Draggable",
a),c=b.hasEventListener("dragging",this._onColumnDividerDragInstance),1==a&&0==c?b.addEventListener("dragging",this._onColumnDividerDragInstance):0==a&&1==c&&b.removeEventListener("dragging",this._onColumnDividerDragInstance),1==a?b.setStyle("Enabled",!0):b.setStyle("Enabled",!1)}};
DataGridHeaderElement.prototype._setListData=function(a,b){DataGridDataRenderer.base.prototype._setListData.call(this,a,b);if(null!=a){var c,d;for(c=0;c<a._parentList._gridColumns.length;c++)d=this._itemRenderersContainer._getChildAt(c),null==d?(d=a._parentList._createHeaderItemRenderer(c),this._itemRenderersContainer._addChildAt(d,c)):(columnDef=a._parentList._gridColumns[c],d.constructor!=columnDef.getStyle("HeaderItemClass")?(this._itemRenderersContainer._removeChildAt(c),d=a._parentList._createHeaderItemRenderer(c),
this._itemRenderersContainer._addChildAt(d,c)):a._parentList._updateHeaderItemRendererData(d,c));var e=this.getStyle("ColumnDividerClass"),f=this.getStyle("DraggableColumns"),g=a._parentList._gridColumns.length;for(null!=e&&(g=2*g-1);c<g;c++)d=this._itemRenderersContainer._getChildAt(c),null!=d&&d.constructor!=e&&(this._itemRenderersContainer._removeChildAt(c),d=null),null==d?(d=new e,d._setStyleDefinitionDefault(this._getDefaultStyle("ColumnDividerStyle")),d.setStyleDefinitions(this.getStyle("ColumnDividerStyle")),
d.setStyle("Draggable",f),1==f&&d.addEventListener("dragging",this._onColumnDividerDragInstance),this._itemRenderersContainer._addChildAt(d,c)):d.setStyleDefinitions(this.getStyle("ColumnDividerStyle"));for(;this._itemRenderersContainer._children.length>g;)this._itemRenderersContainer._removeChildAt(this._itemRenderersContainer._children.length-1);this._invalidateMeasure();this._invalidateLayout()}};
DataGridHeaderElement.prototype._doLayout=function(a){DataGridHeaderElement.base.prototype._doLayout.call(this,a);if(null!=this._listData){a=this._listData._parentList;for(var b,c=0,d,e=a._columnSizes.length;e<this._itemRenderersContainer._children.length;e++)b=this._itemRenderersContainer._children[e],d=a._columnSizes[e-a._columnSizes.length],c+=d,d=b.getStyle("Height"),null==d&&(d=Math.round(.7*this._itemRenderersContainer._height)),b._setActualSize(b._getStyledOrMeasuredWidth(),d),b._setActualPosition(c-
b._getStyledOrMeasuredWidth()/2,this._itemRenderersContainer._height/2-b._height/2)}};
function DataGridElement(){DataGridElement.base.prototype.constructor.call(this);this._gridColumns=[];this._columnSizes=[];this._columnPercents=[];this._gridHeader=null;this._gridLineContainer=new CanvasElement;this._gridLineContainer.setStyle("MouseEnabled",!1);this._gridLineContainer.setStyle("ClipContent",!0);this._addChild(this._gridLineContainer);var a=this;this._onDataGridColumnDefinitionChangedInstance=function(b){a._onDataGridColumnDefinitionChanged(b)};this._onDataGridRowItemClickInstance=
function(b){a._onDataGridRowItemClick(b)};this._onDataGridHeaderItemClickInstance=function(b){a._onDataGridHeaderItemClick(b)}}DataGridElement.prototype=Object.create(DataListElement.prototype);DataGridElement.prototype.constructor=DataGridElement;DataGridElement.base=DataListElement;DataGridElement._StyleTypes=Object.create(null);DataGridElement._StyleTypes.HeaderClass={inheritable:!1};DataGridElement._StyleTypes.HeaderStyle={inheritable:!1};DataGridElement._StyleTypes.GridLinesPriority={inheritable:!1};
DataGridElement._StyleTypes.VerticalGridLinesClass={inheritable:!1};DataGridElement._StyleTypes.VerticalGridLinesStyle={inheritable:!1};DataGridElement._StyleTypes.HorizontalGridLinesClass={inheritable:!1};DataGridElement._StyleTypes.HorizontalGridLinesStyle={inheritable:!1};DataGridElement.StyleDefault=new StyleDefinition;DataGridElement.GridLineStyleDefault=new StyleDefinition;DataGridElement.GridLineStyleDefault.setStyle("Width",1);DataGridElement.GridLineStyleDefault.setStyle("Height",1);
DataGridElement.GridLineStyleDefault.setStyle("BackgroundColor","#BBBBBB");DataGridElement.ScrollBarStyleDefault=new StyleDefinition;DataGridElement.ScrollBarStyleDefault.setStyle("Padding",-1);DataGridElement.StyleDefault.setStyle("ListItemClass",DataGridDataRenderer);DataGridElement.StyleDefault.setStyle("ListItemStyle",null);DataGridElement.StyleDefault.setStyle("BorderType","solid");DataGridElement.StyleDefault.setStyle("BorderThickness",1);DataGridElement.StyleDefault.setStyle("PaddingTop",1);
DataGridElement.StyleDefault.setStyle("PaddingBottom",1);DataGridElement.StyleDefault.setStyle("PaddingLeft",1);DataGridElement.StyleDefault.setStyle("PaddingRight",1);DataGridElement.StyleDefault.setStyle("ScrollBarStyle",DataGridElement.ScrollBarStyleDefault);DataGridElement.StyleDefault.setStyle("HeaderClass",DataGridHeaderElement);DataGridElement.StyleDefault.setStyle("HeaderStyle",null);DataGridElement.StyleDefault.setStyle("GridLinesPriority","vertical");
DataGridElement.StyleDefault.setStyle("VerticalGridLinesClass",CanvasElement);DataGridElement.StyleDefault.setStyle("VerticalGridLinesStyle",DataGridElement.GridLineStyleDefault);DataGridElement.StyleDefault.setStyle("HorizontalGridLinesClass",null);DataGridElement.StyleDefault.setStyle("HorizontalGridLinesStyle",DataGridElement.GridLineStyleDefault);DataGridElement.StyleDefault.setStyle("TabStop",0);DataGridElement.prototype.addColumnDefinition=function(a){return this.addColumnDefinitionAt(a,this._gridColumns.length)};
DataGridElement.prototype.addColumnDefinitionAt=function(a,b){if(!(a instanceof DataGridColumnDefinition))throw"Invalid DataGridColumnDefinition";this._gridColumns.splice(b,0,a);this._columnPercents.splice(b,0,a.getStyle("PercentSize"));null!=this._manager&&a.addEventListener("stylechanged",this._onDataGridColumnDefinitionChangedInstance);this._columnSizes=[];this._columnsChanged();return a};DataGridElement.prototype.getColumnDefinitionAt=function(a){return 0>a||a>=this._gridColumns.length?null:this._gridColumns[a]};
DataGridElement.prototype.removeColumnDefinition=function(a){return this.removeColumnDefinitionAt(this._gridColumns.indexOf(a))};DataGridElement.prototype.removeColumnDefinitionAt=function(a){if(0>a||a>=this._gridColumns.length)return null;var b=this._gridColumns.splice(a,1)[0];this._columnPercents.splice(a,1);null!=this._manager&&b.removeEventListener("stylechanged",this._onDataGridColumnDefinitionChangedInstance);this._columnSizes=[];this._columnsChanged();return b};
DataGridElement.prototype.getNumColumns=function(){return this._gridColumns.length};DataGridElement.prototype._onDataGridColumnDefinitionChanged=function(a){var b=a.getStyleName();"PercentSize"==b?(b=this._gridColumns.indexOf(a.getTarget()),this._columnPercents[b]=a.getNewValue(),this._columnSizes=[],this._invalidateLayout()):"MinSize"==b?(this._columnSizes=[],this._invalidateLayout()):this._columnsChanged()};
DataGridElement.prototype._columnsChanged=function(){null!=this._gridHeader&&this._gridHeader._setListData(this._gridHeader._listData,null);for(var a,b=0;b<this._contentPane._children.length;b++)a=this._contentPane._children[b],a._setListData(a._listData,a._itemData);this._invalidateLayout()};
DataGridElement.prototype._onDataListCollectionChanged=function(a){DataGridElement.base.prototype._onDataListCollectionChanged.call(this,a);"reset"==a.getKind()&&null!=this._gridHeader&&this._gridHeader._setListData(this._gridHeader._listData,null)};DataGridElement.prototype._onCanvasElementAdded=function(a){DataGridElement.base.prototype._onCanvasElementAdded.call(this,a);for(a=0;a<this._gridColumns.length;a++)this._gridColumns[a].addEventListener("stylechanged",this._onDataGridColumnDefinitionChangedInstance)};
DataGridElement.prototype._onCanvasElementRemoved=function(a){DataGridElement.base.prototype._onCanvasElementRemoved.call(this,a);for(a=0;a<this._gridColumns.length;a++)this._gridColumns[a].removeEventListener("stylechanged",this._onDataGridColumnDefinitionChangedInstance)};
DataGridElement.prototype._doStylesUpdated=function(a){DataGridElement.base.prototype._doStylesUpdated.call(this,a);if("HeaderClass"in a){var b=this.getStyle("HeaderClass");if(null==b&&null!=this._gridHeader||null!=this._gridHeader&&this._gridHeader.constructor!=b)this._removeChild(this._gridHeader),this._gridHeader=null;null!=b&&null==this._gridHeader&&(this._gridHeader=new b,this._gridHeader._setStyleDefinitionDefault(this._getDefaultStyle("HeaderStyle")),this._gridHeader._setListData(new DataListData(this,
-1),null),this._addChild(this._gridHeader));this._invalidateLayout()}"HeaderStyle"in a&&null!=this._gridHeader&&this._gridHeader.setStyleDefinitions(this.getStyle("HeaderStyle"));("GridLinesPriority"in a||"VerticalGridLinesClass"in a||"VerticalGridLinesStyle"in a||"HorizontalGridLinesClass"in a||"HorizontalGridLinesStyle"in a)&&this._invalidateLayout()};
DataGridElement.prototype._createRenderer=function(a){var b=new (this.getStyle("ListItemClass"));b._setStyleDefinitionDefault(this._getDefaultStyle("ListItemStyle"));b.setStyleDefinitions(this.getStyle("ListItemStyle"));this._updateRendererData(b,a);return b};
DataGridElement.prototype._createHeaderItemRenderer=function(a){var b=this._gridColumns[a],c=new (b.getStyle("HeaderItemClass"));c._setStyleDefinitionDefault(b._getDefaultStyle("HeaderItemStyle"));this._updateHeaderItemRendererData(c,a);c.addEventListener("click",this._onDataGridHeaderItemClickInstance);return c};
DataGridElement.prototype._updateHeaderItemRendererData=function(a,b){var c=this._gridColumns[b],d;d=null!=a._listData&&a._listData._columnIndex==b?a._listData:new DataGridItemData(this,-1,b);a.setStyleDefinitions(c.getStyle("HeaderItemStyle"));a._setListData(d,null)};
DataGridElement.prototype._onDataGridHeaderItemClick=function(a){a=a.getCurrentTarget()._listData._columnIndex;var b=this._gridColumns[a].getStyle("CollectionSort");null!=b&&b instanceof CollectionSort&&(this._listCollection._collectionSort!=b?(b._isDecending=!1,this._listCollection.setCollectionSort(b)):b._isDecending=!b._isDecending,this._listCollection.sort());this._dispatchEvent(new ElementGridItemClickEvent(-1,a,null))};
DataGridElement.prototype._createRowItemRenderer=function(a,b){var c=this._gridColumns[b],d=new (c.getStyle("RowItemClass"));d._setStyleDefinitionDefault(c._getDefaultStyle("RowItemStyle"));this._updateRowItemRendererData(d,a,b);d.addEventListener("click",this._onDataGridRowItemClickInstance);return d};
DataGridElement.prototype._updateRowItemRendererData=function(a,b,c){var d=this._gridColumns[c];c=null!=a._listData&&a._listData._columnIndex==c&&a._listData._itemIndex==b?a._listData:new DataGridItemData(this,b,c);a.setStyleDefinitions(d.getStyle("RowItemStyle"));a._setListData(c,this._listCollection.getItemAt(b))};
DataGridElement.prototype._onDataGridRowItemClick=function(a){var b=a.getCurrentTarget()._listData._itemIndex,c=a.getCurrentTarget()._listData._columnIndex;a=a.getCurrentTarget()._itemData;var d=!1;1==this.getStyle("Selectable")&&1==this.setSelectedIndex(b)&&(d=!0);this._dispatchEvent(new ElementGridItemClickEvent(b,c,a));1==d&&this._dispatchEvent(new ElementEvent("changed",!1))};DataGridElement.prototype._doMeasure=function(a,b){return{width:16,height:16}};
DataGridElement.prototype._createGridLine=function(a){"vertical"==a?(a=new (this.getStyle("VerticalGridLinesClass")),a._setStyleDefinitionDefault(this._getDefaultStyle("VerticalGridLinesStyle")),a.setStyleDefinitions(this.getStyle("VerticalGridLinesStyle"))):(a=new (this.getStyle("HorizontalGridLinesClass")),a._setStyleDefinitionDefault(this._getDefaultStyle("HorizontalGridLinesStyle")),a.setStyleDefinitions(this.getStyle("HorizontalGridLinesStyle")));return a};
DataGridElement.prototype._doLayout=function(a){if(null!=this._gridHeader){var b=this._gridHeader._getStyledOrMeasuredHeight(),c=new DrawMetrics;c._x=a._x;c._y=a._y+b;c._width=a._width;c._height=a._height-b;DataGridElement.base.prototype._doLayout.call(this,c)}else DataGridElement.base.prototype._doLayout.call(this,a);if(1!=this._layoutInvalid){null!=this._gridHeader&&(this._gridHeader._setActualPosition(this._contentPane._x,a.getY()),this._gridHeader._setActualSize(a.getWidth(),this._gridHeader._getStyledOrMeasuredHeight()));
b=!1;if(this._columnSizes.length!=this._gridColumns.length)b=!0;else{for(a=c=0;a<this._columnSizes.length;a++)c+=this._columnSizes[a];c!=this._contentPane._width&&(b=!0)}if(1==b){b=[];for(a=0;a<this._gridColumns.length;a++)b.push({percentSize:this._columnPercents[a],minSize:this._gridColumns[a].getStyle("MinSize")});CanvasElement._calculateMinMaxPercentSizes(b,this._contentPane._width);c=[];for(a=0;a<b.length;a++)c.push(b[a].actualSize);this._columnSizes=c;null!=this._gridHeader&&this._gridHeader._invalidateLayout();
this._invalidateListRenderersLayout()}this._gridLineContainer._setActualPosition(this._contentPane._x,this._contentPane._y);this._gridLineContainer._setActualSize(this._contentPane._width,this._contentPane._height);var d,b=0,e,f=!1;e=!1;for(var c=this.getStyle("GridLinesPriority"),g=this.getStyle("VerticalGridLinesClass"),k=this.getStyle("VerticalGridLinesStyle"),m=this.getStyle("HorizontalGridLinesClass"),l=this.getStyle("HorizontalGridLinesStyle");0==f||0==e;){if("horizontal"==c&&0==e||1==f&&0==
e){if(null!=m)for(a=0;a<this._contentPane._children.length;a++)e=this._contentPane._children[a],d=e._listData._itemIndex,0!=d&&(d=this._gridLineContainer._getChildAt(b),null==d?(d=this._createGridLine("horizontal"),this._gridLineContainer._addChildAt(d,b)):d.constructor!=m?(this._gridLineContainer._removeChildAt(b),d=this._createGridLine("horizontal"),this._gridLineContainer._addChildAt(d,b)):d.setStyleDefinitions(l),d._setActualSize(this._gridLineContainer._width,d.getStyle("Height")),d._setActualPosition(0,
e._y-d._height/2),b++);e=!0}if("vertical"==c&&0==f||1==e&&0==f){if(null!=g)for(a=f=0;a<this._columnSizes.length-1;a++)f+=this._columnSizes[a],d=this._gridLineContainer._getChildAt(b),null==d?(d=this._createGridLine("vertical"),this._gridLineContainer._addChildAt(d,b)):d.constructor!=g?(this._gridLineContainer._removeChildAt(b),d=this._createGridLine("vertical"),this._gridLineContainer._addChildAt(d,b)):d.setStyleDefinitions(k),d._setActualSize(d.getStyle("Width"),this._gridLineContainer._height),
d._setActualPosition(f-d._width/2,0),b++;f=!0}}for(;b<this._gridLineContainer._children.length;)this._gridLineContainer._removeChildAt(this._gridLineContainer._children.length-1)}};function DataGridColumnDefinition(){DataGridColumnDefinition.base.prototype.constructor.call(this)}DataGridColumnDefinition.prototype=Object.create(StyleableBase.prototype);DataGridColumnDefinition.prototype.constructor=DataGridColumnDefinition;DataGridColumnDefinition.base=StyleableBase;
DataGridColumnDefinition._StyleTypes=Object.create(null);DataGridColumnDefinition._StyleTypes.PercentSize={inheritable:!1};DataGridColumnDefinition._StyleTypes.MinSize={inheritable:!1};DataGridColumnDefinition._StyleTypes.HeaderLabel={inheritable:!1};DataGridColumnDefinition._StyleTypes.HeaderItemClass={inheritable:!1};DataGridColumnDefinition._StyleTypes.HeaderItemStyle={inheritable:!1};DataGridColumnDefinition._StyleTypes.CollectionSort={inheritable:!1};
DataGridColumnDefinition._StyleTypes.RowItemClass={inheritable:!1};DataGridColumnDefinition._StyleTypes.RowItemStyle={inheritable:!1};DataGridColumnDefinition._StyleTypes.RowItemLabelFunction={inheritable:!1};DataGridColumnDefinition.StyleDefault=new StyleDefinition;DataGridColumnDefinition.StyleDefault.setStyle("PercentSize",100);DataGridColumnDefinition.StyleDefault.setStyle("MinSize",12);DataGridColumnDefinition.StyleDefault.setStyle("HeaderLabel","");
DataGridColumnDefinition.StyleDefault.setStyle("HeaderItemClass",DataGridHeaderItemRenderer);DataGridColumnDefinition.StyleDefault.setStyle("HeaderItemStyle",null);DataGridColumnDefinition.StyleDefault.setStyle("CollectionSort",null);DataGridColumnDefinition.StyleDefault.setStyle("RowItemClass",DataGridLabelItemRenderer);DataGridColumnDefinition.StyleDefault.setStyle("RowItemStyle",null);DataGridColumnDefinition.StyleDefault.setStyle("RowItemLabelFunction",null);
function CheckboxElement(){CheckboxElement.base.prototype.constructor.call(this)}CheckboxElement.prototype=Object.create(RadioButtonElement.prototype);CheckboxElement.prototype.constructor=CheckboxElement;CheckboxElement.base=RadioButtonElement;CheckboxElement._StyleTypes=Object.create(null);CheckboxElement._StyleTypes.HalfSelectedUpSkinClass={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedUpSkinStyle={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedUpTextColor={inheritable:!1};
CheckboxElement._StyleTypes.HalfSelectedOverSkinClass={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedOverSkinStyle={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedOverTextColor={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedDownSkinClass={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedDownSkinStyle={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedDownTextColor={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedDisabledSkinClass={inheritable:!1};
CheckboxElement._StyleTypes.HalfSelectedDisabledSkinStyle={inheritable:!1};CheckboxElement._StyleTypes.HalfSelectedDisabledTextColor={inheritable:!1};CheckboxElement.StyleDefault=new StyleDefinition;CheckboxElement.StyleDefault.setStyle("AllowDeselect",!0);CheckboxElement.StyleDefault.setStyle("SkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("UpSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("OverSkinClass",CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("DownSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("DisabledSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("SelectedUpSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("SelectedOverSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("SelectedDownSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("SelectedDisabledSkinClass",CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("HalfSelectedUpSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("HalfSelectedOverSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("HalfSelectedDownSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledSkinClass",CheckboxSkinElement);CheckboxElement.StyleDefault.setStyle("HalfSelectedUpTextColor","#000000");CheckboxElement.StyleDefault.setStyle("HalfSelectedOverTextColor","#000000");
CheckboxElement.StyleDefault.setStyle("HalfSelectedDownTextColor","#000000");CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledTextColor","#888888");CheckboxElement.UpSkinStyleDefault=new StyleDefinition;CheckboxElement.UpSkinStyleDefault.setStyle("BorderType","solid");CheckboxElement.UpSkinStyleDefault.setStyle("BorderThickness",1);CheckboxElement.UpSkinStyleDefault.setStyle("BorderColor","#333333");CheckboxElement.UpSkinStyleDefault.setStyle("BackgroundColor","#EBEBEB");
CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientType","linear");CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientStart",.05);CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientStop",-.05);CheckboxElement.UpSkinStyleDefault.setStyle("CheckColor","#000000");CheckboxElement.OverSkinStyleDefault=new StyleDefinition;CheckboxElement.OverSkinStyleDefault.setStyle("BorderType","solid");CheckboxElement.OverSkinStyleDefault.setStyle("BorderThickness",1);
CheckboxElement.OverSkinStyleDefault.setStyle("BorderColor","#333333");CheckboxElement.OverSkinStyleDefault.setStyle("BackgroundColor","#DDDDDD");CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientType","linear");CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientStart",.05);CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientStop",-.05);CheckboxElement.OverSkinStyleDefault.setStyle("CheckColor","#000000");CheckboxElement.DownSkinStyleDefault=new StyleDefinition;
CheckboxElement.DownSkinStyleDefault.setStyle("BorderType","solid");CheckboxElement.DownSkinStyleDefault.setStyle("BorderThickness",1);CheckboxElement.DownSkinStyleDefault.setStyle("BorderColor","#333333");CheckboxElement.DownSkinStyleDefault.setStyle("BackgroundColor","#CCCCCC");CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientType","linear");CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientStart",-.06);CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientStop",.02);
CheckboxElement.DownSkinStyleDefault.setStyle("CheckColor","#000000");CheckboxElement.DisabledSkinStyleDefault=new StyleDefinition;CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderType","solid");CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderThickness",1);CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderColor","#999999");CheckboxElement.DisabledSkinStyleDefault.setStyle("BackgroundColor","#ECECEC");CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientType","linear");
CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart",.05);CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop",-.05);CheckboxElement.DisabledSkinStyleDefault.setStyle("CheckColor","#777777");CheckboxElement.StyleDefault.setStyle("UpSkinStyle",CheckboxElement.UpSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("OverSkinStyle",CheckboxElement.OverSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("DownSkinStyle",CheckboxElement.DownSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("DisabledSkinStyle",CheckboxElement.DisabledSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("SelectedUpSkinStyle",CheckboxElement.UpSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("SelectedOverSkinStyle",CheckboxElement.OverSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("SelectedDownSkinStyle",CheckboxElement.DownSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("SelectedDisabledSkinStyle",CheckboxElement.DisabledSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("HalfSelectedUpSkinStyle",CheckboxElement.UpSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("HalfSelectedOverSkinStyle",CheckboxElement.OverSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("HalfSelectedDownSkinStyle",CheckboxElement.DownSkinStyleDefault);CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledSkinStyle",CheckboxElement.DisabledSkinStyleDefault);
CheckboxElement.prototype.setSelected=function(a){CheckboxElement.base.prototype.setSelected.call(this,a)};CheckboxElement.prototype._updateState=function(){if(2==this.getStyle("Selected")){var a="halfSelectedUp";0==this.getStyle("Enabled")?a="halfSelectedDisabled":1==this._mouseIsDown?a="halfSelectedDown":1==this._mouseIsOver&&(a="halfSelectedOver");this.setStyle("SkinState",a)}else CheckboxElement.base.prototype._updateState.call(this)};
CheckboxElement.prototype._getSkinClass=function(a){if("halfSelectedUp"==a)a=this.getStyleData("HalfSelectedUpSkinClass");else if("halfSelectedOver"==a)a=this.getStyleData("HalfSelectedOverSkinClass");else if("halfSelectedDown"==a)a=this.getStyleData("HalfSelectedDownSkinClass");else if("halfSelectedDisabled"==a)a=this.getStyleData("HalfSelectedDisabledSkinClass");else return CheckboxElement.base.prototype._getSkinClass.call(this,a);var b=this.getStyleData("SkinClass");return 0<b.comparePriority(a)?
b.value:a.value};CheckboxElement.prototype._getSkinStyleDefinitions=function(a){return"halfSelectedUp"==a?this.getStyle("HalfSelectedUpSkinStyle"):"halfSelectedOver"==a?this.getStyle("HalfSelectedOverSkinStyle"):"halfSelectedDown"==a?this.getStyle("HalfSelectedDownSkinStyle"):"halfSelectedDisabled"==a?this.getStyle("HalfSelectedDisabledSkinStyle"):CheckboxElement.base.prototype._getSkinStyleDefinitions.call(this,a)};
CheckboxElement.prototype._getSkinStyleDefinitionDefault=function(a){return"halfSelectedUp"==a?this._getDefaultStyle("HalfSelectedUpSkinStyle"):"halfSelectedOver"==a?this._getDefaultStyle("HalfSelectedOverSkinStyle"):"halfSelectedDown"==a?this._getDefaultStyle("HalfSelectedDownSkinStyle"):"halfSelectedDisabled"==a?this._getDefaultStyle("HalfSelectedDisabledSkinStyle"):CheckboxElement.base.prototype._getSkinStyleDefinitionDefault.call(this,a)};
CheckboxElement.prototype._getTextColor=function(a){if("halfSelectedUp"==a)a=this.getStyleData("HalfSelectedUpTextColor");else if("halfSelectedOver"==a)a=this.getStyleData("HalfSelectedOverTextColor");else if("halfSelectedDown"==a)a=this.getStyleData("HalfSelectedDownTextColor");else if("halfSelectedDisabled"==a)a=this.getStyleData("HalfSelectedDisabledTextColor");else return CheckboxElement.base.prototype._getTextColor.call(this,a);var b=this.getStyleData("TextColor");return 0<b.comparePriority(a)?
b.value:a.value};CheckboxElement.prototype._doStylesUpdated=function(a){CheckboxElement.base.prototype._doStylesUpdated.call(this,a);this._updateSkinClass("halfSelectedUp");this._updateSkinStyleDefinitions("halfSelectedUp");this._updateSkinClass("halfSelectedOver");this._updateSkinStyleDefinitions("halfSelectedOver");this._updateSkinClass("halfSelectedDown");this._updateSkinStyleDefinitions("halfSelectedDown");this._updateSkinClass("HalfSelectedDisabled");this._updateSkinStyleDefinitions("halfSelectedDisabled")};
function AnchorContainerElement(){AnchorContainerElement.base.prototype.constructor.call(this)}AnchorContainerElement.prototype=Object.create(ContainerBaseElement.prototype);AnchorContainerElement.prototype.constructor=AnchorContainerElement;AnchorContainerElement.base=ContainerBaseElement;
AnchorContainerElement.prototype._doMeasure=function(a,b){for(var c={width:0,height:0},d,e,f,g,k,m,l,p,q,n,r,v,t,u,y,z,x,B,A,F,G,E=0;E<this._elements.length;E++)if(d=this._elements[E],0!=d.getStyle("IncludeInLayout")){var C=0,D=0;e=d.getStyle("X");f=d.getStyle("Y");v=d.getStyle("Top");t=d.getStyle("Left");u=d.getStyle("Bottom");y=d.getStyle("Right");g=d.getStyle("Width");k=d.getStyle("Height");p=d.getStyle("MinWidth");q=d.getStyle("MinHeight");n=d.getStyle("MaxWidth");r=d.getStyle("MaxHeight");z=
d.getStyle("HorizontalCenter");x=d.getStyle("VerticalCenter");B=d.getStyle("RotateDegrees");m=d.getStyle("RotateCenterX");l=d.getStyle("RotateCenterY");null==p&&(p=0);null==q&&(q=0);null==n&&(n=Number.MAX_VALUE);null==r&&(r=Number.MAX_VALUE);0!=B?(null==g&&(g=d._measuredWidth,g=Math.min(g,n),g=Math.max(g,p)),null==k&&(k=d._measuredHeight,k=Math.min(k,r),k=Math.max(k,q)),p=d._x,q=d._y,n=d._width,r=d._height,A=d._rotateDegrees,F=d._rotateCenterX,G=d._rotateCenterY,d._x=null==e?0:e,d._y=null==f?0:f,
d._width=g,d._height=k,d._rotateDegrees=B,d._rotateCenterX=null==m?0:m,d._rotateCenterY=null==l?0:l,g=d.getMetrics(this),d._x=p,d._y=q,d._width=n,d._height=r,d._rotateDegrees=A,d._rotateCenterX=F,d._rotateCenterY=G,null!=m&&null!=l?(e=Math.max(g.getX(),0),f=Math.max(g.getY(),0)):(null==e&&(e=t),null==f&&(f=v),null==e&&null!=y&&(C+=y),null==f&&null!=u&&(D+=u)),C+=Math.ceil(g.getWidth()),D+=Math.ceil(g.getHeight())):(null==e&&(e=t),null==f&&(f=v),m=d.getStyle("PercentWidth"),l=d.getStyle("PercentHeight"),
null!=g&&null!=e||null==y||(C+=y),null!=k&&null!=f||null==u||(D+=u),null==g&&(null!=m||null!=t&&null!=y?g=p:(g=d._measuredWidth,g=Math.min(g,n),g=Math.max(g,p))),null==k&&(null!=l||null!=v&&null!=u?k=q:(k=d._measuredHeight,k=Math.min(k,r),k=Math.max(k,q))),C+=g,D+=k);null==e&&null==y&&null!=z&&(C+=Math.abs(2*z));null==f&&null==u&&null!=x&&(D+=Math.abs(2*x));if(null==e||0>e)e=0;if(null==f||0>f)f=0;C+=e;D+=f;c.width=Math.max(c.width,Math.ceil(C));c.height=Math.max(c.height,Math.ceil(D))}return c};
AnchorContainerElement.prototype._doLayout=function(a){AnchorContainerElement.base.prototype._doLayout.call(this,a);for(var b,c,d,e,f,g,k,m,l,p,q,n,r,v,t,u,y,z=0;z<this._elements.length;z++)if(a=this._elements[z],0!=a.getStyle("IncludeInLayout"))if(b=a.getStyle("X"),c=a.getStyle("Y"),q=a.getStyle("Top"),n=a.getStyle("Left"),r=a.getStyle("Bottom"),v=a.getStyle("Right"),d=a.getStyle("Width"),e=a.getStyle("Height"),k=a.getStyle("MinWidth"),l=a.getStyle("MinHeight"),m=a.getStyle("MaxWidth"),p=a.getStyle("MaxHeight"),
t=a.getStyle("HorizontalCenter"),u=a.getStyle("VerticalCenter"),f=a.getStyle("RotateDegrees"),g=a.getStyle("RotateCenterX"),y=a.getStyle("RotateCenterY"),null==k&&(k=0),null==l&&(l=0),null==m&&(m=Number.MAX_VALUE),null==p&&(p=Number.MAX_VALUE),a._setActualRotation(f,g,y),0!=f)if(null==d&&(d=a._measuredWidth,d=Math.min(d,m),d=Math.max(d,k)),null==e&&(e=a._measuredHeight,e=Math.min(e,p),e=Math.max(e,l)),a._setActualSize(d,e),null==g||null==y){null==b&&(b=n);null==c&&(c=q);if(null==b||null==c)e=a.getMetrics(this),
d=Math.ceil(e.getWidth()),e=Math.ceil(e.getHeight()),null==b&&null!=v&&(b=this._width-d-v),null==c&&null!=r&&(c=this._height-e-r),null==b&&null!=t&&(b=Math.round(this._width/2-d/2+t)),null==c&&null!=u&&(c=Math.round(this._height/2-e/2+u));null==b&&(b=0);null==c&&(c=0);a._setRelativePosition(b,c,this)}else null==b&&(b=0),null==c&&(c=0),a._setActualPosition(b,c);else f=a.getStyle("PercentWidth"),g=a.getStyle("PercentHeight"),null==b&&(b=n),null==c&&(c=q),null==d&&(d=null!=b&&null!=v?this._width-b-v:
null!=f?Math.round(f/100*this._width):a._measuredWidth,d=Math.min(d,m),d=Math.max(d,k)),null==e&&(e=null!=c&&null!=r?this._height-c-r:null!=g?Math.round(g/100*this._height):a._measuredHeight,e=Math.min(e,p),e=Math.max(e,l)),null==b&&null!=v&&(b=this._width-d-v),null==c&&null!=r&&(c=this._height-e-r),null==b&&null!=t&&(b=Math.round(this._width/2-d/2+t)),null==c&&null!=u&&(c=Math.round(this._height/2-e/2+u)),null==b&&(b=0),null==c&&(c=0),a._setActualPosition(b,c),a._setActualSize(d,e)};
function ViewportElement(){ViewportElement.base.prototype.constructor.call(this);this._verticalScrollBar=this._horizontalScrollBar=this._viewElement=null;this._viewPortContainer=new ViewportAnchorContainerElement;this._addChild(this._viewPortContainer);var a=this;this._onViewportScrollBarChangeInstance=function(b){a._onViewportScrollBarChange(b)};this._onViewportMouseWheelEventInstance=function(b){a._onViewportMouseWheelEvent(b)};this.addEventListener("wheel",this._onViewportMouseWheelEventInstance)}
ViewportElement.prototype=Object.create(CanvasElement.prototype);ViewportElement.prototype.constructor=ViewportElement;ViewportElement.base=CanvasElement;ViewportElement._StyleTypes=Object.create(null);ViewportElement._StyleTypes.HorizontalScrollBarDisplay={inheritable:!1};ViewportElement._StyleTypes.HorizontalScrollBarPlacement={inheritable:!1};ViewportElement._StyleTypes.VerticalScrollBarDisplay={inheritable:!1};ViewportElement._StyleTypes.VerticalScrollBarPlacement={inheritable:!1};
ViewportElement._StyleTypes.HorizontalScrollBarStyle={inheritable:!1};ViewportElement._StyleTypes.VerticalScrollBarStyle={inheritable:!1};ViewportElement.StyleDefault=new StyleDefinition;ViewportElement.StyleDefault.setStyle("HorizontalScrollBarDisplay","auto");ViewportElement.StyleDefault.setStyle("HorizontalScrollBarPlacement","bottom");ViewportElement.StyleDefault.setStyle("VerticalScrollBarDisplay","auto");ViewportElement.StyleDefault.setStyle("VerticalScrollBarPlacement","right");
ViewportElement.StyleDefault.setStyle("HorizontalScrollBarStyle",null);ViewportElement.StyleDefault.setStyle("VerticalScrollBarStyle",null);ViewportElement.prototype.setElement=function(a){null!=this._viewElement&&this._viewPortContainer.removeElement(this._viewElement);this._viewElement=a;null!=this._viewElement&&this._viewPortContainer.addElement(this._viewElement);this._invalidateLayout()};ViewportElement.prototype._onViewportScrollBarChange=function(a){this._invalidateLayout()};
ViewportElement.prototype._onViewportMouseWheelEvent=function(a){if(1!=a.getDefaultPrevented()){var b=!1,c,d,e,f=a.getDeltaX(),g=a.getDeltaY();0!=f&&null!=this._horizontalScrollBar&&(c=this._horizontalScrollBar.getScrollPageSize(),d=this._horizontalScrollBar.getScrollViewSize(),e=this._horizontalScrollBar.getScrollLineSize(),d=c-d,0<d&&(c=this._horizontalScrollBar.getTweenToValue(),null==c&&(c=this._horizontalScrollBar.getScrollValue()),0>f&&0<c?(this._horizontalScrollBar.startScrollTween(Math.max(c+
3*f*e,0)),b=!0):0<f&&c<d&&(this._horizontalScrollBar.startScrollTween(Math.min(c+3*f*e,d)),b=!0)));0!=g&&null!=this._verticalScrollBar&&(c=this._verticalScrollBar.getScrollPageSize(),d=this._verticalScrollBar.getScrollViewSize(),e=this._verticalScrollBar.getScrollLineSize(),d=c-d,0<d&&(c=this._verticalScrollBar.getTweenToValue(),null==c&&(c=this._verticalScrollBar.getScrollValue()),0>g&&0<c?(this._verticalScrollBar.startScrollTween(Math.max(c+3*g*e,0)),b=!0):0<g&&c<d&&(this._verticalScrollBar.startScrollTween(Math.min(c+
3*g*e,d)),b=!0)));1==b&&(a.preventDefault(),this._invalidateLayout())}};
ViewportElement.prototype._doStylesUpdated=function(a){ViewportElement.base.prototype._doStylesUpdated.call(this,a);"HorizontalScrollBarDisplay"in a||"VerticalScrollBarDisplay"in a?(this._invalidateLayout(),this._invalidateMeasure()):("HorizontalScrollBarPlacement"in a||"VerticalScrollBarPlacement"in a)&&this._invalidateLayout();null!=this._horizontalScrollBar&&this._horizontalScrollBar.setStyleDefinitions(this.getStyle("HorizontalScrollBarStyle"));null!=this._verticalScrollBar&&this._verticalScrollBar.setStyleDefinitions(this.getStyle("VerticalScrollBarStyle"))};
ViewportElement.prototype._doMeasure=function(a,b){var c=0,d=0,e=0,f=0;null!=this._verticalScrollBar&&(c=this._verticalScrollBar._getStyledOrMeasuredWidth(),d=this._verticalScrollBar._getStyledOrMeasuredHeight());null!=this._horizontalScrollBar&&(e=this._horizontalScrollBar._getStyledOrMeasuredWidth(),f=this._horizontalScrollBar._getStyledOrMeasuredHeight());return{width:Math.max(c,e)+a,height:Math.max(d,f)+b}};
ViewportElement.prototype._doLayout=function(a){var b=this.getStyle("HorizontalScrollBarDisplay"),c=this.getStyle("VerticalScrollBarDisplay"),d=a.getWidth(),e=a.getHeight(),f=0,g=0;null!=this._viewElement&&(f=this._viewElement._getStyledOrMeasuredWidth(),g=this._viewElement._getStyledOrMeasuredHeight());var k=!1,m=!1,l=!1;if("on"==b||"auto"==b&&f>d)m=!0;if("on"==c||"auto"==c&&g>e)l=!0;1==m&&0==l&&"auto"==c&&null!=this._horizontalScrollBar&&g>e-this._horizontalScrollBar._getStyledOrMeasuredHeight()&&
(l=!0);1==l&&0==m&&"auto"==b&&null!=this._verticalScrollBar&&f>d-this._verticalScrollBar._getStyledOrMeasuredWidth()&&(m=!0);0==m?null!=this._horizontalScrollBar&&(this._removeChild(this._horizontalScrollBar),this._horizontalScrollBar=null,k=!0):null==this._horizontalScrollBar&&(this._horizontalScrollBar=new ScrollBarElement,this._horizontalScrollBar._setStyleDefinitionDefault(this._getDefaultStyle("HorizontalScrollBarStyle")),this._horizontalScrollBar.setStyleDefinitions(this.getStyle("HorizontalScrollBarStyle")),
this._horizontalScrollBar.setStyle("ScrollBarDirection","horizontal"),this._horizontalScrollBar.setScrollLineSize(25),this._horizontalScrollBar.addEventListener("changed",this._onViewportScrollBarChangeInstance),this._addChild(this._horizontalScrollBar),k=!0);0==l?null!=this._verticalScrollBar&&(this._removeChild(this._verticalScrollBar),this._verticalScrollBar=null,k=!0):null==this._verticalScrollBar&&(this._verticalScrollBar=new ScrollBarElement,this._verticalScrollBar._setStyleDefinitionDefault(this._getDefaultStyle("VerticalScrollBarStyle")),
this._verticalScrollBar.setStyleDefinitions(this.getStyle("VerticalScrollBarStyle")),this._verticalScrollBar.setStyle("ScrollBarDirection","vertical"),this._verticalScrollBar.setScrollLineSize(25),this._verticalScrollBar.addEventListener("changed",this._onViewportScrollBarChangeInstance),this._addChild(this._verticalScrollBar),k=!0);if(1!=k){m=k=c=b=0;null!=this._horizontalScrollBar&&(k=this._horizontalScrollBar.getScrollValue(),b=this._horizontalScrollBar._getStyledOrMeasuredHeight(),e-=b);null!=
this._verticalScrollBar&&(m=this._verticalScrollBar.getScrollValue(),c=this._verticalScrollBar._getStyledOrMeasuredWidth(),d-=c);k=Math.min(k,f-d);k=Math.max(k,0);m=Math.min(m,g-e);m=Math.max(m,0);d<f||e<g?this._viewPortContainer.setStyle("ClipContent",!0):this._viewPortContainer.setStyle("ClipContent",!1);var l=this.getStyle("HorizontalScrollBarPlacement"),p=this.getStyle("VerticalScrollBarPlacement"),q=a.getX();a=a.getY();null!=this._horizontalScrollBar&&(this._horizontalScrollBar.setScrollPageSize(f),
this._horizontalScrollBar.setScrollViewSize(d),this._horizontalScrollBar.setScrollValue(k),this._horizontalScrollBar._setActualSize(d,b),"top"==l?"left"==p?this._horizontalScrollBar._setActualPosition(q+c,a):this._horizontalScrollBar._setActualPosition(q,a):"left"==p?this._horizontalScrollBar._setActualPosition(q+c,a+e):this._horizontalScrollBar._setActualPosition(q,a+e));null!=this._verticalScrollBar&&(this._verticalScrollBar.setScrollPageSize(g),this._verticalScrollBar.setScrollViewSize(e),this._verticalScrollBar.setScrollValue(m),
this._verticalScrollBar._setActualSize(c,e),"left"==p?"top"==l?this._verticalScrollBar._setActualPosition(q,a+b):this._verticalScrollBar._setActualPosition(q,a):"top"==l?this._verticalScrollBar._setActualPosition(q+d,a+b):this._verticalScrollBar._setActualPosition(q+d,a));f=q;g=a;"top"==l&&(g+=b);"left"==p&&(f+=c);this._viewPortContainer._setActualSize(d,e);this._viewPortContainer._setActualPosition(f,g);null!=this._viewElement&&(this._viewElement.setStyle("X",-1*k),this._viewElement.setStyle("Y",
-1*m))}};function ViewportAnchorContainerElement(){ViewportAnchorContainerElement.base.prototype.constructor.call(this)}ViewportAnchorContainerElement.prototype=Object.create(AnchorContainerElement.prototype);ViewportAnchorContainerElement.prototype.constructor=ViewportAnchorContainerElement;ViewportAnchorContainerElement.base=AnchorContainerElement;ViewportAnchorContainerElement.prototype._doMeasure=function(a,b){return{width:0,height:0}};
function CanvasManager(){this._updateStylesQueue=new CmDepthQueue;this._updateMeasureQueue=new CmDepthQueue;this._updateLayoutQueue=new CmDepthQueue;this._updateRenderQueue=new CmDepthQueue;this._compositeRenderQueue=new CmDepthQueue;this._addRemoveDisplayChainQueue=new CmLinkedList;this._addRemoveDisplayChainQueueProcessing=!1;this._broadcastDispatcher=new EventDispatcher;this._browserCursor=null;this._cursorChain=new CmLinkedList;this._tabStopReverse=!1;this._canvasContext=this._canvas=this._focusElement=
null;this._canvasRenderFramePending=!1;this._mouseY=this._mouseX=-1;this._rollOverInvalid=!0;this._rollOverElement=null;this._rollOverY=this._rollOverX=-1;this._draggingOffsetY=this._draggingOffsetX=this._draggingElement=this._mouseDownElement=null;this._currentLocale="en-us";this._redrawRegionInvalid=!0;this._redrawRegionPrevMetrics=null;CanvasManager.base.prototype.constructor.call(this);this._cursorContainer=new CanvasElement;this._cursorContainer.setStyle("MouseEnabled",!1);this._addOverlayChild(this._cursorContainer);
var a=this;this._onCursorDefinitionStyleChangedInstance=function(b){a._onCursorDefinitionStyleChanged(b)};this._onCanvasFrame=function(){null==a._canvasContext?a._canvasRenderFramePending=!1:(window.requestAnimationFrame(a._onCanvasFrame),a.updateNow())};this._canvasResizeEventHandler=function(){a.setStyle("Width",a._canvas.clientWidth);a.setStyle("Height",a._canvas.clientHeight);a._setActualSize(a._canvas.clientWidth,a._canvas.clientHeight);a._redrawRegionPrevMetrics=null;a._updateRedrawRegion(a.getMetrics(null));
a.updateNow()};this._canvasFocusEventHandler=function(b){null==a._focusElement&&"focus"==b.type?1==a._tabStopReverse?a._updateFocusElement(a._findChildTabStopReverse(a,null,null),!0):a._updateFocusElement(a._findChildTabStopForward(a,null),!0):null!=a._focusElement&&"blur"==b.type&&a._updateFocusElement(null,!0)};this._canvasKeyboardEventHandler=function(b){"keydown"==b.type&&("Tab"==b.key&&1==b.shiftKey?a._tabStopReverse=!0:"Tab"==b.key&&0==b.shiftKey&&(a._tabStopReverse=!1));if(null!=a._focusElement){var c=
new ElementKeyboardEvent(b.type,b.key,b.which,b.ctrlKey,b.altKey,b.shiftKey,b.metaKey);a._focusElement._dispatchEvent(c);if(1==c._canceled||1==c._defaultPrevented)b.preventDefault();else if("keydown"==b.type&&"Tab"==c.getKey()){var c=null,d=a._focusElement,e=null;if(0==a._tabStopReverse)for(;null!=d;){c=a._findChildTabStopForward(d,e);if(null!=c)break;e=d;d=d._parent}else for(;null!=d;){c=a._findChildTabStopReverse(d,e,null);if(null!=c)break;e=d;d=d._parent}a._updateFocusElement(c,!0);null!=c&&b.preventDefault()}}};
this._canvasMouseEventHandler=function(b){var c=CanvasManager.getLocalMousePos(b,a._canvas),d;if("mouseup"==b.type){window.removeEventListener("mouseup",a._canvasMouseEventHandler);a._clearDraggingElement();a._mouseDownElement._mouseIsDown=!1;b=[];for(b.push(a._mouseDownElement);null!=b[b.length-1]._parent;)b[b.length-1]._parent._mouseIsDown=!1,b.push(b[b.length-1]._parent);var e=null,f=0,g=0;for(d=b.length-1;0<=d;d--)b[d].rotatePoint(c,!0),c.x-=b[d]._x,c.y-=b[d]._y,0<=c.x&&c.x<=b[d]._width&&0<=c.y&&
c.y<=b[d]._height&&(e=b[d],f=c.x,g=c.y);a._mouseDownElement=null;b[0]._dispatchEvent(new ElementMouseEvent("mouseup",c.x,c.y));null!=e&&e._dispatchEvent(new ElementMouseEvent("click",f,g))}else if("wheel"==b.type){if(0!=a.getStyle("MouseEnabled")&&0!=a.getStyle("Visible")){e=null;if(0<=c.x&&c.x<=a._width&&0<=c.y&&c.y<=a._height)for(var e=a,k;;){k=!1;for(d=e._children.length-1;0<=d;d--)if(0!=e._children[d].getStyle("MouseEnabled")&&0!=e._children[d].getStyle("Visible")){e._children[d].rotatePoint(c,
!0);if(c.x>=e._children[d]._x&&c.x<=e._children[d]._x+e._children[d]._width&&c.y>=e._children[d]._y&&c.y<=e._children[d]._y+e._children[d]._height){e=e._children[d];c.x-=e._x;c.y-=e._y;k=!0;break}e._children[d].rotatePoint(c,!1)}if(0==k)break}null!=e&&(d=0,0<b.deltaX?d=1:0>b.deltaX&&(d=-1),f=0,0<b.deltaY?f=1:0>b.deltaY&&(f=-1),c=new ElementMouseWheelEvent(c.x,c.y,d,f),e._dispatchEvent(c),1!=c._canceled&&1!=c._defaultPrevented||b.preventDefault())}}else if("mousedown"==b.type)if(0>c.x||c.x>this._width||
0>c.y||c.y>this._height)a._updateFocusElement(null,!1);else{if(0!=a.getStyle("MouseEnabled")&&0!=a.getStyle("Visible")&&null==a._mouseDownElement){for(var f=null,m=g=0,l=null,p=-1,e=a;;){e._mouseIsDown=!0;1!=e.getStyle("Draggable")||!(e._parent instanceof AnchorContainerElement)&&e._parent instanceof ContainerBaseElement||(f=e,g=c.x,m=c.y);d=e.getStyle("TabStop");if(0<=d||0>p)l=e,p=d;k=!1;for(d=e._children.length-1;0<=d;d--)if(0!=e._children[d].getStyle("MouseEnabled")&&0!=e._children[d].getStyle("Visible")){e._children[d].rotatePoint(c,
!0);if(c.x>=e._children[d]._x&&c.x<=e._children[d]._x+e._children[d]._width&&c.y>=e._children[d]._y&&c.y<=e._children[d]._y+e._children[d]._height){e=e._children[d];c.x-=e._x;c.y-=e._y;k=!0;break}e._children[d].rotatePoint(c,!1)}if(0==k)break}a._mouseDownElement=e;window.addEventListener("mouseup",a._canvasMouseEventHandler,!1);null!=f&&a._setDraggingElement(f,g,m);e._dispatchEvent(new ElementMouseEvent(b.type,c.x,c.y));a._updateFocusElement(l,!1);null!=a._focusElement&&a._focusElement._setRenderFocusRing(!1)}}else"mousemove"==
b.type&&0!=a.getStyle("MouseEnabled")&&(a._mouseX=c.x,a._mouseY=c.y,a._rollOverInvalid=!0,a._updateCursor(),null!=a._draggingElement&&(b=a._draggingElement.getMetrics(a._draggingElement._parent),d={x:a._draggingOffsetX,y:a._draggingOffsetY},a._draggingElement.translatePointTo(d,a._draggingElement._parent),c={x:c.x,y:c.y},a.translatePointTo(c,a._draggingElement._parent),c.x+=b.getX()-d.x,c.y+=b.getY()-d.y,0>c.x&&(c.x=0),c.x>a._draggingElement._parent._width-b.getWidth()&&(c.x=a._draggingElement._parent._width-
b.getWidth()),0>c.y&&(c.y=0),c.y>a._draggingElement._parent._height-b.getHeight()&&(c.y=a._draggingElement._parent._height-b.getHeight()),a._draggingElement._setRelativePosition(c.x,c.y,a._draggingElement._parent),a._draggingElement._parent instanceof AnchorContainerElement&&(null==a._draggingElement.getStyle("RotateCenterX")||null==a._draggingElement.getStyle("RotateCenterY")?(null!=a._draggingElement.getStyle("X")&&a._draggingElement.setStyle("X",c.x),null!=a._draggingElement.getStyle("Y")&&a._draggingElement.setStyle("Y",
c.y)):(null!=a._draggingElement.getStyle("X")&&a._draggingElement.setStyle("X",a._draggingElement._x),null!=a._draggingElement.getStyle("Y")&&a._draggingElement.setStyle("Y",a._draggingElement._y),a._draggingElement.setStyle("RotateCenterX",a._draggingElement._rotateCenterX),a._draggingElement.setStyle("RotateCenterY",a._draggingElement._rotateCenterY))),a._draggingElement._dispatchEvent(new ElementEvent("dragging",!1))))}}CanvasManager.prototype=Object.create(AnchorContainerElement.prototype);
CanvasManager.prototype.constructor=CanvasManager;CanvasManager.base=AnchorContainerElement;CanvasManager._StyleTypes=Object.create(null);CanvasManager._StyleTypes.ShowRedrawRegion={inheritable:!1};CanvasManager.StyleDefault=new StyleDefinition;CanvasManager.StyleDefault.setStyle("ShowRedrawRegion",!1);
CanvasManager.prototype.setCanvas=function(a){if(this._canvas!=a){var b=null==this._canvas||null==a;null!=this._canvas&&(window.removeEventListener("mousedown",this._canvasMouseEventHandler,!1),window.removeEventListener("mousemove",this._canvasMouseEventHandler,!1),window.removeEventListener("wheel",this._canvasMouseEventHandler,!1),window.removeEventListener("keydown",this._canvasKeyboardEventHandler,!1),window.removeEventListener("keyup",this._canvasKeyboardEventHandler,!1),window.removeEventListener("resize",
this._canvasResizeEventHandler,!1),this._canvas.removeEventListener("focus",this._canvasFocusEventHandler,!0),this._canvas.removeEventListener("blur",this._canvasFocusEventHandler,!0),this._canvasContext=this._canvas=null);null!=a&&(this._canvas=a,this._canvasContext=a.getContext("2d"),window.addEventListener("mousedown",this._canvasMouseEventHandler,!1),window.addEventListener("mousemove",this._canvasMouseEventHandler,!1),window.addEventListener("wheel",this._canvasMouseEventHandler,!1),window.addEventListener("keydown",
this._canvasKeyboardEventHandler,!1),window.addEventListener("keyup",this._canvasKeyboardEventHandler,!1),window.addEventListener("resize",this._canvasResizeEventHandler,!1),this._canvas.addEventListener("focus",this._canvasFocusEventHandler,!0),this._canvas.addEventListener("blur",this._canvasFocusEventHandler,!0),this._canvas.tabIndex=1,this._canvas.style.outline="none",this._canvas.style.cursor="default",0==this._canvasRenderFramePending&&(this._canvasRenderFramePending=!0,window.requestAnimationFrame(this._onCanvasFrame)),
0<navigator.userAgent.indexOf("Firefox")&&(CanvasElement._browserType="Firefox"));1==b&&(this._propagateChildData(),this._processAddRemoveDisplayChainQueue());null!=this._canvas&&(this._rollOverInvalid=!0,this._canvasResizeEventHandler())}};CanvasManager.prototype.getCanvas=function(){return this._canvas};CanvasManager.prototype.setLocale=function(a){this._currentLocale!=a&&(this._currentLocale=a,1==this._broadcastDispatcher.hasEventListener("localechanged",null)&&this._broadcastDispatcher._dispatchEvent(new DispatcherEvent("localechanged")))};
CanvasManager.prototype.getLocale=function(){return this._currentLocale};
CanvasManager.prototype.addCursor=function(a,b){null==b&&(b=0);a instanceof CursorDefinition&&(0==a._addedCount&&a.addEventListener("stylechanged",this._onCursorDefinitionStyleChangedInstance),a._addedCount++);var c=new CmLinkedNode;c.data=a;c.priority=b;var d=this._cursorChain.back;if(null==d)this._cursorChain.pushBack(c);else{for(;null!=d&&d.priority>c.priority;)d=d.prev;null==d?this._cursorChain.pushFront(c):this._cursorChain.insertAfter(c,d)}this._updateCursor();return c};
CanvasManager.prototype.removeCursor=function(a){if(b instanceof CursorDefinition){var b=a.data;b._addedCount--;0==b._addedCount&&b.removeEventListener("stylechanged",this._onCursorDefinitionStyleChangedInstance)}this._cursorChain.removeNode(a);this._updateCursor();return!0};
CanvasManager.prototype.updateNow=function(){for(1==this._broadcastDispatcher.hasEventListener("enterframe",null)&&this._broadcastDispatcher._dispatchEvent(new DispatcherEvent("enterframe"));0<this._updateStylesQueue.length||0<this._updateMeasureQueue.length||0<this._updateLayoutQueue.length||1==this._rollOverInvalid||0<this._updateRenderQueue.length;){for(;0<this._updateStylesQueue.length;)this._updateStylesQueue.removeSmallest().data._validateStyles();for(;0<this._updateMeasureQueue.length&&0==
this._updateStylesQueue.length;)this._updateMeasureQueue.removeLargest().data._validateMeasure();for(;0<this._updateLayoutQueue.length&&0==this._updateMeasureQueue.length&&0==this._updateStylesQueue.length;)this._updateLayoutQueue.removeSmallest().data._validateLayout();if(1==this._rollOverInvalid&&0==this._updateLayoutQueue.length&&0==this._updateMeasureQueue.length&&0==this._updateStylesQueue.length){this._rollOverInvalid=!1;var a,b=null,c={x:this._mouseX,y:this._mouseY},d=this._rollOverElement,
e=this._rollOverX,f=this._rollOverY,g=this._rollOverElement=null,k=[];if(0<=c.x&&c.x<=this._width&&0<=c.y&&c.y<=this._height){b=this;0==b._mouseIsOver?(k.push(b),b._mouseIsOver=!0):g=b;this._rollOverElement=b;this._rollOverX=c.x;this._rollOverY=c.y;for(var m;;){m=!1;for(a=b._children.length-1;0<=a;a--)if(0!=b._children[a].getStyle("MouseEnabled")&&0!=b._children[a].getStyle("Visible")){b._children[a].rotatePoint(c,!0);if(c.x>=b._children[a]._x&&c.x<=b._children[a]._x+b._children[a]._width&&c.y>=b._children[a]._y&&
c.y<=b._children[a]._y+b._children[a]._height){b=b._children[a];0==b._mouseIsOver?(k.push(b),b._mouseIsOver=!0):g=b;c.x-=b._x;c.y-=b._y;this._rollOverElement=b;this._rollOverX=c.x;this._rollOverY=c.y;m=!0;break}b._children[a].rotatePoint(c,!1)}if(0==m)break}}null==b||this._rollOverElement==d&&this._rollOverX==e&&this._rollOverY==f||b._dispatchEvent(new ElementMouseEvent("mousemove",c.x,c.y));this._broadcastDispatcher._dispatchEvent(new ElementMouseEvent("mousemoveex",this._mouseX,this._mouseY));if(null!=
d&&this._rollOverElement!=d){c=[];for(b=d;b!=g;)b._mouseIsOver=!1,c.push(b),b=b._parent;for(a=0;a<c.length;a++)c[a]._dispatchEvent(new ElementEvent("rollout",!1))}for(a=0;a<k.length;a++)k[a]._dispatchEvent(new ElementEvent("rollover",!1))}for(;0<this._updateRenderQueue.length&&0==this._rollOverInvalid&&0==this._updateLayoutQueue.length&&0==this._updateMeasureQueue.length&&0==this._updateStylesQueue.length;)this._updateRenderQueue.removeSmallest().data._validateRender()}1==this._redrawRegionInvalid&&
(this._validateRedrawRegion(this,!1),this._redrawRegionInvalid=!1);for(;0<this._compositeRenderQueue.length;)this._compositeRenderQueue.removeLargest().data._validateCompositeRender();null!=this._redrawRegionPrevMetrics&&this._invalidateCompositeRender()};CanvasManager.getLocalMousePos=function(a,b){var c=b.getBoundingClientRect();return{x:Math.round((a.clientX-c.left)/(c.right-c.left)*b.width),y:Math.round((a.clientY-c.top)/(c.bottom-c.top)*b.height)}};
CanvasManager.prototype._updateCompositeCanvas=function(){null==this._compositeCanvas&&(this._compositeCanvas=this._canvas,this._compositeCtx=this._canvasContext);if(this._compositeCanvas.width!=this._width||this._compositeCanvas.height!=this._height)this._compositeCanvas.width=this._width,this._compositeCanvas.height=this._height,null==this._compositeCanvasMetrics&&(this._compositeCanvasMetrics=new DrawMetrics),this._compositeCanvasMetrics._x=0,this._compositeCanvasMetrics._y=0,this._compositeCanvasMetrics._width=
this._width,this._compositeCanvasMetrics._height=this._height,null==this._redrawRegionMetrics?this._redrawRegionMetrics=this._compositeCanvasMetrics.clone():this._redrawRegionMetrics.mergeExpand(this._compositeCanvasMetrics)};
CanvasManager.prototype._validateRedrawRegion=function(a,b){var c=[],d=a._renderVisible,e=!0;if(null!=a._parent&&0==a._parent._renderVisible||0==a.getStyle("Visible")||0>=a.getStyle("Alpha"))e=!1;1==a._compositeEffectChanged&&(b=!0);a._compositeVisibleMetrics=null;a._transformVisibleMetrics=null;a._transformDrawableMetrics=null;if(!(1!=a._renderChanged&&0!=a._graphicsClear||1!=d&&1!=e))for(var f=a,g=a.getMetrics(),k=g.clone(),m={x:g._x,y:g._y},l={x:g._x+g._width,y:g._y},p={x:g._x+g._width,y:g._y+
g._height},q={x:g._x,y:g._y+g._height},n={x:0,y:0},r={x:0,y:0},v={x:0,y:0},t={x:0,y:0},u,y,z,x,B=new DrawMetrics,A=new DrawMetrics;null!=f;){null!=k&&(f==this||1==f.getStyle("ClipContent"))&&(B._x=0,B._y=0,B._width=f._width,B._height=f._height,k.mergeReduce(B),0>=k._width||0>=k._height)&&(k=null);if(1==f._isCompositeElement()){u=a._getCompositeMetrics(f);null!=k&&1==e&&0==a._graphicsClear?(c.push({element:f,metrics:g.clone(),drawableMetrics:k.clone()}),null==f._compositeVisibleMetrics?f._compositeVisibleMetrics=
k.clone():f._compositeVisibleMetrics.mergeExpand(k)):newMetrics=null;y=!0;if(null==u&&null==k||null!=u&&null!=k&&1==u.drawableMetrics.equals(k))y=!1;z=!0;null!=u&&1==u.metrics.equals(g)&&(z=!1);if(1==b||1==a._renderChanged||d!=e||1==y||z)1==d&&null!=u&&f._updateRedrawRegion(u.drawableMetrics),1==e&&f._updateRedrawRegion(k)}null!=k&&(k._x+=f._x,k._y+=f._y,u=f.getStyle("ShadowSize"),0<u&&null!=f.getStyle("ShadowColor")?(A.copyFrom(k),A._width+=2*u,A._height+=2*u,A._x-=u,A._y-=u,A._x+=f.getStyle("ShadowOffsetX"),
A._y+=f.getStyle("ShadowOffsetY"),k.mergeExpand(A),0!=CanvasElement.normalizeDegrees(f._rotateDegrees)&&(n.x=k._x,n.y=k._y,r.x=k._x+k._width,r.y=k._y,v.x=k._x+k._width,v.y=k._y+k._height,t.x=k._x,t.y=k._y+k._height,f.rotatePoint(n,!1),f.rotatePoint(r,!1),f.rotatePoint(t,!1),f.rotatePoint(v,!1),u=Math.min(n.x,r.x,v.x,t.x),y=Math.max(n.x,r.x,v.x,t.x),z=Math.min(n.y,r.y,v.y,t.y),x=Math.max(n.y,r.y,v.y,t.y),k._x=u,k._y=z,k._width=y-u,k._height=x-z),g.copyFrom(k),m.x+=g._x,m.y+=g._y,l.x+=g._x+g._width,
l.y+=g._y,p.x+=g._x+g._width,p.y+=g._y+g._height,q.x+=g._x,q.y+=g._y+g._height):(m.x+=f._x,m.y+=f._y,l.x+=f._x,l.y+=f._y,p.x+=f._x,p.y+=f._y,q.x+=f._x,q.y+=f._y,0!=CanvasElement.normalizeDegrees(f._rotateDegrees)&&(f.rotatePoint(m,!1),f.rotatePoint(l,!1),f.rotatePoint(q,!1),f.rotatePoint(p,!1),n.x=k._x,n.y=k._y,r.x=k._x+k._width,r.y=k._y,v.x=k._x+k._width,v.y=k._y+k._height,t.x=k._x,t.y=k._y+k._height,f.rotatePoint(n,!1),f.rotatePoint(r,!1),f.rotatePoint(t,!1),f.rotatePoint(v,!1),u=Math.min(n.x,r.x,
v.x,t.x),y=Math.max(n.x,r.x,v.x,t.x),z=Math.min(n.y,r.y,v.y,t.y),x=Math.max(n.y,r.y,v.y,t.y),k._x=u,k._y=z,k._width=y-u,k._height=x-z),u=Math.min(m.x,l.x,p.x,q.x),y=Math.max(m.x,l.x,p.x,q.x),z=Math.min(m.y,l.y,p.y,q.y),x=Math.max(m.y,l.y,p.y,q.y),g._x=u,g._y=z,g._width=y-u,g._height=x-z),g.roundToPrecision(3),k.mergeReduce(g),k.roundToPrecision(3));f=f._parent}a._compositeMetrics=c;a._renderVisible=e;a._renderChanged=!1;if(1==d||1==e){for(c=0;c<a._children.length;c++)this._validateRedrawRegion(a._children[c],
b);1==a._isCompositeElement()&&this._updateTransformMetrics(a)}};
CanvasManager.prototype._updateTransformMetrics=function(a){if(a!=this&&null!=a._compositeVisibleMetrics){var b={x:0,y:0},c={x:0,y:0},d={x:0,y:0},e={x:0,y:0},f,g,k,m,l=a;a._transformVisibleMetrics=a._compositeVisibleMetrics.clone();a._transformDrawableMetrics=a._compositeVisibleMetrics.clone();for(var p=new DrawMetrics,q=!1;;){if(null!=a._transformDrawableMetrics&&1==l.getStyle("ClipContent")&&(p._x=0,p._y=0,p._width=l._width,p._height=l._height,a._transformDrawableMetrics.mergeReduce(p),0>=a._transformDrawableMetrics._width||
0>=a._transformDrawableMetrics._height)){a._transformDrawableMetrics=null;a._transformVisibleMetrics=null;break}if(1==q)break;a._transformVisibleMetrics._x+=l._x;a._transformVisibleMetrics._y+=l._y;a._transformDrawableMetrics._x+=l._x;a._transformDrawableMetrics._y+=l._y;f=l.getStyle("ShadowSize");0<f&&null!=l.getStyle("ShadowColor")&&(g=a._transformDrawableMetrics.clone(),g._width+=2*f,g._height+=2*f,g._x-=f,g._y-=f,g._x+=l.getStyle("ShadowOffsetX"),g._y+=l.getStyle("ShadowOffsetY"),a._transformDrawableMetrics.mergeExpand(g));
0!=CanvasElement.normalizeDegrees(l._rotateDegrees)&&(b.x=a._transformVisibleMetrics._x,b.y=a._transformVisibleMetrics._y,c.x=a._transformVisibleMetrics._x+a._transformVisibleMetrics._width,c.y=a._transformVisibleMetrics._y,d.x=a._transformVisibleMetrics._x+a._transformVisibleMetrics._width,d.y=a._transformVisibleMetrics._y+a._transformVisibleMetrics._height,e.x=a._transformVisibleMetrics._x,e.y=a._transformVisibleMetrics._y+a._transformVisibleMetrics._height,l.rotatePoint(b,!1),l.rotatePoint(c,!1),
l.rotatePoint(e,!1),l.rotatePoint(d,!1),f=Math.min(b.x,c.x,d.x,e.x),g=Math.max(b.x,c.x,d.x,e.x),k=Math.min(b.y,c.y,d.y,e.y),m=Math.max(b.y,c.y,d.y,e.y),a._transformVisibleMetrics._x=f,a._transformVisibleMetrics._y=k,a._transformVisibleMetrics._width=g-f,a._transformVisibleMetrics._height=m-k,a._transformVisibleMetrics.roundToPrecision(3),b.x=a._transformDrawableMetrics._x,b.y=a._transformDrawableMetrics._y,c.x=a._transformDrawableMetrics._x+a._transformDrawableMetrics._width,c.y=a._transformDrawableMetrics._y,
d.x=a._transformDrawableMetrics._x+a._transformDrawableMetrics._width,d.y=a._transformDrawableMetrics._y+a._transformDrawableMetrics._height,e.x=a._transformDrawableMetrics._x,e.y=a._transformDrawableMetrics._y+a._transformDrawableMetrics._height,l.rotatePoint(b,!1),l.rotatePoint(c,!1),l.rotatePoint(e,!1),l.rotatePoint(d,!1),f=Math.min(b.x,c.x,d.x,e.x),g=Math.max(b.x,c.x,d.x,e.x),k=Math.min(b.y,c.y,d.y,e.y),m=Math.max(b.y,c.y,d.y,e.y),a._transformDrawableMetrics._x=f,a._transformDrawableMetrics._y=
k,a._transformDrawableMetrics._width=g-f,a._transformDrawableMetrics._height=m-k,a._transformDrawableMetrics.roundToPrecision(3));l=l._parent;1==l._isCompositeElement()&&(q=!0)}}};
CanvasManager.prototype._validateCompositeRender=function(){if(1==this.getStyle("ShowRedrawRegion")){var a=null;null!=this._redrawRegionMetrics?(a=this._redrawRegionMetrics.clone(),--a._x,--a._y,a._width+=2,a._height+=2,a.roundUp(),null!=this._redrawRegionPrevMetrics&&this._redrawRegionMetrics.mergeExpand(this._redrawRegionPrevMetrics)):null!=this._redrawRegionPrevMetrics&&(this._redrawRegionMetrics=this._redrawRegionPrevMetrics.clone());CanvasManager.base.prototype._validateCompositeRender.call(this);
null!=a&&(this._canvasContext.lineWidth=1,this._canvasContext.strokeStyle="#FF0000",this._canvasContext.beginPath(),this._canvasContext.moveTo(a._x+.5,a._y+.5),this._canvasContext.lineTo(a._x+a._width-.5,a._y+.5),this._canvasContext.lineTo(a._x+a._width-.5,a._y+a._height-.5),this._canvasContext.lineTo(a._x+.5,a._y+a._height-.5),this._canvasContext.closePath(),this._canvasContext.stroke());this._redrawRegionPrevMetrics=a}else CanvasManager.base.prototype._validateCompositeRender.call(this),this._redrawRegionPrevMetrics=
null};
CanvasManager.prototype._updateFocusElement=function(a,b){a!=this._focusElement&&(null!=this._focusElement&&(this._focusElement._isFocused=!1,this._focusElement._setRenderFocusRing(!1),1==this._focusElement.hasEventListener("focusout",null)&&this._focusElement._dispatchEvent(new ElementEvent("focusout",!1))),this._focusElement=a,null!=this._focusElement&&(this._focusElement._isFocused=!0,this._focusElement._setRenderFocusRing(b),1==this._focusElement.hasEventListener("focusin",null)&&this._focusElement._dispatchEvent(new ElementEvent("focusin",!1))))};
CanvasManager.prototype._findChildTabStopForward=function(a,b){var c=0;null!=b&&(c=a._children.indexOf(b)+1);for(var d=null;c<a._children.length;c++)if(0!=a._children[c].getStyle("MouseEnabled")&&0!=a._children[c].getStyle("Visible")&&0!=a._children[c].getStyle("Enabled")){if(0<=a._children[c].getStyle("TabStop"))return a._children[c];d=this._findChildTabStopForward(a._children[c],null);if(null!=d)break}return d};
CanvasManager.prototype._findChildTabStopReverse=function(a,b,c){var d=a._children.length-1;null!=b&&(d=a._children.indexOf(b)-1);for(b=d;0<=b&&(0==a._children[b].getStyle("MouseEnabled")||0==a._children[b].getStyle("Visible")||0==a._children[b].getStyle("Enabled")||(0<=a._children[b].getStyle("TabStop")&&(c=a._children[b]),this._findChildTabStopReverse(a._children[b],null,c),null==c));b--);return c};
CanvasManager.prototype._updateCursor=function(){var a=null;null!=this._cursorChain.back&&(a=this._cursorChain.back.data);var b=null;0<this._cursorContainer._getNumChildren()&&(b=this._cursorContainer._getChildAt(0));if(null!=a){var c=null;if(!("string"===typeof a||a instanceof String)){var d=a.getStyle("CursorClass");if(null==d)a._cursorElement=null;else{if(null==a._cursorElement||a._cursorElement.constructor!=d)a._cursorElement=new d;a._cursorElement.setStyleDefinitions(a.getStyle("CursorStyle"));
c=a._cursorElement}}b!=c&&(null!=b&&this._cursorContainer._removeChild(b),null!=c&&this._cursorContainer._addChild(c));if(null!=c)if("none"!=this._browserCursor&&(this._browserCursor="none",this._canvas.style.cursor="none"),0<=this._mouseX&&this._mouseX<=this._width&&0<=this._mouseY&&this._mouseY<=this._height){var b=a._cursorElement._getStyledOrMeasuredWidth(),d=a._cursorElement._getStyledOrMeasuredHeight(),e=a.getStyle("CursorOffsetX"),a=a.getStyle("CursorOffsetY");c._setActualPosition(this._mouseX+
e,this._mouseY+a);c._setActualSize(b,d);c.setStyle("Visible",!0)}else c.setStyle("Visible",!1);else this._browserCursor!=a&&(this._browserCursor=a,this._canvas.style.cursor=a)}else null!=b&&this._cursorContainer._removeChildAt(0),"default"!=this._browserCursor&&(this._browserCursor="default",this._canvas.style.cursor="default")};
CanvasManager.prototype._onCursorDefinitionStyleChanged=function(a){var b=a.getTarget();a=a.getStyleName();if("CursorClass"==a&&null!=b._cursorElement){var c=b.getStyle("CursorClass");b._cursorElement.constructor!=c&&(b._cursorElement=null)}"CursorStyle"==a&&null!=b._cursorElement&&b._cursorElement.setStyleDefinitions(this.getStyle("CursorStyle"));this._updateCursor()};CanvasManager.prototype._pushAddRemoveDisplayChainQueue=function(a,b){var c=new CmLinkedNode;c.data={element:a,type:b};this._addRemoveDisplayChainQueue.pushBack(c)};
CanvasManager.prototype._popAddRemoveDisplayChainQueue=function(){if(0==this._addRemoveDisplayChainQueue.length)return null;var a=this._addRemoveDisplayChainQueue.front.data;this._addRemoveDisplayChainQueue.removeNode(this._addRemoveDisplayChainQueue.front);return a};
CanvasManager.prototype._processAddRemoveDisplayChainQueue=function(){if(1!=this._addRemoveDisplayChainQueueProcessing){this._addRemoveDisplayChainQueueProcessing=!0;for(var a=this._popAddRemoveDisplayChainQueue();null!=a;)a.element._dispatchEvent(new AddedRemovedEvent(a.type,this)),a=this._popAddRemoveDisplayChainQueue();this._addRemoveDisplayChainQueueProcessing=!1}};
CanvasManager.prototype._clearDraggingElement=function(){null!=this._draggingElement&&(this._draggingOffsetY=this._draggingOffsetX=this._draggingElement=null)};CanvasManager.prototype._setDraggingElement=function(a,b,c){null==this._draggingElement&&(this._draggingElement=a,this._draggingOffsetX=b,this._draggingOffsetY=c)};CanvasManager.prototype._doLayout=function(a){CanvasManager.base.prototype._doLayout.call(this,a);this._cursorContainer._setActualSize(this._width,this._height)};
function CmDepthQueue(){this.depthArrayOfLists=[];this.length=0;this.maxDepth=this.minDepth=-1}CmDepthQueue.prototype.addNode=function(a,b){var c=b-1;null==this.depthArrayOfLists[c]&&(this.depthArrayOfLists[c]=new CmLinkedList);this.depthArrayOfLists[c].pushBack(a);this.length+=1;if(c<this.minDepth||-1==this.minDepth)this.minDepth=c;c>this.maxDepth&&(this.maxDepth=c)};
CmDepthQueue.prototype.removeNode=function(a,b){this.depthArrayOfLists[b-1].removeNode(a);--this.length;0==this.length&&(this.maxDepth=this.minDepth=-1)};
CmDepthQueue.prototype.removeSmallest=function(){if(0==this.length)return null;for(var a=this.minDepth;a<this.depthArrayOfLists.length;a++)if(this.minDepth=a,null!=this.depthArrayOfLists[a]&&0!=this.depthArrayOfLists[a].length){var b=this.depthArrayOfLists[a].front;this.depthArrayOfLists[a].removeNode(b);--this.length;0==this.length&&(this.maxDepth=this.minDepth=-1);return b}};
CmDepthQueue.prototype.removeLargest=function(){if(0==this.length)return null;for(var a=this.maxDepth;0<=a;a--)if(this.maxDepth=a,null!=this.depthArrayOfLists[a]&&0!=this.depthArrayOfLists[a].length){var b=this.depthArrayOfLists[a].back;this.depthArrayOfLists[a].removeNode(b);--this.length;0==this.length&&(this.maxDepth=this.minDepth=-1);return b}};function CmLinkedList(){this.back=this.front=null;this.length=0}
CmLinkedList.prototype.pushFront=function(a){this.length++;null==this.front?(a.prev=null,a.next=null,this.back=this.front=a):(a.prev=null,a.next=this.front,this.front=this.front.prev=a)};CmLinkedList.prototype.pushBack=function(a){this.length++;null==this.back?(a.prev=null,a.next=null,this.front=a):(a.prev=this.back,a.next=null,this.back.next=a);this.back=a};
CmLinkedList.prototype.insertBefore=function(a,b){this.length++;this.front==b&&(this.front=a);null!=b.prev&&(b.prev.next=a);a.prev=b.prev;a.next=b;b.prev=a};CmLinkedList.prototype.insertAfter=function(a,b){this.length++;this.back==b&&(this.back=a);null!=b.next&&(b.next.prev=a);a.next=b.next;a.prev=b;b.next=a};
CmLinkedList.prototype.removeNode=function(a){if(null==a)return null;this.length--;this.front==a&&(this.front=a.next);this.back==a&&(this.back=a.prev);null!=a.prev&&(a.prev.next=a.next);null!=a.next&&(a.next.prev=a.prev);a.next=null;a.prev=null};function CmLinkedNode(){this.data=this.next=this.prev=null};



///////////////////////////////////////////////////////
//////////////////Tween////////////////////////////////
	
/**
 * @class Tween
 * 
 * Tween is a helper class that is used to interpolate values
 * across a given time span and is essentially just a calculator. 
 * It can be used for nearly any type of animation and supports
 * easing for acceleration and deceleration. 
 * 
 * If you're unsure about easing, a hint is that SineInOut is a kind of magic salt 
 * you can sprinkle on just about any linear animation that usually makes everything 
 * look smoother and less jarring without being obvious.
 * 
 * @constructor Tween 
 * Creates new Tween instance.
 */
function Tween()
{
	/**
	 * @member startVal Number
	 * Beginning value at the start time of the tween.
	 */
	this.startVal = 0;
	
	/**
	 * @member endVal Number
	 * Ending value at the end time of the tween duration.
	 */
	this.endVal = 0;
	
	/**
	 * @member duration Number
	 * Duration in milliseconds the tween will run.
	 */
	this.duration = 0;
	
	/**
	 * @member startTime Number
	 * Time in milliseconds that the tween should start as returned by Date.now().
	 */
	this.startTime = null;
	
	/**
	 * @member easingFunction Function
	 * Easing function to use when calculating the tween value. This is used
	 * to create acceleration/deceleration. Setting this to null will result
	 * in a linear tween. This is a function that accepts a fraction
	 * between 0 and 1 and returns a fraction between 0 and 1. The result is used
	 * to calculate the value based on progress and start/end values. There are several
	 * standard easing functions built in as static functions of Tween that you can set to this.
	 */
	this.easingFunction = null;
}
	
//Tween is base object, no inheritance.
Tween.prototype.constructor = Tween;


/**
 * @function getProgress
 * Gets the current progress of the tween based on the start time and the current time.
 * 
 * @param time Number
 * The current time as returned by Date.now().
 * 
 * @returns Number
 * Fraction between 0 and 1.
 */
Tween.prototype.getProgress = 
	function (time)
	{
		if (time >= this.startTime + this.duration)
			return 1;
		else if (time <= this.startTime)
			return 0;
		
		return (time - this.startTime) / this.duration;
	};
	
/**
 * @function getValue
 * Gets the current value based on the supplied time.
 * 
 * @param time Number
 * The current time as returned by Date.now().
 * 
 * @returns Number
 * A number between the start and end values (inclusive).
 */	
Tween.prototype.getValue = 
	function (time)
	{
		var progress = this.getProgress(time);
		
		if (progress == 1)
			return this.endVal;
		else if (progress == 0)
			return this.startVal;
	
		if (this.easingFunction != null)
			progress = this.easingFunction(progress);
		
		var range = Math.abs(this.endVal - this.startVal);
		
		if (this.startVal < this.endVal)
			return this.startVal + (range * progress);
		
		return this.startVal - (range * progress);
	};

//////Static//////////////////
	
/**
 * @function easeInQuad
 * @static
 * Use for quadratic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */	
Tween.easeInQuad = 
	function (fraction)
	{
		return fraction * fraction;
	};
	
/**
 * @function easeOutQuad
 * @static
 * Use for quadratic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeOutQuad = 
	function (fraction)
	{
		return 1 - Tween.easeInQuad(1 - fraction);
	};

/**
 * @function easeInOutQuad
 * @static
 * Use for quadratic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInOutQuad = 
	function (fraction)
	{
		if (fraction < 0.5)
			return Tween.easeInQuad(fraction * 2.0) / 2.0;
		
		return 1 - (Tween.easeInQuad((1 - fraction) * 2.0) / 2.0);  
	};
	
/**
 * @function easeInCubic
 * @static
 * Use for cubic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInCubic = 
	function (fraction)
	{
		return Math.pow(fraction, 3);
	};
	
/**
 * @function easeOutCubic
 * @static
 * Use for cubic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeOutCubic = 
	function (fraction)
	{
		return 1 - Tween.easeInCubic(1 - fraction);
	};

/**
 * @function easeInOutCubic
 * @static
 * Use for cubic easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInOutCubic = 
	function (fraction)
	{
		if (fraction < 0.5)
			return Tween.easeInCubic(fraction * 2.0) / 2.0;
		
		return 1 - (Tween.easeInCubic((1 - fraction) * 2.0) / 2.0);  
	};	
	
/**
 * @function easeOutSine
 * @static
 * Use for sine easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeOutSine = 
	function (fraction)
	{
		return Math.sin(fraction * (Math.PI / 2.0));
	};

/**
 * @function easeInSine
 * @static
 * Use for sine easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInSine = 
	function (fraction)
	{
		return 1 - Tween.easeOutSine(1 - fraction);
	};	
	
/**
 * @function easeInOutSine
 * @static
 * Use for sine easing.
 * 
 * @param fraction Number
 * A number between 0 and 1.
 * 
 * @returns Number
 * A number between 0 and 1.
 */		
Tween.easeInOutSine = 
	function (fraction)
	{
		if (fraction < 0.5)
			return Tween.easeInSine(fraction * 2.0) / 2.0;
		
		return 1 - (Tween.easeInSine((1 - fraction) * 2.0) / 2.0);  
	};
	
	


///////////////////////////////////////////////////////////////////////////	
///////////////////////StyleProxy////////////////////////////////////////		
	
/**
 * @class StyleProxy
 * 
 * Internal class used to wrap CanvasElements to proxy styles to other elements. 
 * This should only be used by component developers. When a proxy is assigned
 * to an element, the proxy is included in its style chain lookup after assigned
 * styles (instance, and styleDefinition) but before default styles.   
 * 
 * @constructor StyleProxy 
 * Creates new StyleProxy instance.
 * 
 * @param styleProxyElement CanvasElement
 * The element to proxy styles from.
 * 
 * @param styleProxyMap Object
 * A map of styleNames to proxy. This Object is walked for members so
 * should always be created using a null prototype: Object.create(null) and
 * members created for each styleName to proxy (set to true). 
 * 
 * MyProxyMap = Object.create(null);
 * MyProxyMap.StyleName1 = true;
 * MyProxyMap.StyleName2 = true;
 * 
 * MyProxyMap._Arbitrary = true; 
 * 
 * _Arbitrary is a special flag that indicates all styles that are not defined / unknown 
 * by the element will also be proxied.
 * 
 * For example, a Button will proxy several styles to its skins such as "BackgroundColor" by including
 * them in the proxy map it passes to its skins. Styles like "Visible" however, are omitted from the proxy
 * map. Also, the button sets the _Arbitrary flag so any styles the Button is not aware of and does not define itself, 
 * are automatically proxied to the skin, without having to be added to the proxy map. 
 * This is so that skins may have custom styles and still be blanket set by setting the Button style itself. 
 */
function StyleProxy(styleProxyElement, styleProxyMap)
{
	this._proxyElement = styleProxyElement;
	this._proxyMap = styleProxyMap;
}

//No Inheritance
StyleProxy.prototype.constructor = StyleProxy;

	


//////////////////////////////////////////////////////////////////////
/////////////////////DispatcherEvent//////////////////////////////////

/**
 * @class DispatcherEvent
 * Base class for all events.
 * 
 * @constructor DispatcherEvent 
 * Creates new DispatcherEvent instance
 * 
 * @param type String
 * String representing the event type
 * 
 */
function DispatcherEvent(type)
{
	this._type = type;
	
	this._target = null;
	this._canceled = false;
}

//DispatcherEvent is base object, no inheritance.
DispatcherEvent.prototype.constructor = DispatcherEvent;


/**
 * @function getType
 * Gets the event type
 * 
 * @returns String
 * String representing the event type
 */
DispatcherEvent.prototype.getType = 
	function ()
	{
		return this._type;
	};

	
/**
 * @function getTarget
 * Gets event target
 * 
 * @returns Object
 * Object that originally dispatched the event 
 */	
DispatcherEvent.prototype.getTarget = 
	function ()
	{
		return this._target;
	};

/**
 * @function cancelEvent
 * Prevents processing of any subsequent event handlers
 */
DispatcherEvent.prototype.cancelEvent = 
	function ()
	{
		this._canceled = true;
	};	
	
/**
 * @function getIsCanceled
 * Checks if the event has been canceled
 * 
 * @returns boolean
 * Returns true if the event has been canceled, otherwise false
 */	
DispatcherEvent.prototype.getIsCanceled = 
	function ()
	{
		return this._canceled;
	};
	
/**
 * @function clone
 * Duplicates an instance of an Event or Event subclass. 
 * The event dispatcher calls this when dispatching or re-dispatching events to multiple targets. 
 * When creating a custom event class, you should override this and call the base class's clone() 
 * then copy the new event properties to the cloned instance.
 * 
 * @returns DispatcherEvent
 * A new event object instance identical to the cloned instance.
 */	
DispatcherEvent.prototype.clone = 
	function ()
	{
		var clonedEvent = this._cloneInstance();
		
		clonedEvent._target = this._target;
		clonedEvent._canceled = this._canceled;
		
		return clonedEvent;
	};
	
/**
 * @function _cloneInstance
 * Calls and returns the constructor() of the appropriate event subclass when cloning an event. 
 * When creating a custom event class, you should override this and return the appropriate event subclass type.
 * 
 * @returns DispatcherEvent
 * A new event instance of the same type being cloned.
 */	
DispatcherEvent.prototype._cloneInstance = 
	function ()
	{
		return new DispatcherEvent(this._type);
	};	
	
	


/**
 * @depends DispatcherEvent.js
 */

//////////////////////////////////////////////////////////////////////
/////////////////////StyleChangedEvent////////////////////////////////	
	
/**
 * @class StyleChangedEvent
 * @inherits DispatcherEvent
 * 
 * Event that is dispatched when a style is changed of type "stylechanged". 
 * This is typically an internal event that the system uses to monitor 
 * style changes to Elements, StyleDefnitions, or any style-able objects.
 * 
 * 
 * @constructor StyleChangedEvent 
 * Creates new StyleChangedEvent instance.
 * 
 * @param styleName String
 * String representing style type that was updated
 */
function StyleChangedEvent(styleName)
{
	StyleChangedEvent.base.prototype.constructor.call(this, "stylechanged");
	
	this._styleName = styleName;
}	
	
//Inherit from DispatcherEvent
StyleChangedEvent.prototype = Object.create(DispatcherEvent.prototype);
StyleChangedEvent.prototype.constructor = StyleChangedEvent;
StyleChangedEvent.base = DispatcherEvent;

/**
 * @function getStyleName
 * Gets the style name of the style which has changed
 * 
 * @returns String
 * String representing the style that has changed
 */
StyleChangedEvent.prototype.getStyleName = 
	function ()
	{
		return this._styleName;
	};
	
//@override
StyleChangedEvent.prototype.clone =
	function ()
	{
		var clonedEvent = StyleChangedEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@override
StyleChangedEvent.prototype._cloneInstance = 
	function ()
	{
		return new StyleChangedEvent(this._styleName, this._oldValue, this._newValue);
	};
	
	


/**
 * @depends DispatcherEvent.js
 */

//////////////////////////////////////////////////////////////////////
/////////////////////ElementEvent/////////////////////////////////////	

/**
 * @class ElementEvent
 * @inherits DispatcherEvent
 * 
 * Base class for CanvasElement UI events. ElementEvents support
 * capture and bubbling phase when dispatched from CanvasElement(s). A bubbling event
 * invokes capture listeners from the root parent to the target child element and then
 * bubbling (normal) listeners from the target element to the root parent. 
 * Bubbling events are used to detect events dispatched on child elements.
 * Capture events are typically not needed but sometimes useful if you wish to 
 * detect an event before the target has a chance to process it.
 * 
 * For Example, when a Button dispatches a ElementMouseEvent.
 * The event propagates from the root parent (CanvasManager) down the display chain
 * from child to child dispatching capture events to any parents with registered listeners. 
 * Once reaching the target element (Button) the event then propagates back up the display chain 
 * from parent to parent dispatching bubbling events.  
 * You may cancel the event at any time to stop the event flow.
 * 
 * 
 * @constructor ElementEvent 
 * Creates new ElementEvent instance.
 * 
 * @param type String
 * String representing the event type
 * 
 * @param bubbles boolean
 * True if the ElementEvent should be dispatch capture and bubbling events.
 */

function ElementEvent(type, bubbles)
{
	ElementEvent.base.prototype.constructor.call(this, type);
	
	this._currentTarget = null;
	this._bubbles = bubbles;
	this._phase = null;  // "capture" || "bubble"
	this._defaultPrevented = false;
}

//Inherit from DispatcherEvent
ElementEvent.prototype = Object.create(DispatcherEvent.prototype);
ElementEvent.prototype.constructor = ElementEvent;
ElementEvent.base = DispatcherEvent;

/**
 * @function getCurrentTarget
 * 
 * Gets the element that is currently dispatching the event. Note that is
 * is not always the same as getTarget() which returns the element that
 * originally dispatched the event. 
 * 
 * For Example, when a click listener is registered to an element, and a child of that
 * element dispatches a click (like a Button), the target will be the child (Button) and the 
 * current target will be the element that registered the click listener.
 * 
 * 
 * @returns CanvasElement
 * The element that is currently dispatching the event.
 */
ElementEvent.prototype.getCurrentTarget = 
	function ()
	{
		return this._currentTarget;
	};

/**
 * @function getPhase
 * 
 * Gets the current phase of the event. ("bubbling" or "capture")
 * 
 * @returns String
 * String representing the event's current phase when dispatched ("bubbling" or "capture")
 */
ElementEvent.prototype.getPhase = 
	function ()
	{
		return this._phase;
	};
	
/**
 * @function preventDefault
 * 
 * Prevents the event's typical action from being taken. This is also sometimes used to "consume"
 * the event so it is only processed once. Such as preventing a mousewheel event from scrolling multiple
 * parent/child views at once. A scroll-able child will call preventDefault() to "consume" the event
 * and prevent any parents from also scrolling.
 */	
ElementEvent.prototype.preventDefault = 
	function ()
	{
		this._defaultPrevented = true;
	};

/**
 * @function getDefaultPrevented
 * 
 * Gets the default prevented state of the event.
 * 
 * @returns boolean
 * Returns true if preventDefault() has been called, false otherwise.
 */	
ElementEvent.prototype.getDefaultPrevented = 
	function ()
	{
		return this._defaultPrevented;
	};
	
//@Override	
ElementEvent.prototype.clone = 
	function ()
	{
		var clonedEvent = ElementEvent.base.prototype.clone.call(this);
		
		clonedEvent._currentTarget = this._currentTarget;
		clonedEvent._phase = this._phase;
		clonedEvent._defaultPrevented = this._defaultPrevented;
		clonedEvent._bubbles = this._bubbles; //Need to set, some subclasses always pass true in constructor.
		
		return clonedEvent;
	};
	
//@Override	
ElementEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementEvent(this._type, this._bubbles);
	};


/**
 * @depends ElementEvent.js
 */

//////////////////////////////////////////////////////////////////////////	
/////////////////////ElementMouseEvent////////////////////////////////////

/**
 * @class ElementMouseEvent
 * @inherits ElementEvent
 * 
 * Event class used to represent mouse events of type "mousedown", "mouseup" or "click". 
 * Every "mousedown" event is always paired with a "mouseup" event. Note that the mouse is
 * not necessarily still over the same object when "mouseup" is dispatched. The user may have
 * pressed and then moved the mouse before releasing. A "click" event however, is only dispatched
 * if the mouse is still over the "mousedown" object when the mouse is released.
 * 
 * @constructor ElementMouseEvent 
 * Creates new ElementMouseEvent instance.
 * 
 * @param type String
 * String representing the event type ("mousedown", "mouseup", or "click")
 * 
 * @param x int
 * The X coordinate of the mouse relative to the object dispatching the mouse event.
 * 
 * @param y int
 * The Y coordinate of the mouse relative to the object dispatching the mouse event.
 */
function ElementMouseEvent(type, x, y)
{
	ElementMouseEvent.base.prototype.constructor.call(this, type, true);
	
	this._x = x; 
	this._y = y;
}

//Inherit from ElementEvent
ElementMouseEvent.prototype = Object.create(ElementEvent.prototype);
ElementMouseEvent.prototype.constructor = ElementMouseEvent;
ElementMouseEvent.base = ElementEvent;

/**
 * @function getX
 * 
 * Gets the X coordinate of the mouse relative to the object dispatching the mouse event. 
 * 
 * @returns int
 * The X coordinate of the mouse relative to the object dispatching the mouse event. 
 */
ElementMouseEvent.prototype.getX = 
	function()
	{
		return this._x;
	};
	
/**
 * @function getY
 * 
 * Gets the Y coordinate of the mouse relative to the object dispatching the mouse event. 
 * 
 * @returns int
 * The Y coordinate of the mouse relative to the object dispatching the mouse event. 
 */	
ElementMouseEvent.prototype.getY = 
	function()
	{
		return this._y;
	};
	
//@Override
ElementMouseEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementMouseEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
ElementMouseEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementMouseEvent(this._type, this._x, this._y);
	};
	


/**
 * @depends ElementMouseEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementMouseWheelEvent///////////////////////////////

/**
 * @class ElementMouseWheelEvent
 * @inherits ElementMouseEvent
 * 
 * Event class used to represent mouse wheel events of type "wheel". 
 * 
 * 
 * @constructor ElementMouseWheelEvent 
 * Creates new ElementMouseWheelEvent instance.
 * 
 * @param x int
 * The X coordinate of the mouse relative to the object dispatching the mouse event.
 * 
 * @param y int
 * The Y coordinate of the mouse relative to the object dispatching the mouse event.
 * 
 * @param deltaX int
 * The change of the X position of the the mouse wheel. (Currently -1, 0, or +1)
 * 
 * @param deltaY int
 * The change of the Y position of the the mouse wheel. (Currently -1, 0, or +1)
 */
function ElementMouseWheelEvent(x, y, deltaX, deltaY)
{
	ElementMouseWheelEvent.base.prototype.constructor.call(this, "wheel", x, y);

	this._deltaX = deltaX;
	this._deltaY = deltaY;
}

//Inherit from ElementMouseEvent
ElementMouseWheelEvent.prototype = Object.create(ElementMouseEvent.prototype);
ElementMouseWheelEvent.prototype.constructor = ElementMouseWheelEvent;
ElementMouseWheelEvent.base = ElementMouseEvent;	

/**
 * @function getDeltaX
 * 
 * Gets the change of the X position of the mouse wheel. The system normalizes this
 * across browsers to values -1, 0, or +1. 
 * 
 * @returns int
 * The change of the X position of the mouse wheel.
 */
ElementMouseWheelEvent.prototype.getDeltaX = 
	function()
	{
		return this._deltaX;
	};
	
/**
 * @function getDeltaY
 * 
 * Gets the change of the Y position of the mouse wheel. The system normalizes this
 * across browsers to values -1, 0, or +1. 
 * 
 * @returns int
 * The change of the Y position of the mouse wheel.
 */	
ElementMouseWheelEvent.prototype.getDeltaY = 
	function()
	{
		return this._deltaY;
	};
	
//@Override
ElementMouseWheelEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementMouseWheelEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
ElementMouseWheelEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementMouseWheelEvent(this._x, this._y, this._deltaX, this._deltaY);
	};
	


/**
 * @depends ElementEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementListItemClickEvent////////////////////////////

/**
 * @class ElementListItemClickEvent
 * @inherits ElementEvent
 * 
 * Event class dispatched when a DataRenderer is clicked of type "listitemclick". 
 * 
 * 
 * @constructor ElementListItemClickEvent 
 * Creates new ElementListItemClickEvent instance.
 * 
 * @param item Object
 * The collection item associated with the DataRenderer that was clicked.
 * 
 * @param index int
 * The collection index associated with the DataRenderer that was clicked.
 */
function ElementListItemClickEvent(item, index)
{
	ElementListItemClickEvent.base.prototype.constructor.call(this, "listitemclick", false);
	
	this._item = item;
	this._index = index;
}

//Inherit from ElementEvent
ElementListItemClickEvent.prototype = Object.create(ElementEvent.prototype);
ElementListItemClickEvent.prototype.constructor = ElementListItemClickEvent;
ElementListItemClickEvent.base = ElementEvent;	

/**
 * @function getItem
 * Gets the collection item associated with the DataRenderer that was clicked.
 * 
 * @returns Object
 * The collection item associated with the DataRenderer that was clicked.
 */
ElementListItemClickEvent.prototype.getItem = 
	function()
	{
		return this._item;
	};

/**
 * @function getIndex
 * Gets the collection index associated with the DataRenderer that was clicked.
 * 
 * @returns int
 * The collection index associated with the DataRenderer that was clicked.
 */	
ElementListItemClickEvent.prototype.getIndex = 
	function()
	{
		return this._index;
	};

//@Override
ElementListItemClickEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementListItemClickEvent.base.prototype.clone.call(this);

		//No additional property copies (handled by constructor)

		return clonedEvent;
};

//@Override
ElementListItemClickEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementListItemClickEvent(this._item, this._index);
	};	


/**
 * @depends ElementEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementKeyboardEvent/////////////////////////////////

/**
 * @class ElementKeyboardEvent
 * @inherits ElementEvent
 * 
 * Event class used to represent keyboard events of type "keydown" or "keyup". 
 * Note that unlike mouse events, every "keydown" is not necessarily paired with a "keyup".
 * When a key is held down, "keydown" events will repeatedly be dispatched until the key
 * is released which will then dispatch a "keyup" event.
 * 
 * @constructor ElementKeyboardEvent 
 * Creates new ElementKeyboardEvent instance.
 * 
 * @param type String
 * String representing the event type ("keydown" or "keyup")
 * 
 * @param key String
 * Printable representation of the key. If the key is not printable such as
 * Shift or Return this should be an emtpy string "".
 * 
 * @param keyCode int
 * The keycode of the key that caused the event.
 * 
 * @param ctrl boolean
 * True if the ctrl key is pressed, false otherwise.
 * 
 * @param alt boolean
 * True if the alt key is pressed, false otherwise.
 * 
 * @param shift boolean
 * True if the shift key is pressed, false otherwise.
 * 
 * @param meta boolean
 * True if the meta key (such as windows key) is pressed, false otherwise.
 */
function ElementKeyboardEvent(type, key, keyCode, ctrl, alt, shift, meta)
{
	ElementKeyboardEvent.base.prototype.constructor.call(this, type, true);
	
	//IE key names are different... normalize
	if (key == "Spacebar")
		key = " ";
	else if (key == "Left")
		key = "ArrowLeft";
	else if (key == "Right")
		key = "ArrowRight";		
	else if (key == "Del")
		key = "Delete";
	
	this._key = key;
	this._keyCode = keyCode;
	
	this._ctrl = ctrl;
	this._alt = alt;
	this._shift = shift;
	this._meta = meta;
}

//Inherit from ElementEvent
ElementKeyboardEvent.prototype = Object.create(ElementEvent.prototype);
ElementKeyboardEvent.prototype.constructor = ElementKeyboardEvent;
ElementKeyboardEvent.base = ElementEvent;	

/**
 * @function getKey
 * 
 * Gets the printable version of the key which caused the event. 
 * 
 * @returns String
 * The printable version of the key which caused the event. Empty string "" if the
 * key is not printable.
 */
ElementKeyboardEvent.prototype.getKey = 
	function ()
	{
		return this._key;
	};
	
/**
 * @function getKeyCode
 * 
 * Gets the key code of the key which caused the event. 
 * 
 * @returns int
 * The keycode of the key which caused the event.
 */	
ElementKeyboardEvent.prototype.getKeyCode = 
	function ()
	{
		return this._keyCode;
	};	

/**
 * @function getCtrl
 * 
 * Gets the state of the ctrl key. 
 * 
 * @returns boolean
 * True if the ctrl key is pressed, otherwise false.
 */	
ElementKeyboardEvent.prototype.getCtrl = 
	function ()
	{
		return this._ctrl;
	};		

/**
 * @function getAlt
 * 
 * Gets the state of the alt key. 
 * 
 * @returns boolean
 * True if the alt key is pressed, otherwise false.
 */		
ElementKeyboardEvent.prototype.getAlt = 
	function ()
	{
		return this._alt;
	};

/**
 * @function getShift
 * 
 * Gets the state of the shift key. 
 * 
 * @returns boolean
 * True if the shift key is pressed, otherwise false.
 */	
ElementKeyboardEvent.prototype.getShift = 
	function ()
	{
		return this._shift;
	};	
	
/**
 * @function getMeta
 * 
 * Gets the state of the meta key (such as the windows key). 
 * 
 * @returns boolean
 * True if the meta key is pressed, otherwise false.
 */		
ElementKeyboardEvent.prototype.getMeta = 
	function ()
	{
		return this._meta;
	};		
	
//@Override
ElementKeyboardEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementKeyboardEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
ElementKeyboardEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementKeyboardEvent(this._type, 
				this._key, this._keyCode, 
				this._ctrl, this._alt, this._shift, this._meta);
	};	
	


/**
 * @depends ElementListItemClickEvent.js
 */

//////////////////////////////////////////////////////////////////////////
/////////////////////ElementGridItemClickEvent////////////////////////////

/**
 * @class ElementGridItemClickEvent
 * @inherits ElementListItemClickEvent
 * 
 * Event class dispatched when a DataGrid DataRenderer is clicked of type "listitemclick". 
 * 
 * 
 * @constructor ElementGridItemClickEvent 
 * Creates new ElementGridItemClickEvent instance.
 * 
 * @param item Object
 * The collection item associated with the DataRenderer that was clicked.
 * 
 * @param index int
 * The collection index associated with the DataRenderer that was clicked.
 * 
 * @param columnIndex int
 * The column index associated with the DataRenderer that was clicked.
 */
function ElementGridItemClickEvent(item, index, columnIndex)
{
	ElementGridItemClickEvent.base.prototype.constructor.call(this, item, index);
	
	this._columnIndex = columnIndex;
}

//Inherit from ElementListItemClickEvent
ElementGridItemClickEvent.prototype = Object.create(ElementListItemClickEvent.prototype);
ElementGridItemClickEvent.prototype.constructor = ElementGridItemClickEvent;
ElementGridItemClickEvent.base = ElementListItemClickEvent;	

/**
 * @function getColumnIndex
 * Gets the column index that dispatched the event.
 * 
 * @returns int
 * Column index.
 */
ElementGridItemClickEvent.prototype.getColumnIndex = 
	function()
	{
		return this._columnIndex;
	};

//@Override
ElementGridItemClickEvent.prototype.clone =
	function ()
	{
		var clonedEvent = ElementGridItemClickEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};

//@Override
ElementGridItemClickEvent.prototype._cloneInstance = 
	function ()
	{
		return new ElementListItemClickEvent(this._item, this._index, this._columnIndex);
	};	


/**
 * @depends DispatcherEvent.js
 */

///////////////////////////////////////////////////////////////////
//////////////////CollectionChangedEvent///////////////////////////	
	
/**
 * @class CollectionChangedEvent
 * @inherits DispatcherEvent
 * 
 * Event that is dispatched when a data collection is changed of type "collectionchanged". 
 * This is typically an internal event that the data driven containers use to monitor 
 * changes to their data collections.
 * 
 * 
 * @constructor CollectionChangedEvent 
 * Creates new CollectionChangedEvent instance.
 * 
 * @param kind String
 * String representing type of change that occurred to the collection.
 * Allowable values are "add", "remove", "update", and "reset".
 * 
 * @param index int
 * Index position the change occurred (or -1 if kind is "reset").
 */
function CollectionChangedEvent(kind, index)
{
	CollectionChangedEvent.base.prototype.constructor.call(this, "collectionchanged");
	
	this._kind = kind;
	this._index = index;
}	
	
//Inherit from DispatcherEvent
CollectionChangedEvent.prototype = Object.create(DispatcherEvent.prototype);
CollectionChangedEvent.prototype.constructor = CollectionChangedEvent;
CollectionChangedEvent.base = DispatcherEvent;

/**
 * @function getKind
 * Gets the kind of the collection event. Possible types are "add", "remove", "update", and "reset".
 * 
 * @returns String
 * The kind of the collection event.
 */
CollectionChangedEvent.prototype.getKind = 
	function ()
	{
		return this._kind;
	};
	
/**
 * @function getIndex
 * Gets the index of the data collection that the change occurred.
 * 
 * @returns int
 * The index of the data collection that the change occurred.
 */	
CollectionChangedEvent.prototype.getIndex = 
	function ()
	{
		return this._index;
	};

//@Override
CollectionChangedEvent.prototype.clone =
	function ()
	{
		var clonedEvent = CollectionChangedEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
CollectionChangedEvent.prototype._cloneInstance = 
	function ()
	{
		return new CollectionChangedEvent(this._kind, this._index);
	};
	
	


/**
 * @depends DispatcherEvent.js
 */

//////////////////////////////////////////////////////////////////////
/////////////////////AddedRemovedEvent////////////////////////////////		
	
/**
 * @class AddedRemovedEvent
 * @inherits DispatcherEvent
 * 
 * Event that is dispatched when a CanvasElement is added or removed from
 * a CanvasManager and can be of type "added" or "removed". This is used to detect
 * when an Element is added or removed from the display and to create / destroy or 
 * associate / dissociate resources. For example, CanvasElement uses these events
 * to add and remove event listeners to its associated StyleDefinitions which are 
 * external resources and would cause memory leaks if not cleaned up. 
 * 
 * 
 * @constructor AddedRemovedEvent 
 * Creates new AddedRemovedEvent instance.
 * 
 * @param type String
 * String representing the event type ("added" or "removed")
 * 
 * @param manager CanvasManager
 * The CanvasManager instance that the element is being added or removed.
 */
function AddedRemovedEvent(type, manager)
{
	AddedRemovedEvent.base.prototype.constructor.call(this, type);
	
	this._manager = manager;
}	
	
//Inherit from DispatcherEvent
AddedRemovedEvent.prototype = Object.create(DispatcherEvent.prototype);
AddedRemovedEvent.prototype.constructor = AddedRemovedEvent;
AddedRemovedEvent.base = DispatcherEvent;

/**
 * @function getManager
 * Gets the CanvasManager instance that the Element has been added or removed. 
 * Note that when an element is removed, the Element is no longer associated with the CanvasManager
 * so you must use this method to get the appropriate CanvasManager reference.
 * 
 * @returns CanvasManager
 * The CanvasManager instance the element is now associated with when added, or no longer associated with when removed.
 */
AddedRemovedEvent.prototype.getManager = 
	function ()
	{
		return this._manager;
	};
	
//@Override
AddedRemovedEvent.prototype.clone =
	function ()
	{
		var clonedEvent = AddedRemovedEvent.base.prototype.clone.call(this);
		
		//No additional property copies (handled by constructor)
		
		return clonedEvent;
	};
	
//@Override
AddedRemovedEvent.prototype._cloneInstance = 
	function ()
	{
		return new AddedRemovedEvent(this._type, this._manager);
	};	
	
	


//////////////////////////////////////////////////////////////////////
/////////////////////EventDispatcher//////////////////////////////////
	
/**
 * @class EventDispatcher
 * Base class for all objects that dispatch events.
 * 
 * @constructor EventDispatcher 
 * Creates new EventDispatcher instance.
 */
function EventDispatcher()
{
	this._eventListeners = Object.create(null); //Map of arrays by event name.
}
	
//EventDispatcher is base object, no inheritance.
EventDispatcher.prototype.constructor = EventDispatcher;

///////////EventDispatcher Public Functions///////////////////////////

/**
 * @function addEventListener
 * Registers an event lister function to be called when an event occurs.
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function to be called when the event occurs.
 */
EventDispatcher.prototype.addEventListener = 
	function (type, callback)
	{
		if (this._eventListeners[type] == null)
			this._eventListeners[type] = [];
		
		this._eventListeners[type].push(callback);
	};

/**
 * @function removeEventListener
 * Removes a callback from the EventDispatcher
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be removed.
 * 
 * @returns boolean
 * Returns true if the callback was successfully removed, otherwise false
 * such as if the function callback was not previously registered.
 */	
EventDispatcher.prototype.removeEventListener = 
	function (type, callback)
	{
		if (!(type in this._eventListeners))
			return false;
	
		for (var i = 0; i < this._eventListeners[type].length; i++)
		{
			if (this._eventListeners[type][i] == callback)
			{
				this._eventListeners[type].splice(i, 1);
				return true;
			}
		}
		
		return false;
	};

/**
 * @function hasEventListener
 * Checks if an event listener has been registered with this EventDispatcher
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be called when the event occurs. This may be null to check
 * if the EventDispatcher has any events registered for the provided type.
 * 
 * @returns boolean
 * Returns true if the EventDispatcher has the provided callback registered for the 
 * provided type, or any callback for the provided type if the callback parameter is null.
 * Otherwise, returns false.
 */	
EventDispatcher.prototype.hasEventListener = 
	function (type, callback)
	{
		if (!(type in this._eventListeners))
			return false;
	
		if (callback == null)
		{
			if (this._eventListeners[type].length > 0)
				return true;
			
			return false;
		}
		
		
		for (var i = 0; i < this._eventListeners[type].length; i++)
		{
			if (this._eventListeners[type][i] == callback)
				return true;
		}
		
		return false;
	};

///////////EventDispatcher Internal Functions///////////////////////////	
	
/**
 * @function _dispatchEvent
 * Dispatches an event to be processed by registered event listeners. The Event's target is the
 * EventDispatcher which called _dispatchEvent. The Event will be cloned prior to passing to callback functions
 * to ensure the callback cannot modify the Event data or properties. You can check if the event was canceled
 * by calling the Event's getIsCanceled after dispatching it. Re-dispatching the same event will re-set its canceled state to false.
 * 
 * @param event DispatcherEvent
 * The DispatcherEvent class or subclass to be dispatched. 
 */	
EventDispatcher.prototype._dispatchEvent = 
	function (event)
	{
		event._canceled = false;
	
		if (event._type in this._eventListeners && this._eventListeners[event._type].length > 0)
		{
			//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
			//we dont want to miss an event, or inconsistently dispatch newly added events.
			var listeners = this._eventListeners[event._type].slice();
			
			//TODO: Sort by priority (no priority available yet).
			
			var cloneEvent = null;
			for (var i = 0; i < listeners.length; i++)
			{
				//Clone the event so the handler can't fudge our event data.
				cloneEvent = event.clone(); 
				cloneEvent._target = this;				

				listeners[i](cloneEvent);
				
				if (cloneEvent._canceled == true)
				{
					event._canceled = true;
					return;
				}
			}
		}
	};	
	
	
	


/**
 * @depends EventDispatcher.js
 */

///////////////////////////////////////////////////////////////////
///////////////////////ToggleButtonGroup///////////////////////////

/**
 * @class ToggleButtonGroup
 * @inherits EventDispatcher
 * 
 * Convenience helper class for grouping ToggleButtons or subclasses.
 * The ToggleButtonGroup can be assigned to set of toggle buttons
 * and will only allow a single ToggleButton to be selected at a time.
 * When a ToggleButton changes state, the ToggleButtonGroup will dispatch
 * a changed event. Use this for functionality like RadioButtons and Tabs.
 * 
 * @constructor ToggleButtonGroup 
 * Creates new ToggleButtonGroup instance.
 */
function ToggleButtonGroup()
{
	ToggleButtonGroup.base.prototype.constructor.call(this);
	
	this._selectedButton = null;
	
	this._toggleButtons = [];
	
	var _self = this;
	
	this._toggleButtonChangedInstance =
		function (event)
		{
			_self._toggleButtonChanged(event);
		};
}

//Inherit from EventDispatcher
ToggleButtonGroup.prototype = Object.create(EventDispatcher.prototype);
ToggleButtonGroup.prototype.constructor = ToggleButtonGroup;
ToggleButtonGroup.base = EventDispatcher;

////////////Events/////////////////////////////////////

/**
 * @event changed DispatcherEvent
 * Dispatched when the selected ToggleButton is changed due to user interaction.
 */

//////////////Public Functions/////////////////////////////////////////

/**
 * @function addButton
 * Adds a ToggleButton or subclass to be managed by ToggleButtonGroup.
 * 
 * @param toggleButton ToggleButtonElement
 * ToggleButton or subclass to be managed by ToggleButtonGroup.
 * 
 * @returns boolean
 * True when successfully added, false if is not a instance of ToggleButton or already added.
 */	
ToggleButtonGroup.prototype.addButton = 
	function (toggleButton)
	{
		if (toggleButton == null || 
			toggleButton instanceof ToggleButtonElement == false ||
			this._toggleButtons.indexOf(toggleButton) > -1)
			return false;
		
		this._toggleButtons.push(toggleButton);
		toggleButton.addEventListener("changed", this._toggleButtonChangedInstance);
		
		return true;
	};

/**
 * @function removeButton
 * Removes a ToggleButton or subclass currently being managed by ToggleButtonGroup
 * 
 * @param toggleButton ToggleButtonElement
 * ToggleButton or subclass to be removed from ToggleButtonGroup.
 * 
 * @returns boolean
 * True when successfully removed, false if the toggle button is not currently managed by ToggleButtonGroup.
 */		
ToggleButtonGroup.prototype.removeButton = 
	function (toggleButton)
	{
		var index = this._toggleButtons.indexOf(toggleButton);
	
		if (index == -1)
			return false;
		
		this._toggleButtons.splice(index, 1);
		toggleButton.removeEventListener("changed", this._toggleButtonChangedInstance);
	};	

/**
 * @function clearButtons
 * Removes all ToggleButtons currently managed by ToggleButtonGroup.
 */		
ToggleButtonGroup.prototype.clearButtons = 
	function ()
	{
		for (var i = 0; i < this._toggleButtons.length; i++)
			this._toggleButtons[i].removeEventListener("changed", this._toggleButtonChangedInstance);
		
		this._toggleButtons = [];
	};
	
/**
 * @function setSelectedButton
 * Sets the ToggleButton to be selected.
 * 
 * @param toggleButton ToggleButtonElement
 * ToggleButton or subclass to be selected. May be set to null.
 */	
ToggleButtonGroup.prototype.setSelectedButton = 
	function (toggleButton)
	{
		if (this._selectedButton = toggleButton)
			this._selectedButton.setSelected(true);
		else if (toggleButton == null || this._toggleButtons.indexOf(toggleButton) > -1)
		{
			this._selectedButton = toggleButton;
			
			if (this._selectedButton != null)
				this._selectedButton.setSelected(true);
			
			for (var i = 0; i < this._toggleButtons.length; i++)
			{
				if (this._toggleButtons[i] != toggleButton)
					this._toggleButtons[i].setSelected(false);
			}
		}
	};
	
/**
 * @function getSelectedButton
 * Gets the selected ToggleButton.
 * 
 * @returns ToggleButtonElement
 * ToggleButton or subclass currently selected. May be null.
 */		
ToggleButtonGroup.prototype.getSelectedButton = 
	function ()
	{
		return this._selectedButton;
	};
	
////////////////////Internal/////////////////////////
	
	
/**
 * @function _toggleButtonChanged
 * Event handler for managed ToggleButton's "changed" event. 
 * Updates toggle button selected states and dispatches "changed" event.
 * 
 * @param event ElementEvent
 * ElementEvent to be processed.
 */		
ToggleButtonGroup.prototype._toggleButtonChanged = 
	function (elementEvent)
	{
		var toggleButton = elementEvent.getTarget();
		
		if (toggleButton.getSelected() == true)
			this._selectedButton = toggleButton;
		else
			this._selectedButton = null;
		
		for (var i = 0; i < this._toggleButtons.length; i++)
		{
			if (this._toggleButtons[i] != toggleButton)
				this._toggleButtons[i].setSelected(false);
		}
		
		//Dispatch changed event.
		if (this.hasEventListener("changed", null) == true)
			this._dispatchEvent(new DispatcherEvent("changed", false));
	};
	
	


/**
 * @depends EventDispatcher.js
 */

///////////////////////////////////////////////////////////////////
///////////////////////StyleDefinition/////////////////////////////	

/**
 * @class StyleDefinition
 * @inherits EventDispatcher
 * 
 * Stores a key value data set of style values by name.
 * 
 * 
 * @constructor StyleDefinition 
 * Creates new StyleDefinition instance.
 */
function StyleDefinition()
{
	StyleDefinition.base.prototype.constructor.call(this);

	this._styleMap = Object.create(null);
}

//Inherit from EventDispatcher
StyleDefinition.prototype = Object.create(EventDispatcher.prototype);
StyleDefinition.prototype.constructor = StyleDefinition;
StyleDefinition.base = EventDispatcher;

/**
 * @event stylechanged StyleChangedEvent
 * 
 * Dispatched when a style is added, cleared, or changed.
 */


/**
 * @function getStyle
 * Gets the stored style value for this object.
 * 
 * @param styleName String
 * String representing the style to return.
 * 
 * @returns Any
 * Returns the associated style value if found, otherwise undefined.
 */	
StyleDefinition.prototype.getStyle = 
	function (styleName)
	{
		if (styleName in this._styleMap)
			return this._styleMap[styleName];
		
		return undefined;
	};

/**
 * @function setStyle
 * Sets the stored style value for this object.
 * 
 * @param styleName String
 * String representing the style to set.
 * 
 * @param value Any
 * The value to store. This may be null or undefined. 
 * Note that a null style is different from an absent (undefined) style. A null style
 * will terminate a style chain lookup and return null value. An undefined style will cause
 * the system to look further up the style chain for a value. Passing undefined is the
 * same as calling clearStyle().
 */
StyleDefinition.prototype.setStyle = 
	function (styleName, value)
	{
		var oldStyle = undefined;
		if (styleName in this._styleMap)
			oldStyle = this._styleMap[styleName];
		
		//No change
		if (oldStyle === value)
			return;
	
		if (this.hasEventListener("stylechanged", null) == true)
		{
			oldStyle = this.getStyle(styleName);
			
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
			
			var newStyle = this.getStyle(styleName);
			
			//Strict equality required (undefined !== null)
			if (newStyle !== oldStyle)
				this._dispatchEvent(new StyleChangedEvent(styleName));
		}
		else
		{
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
		}
	};

/**
 * @function clearStyle
 * Clears style data from this object. This is the same 
 * passing undefined to setStyle().
 * 
 * @param styleName String
 * String representing the style to clear.
 */		
StyleDefinition.prototype.clearStyle = 
	function (styleName)
	{
		this.setStyle(styleName, undefined);
	};
	
	


/**
 * @depends StyleDefinition.js
 */

///////////////////////////////////////////////////////////////////////////	
/////////////////////////StyleData/////////////////////////////////////////

/**
 * @class StyleData
 * 
 * Storage class for style data.
 * 
 * 
 * @constructor StyleData 
 * Creates new StyleData instance.
 * 
 * @param styleName String
 * String representing style name for associated data.
 */

function StyleData(styleName)
{
	/**
	 * @member styleName string
	 * Name of associated style
	 */
	this.styleName = styleName;
	
	/**
	 * @member value Any
	 * Value of associated style 
	 */
	this.value = undefined;
	
	/**
	 * @member priority Array
	 * Array of integers representing the position 
	 * in the style chain the style was found.
	 */
	this.priority = [];
}

//StyleData is base object, no inheritance.
StyleData.prototype.constructor = StyleData;

/**
 * @function equals
 * 
 * Checks if two instances of StyleData contain the same values.
 * 
 * @param equalToStyleData StyleData
 * StyleData instance to compare.
 * 
 * @returns boolean
 * Returns true when both instances contain the same values.
 */
StyleData.prototype.equals = 
	function (equalToStyleData)
	{
		if (equalToStyleData.styleName != this.styleName || 
			equalToStyleData.priority.length != this.priority.length ||
			equalToStyleData.value !== this.value)	//Strict equality required (undefined !== null)
		{
			return false;
		}
			
		for (var i = 0; i < this.priority.length; i++)
		{
			if (equalToStyleData.priority[i] != this.priority[i])
				return false;
		}
		
		return true;
	};
	
/**
 * @function comparePriority
 * Compares the style priority (position in style chain) of two StyleData instances.
 * 
 * @param compareToStyleData StyleData
 * StyleData instance to compare.
 * 
 * @returns int
 * Returns -1 if this instance is lower priority than compareToStyleData.
 * Returns +1 if this instance is higher priority than compareToStyleData.
 * Returns 0 if this instance is the same priority as compareToStyleData.
 */	
StyleData.prototype.comparePriority = 
	function (compareToStyleData)
	{
		var minLength = Math.min(this.priority.length, compareToStyleData.priority.length);
		
		for (var i = 0; i < minLength; i++)
		{
			if (this.priority[i] < compareToStyleData.priority[i])
				return +1;
			
			if (this.priority[i] > compareToStyleData.priority[i])
				return -1;
		}

		//Dont worry about different lengths... 
		//Anything with an equal priority will be the same length.
		return 0;
	};
	

	
/**
 * @function clone
 * Duplicates an instance of StyleData (deep copy). 
 * 
 * @returns StyleData
 * A new StyleData instance identical to the cloned instance.
 */	
	StyleData.prototype.clone = 
	function ()
	{
		var cloned = new StyleData(this.styleName);
		cloned.value = this.value;
		cloned.priority = this.priority.slice();
		
		return cloned;
	};	
	
	

///////////////////////////////////////////////////////////////////////////	
///////////////////////StyleableBase///////////////////////////////////////
	
/**
 * @class StyleableBase
 * @inherits StyleDefinition
 * 
 * Internal abstract base class for classes that define styles. 
 * 
 * StylableBase defines no styles itself, but allows subclasses to define them by adding  
 * and populating static Object _StyleTypes and StyleDefinition StyleDefault on the class.
 * See example.
 * 
 * inheritable: Only applicable for CanvasElements.
 * If no explicit style is set (instance, style definition, or proxy) look up the
 * parent chain for the first element supporting the style with inheritable.
 * If no style is found up the parent chain, use the element's default style.
 * 
 * Subclasses can add new styles and override the style types or defaults of their base
 * classes by creating their own _StyleTypes and StyleDefault objects.
 * 
 * Example:
 * 
 * StylableBaseSubclass._StyleTypes = Object.create(null);
 * StylableBaseSubclass._StyleTypes.Visible = 				{inheritable:false};		
 * StylableBaseSubclass._StyleTypes.BorderType = 			{inheritable:false};		
 * StylableBaseSubclass._StyleTypes.SkinStyle = 			{inheritable:false};		
 * StylableBaseSubclass._StyleTypes.TextStyle =				{inheritable:true};			
 * StylableBaseSubclass._StyleTypes.TextFont =				{inheritable:true};			
 * StylableBaseSubclass._StyleTypes.TextSize =				{inheritable:true};			
 * 
 * StylableBaseSubclass.StyleDefault = new StyleDefinition();
 * StylableBaseSubclass.StyleDefault.setStyle("Visible", 				true);
 * StylableBaseSubclass.StyleDefault.setStyle("BorderType", 			"none");
 * StylableBaseSubclass.StyleDefault.setStyle("SkinStyle", 				null);
 * StylableBaseSubclass.StyleDefault.setStyle("TextStyle", 				"normal");
 * StylableBaseSubclass.StyleDefault.setStyle("TextFont", 				"Arial");
 * StylableBaseSubclass.StyleDefault.setStyle("TextSize", 				12);
 * 
 * 
 * @constructor StyleableBase 
 * Creates new StyleableBase instance.
 */
function StyleableBase()
{
	StyleableBase.base.prototype.constructor.call(this);
}
	
//Inherit from StyleDefinition
StyleableBase.prototype = Object.create(StyleDefinition.prototype);
StyleableBase.prototype.constructor = StyleableBase;
StyleableBase.base = StyleDefinition;

//Priority enum
StyleableBase.StylePriorities = 
	{
		INSTANCE:0,
		CLASS:1
	};

//////////////Public//////////////////////

//@override	
StyleableBase.prototype.getStyle = 
	function (styleName)
	{
		return this.getStyleData(styleName).value;
	};	

//@override
StyleableBase.prototype.setStyle = 
	function (styleName, value)
	{
		var oldStyle = undefined;
		if (styleName in this._styleMap)
			oldStyle = this._styleMap[styleName];
		
		//No change
		if (oldStyle === value)
			return;
		
		if (this.hasEventListener("stylechanged", null) == true)
		{
			var oldStyleData = this.getStyleData(styleName);			
			
			//Change style
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
			
			var newStyleData = this.getStyleData(styleName);
			
			if (oldStyleData.equals(newStyleData) == false)
				this._dispatchEvent(new StyleChangedEvent(styleName));
		}
		else
		{
			if (value === undefined)
				delete this._styleMap[styleName];
			else
				this._styleMap[styleName] = value;
		}
	};
	
/**
 * @function getStyleData
 * 
 * Gets the style data for the supplied style name, this includes
 * additional info than getStyle() such as the style priority.
 * 
 * @param styleName String
 * String representing style to return the associated StyleData.
 * 
 * @returns StyleData
 * Returns the associated StyleData
 */	
StyleableBase.prototype.getStyleData = 
	function (styleName)
	{
		var styleData = new StyleData(styleName);
	
		styleData.value = StyleableBase.base.prototype.getStyle.call(this, styleName);
		if (styleData.value !== undefined)
		{
			styleData.priority.push(StyleableBase.StylePriorities.INSTANCE);
			return styleData;			
		}
		
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(StyleableBase.StylePriorities.CLASS);
		
		return styleData;
	};
	
///////////////Internal///////////////////	
	
//@private	
StyleableBase.prototype._getStyleType = 
	function (styleName)
	{
		var thisProto = Object.getPrototypeOf(this);
		if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
			return null;
		
		var thisClass = thisProto.constructor;
		
		while (true)
		{
			if ("_StyleTypes" in thisClass && styleName in thisClass._StyleTypes)
				return thisClass._StyleTypes[styleName];
			
			thisProto = Object.getPrototypeOf(thisProto);
			if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
				return null;
			
			thisClass = thisProto.constructor;
		}
	};

/**
 * @function _getDefaultStyle
 * 
 * Gets default value for the supplied style. 
 * 
 * @param styleName String
 * String representing the default style to return.
 * 
 * @returns Any
 * Returns the associated default style value if found, otherwise undefined.
 */	
StyleableBase.prototype._getDefaultStyle = 
	function (styleName)
	{
		return this._getDefaultStyleData(styleName).value;
	};	
	
/**
 * @function _getDefaultStyleData
 * 
 * Gets default StyleData for the supplied style. 
 *  
 * @param styleName String
 * String representing the default style to return.
 * 
 * @returns StyleData
 * Returns the associated default StyleData.
 */	
StyleableBase.prototype._getDefaultStyleData = 
	function (styleName)
	{
		var styleData = new StyleData(styleName);
		
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(StyleableBase.StylePriorities.CLASS);
		
		return styleData;
	};
	
//@private	
StyleableBase.prototype._getClassStyle = 
	function (styleName)
	{
		var styleValue = undefined;
		
		var thisProto = Object.getPrototypeOf(this);
		if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
			return styleValue;
		
		var thisClass = thisProto.constructor;
		
		while (true)
		{
			if ("StyleDefault" in thisClass)
			{
				styleValue = thisClass.StyleDefault.getStyle(styleName);
				if (styleValue !== undefined)
					return styleValue;
			}
			
			thisProto = Object.getPrototypeOf(thisProto);
			if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
				return styleValue;
			
			thisClass = thisProto.constructor;
		}
	};	
	


/**
 * @depends StyleableBase.js
 */

////////////////////////////////////////////////////////
////////////////////ShapeBase///////////////////////////

/**
 * @class ShapeBase
 * @inherits StyleableBase
 * 
 * Abstract base class for drawing vector shape paths.
 * 
 * @constructor ShapeBase 
 * Creates new ShapeBase instance.
 */
function ShapeBase()
{
	ShapeBase.base.prototype.constructor.call(this);
}

//Inherit from StyleableBase
ShapeBase.prototype = Object.create(StyleableBase.prototype);
ShapeBase.prototype.constructor = ShapeBase;
ShapeBase.base = StyleableBase;

////////////Public//////////////////////

/**
 * @function drawShape
 * Used to draw a sub-path shape path to the supplied Canvas2DContext using the supplied metrics.
 * Override this to draw custom shapes. Do *not* call beginPath() as that will destroy previous 
 * sub-paths and *do not* do any filling or other context calls. Only draw and closePath() the sub-path.
 * 
 * @param ctx Canvas2DContext
 * The Canvas2DContext to draw the sub-path on.
 * 
 * @param metrics DrawMetrics
 * DrawMetrics object to use as the bounding box for the sub-path.
 */
ShapeBase.prototype.drawShape = 
	function (ctx, metrics)
	{
		//Stub for override.
	};
	
	


/**
 * @depends ShapeBase.js
 */

////////////////////////////////////////////////////////
/////////////RoundedRectangleShape//////////////////////	

/**
 * @class RoundedRectangleShape
 * @inherits ShapeBase
 * 
 * Draws rectangles and rounded rectangles.
 * 
 * @constructor RoundedRectangleShape 
 * Creates new RoundedRectangleShape instance.
 */
function RoundedRectangleShape()
{
	RoundedRectangleShape.base.prototype.constructor.call(this);
}

//Inherit from ShapeBase
RoundedRectangleShape.prototype = Object.create(ShapeBase.prototype);
RoundedRectangleShape.prototype.constructor = RoundedRectangleShape;
RoundedRectangleShape.base = ShapeBase;

/////////////Style Types///////////////////////////////

RoundedRectangleShape._StyleTypes = Object.create(null);

/**
 * @style CornerRadius Number
 * 
 * Radius size in pixels for the rectangle's corners. 
 * CornerRadius effects all corners of the rectangle.
 */
RoundedRectangleShape._StyleTypes.CornerRadius = 					{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopLeft Number
 * 
 * Radius size in pixels for the rectangle's top left corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusTopLeft = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopRight Number
 * 
 * Radius size in pixels for the rectangle's top right corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusTopRight = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomLeft Number
 * 
 * Radius size in pixels for the rectangle's bottom left corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusBottomLeft = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomRight Number
 * 
 * Radius size in pixels for the rectangle's bottom right corner.  
 * This will override the CornerRadius style unless it is null.
 */
RoundedRectangleShape._StyleTypes.CornerRadiusBottomRight = 		{inheritable:false};		// number || null


////////////Style Defaults////////////////////////////

RoundedRectangleShape.StyleDefault = new StyleDefinition();

RoundedRectangleShape.StyleDefault.setStyle("CornerRadius", 					0);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusTopLeft",				null);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusTopRight",				null);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusBottomLeft",			null);
RoundedRectangleShape.StyleDefault.setStyle("CornerRadiusBottomRight",			null);

////////////Public//////////////////////

//@Override
RoundedRectangleShape.prototype.drawShape = 
	function (ctx, metrics)
	{
		var x = metrics.getX();
		var y = metrics.getY();
		
		var width = metrics.getWidth();
		var height = metrics.getHeight();
		
		var c = this.getStyle("CornerRadius");
		var cTl = this.getStyle("CornerRadiusTopLeft");
		var cTr = this.getStyle("CornerRadiusTopRight");
		var cBl = this.getStyle("CornerRadiusBottomLeft");
		var cBr = this.getStyle("CornerRadiusBottomRight");
		
		if (c == null)
			c = 0;
		if (cTl == null)
			cTl = c;
		if (cTr == null)
			cTr = c;
		if (cBl == null)
			cBl = c;
		if (cBr == null)
			cBr = c;
		
		ctx.moveTo(x, y + cTl);
		
		if (cTl > 0)
			ctx.arcTo(x, y, 
				x + cTl, y, 
				cTl);
		
		ctx.lineTo(x + width - cTr, y);
		
		if (cTr > 0)
			ctx.arcTo(x + width, y, 
				x + width, y + cTr, 
				cTr);
		
		ctx.lineTo(x + width, y + height - cBr);
		
		if (cBr > 0)
			ctx.arcTo(x + width, y + height, 
				x + width - cBr, y + height, 
				cBr);
		
		ctx.lineTo(x + cBl, y + height);
		
		if (cBl > 0)
			ctx.arcTo(x, y + height, 
				x, y + height - cBl, 
				cBl);
		
		ctx.closePath();
	};
	
	


/**
 * @depends ShapeBase.js
 */

////////////////////////////////////////////////////////
/////////////////EllipseShape///////////////////////////

/**
 * @class EllipseShape
 * @inherits ShapeBase
 * 
 * Draws an ellipse that fills the supplied metrics rectangle.
 * 
 * @constructor EllipseShape 
 * Creates new EllipseShape instance.
 */
function EllipseShape()
{
	EllipseShape.base.prototype.constructor.call(this);
}

//Inherit from ShapeBase
EllipseShape.prototype = Object.create(ShapeBase.prototype);
EllipseShape.prototype.constructor = EllipseShape;
EllipseShape.base = ShapeBase;

////////////Public//////////////////////

//@Override
EllipseShape.prototype.drawShape = 
	function (ctx, metrics)
	{
		var w = metrics.getWidth();
		var h = metrics.getHeight();
		
		var spline4Magic = 0.551784;
		var xOffset = (w / 2) * spline4Magic;
		var yOffset = (h / 2) * spline4Magic;
		
		var xStart = metrics.getX();
		var yStart = metrics.getY();
		var xMiddle = xStart + (w / 2);
		var yMiddle = yStart + (h / 2);
		var xEnd = xStart + w;
		var yEnd = yStart + h;
		
		ctx.moveTo(xStart, yMiddle);
		ctx.bezierCurveTo(xStart, yMiddle - yOffset, xMiddle - xOffset, yStart, xMiddle, yStart);
		ctx.bezierCurveTo(xMiddle + xOffset, yStart, xEnd, yMiddle - yOffset, xEnd, yMiddle);
		ctx.bezierCurveTo(xEnd, yMiddle + yOffset, xMiddle + xOffset, yEnd, xMiddle, yEnd);
		ctx.bezierCurveTo(xMiddle - xOffset, yEnd, xStart, yMiddle + yOffset, xStart, yMiddle);
		ctx.closePath();
	};
	
	


/**
 * @depends ShapeBase.js
 */

////////////////////////////////////////////////////////
/////////////////ArrowShape/////////////////////////////	

/**
 * @class ArrowShape
 * @inherits ShapeBase
 * 
 * Draws a variety of arrow-ish shapes such as triangles, rounded pointers,
 * and traditional arrows.
 * 
 * @constructor ArrowShape 
 * Creates new ArrowShape instance.
 */
function ArrowShape()
{
	ArrowShape.base.prototype.constructor.call(this);
}

//Inherit from ShapeBase
ArrowShape.prototype = Object.create(ShapeBase.prototype);
ArrowShape.prototype.constructor = ArrowShape;
ArrowShape.base = ShapeBase;

/////////////Style Types///////////////////////////////

ArrowShape._StyleTypes = Object.create(null);

/**
 * @style Direction String
 * 
 * Determines the direction that the arrow or triangle will point. Acceptable values are "up", "down", "left", and "right".
 * Other styles are named as such when the Arrow is pointed "up". Styles do not change with orientation.
 */
ArrowShape._StyleTypes.Direction = 						{inheritable:false};		// "up" || "down" || "left" || "right"

/**
 * @style RectBaseWidth Number
 * 
 * The size in pixels used for the width of the rectangular base of the arrow. Setting this to zero creates a triangle.
 * It is preferrable to use RectBasePercentWidth so that the arrow can scale.
 */
ArrowShape._StyleTypes.RectBaseWidth = 					{inheritable:false};		// number || null

/**
 * @style RectBaseHeight Number
 * 
 * The size in pixels used for the height of the rectangular base of the arrow. Setting this to zero creates a triangle.
 * It is preferrable to use RectBasePercentHeight so that the arrow can scale.
 */
ArrowShape._StyleTypes.RectBaseHeight = 				{inheritable:false};		// number || null

/**
 * @style RectBasePercentWidth Number
 * 
 * The percentage of available width to use for the width of the rectangular base of the arrow. 
 * Acceptable values are between 0 and 100. Setting this to zero will create a triangle.
 */
ArrowShape._StyleTypes.RectBasePercentWidth = 			{inheritable:false};		// number || null

/**
 * @style RectBasePercentHeight Number
 * 
 * The percentage of available height to use for the height of the rectangular base of the arrow. 
 * Acceptable values are between 0 and 100. Setting this to zero will create a triangle.
 */
ArrowShape._StyleTypes.RectBasePercentHeight = 			{inheritable:false};		// number || null

/**
 * @style CornerRadius Number
 * 
 * Radius size in pixels for the rectangular base's corners. 
 * CornerRadius effects all corners of the rectangular base. 
 */
ArrowShape._StyleTypes.CornerRadius = 					{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopLeft Number
 * 
 * Radius size in pixels for the rectangular base's top left corner. 
 * This will override the CornerRadius style unless it is null.
 */
ArrowShape._StyleTypes.CornerRadiusTopLeft = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusTopRight Number
 * 
 * Radius size in pixels for the rectangular base's top right corner. 
 * This will override the CornerRadius style unless it is null.
 */
ArrowShape._StyleTypes.CornerRadiusTopRight = 			{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomLeft Number
 * 
 * Radius size in pixels for the rectangular base's bottom left corner. 
 * This will override the CornerRadius style unless it is null. Rounding both bottom corners
 * will give the effect of a rounded pointer. 
 */
ArrowShape._StyleTypes.CornerRadiusBottomLeft = 		{inheritable:false};		// number || null

/**
 * @style CornerRadiusBottomRight Number
 * 
 * Radius size in pixels for the rectangular base's bottom right corner. 
 * This will override the CornerRadius style unless it is null. Rounding both bottom corners
 * will give the effect of a rounded pointer. 
 */
ArrowShape._StyleTypes.CornerRadiusBottomRight = 		{inheritable:false};		// number || null


////////////Default Styles///////////////////////////

ArrowShape.StyleDefault = new StyleDefinition();

ArrowShape.StyleDefault.setStyle("Direction", 						"up");	// "up" || "down" || "left" || "right"

ArrowShape.StyleDefault.setStyle("RectBaseWidth", 					null); 	// number || null
ArrowShape.StyleDefault.setStyle("RectBaseHeight", 					null); 	// number || null
ArrowShape.StyleDefault.setStyle("RectBasePercentWidth", 			null);	// number || null
ArrowShape.StyleDefault.setStyle("RectBasePercentHeight", 			null); 	// number || null

ArrowShape.StyleDefault.setStyle("CornerRadius", 					0);		// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusTopLeft",				null);	// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusTopRight",			null);	// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusBottomLeft",			null);	// number || null
ArrowShape.StyleDefault.setStyle("CornerRadiusBottomRight",			null);	// number || null


////////////Public//////////////////////

ArrowShape.prototype.drawShape = 
	function (ctx, metrics)
	{
		var direction = this.getStyle("Direction");
		
		if (direction != "up" && direction != "down" && direction != "left" && direction != "right")
			return;
		
		var x = metrics.getX();
		var y = metrics.getY();
		var width = metrics.getWidth();
		var height = metrics.getHeight();
		
		var c = this.getStyle("CornerRadius");
		var cornerTl = this.getStyle("CornerRadiusTopLeft");
		var cornerTr = this.getStyle("CornerRadiusTopRight");
		var cornerBl = this.getStyle("CornerRadiusBottomLeft");
		var cornerBr = this.getStyle("CornerRadiusBottomRight");
		
		if (c == null)
			c = 0;
		if (cornerTl == null)
			cornerTl = c;
		if (cornerTr == null)
			cornerTr = c;
		if (cornerBl == null)
			cornerBl = c;
		if (cornerBr == null)
			cornerBr = c;
		
		var baseWidth = this.getStyle("RectBaseWidth");
		var baseHeight = this.getStyle("RectBaseHeight");
		
		if (baseWidth == null)
		{
			var rectWidthPercent = this.getStyle("RectBasePercentWidth");
			if (rectWidthPercent == null)
				baseWidth = 0;
			else
				baseWidth = Math.round(w * (rectWidthPercent / 100));
		}
		if (baseHeight == null)
		{
			var rectHeightPercent = this.getStyle("RectBasePercentHeight");
			if (rectHeightPercent == null)
				baseHeight = 0;
			else
				baseHeight = Math.round(h * (rectHeightPercent / 100));
		}
		
		if (baseWidth == 0 || baseHeight == 0)
		{
			baseWidth = 0;
			baseHeight = 0;
		}
		
		if (direction == "down")
		{
			ctx.moveTo(x + ((width - baseWidth) / 2), 
				y + cornerTl);
			
			if (cornerTl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y, 
					x + ((width - baseWidth) / 2) + cornerTl, y, 
					cornerTl);
			
			ctx.lineTo(x + ((width - baseWidth) / 2) + baseWidth - cornerTr, 
				y);
			
			if (cornerTr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y, 
					x + ((width - baseWidth) / 2) + baseWidth, y + cornerTr, 
					cornerTr);
			
			ctx.lineTo(x + ((width - baseWidth) / 2) + baseWidth, y + baseHeight - cornerBr);
			
			if (cornerBr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y + baseHeight,
					Math.min(x + ((width - baseWidth) / 2) + baseWidth + cornerBr, x + width), y + baseHeight,
					Math.min(cornerBr, (width - baseWidth) / 2));			
			
			ctx.lineTo(x + width, y + baseHeight);
			ctx.lineTo(x + (width / 2), y + height);
			ctx.lineTo(x, y + baseHeight);
			
			ctx.lineTo(Math.max(x + ((width - baseWidth) / 2) - cornerBl, x), y + baseHeight);
			
			if (cornerBl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y + baseHeight,
					x + ((width - baseWidth) / 2), y + baseHeight - cornerBl,
					Math.min(cornerBl, (width - baseWidth) / 2));
		}
		else if (direction == "left")
		{
			ctx.moveTo(x + width - cornerTr, 
					y +  ((height - baseHeight) / 2));
			
			if (cornerTr > 0)
				ctx.arcTo(x + width, y +  ((height - baseHeight) / 2), 
					x + width, y +  ((height - baseHeight) / 2) + cornerTr, 
					cornerTr);
			
			ctx.lineTo(x + width, 
				y + ((height - baseHeight) / 2) + baseHeight - cornerBr);
			
			if (cornerBr > 0)
				ctx.arcTo(x + width, y + ((height - baseHeight) / 2) + baseHeight, 
					x + width - cornerBr, y + ((height - baseHeight) / 2) + baseHeight, 
					cornerBr);
			
			ctx.lineTo(x + width - baseWidth + cornerBl, y + ((height - baseHeight) / 2) + baseHeight);
			
			if (cornerBl > 0)
				ctx.arcTo(x + width - baseWidth, y + ((height - baseHeight) / 2) + baseHeight,
					x + width - baseWidth, Math.min(y + ((height - baseHeight) / 2) + baseHeight + cornerBl, y + height),
					Math.min(cornerBl, (height - baseHeight) / 2));
			
			
			ctx.lineTo(x + width - baseWidth, y + height);
			ctx.lineTo(x, y + (height / 2));
			ctx.lineTo(x + width - baseWidth, y);
			
			ctx.lineTo(x + width - baseWidth, Math.max(y, y + ((height - baseHeight) / 2) - cornerTl));

			if (cornerTl > 0)
				ctx.arcTo(x + width - baseWidth, y + ((height - baseHeight) / 2),
					x + width - baseWidth + cornerTl, y + ((height - baseHeight) / 2),
					Math.min(cornerTl, (height - baseHeight) / 2));
		}
		else if (direction == "up")
		{
			ctx.moveTo(x + ((width - baseWidth) / 2) + baseWidth, 
				y + height - cornerBr);
			
			if (cornerBr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y + height, 
					x + ((width - baseWidth) / 2) + baseWidth - cornerBr, y + height, 
					cornerBr);
			
			ctx.lineTo(x + ((width - baseWidth) / 2) + cornerBl, 
				y + height);
			
			if (cornerBl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y + height, 
					x + ((width - baseWidth) / 2), y + height - cornerBl, 
					cornerBl);
			
			ctx.lineTo(x + ((width - baseWidth) / 2), y + height - baseHeight + cornerTl);
			
			if (cornerTl > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2), y + height - baseHeight,
					Math.max(x + ((width - baseWidth) / 2) - cornerTl, x), y + height - baseHeight,
					Math.min(cornerTl, (width - baseWidth) / 2));			
			
			
			ctx.lineTo(x, y + height - baseHeight);
			ctx.lineTo(x + (width / 2), y);
			ctx.lineTo(x + width, y + height - baseHeight);
			
			
			ctx.lineTo(Math.min(x + ((width - baseWidth) / 2) + baseWidth + cornerTr, x + width), y + height - baseHeight);
			
			if (cornerTr > 0)
				ctx.arcTo(x + ((width - baseWidth) / 2) + baseWidth, y + height - baseHeight,
					x + ((width - baseWidth) / 2) + baseWidth, y + height - baseHeight + cornerTr,
					Math.min(cornerTr, (width - baseWidth) / 2));
		}
		else if (direction == "right")
		{
			ctx.moveTo(x + cornerBl, 
				y +  ((height - baseHeight) / 2) + baseHeight);
			
			if (cornerBl > 0)
				ctx.arcTo(x, y +  ((height - baseHeight) / 2) + baseHeight, 
					x, y +  ((height - baseHeight) / 2) + baseHeight - cornerBl, 
					cornerBl);
			
			ctx.lineTo(x, 
				y + ((height - baseHeight) / 2) + cornerTl);
			
			if (cornerTl > 0)
				ctx.arcTo(x, y + ((height - baseHeight) / 2), 
					x + cornerTl, y + ((height - baseHeight) / 2), 
					cornerTl);
			
			ctx.lineTo(x + baseWidth - cornerTr, y + ((height - baseHeight) / 2));
			
			if (cornerTr > 0)
				ctx.arcTo(x + baseWidth, y + ((height - baseHeight) / 2),
					x + baseWidth, Math.max(y + ((height - baseHeight) / 2) - cornerTr, y),
					Math.min(cornerTr, (height - baseHeight) / 2));
			
			
			ctx.lineTo(x + baseWidth, y);
			ctx.lineTo(x + width, y + (height / 2));
			ctx.lineTo(x + baseWidth, y + height);
			
			ctx.lineTo(x + baseWidth, Math.min(y + height, y + ((height - baseHeight) / 2) + baseHeight + cornerBr));

			if (cornerBr > 0)
				ctx.arcTo(x + baseWidth, y + ((height - baseHeight) / 2) + baseHeight,
					x + baseWidth - cornerBr, y + ((height - baseHeight) / 2) + baseHeight,
					Math.min(cornerBr, (height - baseHeight) / 2));
		}
		
		ctx.closePath();
	};	
	
	


/**
 * @depends EventDispatcher.js
 */

///////////////////////////////////////////////////////////////////
///////////////////////ListCollection//////////////////////////////	

/**
 * @class ListCollection
 * @inherits EventDispatcher
 * 
 * ListCollection is a wrapper for an Array that dispatches "collectionchanged"
 * events when the collection is modified. This is used by data driven containers
 * like the DataList or DataGrid to track and respond to changes on their associated data.
 * 
 * 
 * @constructor ListCollection 
 * Creates new ListCollection instance.
 * 
 * @param sourceArray Array
 * Backing array to be used as the collection's source. This is used
 * if you have an existing array you want to give to the ListCollection
 * to manage. Setting this to null will cause the ListCollection to create 
 * its own internal array.
 */
function ListCollection(sourceArray)
{
	ListCollection.base.prototype.constructor.call(this);
	
	this._backingArray = [];		
	this._collectionSort = null;	
	
	if (sourceArray != null)
		this._backingArray = sourceArray;
}

//Inherit from EventDispatcher
ListCollection.prototype = Object.create(EventDispatcher.prototype);
ListCollection.prototype.constructor = ListCollection;
ListCollection.base = EventDispatcher;

/**
 * @event collectionchanged CollectionChangedEvent
 * Dispatched when the collection is modified. CollectionChangedEvents can be of kinds "add", "remove", "update", "reset",
 * and include the index which has been changed.
 */


////////////Public///////////////////////////////

/**
 * @function getLength
 * Gets the number of elements in the collection.
 * 
 * @returns int
 * The number of elements in the collection.
 */
ListCollection.prototype.getLength = 
	function ()
	{
		return this._backingArray.length;
	};

/**
 * @function setSourceArray
 * Sets the source array to be used for the collection and dispatches a "collectionchanged" "reset" event.
 * 
 * @param sourceArray Array
 * The source array to be used for the collection.
 */	
ListCollection.prototype.setSourceArray = 
	function (sourceArray)
	{
		this._backingArray = sourceArray;
		this._dispatchEvent(new CollectionChangedEvent("reset", -1));
	};
	
/**
 * @function getSourceArray
 * Gets the source array currently used for the collection.
 * 
 * @returns Array
 * The source array currently used for the collection.
 */		
ListCollection.prototype.getSourceArray = 
	function ()
	{
		return this._backingArray;
	};
	
/**
 * @function setCollectionSort
 * Sets the CollectionSort to be used when calling sort().
 * 
 * @param collectionSort CollectionSort
 * The CollectionSort to be used when calling sort(). (or null)
 */	
ListCollection.prototype.setCollectionSort = 
	function (collectionSort)
	{
		if (this._collectionSort == collectionSort)
			return; 
			
		if (!(collectionSort instanceof CollectionSort))
			throw "Invalid CollectionSort";
			
		this._collectionSort = collectionSort;
	};
	
/**
 * @function getCollectionSort
 * Gets the CollectionSort used when calling sort().
 * 
 * @returns CollectionSort
 * The CollectionSort to be used when calling sort().
 */	
ListCollection.prototype.getCollectionSort = 
	function ()
	{
		return this._collectionSort;
	};
	
/**
 * @function sort
 * Sorts the collection and dispatches a "collectionchanged" "reset" event.
 */	
ListCollection.prototype.sort = 
	function ()
	{
		if (this._backingArray == null)
			return;
	
		if (this._collectionSort == null)
			this._backingArray.sort();
		else
			this._collectionSort.sort(this._backingArray);
		
		this._dispatchEvent(new CollectionChangedEvent("reset", -1));
	};
	
/**
 * @function getItemIndex
 * Gets the collection index of the item.
 * 
 * @param item Object
 * The item to which to return the collection index.
 * 
 * @returns int
 * The collection index or -1 if the item is not in the collection.
 */	
ListCollection.prototype.getItemIndex = 
	function (item)
	{
		if (item == null)
			return -1;
		
		return this._backingArray.indexOf(item);
	};
	
/**
 * @function getItemAt
 * Gets an item in the collection at the supplied index.
 * 
 * @param index int
 * The index to which to return the collection item.
 * 
 * @returns Object
 * The collection item or null if the index is out of range.
 */		
ListCollection.prototype.getItemAt = 
	function (index)
	{
		if (index < 0 || index >= this._backingArray.length)
			return null;
	
		return this._backingArray[index];
	};
	
/**
 * @function addItem
 * Adds an item to the end of the collection and dispatches a "collectionchanged" "add" event.
 * 
 * @param item Object
 * The item to add to the collection
 * 
 * @returns Object
 * The item just added to the collection.
 */	
ListCollection.prototype.addItem = 
	function (item)
	{
		return this.addItemAt(item, this._backingArray.length);
	};
	
/**
 * @function addItemAt
 * Adds an item to the collection at the supplied index and dispatches a "collectionchanged" "add" event.
 * 
 * @param item Object
 * The item to add to the collection
 * 
 * @param index int
 * The index to insert the item.
 * 
 * @returns Object
 * The item just added to the collection, or null if the index was out of range.
 */		
ListCollection.prototype.addItemAt = 
	function (item, index)
	{
		if (index < 0 || index > this._backingArray.length || item == null)
			return null;
		
		this._backingArray.splice(index, 0, item);
		
		this._dispatchEvent(new CollectionChangedEvent("add", index));
		
		return item;
	};
	
/**
 * @function removeItem
 * Removes an item from the collection and dispatches a "collectionchanged" "remove" event.
 * 
 * @param item Object
 * The item to remove from the collection.
 * 
 * @returns Object
 * The item just removed from the collection, or null if the item was not in the collection.
 */			
ListCollection.prototype.removeItem = 
	function (item)
	{
		return this.removeItemAt(this._backingArray.indexOf(item));
	};
	
/**
 * @function removeItemAt
 * Removes an item from the collection at the supplied index and dispatches a "collectionchanged" "remove" event.
 * 
 * @param index int
 * The index to remove the item.
 * 
 * @returns Object
 * The item just removed to the collection, or null if the index was out of range.
 */		
ListCollection.prototype.removeItemAt = 
	function (index)
	{
		if (index < 0 || index >= this._backingArray.length)
			return null;
		
		var removed = this._backingArray.splice(index, 1)[0]; //Returns array of removed items.
		
		this._dispatchEvent(new CollectionChangedEvent("remove", index));
		
		return removed;
	};

/**
 * @function replaceItemAt
 * Replaces an item in the collection at the supplied index and dispatches a "collectionchanged" "update" event.
 * 
 * @param item Object
 * The new item to which replace the existing item.
 * 
 * @param index int
 * The index to replace.
 * 
 * @returns Object
 * The item just replaced, or null if the index was out of range.
 */
ListCollection.prototype.replaceItemAt = 
	function (item, index)
	{
		if (index < 0 || index >= this._backingArray.length)
			return null;
		
		var oldItem = this._backingArray[index];
		this._backingArray[index] = item;
		
		this.indexUpdated(index);
		
		return oldItem;
	};
	
/**
 * @function clear
 * Clears the collection and dispatches a "collectionchanged" "reset" event.
 */	
ListCollection.prototype.clear = 
	function ()
	{
		this._backingArray = [];
		
		this._dispatchEvent(new CollectionChangedEvent("reset", -1));
	};
	
/**
 * @function indexUpdated
 * Dispatches a "collectionchanged" "update" event. When a data objects internal
 * data is changed, call this to update the Container such as a DataList or DataGrid.
 * 
 * @param index int
 * The index to dispatch the "update" event.
 */	
ListCollection.prototype.indexUpdated = 
	function (index)
	{
		this._dispatchEvent(new CollectionChangedEvent("update", index));
	};


/////////////////////////////////////////////////////////////////////
/////////////////////DrawMetrics/////////////////////////////////////	

/**
 * @class DrawMetrics
 * 
 * Simple data structure to represent bounds. (X, Y, Width, Height). 
 * 
 * 
 * @constructor DrawMetrics 
 * Creates new DrawMetrics instance.
 */

//Supporting class used to indicate element bounds.
function DrawMetrics()
{
	this._x = 0;
	this._y = 0;
	this._width = 0;
	this._height = 0;
}	

//DrawMetrics is base object, no inheritance.
DrawMetrics.prototype.constructor = DrawMetrics;

/**
 * @function equals
 * 
 * Checks if two instances of DrawMetrics contain the same values.
 * 
 * @param drawMetrics DrawMetrics
 * DrawMetrics instance to compare.
 * 
 * @returns bool
 * True when both instances contain the same values.
 */
DrawMetrics.prototype.equals = 
	function(drawMetrics)
	{
		if (this._x == drawMetrics._x && 
			this._y == drawMetrics._y &&
			this._width == drawMetrics._width && 
			this._height == drawMetrics._height)
		{
			return true;
		}
		
		return false;
	};

/**
 * @function clone
 * Duplicates an instance of DrawMetrics. 
 * 
 * @returns DrawMetrics
 * A new DrawMetrics instance identical to the cloned instance.
 */		
DrawMetrics.prototype.clone = 
	function ()
	{
		var clonedMetrics = new DrawMetrics();
		
		clonedMetrics._x = this._x;
		clonedMetrics._y = this._y;
		clonedMetrics._width = this._width;
		clonedMetrics._height = this._height;
		
		return clonedMetrics;
	};
	
//@private (for now)	
DrawMetrics.prototype.copyFrom = 
	function (copyFromMetrics)
	{
		this._x = copyFromMetrics._x;
		this._y = copyFromMetrics._y;
		this._width = copyFromMetrics._width;
		this._height = copyFromMetrics._height;
	};
	
//@private (for now)
DrawMetrics.prototype.mergeExpand = 
	function (mergeWithDrawMetrics)
	{
		if (mergeWithDrawMetrics._x < this._x)
		{
			this._width += (this._x - mergeWithDrawMetrics._x);
			this._x = mergeWithDrawMetrics._x;
		}
		if (mergeWithDrawMetrics._y < this._y)
		{
			this._height += (this._y - mergeWithDrawMetrics._y);
			this._y = mergeWithDrawMetrics._y;
		}
		if (mergeWithDrawMetrics._x + mergeWithDrawMetrics._width > this._x + this._width)
			this._width += ((mergeWithDrawMetrics._x + mergeWithDrawMetrics._width) - (this._x + this._width));
		if (mergeWithDrawMetrics._y + mergeWithDrawMetrics._height > this._y + this._height)
			this._height += ((mergeWithDrawMetrics._y + mergeWithDrawMetrics._height) - (this._y + this._height));
	};
	
//@private (for now)	
DrawMetrics.prototype.mergeReduce = 
	function (mergeWithDrawMetrics)
	{
		if (this._x < mergeWithDrawMetrics._x)
		{
			this._width -= (mergeWithDrawMetrics._x - this._x);
			this._x = mergeWithDrawMetrics._x;
		}
		if (this._y < mergeWithDrawMetrics._y)
		{
			this._height -= (mergeWithDrawMetrics._y - this._y);
			this._y = mergeWithDrawMetrics._y;
		}
		if (this._x + this._width > mergeWithDrawMetrics._x + mergeWithDrawMetrics._width)
			this._width -= ((this._x + this._width) - (mergeWithDrawMetrics._x + mergeWithDrawMetrics._width));
		if (this._y + this._height > mergeWithDrawMetrics._y + mergeWithDrawMetrics._height)
			this._height -= ((this._y + this._height) - (mergeWithDrawMetrics._y + mergeWithDrawMetrics._height));	
	};
	
DrawMetrics.prototype.roundToPrecision = 
	function (precision)
	{
		this._x = CanvasElement.roundToPrecision(this._x, precision);
		this._y = CanvasElement.roundToPrecision(this._y, precision);
		this._width = CanvasElement.roundToPrecision(this._width, precision);
		this._height = CanvasElement.roundToPrecision(this._height, precision);
	};
	
//@private (for now)	
DrawMetrics.prototype.roundUp = 
	function ()
	{
		var x1 = this._x;
		var x2 = this._x + this._width;
		var y1 = this._y;
		var y2 = this._y + this._height;
		
		x1 = Math.floor(x1);
		x2 = Math.ceil(x2);
		y1 = Math.floor(y1);
		y2 = Math.ceil(y2);
		
		this._x = x1;
		this._y = y1;
		this._width = x2 - x1;
		this._height = y2 - y1;
	};
	
/**
 * @function getX
 * 
 * Gets the X value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The X value.
 */
DrawMetrics.prototype.getX = 
	function()
	{
		return this._x;
	};
	
/**
 * @function getY
 * 
 * Gets the Y value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The Y value.
 */	
DrawMetrics.prototype.getY = 
	function()
	{
		return this._y;
	};
	
/**
 * @function getWidth
 * 
 * Gets the Width value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The Width value.
 */		
DrawMetrics.prototype.getWidth = 
	function()
	{
		return this._width;
	};
	
/**
 * @function getHeight
 * 
 * Gets the Height value in pixels, this may be fractional. 
 * 
 * @returns Number
 * The Height value.
 */		
DrawMetrics.prototype.getHeight = 
	function()
	{
		return this._height;
	};
	
	


///////////////////////////////////////////////////////////////////////
///////////////////////DataListData////////////////////////////////////

/**
 * @class DataListData
 * 
 * Internal data storage class passed to CanvasElements when they are used as
 * DataRenderers for a DataListElement or subclass.
 * 
 * 
 * @constructor DataListData 
 * Creates new DataListData instance.
 * 
 * @param parentList DataListElement
 * The parent DataListElement or subclass.
 * 
 * @param itemIndex int
 * The Collection item index.
 */
function DataListData(parentList, itemIndex)
{
	/**
	 * @member _parentList DataListElement
	 * Read Only - The parent DataListElement or subclass. 
	 */
	this._parentList = parentList;
	
	/**
	 * @member _itemIndex int
	 * Read Only - The Collection item index.
	 */
	this._itemIndex = itemIndex;
};	


///////////////////////////////////////////////////////////////////////
///////////////////////DataGridItemData////////////////////////////////

/**
 * @class DataGridItemData
 * 
 * Internal data storage class passed to CanvasElements when they are used as
 * DataRenderers for a DataGrid.
 * 
 * 
 * @constructor DataGridItemData 
 * Creates new DataGridItemData instance.
 * 
 * @param parentGrid DataGridElement
 * The parent DataListElement or subclass.
 * 
 * @param itemIndex int
 * The Collection item index.
 * 
 * @param columnIndex int
 * The column index associated with the DataGrid renderer.
 */
function DataGridItemData(parentGrid, itemIndex, columnIndex)
{
	/**
	 * @member _parentGrid DataGridElement
	 * Read Only - The parent DataGridElement or subclass. 
	 */
	this._parentGrid = parentGrid;
	
	/**
	 * @member _itemIndex int
	 * Read Only - The Collection item index.
	 */
	this._itemIndex = itemIndex;
	
	/**
	 * @member _columnIndex int
	 * Read Only - Column index associated with the DataGrid renderer.
	 */
	this._columnIndex = columnIndex;
};	




/**
 * @depends StyleableBase.js
 */

////////////////////////////////////////////////////////
//////////////CursorDefinition//////////////////////////	

/**
 * @class CursorDefinition
 * @inherits StyleableBase
 * 
 * CursorDefintion stores styles necessary to render/animate custom cursors.
 * This is used for CanvasElement's Cursor style (roll-over cursor) and can
 * also be added directly to CanvasManager. 
 *  
 * 
 * @constructor CursorDefinition 
 * Creates new CursorDefinition instance.
 */
function CursorDefinition()
{
	CursorDefinition.base.prototype.constructor.call(this);
	
	this._cursorElement = null;
	this._addedCount = 0;
}

//Inherit from StyleableBase
CursorDefinition.prototype = Object.create(StyleableBase.prototype);
CursorDefinition.prototype.constructor = CursorDefinition;
CursorDefinition.base = StyleableBase;

/////////////Style Types///////////////////////////////

CursorDefinition._StyleTypes = Object.create(null);

/**
 * @style CursorClass CanvasElement
 * 
 * The CanvasElement constructor or browser string type to use for the cursor.
 */
CursorDefinition._StyleTypes.CursorClass = 						{inheritable:false};		// CanvasElement() constructor

/**
 * @style CursorStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the cursor class. (Including Width and Height, unless you've implemented
 * the doMeasure() function into a custom CanvasElement subclass).
 */
CursorDefinition._StyleTypes.CursorStyle = 						{inheritable:false};		// StyleDefinition

/**
 * @style CursorOffsetX Number
 * 
 * The X offset from the actual mouse position the cursor should be rendered.
 */
CursorDefinition._StyleTypes.CursorOffsetX = 					{inheritable:false};		// number

/**
 * @style CursorOffsetY Number
 * 
 * The Y offset from the actual mouse position the cursor should be rendered.
 */
CursorDefinition._StyleTypes.CursorOffsetY = 					{inheritable:false};		// number


///////////Default Styles/////////////////////////////

CursorDefinition.StyleDefault = new StyleDefinition();

CursorDefinition.StyleDefault.setStyle("CursorClass", 							"default"); 	// "browsertype" || CanvasElement() constructor
CursorDefinition.StyleDefault.setStyle("CursorStyle", 							null); 			// StyleDefinition
CursorDefinition.StyleDefault.setStyle("CursorOffsetX", 						0); 			// number
CursorDefinition.StyleDefault.setStyle("CursorOffsetY", 						0); 			// number




///////////////////////////////////////////////////////////////////
///////////////////////CollectionSort//////////////////////////////	

/**
 * @class CollectionSort
 * 
 * CollectionSort is a helper class that stores a comparatorFunction
 * and a isDecending flag used to invert the sort.
 * 
 * 
 * @constructor CollectionSort 
 * Creates new CollectionSort instance.
 * 
 * @param comparatorFunction Function
 * The sort comparator function to use when sorting an array.
 * 
 * @param isDecending boolean
 * When true invert the sort.
 */
function CollectionSort(comparatorFunction, isDecending)
{
	this._comparatorFunction = comparatorFunction;
	this._isDecending = isDecending;
	
	var _self = this;
	
	//Private function to invert the comparator (decending sort). 
	//This gets passed to Array as function pointer so there's no point in using prototype.
	this._collectionSortDecendingComparator = 
		function (objA, objB)
		{
			return _self._comparatorFunction(objB, objA);
		};
}

//No inheritance (base object)
CollectionSort.prototype.constructor = CollectionSort;

/**
 * @function setComparatorFunction
 * Sets the comparator function to be used when sorting. Comparators accept 2 parameters and return -1, 0, or +1 
 * depending on the sort relation between the 2 parameters.
 * 
 * function (objA, objB) { return objA - objB; };
 * 
 *  @param comparatorFunction Function
 *  The function to be used as the comparator.
 */
CollectionSort.prototype.setComparatorFunction = 
	function (comparatorFunction)
	{
		this._comparatorFunction = comparatorFunction;
	};
	
/**
 * @function getComparatorFunction
 * Gets the comparator function used when sorting.
 * 
 * @returns Function
 * The comparator function used when sorting.
 */	
CollectionSort.prototype.getComparatorFunction = 
	function ()
	{
		return this._comparatorFunction;
	};

/**
 * @function sort
 * Sorts an array using the comparator function and isDecending flag.
 * 
 * @param array Array
 * Array to be sorted.
 */	
CollectionSort.prototype.sort = 
	function (array)
	{
		if (this._isDecending == true)
			array.sort(this._collectionSortDecendingComparator);
		else
			array.sort(this._comparatorFunction);
	};
	
/**
 * @function setIsDecending
 * Sets the isDecending flag. True to invert the sort.
 * 
 * @param isDecending bool
 * When true, invert the sort comparator function.
 */	
CollectionSort.prototype.setIsDecending = 
	function (isDecending)
	{
		this._isDecending = isDecending;
	};
	
/**
 * @function getIsDecending
 * Gets the state of the isDecending flag.
 * 
 * @returns boolean
 * The state of the isDecending flag.
 */	
CollectionSort.prototype.getIsDecending = 
	function ()
	{
		return this._isDecending;
	};
	
	


/**
 * @depends StyleableBase.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////CanvasElement///////////////////////////////////////	
	
/**
 * @class CanvasElement
 * @inherits StyleableBase
 * 
 * Base class for all Elements to be rendered to the Canvas by CanvasManager. 
 * CanvasElement supports all basic system functions for render-able objects such 
 * as the display chain hierarchy, user interactivity and events, 
 * style management, vector based rendering, etc. 
 * 
 * CanvasElement is the most basic type that can be added to CanvasManager and can be
 * used to automatically draw shapes or any custom rendering to the canvas.
 * 
 * 
 * @constructor CanvasElement 
 * Creates new CanvasElement instance.
 */

function CanvasElement()
{
	CanvasElement.base.prototype.constructor.call(this);
	
	//Proxy styles from a different element.
	this._styleProxy = null;
	
	//This is *not* class based defaults. Its a default version of _styleDefinition.
	//Used when the framework wants to apply a default definition that override class 
	//based default styles but *not* user applied styles.
	this._styleDefinitionDefault = null; 
	
	//Assigned style definitions
	this._styleDefinitions = [];
	
	//Storage for the current background shape ShapeBase() per styling. We need to store a reference 
	//because we listen for style changed events and need to be able to remove the listener when
	//this is changed (via styles) or added/removed to display chain.
	this._backgroundShape = null;
	
	this._manager = null; //Canvas Manager reference
	this._displayDepth = 0; //Depth in display chain hierarchy
	
	//Event listeners for capture phase. (Only ElementEvent events support capture)
	this._captureListeners = Object.create(null);
	
	
	this._name = null;	//User defined identifier
	
	/**
	 * @member _x Number
	 * Read only - X position in pixels relative to this elements parent. This is not updated immediately, only
	 * after our parent has finished its layout phase.
	 */
	this._x = 0;
	
	/**
	 * @member _y Number
	 * Read only - Y position in pixels relative to this elements parent. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._y = 0;
	
	/**
	 * @member _width Number
	 * Read only - This element's actual width in pixels. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._width = 0;
	
	/**
	 * @member _height Number
	 * Read only - This element's actual height in pixels. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._height = 0;
	
	/**
	 * @member _measuredWidth Number
	 * Read only - This element's measured width in pixels. This is not updated immediately, only
	 * after this element has finished its measure phase will this be valid.
	 */
	this._measuredWidth = 0;
	
	/**
	 * @member _measuredHeight Number
	 * Read only - This element's measured height in pixels. This is not updated immediately, only
	 * after this element has finished its measure phase will this be valid.
	 */
	this._measuredHeight = 0;
	
	/**
	 * @member _mouseIsOver boolean
	 * Read only - true if the mouse is over this element, otherwise false.
	 */
	this._mouseIsOver = false;
	
	/**
	 * @member _mouseIsDown boolean
	 * Read only - true if the mouse is pressed on this element, otherwise false.
	 */
	this._mouseIsDown = false;
	
	/**
	 * @member _isFocused boolean
	 * Read only - true if this element currently has focus, otherwise false.
	 */
	this._isFocused = false;
	
	/**
	 * @member _rotateDegrees Number
	 * Read only - Degrees this element is rotated. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._rotateDegrees = 0;
	
	/**
	 * @member _rotateCenterX Number
	 * Read only - The X position relative to the element's parent this element is rotated around. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._rotateCenterX = 0;
	
	/**
	 * @member _rotateCenterY Number
	 * Read only - The Y position relative to the element's parent this element is rotated around. This is not updated immediately, only
	 * after our parent has finished its layout phase will this be valid.
	 */
	this._rotateCenterY = 0;
	
	/**
	 * @member _parent CanvasElement
	 * Read only - This elements parent element.
	 */
	this._parent = null; 	
	
	this._children = [];
	
	this._stylesInvalid = true;
	this._stylesInvalidMap = Object.create(null);	//Dirty map of changed styles for _doStylesChanged()
	this._stylesValidateNode = new CmLinkedNode();	//Reference to linked list iterator
	this._stylesValidateNode.data = this;
	
	//getStyle() can potentially be an expensive operation, we cache the value for performance and comparison when external styles change.
	this._stylesCache = Object.create(null);		
	
	this._measureInvalid = true;					//Dirty flag for _doMeasure()
	this._measureValidateNode = new CmLinkedNode();	//Reference to linked list iterator
	this._measureValidateNode.data = this;
	
	this._layoutInvalid = true;						//Dirty flag for _doLayout()
	this._layoutValidateNode = new CmLinkedNode(); 	//Reference to linked list iterator
	this._layoutValidateNode.data = this;
	
	this._renderInvalid = true;						//Dirty flag for _doRender()
	this._renderValidateNode = new CmLinkedNode();	//Reference to linked list iterator
	this._renderValidateNode.data = this;
	
	//Off screen canvas for rendering this element.
	this._graphicsCanvas = null;
	this._graphicsCtx = null;
	this._graphicsClear = true;					//Optimization, sometimes we may *have* a canvas, but its been cleared so no need to render.
	
	//Metrics used for redraw region relative to composite parents (and ourself if we're a composite layer).
	this._compositeMetrics = [];				//Array of {element:element, metrics:DrawMetrics, drawableMetrics:DrawMetrics}
	
	this._renderChanged = true;					//Dirty flag for redraw region set to true when _graphicsCanvas has been modified.
	this._renderVisible = false; 				//False if any element in the composite parent chain is not visible.	
	
	/////////Composite Rendering////////////////
	
	//Composite rendering is used for effects like shadow, alpha, and transformations which
	//require aggregating child renderings, then re-rendering with the desired effect.
	//When an element requires composite rendering, it and its children are rendered to _compositeCanvas,
	//then _compositeCanvas is rendered to the parent composite (or root canvas) and appropriate effects are applied.
	//These values are only populated when this element requires composite rendering.
	
	this._compositeRenderInvalid = false;
	this._compositeRenderValidateNode = new CmLinkedNode();
	this._compositeRenderValidateNode.data = this;
	
	this._compositeEffectChanged = true;
	
	//Pre-effect / transform. Utilizes re-draw regions when rendering.
	this._compositeVisibleMetrics = null;			//Visible area of the composite layer.																			
	this._redrawRegionMetrics = null;				//Region to redraw																								
	
	this._compositeCtx = null;						//Graphics context																								
	this._compositeCanvas = null;					//Off screen canvas for aggregate rendering of this + child renderings.											
	this._compositeCanvasMetrics = null;			//Metrics of the composite canvas. 																				
	
	//Post-effect / transform. 
	this._transformVisibleMetrics = null;			//Transformed _compositeVisibleMetrics
	this._transformDrawableMetrics = null;			//Transformed _compositeVisibleMetrics region after clipping is applied															
	////////////////////////////////////////////
	
	
	this._rollOverCursorInstance = null; 			//Reference to cursor list iterator for roll-over cursor.
	
	this._renderFocusRing = false;
	
	var _self = this;
	
	//Private event handlers, need instance for each element, proxy to prototype.
	this._onExternalStyleChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onExternalStyleChanged(styleChangedEvent);
		};
	
	this._onBackgroundShapeStyleChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onBackgroundShapeStyleChanged(styleChangedEvent);
		};
		
	this._onCanvasElementAddedRemovedInstance = 
		function (addedRemovedEvent)
		{
			if (addedRemovedEvent.getType() == "added")
				_self._onCanvasElementAdded(addedRemovedEvent);
			else if (addedRemovedEvent.getType() == "removed")
				_self._onCanvasElementRemoved(addedRemovedEvent);
		};
		
	this._onCanvasElementCursorOverOutInstance = 
		function (elementEvent)
		{
			_self._updateRolloverCursorDefinition();
		};
		
		
	//Listen for added/removed to display chain. (Setup / Cleanup)	
	this.addEventListener("added", this._onCanvasElementAddedRemovedInstance);
	this.addEventListener("removed", this._onCanvasElementAddedRemovedInstance);
	
	
	//////////Dynamic Properties////////////////  //Added at runtime when required.
	
	///////DataRenderer/////////////
	
	/**
	 * @member _listData DataListData
	 * Read only - List data provided by parent DataList when acting as a DataRenderer
	 */
	//this._listData = any;
	
	/**
	 * @member _itemData Object
	 * Read only - Collection item associated with this DataRenderer
	 */
	//this._itemData = any;
	
	/**
	 * @member _listSelected Any
	 * Read only - DataRenderer selected state.
	 */
	//this._listSelected = any;
	
	////////////////////////////////
}

//Inherit from StyleableBase
CanvasElement.prototype = Object.create(StyleableBase.prototype);
CanvasElement.prototype.constructor = CanvasElement;
CanvasElement.base = StyleableBase;

//Style priority enum
CanvasElement.StylePriorities = 
{
	INSTANCE:0,
	DEFINITION:1,
	PROXY:2,
	INHERITED:3,
	DEFAULT_DEFINITION:4,
	DEFAULT_PROXY:5,
	CLASS:6
};

////////////Events/////////////////////////////////////

/**
 * @event localechanged DispatcherEvent
 * @broadcast
 * Dispatched when CanvasManager's locale selection changes.
 * 
 * @event enterframe DispatcherEvent
 * @broadcast
 * Dispatched at the beginning of the render frame before any life cycle processing begins.
 * 
 * @event mousemoveex ElementMouseEvent
 * @broadcast
 * Dispatched when the mouse moves anywhere, even outside of the browser window. Mouse coordinates are relative to CanvasManager.
 * 
 * @event resize DispatcherEvent
 * Dispatched when the element's size changes.
 * 
 * @event layoutcomplete DispatcherEvent
 * Typically an internal event. Dispatched when an element has completed its
 * layout phase. This is used when it is necessary to wait for an element to
 * finish its layout pass so things such as its PercentWidth calculation is complete.
 * This is very expensive and should only be used when absolutely necessary. Its usually
 * only needed when elements are not directly related via parent/child. 
 * For example, DropdownElement uses this to adjust the height of the dropdown popup
 * since we do not know how much height it will need until after it has finished layout.
 * 
 * @event keydown ElementKeyboardEvent
 * Dispatched when the element has focus and a key is pressed, repeatedly dispatched if the key is held down.
 * 
 * @event keyup ElementKeyboardEvent
 * Dispatched when the element has focus and a key is released.
 * 
 * @event mousedown ElementMouseEvent
 * Dispatched when the mouse is pressed over this element.
 * 
 * @event mouseup ElementMouseEvent
 * Dispatched when the mouse is released. Note that the mouse may not still be over the element.
 * 
 * @event click ElementMouseEvent
 * Dispatched when the mouse is pressed and released over the same element.
 * 
 * @event mousemove ElementMouseEvent
 * Dispatched when the mouse moves over this element.
 * 
 * @event wheel ElementMouseWheelEvent
 * Dispatched when the mouse wheel is rolled while over this element.
 * 
 * @event dragging ElementEvent
 * Dispatched when this element is moved due to it being dragged.
 * 
 * @event rollover ElementEvent
 * Dispatched when the mouse moves over this element.
 * 
 * @event rollout ElementEvent
 * Dispatched when the mouse moves outside of this element.
 * 
 * @event focusin ElementEvent
 * Dispatched when this element gains focus.
 * 
 * @event focusout ElementEvent
 * Dispatched when this element loses focus.
 * 
 * @event added AddedRemovedEvent
 * Dispatched when this element is added to the display hierarchy and becomes a descendant of CanvasManager. 
 * 
 * @event removed AddedRemovedEvent
 * Dispatched when this element is removed from the display hierarchy and is no longer a descendant of CanvasManager. 
 */


/////////////Style Types///////////////////////////////

CanvasElement._StyleTypes = Object.create(null);

//Rendering
/**
 * @style Visible boolean
 * 
 * When false the element will not be rendered.
 */
CanvasElement._StyleTypes.Visible = 				{inheritable:false};		// true || false

/**
 * @style BorderType String
 * 
 * Determines the border type the CanvasElement should render. Allowable values are
 * "none", "solid", "inset", or "outset". Note that borders are internal and drawn on the inside
 * of the elements bounding area.
 */
CanvasElement._StyleTypes.BorderType = 				{inheritable:false};		// "none" || "solid" || "inset" || "outset"

/**
 * @style BorderColor String
 * 
 * Hex color value to be used when drawing the border. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.BorderColor = 			{inheritable:false};		// "#FF0000" or null

/**
 * @style BorderThickness Number
 * 
 * Thickness in pixels to be used when drawing the border. 
 */
CanvasElement._StyleTypes.BorderThickness = 		{inheritable:false};		// number

/**
 * @style BackgroundColor String
 * 
 * Hex color value to be used when drawing the background. This may be set to null and no
 * background will be rendered. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.BackgroundColor = 		{inheritable:false};		// "#FF0000" or null

/**
 * @style ShadowSize Number
 * 
 * Size in pixels that the drop shadow should be rendered. Note that the drop shadow may be rendered
 * outside the elements bounding area. This will cause the element to be composite rendered.
 */
CanvasElement._StyleTypes.ShadowSize = 				{inheritable:false};		// number

/**
 * @style ShadowOffsetX Number
 * 
 * X offset that the drop shadow will be rendered.
 */
CanvasElement._StyleTypes.ShadowOffsetX = 			{inheritable:false};		// number

/**
 * @style ShadowOffsetY Number
 * 
 * Y offset that the drop shadow will be rendered.
 */
CanvasElement._StyleTypes.ShadowOffsetY = 			{inheritable:false};		// number

/**
 * @style ShadowColor String
 * 
 * Hex color value to be used when drawing the drop shadow. This may be set to null and no
 * shadow will be rendered. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.ShadowColor = 			{inheritable:false};		// "#FF0000" or null

/**
 * @style Alpha Number
 * 
 * Alpha value to use when rendering this component. Allowable values are between 0 and 1 with
 * 0 being transparent and 1 being opaque. This causes the element to perform composite rendering
 * when a value between 1 and 0 is used.
 */
CanvasElement._StyleTypes.Alpha = 					{inheritable:false};		// number

/**
 * @style AutoGradientType String
 * 
 * Determines the type of gradient to be used when rendering the element's background.
 * Allowable values are "none", "linear", or "radial". Auto gradients automatically lighten
 * and darken the associated color are always rendered in the same direction relative to the 
 * canvas itself regardless of rotation or transformation applied to the element. 
 * This is used to create effects like a consistent light source even if the element is rotating.
 */
CanvasElement._StyleTypes.AutoGradientType = 		{inheritable:false};		// "none" || "linear" || "radial"

/**
 * @style AutoGradientStart Number
 * 
 * Color offset to apply to the start of the gradient. Allowable values are numbers between 
 * -1 (white) and +1 (black). 
 */
CanvasElement._StyleTypes.AutoGradientStart = 		{inheritable:false};		// number (-1 to +1 values)

/**
 * @style AutoGradientStop Number
 * 
 * Color offset to apply to the end of the gradient. Allowable values are numbers between 
 * -1 (white) and +1 (black). 
 */
CanvasElement._StyleTypes.AutoGradientStop = 		{inheritable:false};		// number (-1 to +1 values)

/**
 * @style ClipContent boolean
 * 
 * Determines if out of bounds rendering is allowed. If true the element will clip all rendering
 * and children's rendering to the elements bounding box. 
 */
CanvasElement._StyleTypes.ClipContent = 			{inheritable:false};		// number (true || false)

/**
 * @style SkinState String
 * 
 * This is an internal style used to toggle an element's current skin for different states such
 * as normal, mouse-over, mouse-down, etc. Its also commonly used by skin classes to identify their skin state.
 */
CanvasElement._StyleTypes.SkinState = 				{inheritable:false};		// "state"

/**
 * @style BackgroundShape ShapeBase
 * 
 * Shape to be used when rendering the elements background. May be any ShapeBase subclass instance.
 */
CanvasElement._StyleTypes.BackgroundShape = 		{inheritable:false};		// ShapeBase()

/**
 * @style FocusColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing the elements focus indicator. Format "#FF0000" (Red). 
 * The focus indicator is only rendered when the element gains focus due to a tab stop.
 */
CanvasElement._StyleTypes.FocusColor = 				{inheritable:true};			// color ("#000000")

/**
 * @style FocusThickness Number
 * @inheritable
 * 
 * Size in pixels that the focus ring should be rendered. Note that the focus ring is rendered
 * outside the elements bounding area.
 */
CanvasElement._StyleTypes.FocusThickness =			{inheritable:true};			// number


//Layout
/**
 * @style Padding Number
 * 
 * Size in pixels that inner content should be spaced from the outer bounds of the element. 
 * Padding effects all sides of the element. Padding may be negative under certain circumstances like
 * expanding an inner child to allow border collapsing with its parent.
 */
CanvasElement._StyleTypes.Padding = 				{inheritable:false};		// number

/**
 * @style PaddingTop Number
 * 
 * Size in pixels that inner content should be spaced from the upper bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingTop = 				{inheritable:false};		// number or null

/**
 * @style PaddingBottom Number
 * 
 * Size in pixels that inner content should be spaced from the lower bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingBottom = 			{inheritable:false};		// number or null

/**
 * @style PaddingLeft Number
 * 
 * Size in pixels that inner content should be spaced from the left most bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingLeft = 			{inheritable:false};		// number or null

/**
 * @style PaddingRight Number
 * 
 * Size in pixels that inner content should be spaced from the right most bounds of the element. 
 * This will override the Padding style.
 */
CanvasElement._StyleTypes.PaddingRight = 			{inheritable:false};		// number or null


//Functional

/**
 * @style Enabled boolean
 * 
 * When false disables user interaction with the element.
 */
CanvasElement._StyleTypes.Enabled = 				{inheritable:false};		// true || false

/**
 * @style MouseEnabled boolean
 * 
 * When false disables mouse events for the element.
 */
CanvasElement._StyleTypes.MouseEnabled = 			{inheritable:false};		// true || false

/**
 * @style Draggable boolean
 * 
 * When true allows the element to be dragged by the user. This does not work for containers
 * that do not allow absolute positioning such as a ListContainer.
 */
CanvasElement._StyleTypes.Draggable = 				{inheritable:false};		// true || false

/**
 * @style Cursor CursorDefinition
 * 
 * Specifies the cursor to be displayed when the mouse is over the element. A custom CursorDefinition
 * may be used or a browser type String ("text", "none", etc) may be used.
 */
CanvasElement._StyleTypes.Cursor = 					{inheritable:false};		// CursorDefinition()

/**
 * @style TabStop int
 * 
 * Determines if an element can be focused using tab stops. -1 indicates the element cannot
 * take focus, 0 is default and the element will be focused in the order it appears in the display chain.
 * Numbers higher than 0 indicate a specific order to be used (not yet implemented).
 */
CanvasElement._StyleTypes.TabStop = 				{inheritable:false};		// number


//Container Placement
/**
 * @style X Number
 * 
 * The X position the element should be rendered relative to its parent container. This only
 * works if the element is a child of an AnchorContainer.
 */
CanvasElement._StyleTypes.X =						{inheritable:false};		// number || null

/**
 * @style Y Number
 * 
 * The Y position the element should be rendered relative to its parent container. This only
 * works if the element is a child of an AnchorContainer.
 */
CanvasElement._StyleTypes.Y =						{inheritable:false};		// number || null

/**
 * @style Width Number
 * 
 * The Width the element should be rendered relative to its parent container. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.Width =					{inheritable:false};		// number || null

/**
 * @style Height Number
 * 
 * The Height the element should be rendered relative to its parent container. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.Height =					{inheritable:false};		// number || null

/**
 * @style Top Number
 * 
 * The distance the element should be positioned from the upper bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Top =						{inheritable:false};		// number || null

/**
 * @style Left Number
 * 
 * The distance the element should be positioned from the left most bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Left =					{inheritable:false};		// number || null

/**
 * @style Bottom Number
 * 
 * The distance the element should be positioned from the lower bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Bottom =					{inheritable:false};		// number || null

/**
 * @style Right Number
 * 
 * The distance the element should be positioned from the right most bounds of the parent container. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.Right =					{inheritable:false};		// number || null

/**
 * @style PercentWidth Number
 * 
 * The percentage of available width the element should consume relative to its parent container. This only
 * works if the element is a child of a Container element. Note that percentage width is calculated
 * based on the available space left over *after* static sized elements considered. Percentages
 * are allowed to add to more than 100 and will consume all of the available space. For containers
 * like ListContainers, when percents add to more than 100 the elements will share the available space
 * per the ratio of percent vs total percent used so it is perfectly reasonable to set 3 elements all
 * to 100 and allow them to split the real-estate by 3.
 */
CanvasElement._StyleTypes.PercentWidth =			{inheritable:false};		// number || null

/**
 * @style PercentHeight Number
 * 
 * The percentage of available height the element should consume relative to its parent container. This only
 * works if the element is a child of a Container element. Note that percentage height is calculated
 * based on the available space left over *after* static sized elements considered. Percentages
 * are allowed to add to more than 100 and will consume all of the available space. For containers
 * like ListContainers, when percents add to more than 100 the elements will share the available space
 * per the ratio of percent vs total percent used so it is perfectly reasonable to set 3 elements all
 * to 100 and allow them to split the real-estate by 3.
 */
CanvasElement._StyleTypes.PercentHeight =			{inheritable:false};		// number || null

/**
 * @style MinWidth Number
 * 
 * The minimum width in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MinWidth =				{inheritable:false};		// number || null

/**
 * @style MinHeight Number
 * 
 * The minimum height in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MinHeight =				{inheritable:false};		// number || null

/**
 * @style MaxWidth Number
 * 
 * The maximum width in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MaxWidth =				{inheritable:false};		// number || null

/**
 * @style MaxHeight Number
 * 
 * The maximum height in pixels the element should consume. This only
 * works if the element is a child of a Container element.
 */
CanvasElement._StyleTypes.MaxHeight =				{inheritable:false};		// number || null

/**
 * @style HorizontalCenter Number
 * 
 * The distance in pixels from the horizontal center of the parent the element should be positioned.
 * Negative numbers indicate left of center, positive right of center. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.HorizontalCenter =		{inheritable:false};		// number || null

/**
 * @style VerticalCenter Number
 * 
 * The distance in pixels from the vertical center of the parent the element should be positioned.
 * Negative numbers indicate left of center, positive right of center. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.VerticalCenter =			{inheritable:false};		// number || null

/**
 * @style RotateDegrees Number
 * 
 * The number of degrees the element should be rotated (clockwise). When no RotateCenterX or
 * RotateCenterY is set, the element is rotated via its center point and rotated objects are
 * still positioned relative to their parent's coordinate plane after the transform has occurred.
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.RotateDegrees = 			{inheritable:false};		// number

/**
 * @style RotateCenterX Number
 * 
 * The X position of the parent container the element should be rotated around. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.RotateCenterX = 			{inheritable:false};		// number || null

/**
 * @style RotateCenterY Number
 * 
 * The Y position of the parent container the element should be rotated around. 
 * This only works if the element is a child of an AnchorContainer. 
 */
CanvasElement._StyleTypes.RotateCenterY = 			{inheritable:false};		// number || null

/**
 * @style IncludeInLayout boolean
 * 
 * When false, the element is no longer considered in the parent container's layout. 
 * Typically this is used in conjunction with Visible, however sometimes you may want to
 * hide an element, but still have it consume container space.
 */
CanvasElement._StyleTypes.IncludeInLayout = 		{inheritable:false};		// true || false

/**
 * @style CompositeLayer boolean
 * 
 * When true, this element renders itself and all children to a single layer and is treated
 * by its parent as a single element when rendering.  This is necessary and automatically enabled
 * for styles like alpha where the component and all its children must be pre-rendered, and then 
 * re-rendered with the appropriate effect.  
 * 
 * This is very expensive but can also be very beneficial when used appropriately.  
 * For example, if you have an application with a scrolling or constantly changing background
 * thereby always causing a full screen redraw, its beneficial to make the layer on top of the
 * background a composite layer.  This effectively buffers the layer. Only the delta changes
 * will be drawn to the composite. Otherwise the entire display chain would have to be re-drawn 
 * when the background moves. This is memory intensive as it effectively duplicates the rendering
 * area. Composite elements/children changing will update the composite layer, then that region of the 
 * composite layer needs to be copied up to the parent, resulting in an additional buffer copy.
 */
CanvasElement._StyleTypes.CompositeLayer = 					{inheritable:false};		//true || false

//Text
/**
 * @style TextStyle String
 * @inheritable
 * 
 * Determines the style to render text. Available values are "normal", "bold", "italic", and "bold italic".
 */
CanvasElement._StyleTypes.TextStyle =						{inheritable:true};		// "normal" || "bold" || "italic" || "bold italic"

/**
 * @style TextFont String
 * @inheritable
 * 
 * Determines the font family to use when rendering text such as "Arial".
 */
CanvasElement._StyleTypes.TextFont =						{inheritable:true};		// "Arial"

/**
 * @style TextSize int
 * @inheritable
 * 
 * Determines the size in pixels to render text.
 */
CanvasElement._StyleTypes.TextSize =						{inheritable:true};		// number

/**
 * @style TextAlign String
 * @inheritable
 * 
 * Determines alignment when rendering text. Available values are "left", "center", and "right".
 */
CanvasElement._StyleTypes.TextAlign =						{inheritable:true};		// "left" || "center" || "right"

/**
 * @style TextBaseline String
 * @inheritable
 * 
 * Determines the baseline when rendering text. Available values are "top", "middle", or "bottom".
 */
CanvasElement._StyleTypes.TextBaseline =					{inheritable:true};  	// "top" || "middle" || "bottom"

/**
 * @style LinePaddingTop Number
 * @inheritable
 * 
 * Padding to apply to the top of each line of text. This also impacts the size of the highlight background.
 * This is useful when using strange fonts that exceed their typical vertical bounds.
 */
CanvasElement._StyleTypes.TextLinePaddingTop = 				{inheritable:true};		// number

/**
 * @style LinePaddingBottom Number
 * @inheritable
 * 
 * Padding to apply to the bottom of each line of text. This also impacts the size of the highlight background.
 * This is useful when using strange fonts that exceed their typical vertical bounds.
 */
CanvasElement._StyleTypes.TextLinePaddingBottom = 			{inheritable:true};		// number

/**
 * @style TextLineSpacing Number
 * @inheritable
 * 
 * Vertical line spacing in pixels.
 */
CanvasElement._StyleTypes.TextLineSpacing = 				{inheritable:true};		// number

/**
 * @style TextColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing text. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextColor =						{inheritable:true};		// "#000000"

/**
 * @style TextFillType String
 * @inheritable
 * 
 * Determines the fill type when rendering text. Available values are "fill" and "stroke".
 * Stroke draws a border around characters, while fill completely fills them.
 */
CanvasElement._StyleTypes.TextFillType =					{inheritable:true};		// "fill" || "stroke"

/**
 * @style TextHighlightedColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing highlighted text. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextHighlightedColor = 			{inheritable:true};		// color "#000000"

/**
 * @style TextHighlightedColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing highlighted text background. Format like "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextHighlightedBackgroundColor = 	{inheritable:true};		// color "#000000"

/**
 * @style TextCaretColor String
 * @inheritable
 * 
 * Hex color value to be used when drawing blinking text caret. "#FF0000" (red)
 */
CanvasElement._StyleTypes.TextCaretColor = 					{inheritable:true};		// color "#000000"


/////////////Default Styles///////////////////////////////

CanvasElement.StyleDefault = new StyleDefinition();
//CanvasElement specific styles.
CanvasElement.StyleDefault.setStyle("Visible", 							true);
CanvasElement.StyleDefault.setStyle("BorderType", 						"none");
CanvasElement.StyleDefault.setStyle("BorderColor", 						"#000000");
CanvasElement.StyleDefault.setStyle("BorderThickness", 					1);
CanvasElement.StyleDefault.setStyle("BackgroundColor", 					null); 
CanvasElement.StyleDefault.setStyle("ShadowSize", 						0);
CanvasElement.StyleDefault.setStyle("ShadowOffsetX",					0);
CanvasElement.StyleDefault.setStyle("ShadowOffsetY",					0);
CanvasElement.StyleDefault.setStyle("ShadowColor",						"#000000");
CanvasElement.StyleDefault.setStyle("Alpha", 							1);
CanvasElement.StyleDefault.setStyle("AutoGradientType",					"none");
CanvasElement.StyleDefault.setStyle("AutoGradientStart",				(0.15));
CanvasElement.StyleDefault.setStyle("AutoGradientStop",					(-0.15));
CanvasElement.StyleDefault.setStyle("ClipContent",						false);
CanvasElement.StyleDefault.setStyle("SkinState", 						"");
CanvasElement.StyleDefault.setStyle("BackgroundShape", 					null); 		//ShapeBase
CanvasElement.StyleDefault.setStyle("FocusColor", 						"#3333FF");	// color ("#000000")
CanvasElement.StyleDefault.setStyle("FocusThickness", 					1);			// number

CanvasElement.StyleDefault.setStyle("Padding", 							0); 		//Not necessary, just for completeness
CanvasElement.StyleDefault.setStyle("PaddingTop", 						0);
CanvasElement.StyleDefault.setStyle("PaddingBottom",					0);
CanvasElement.StyleDefault.setStyle("PaddingLeft", 						0);
CanvasElement.StyleDefault.setStyle("PaddingRight", 					0);

CanvasElement.StyleDefault.setStyle("Enabled", 							true);
CanvasElement.StyleDefault.setStyle("MouseEnabled", 					true);
CanvasElement.StyleDefault.setStyle("Draggable", 						false);
CanvasElement.StyleDefault.setStyle("Cursor", 							null);		// "browsertype" || CursorDefinition
CanvasElement.StyleDefault.setStyle("TabStop", 							-1);		// number

CanvasElement.StyleDefault.setStyle("X", 								null);
CanvasElement.StyleDefault.setStyle("Y", 								null);
CanvasElement.StyleDefault.setStyle("Width", 							null);
CanvasElement.StyleDefault.setStyle("Height", 							null);
CanvasElement.StyleDefault.setStyle("Top", 								null);
CanvasElement.StyleDefault.setStyle("Left", 							null);
CanvasElement.StyleDefault.setStyle("Bottom", 							null);
CanvasElement.StyleDefault.setStyle("Right", 							null);
CanvasElement.StyleDefault.setStyle("PercentWidth", 					null);
CanvasElement.StyleDefault.setStyle("PercentHeight", 					null);
CanvasElement.StyleDefault.setStyle("MinWidth", 						5);		
CanvasElement.StyleDefault.setStyle("MinHeight", 						5);
CanvasElement.StyleDefault.setStyle("MaxWidth", 						null);
CanvasElement.StyleDefault.setStyle("MaxHeight", 						null);
CanvasElement.StyleDefault.setStyle("HorizontalCenter", 				null);
CanvasElement.StyleDefault.setStyle("VerticalCenter", 					null);
CanvasElement.StyleDefault.setStyle("RotateDegrees", 					0);
CanvasElement.StyleDefault.setStyle("RotateCenterX", 					null);
CanvasElement.StyleDefault.setStyle("RotateCenterY", 					null);
CanvasElement.StyleDefault.setStyle("IncludeInLayout", 					true);
CanvasElement.StyleDefault.setStyle("CompositeLayer",					false);

CanvasElement.StyleDefault.setStyle("TextStyle", 						"normal");
CanvasElement.StyleDefault.setStyle("TextFont", 						"Arial");
CanvasElement.StyleDefault.setStyle("TextSize", 						12);
CanvasElement.StyleDefault.setStyle("TextAlign",						"left");
CanvasElement.StyleDefault.setStyle("TextBaseline", 					"middle");
CanvasElement.StyleDefault.setStyle("TextLinePaddingTop", 				1);
CanvasElement.StyleDefault.setStyle("TextLinePaddingBottom", 			1);
CanvasElement.StyleDefault.setStyle("TextLineSpacing", 					0);
CanvasElement.StyleDefault.setStyle("TextColor", 						"#000000");
CanvasElement.StyleDefault.setStyle("TextFillType", 					"fill");
CanvasElement.StyleDefault.setStyle("TextHighlightedColor", 			"#FFFFFF");
CanvasElement.StyleDefault.setStyle("TextHighlightedBackgroundColor", 	"#000000");
CanvasElement.StyleDefault.setStyle("TextCaretColor", 					"#000000");


///////////CanvasElement Public Functions///////////////////////////////

/**
 * @function addStyleDefinition
 * Adds a style definition to the end element's definition list. Styles in this definition
 * will override styles in previously added definitions (lower index). Instance styles, set 
 * using setStyle() will override all definition styles.
 * Adding style definitions to elements already attached to the display chain is expensive, 
 * for better performance add definitions before attaching the element via addElement()
 * 
 * @param styleDefinition StyleDefinition
 * The StyleDefinition to add and associate with the element.
 * 
 * @returns StyleDefinition
 * The style definition just added.
 */
CanvasElement.prototype.addStyleDefinition = 
	function (styleDefinition)
	{
		return this.addStyleDefinitionAt(styleDefinition, this._styleDefinitions.length);
	};
	
/**
 * @function addStyleDefinitionAt
 * Inserts a style definition to this elements definition list at the specified index.
 * Definitions with higher indexes (added later) are higher priority. Instance styles, set 
 * using setStyle() will override all definition styles. 
 * Adding style definitions to elements already attached to the display chain is expensive, 
 * for better performance add definitions before attaching the element via addElement()
 * 
 * @param styleDefinition StyleDefinition
 * StyleDefinition to be added to this elements definition list.
 * 
 * @param index int
 * The index to insert the style definition within the elements definition list.
 * 
 * @returns StyleDefinition
 * Returns StyleDefinition just added when successfull, null if the StyleDefinition could not
 * be added due to the index being out of range or other error.
 */	
CanvasElement.prototype.addStyleDefinitionAt = 
	function (styleDefinition, index)
	{
		if (!(styleDefinition instanceof StyleDefinition))
			return null;
	
		if (index < 0 || index > this._styleDefinitions.length)
			return null;
		
		//Make sure this style definition is not already in the list (no adding duplicates)
		if (this._styleDefinitions.indexOf(styleDefinition) != -1 || styleDefinition == this._styleDefinitionDefault)
			return null;
		
		this._styleDefinitions.splice(index, 0, styleDefinition);
		
		if (this._manager != null) //Attached to display chain
		{
			styleDefinition.addEventListener("stylechanged", this._onExternalStyleChangedInstance);
			
			//_onExternalStyleChanged() is expensive! We use the map to make sure we only do each style once.
			var styleNamesMap = Object.create(null);
			var styleName = null;
			
			//We're shifting the priority of all existing style definitions with a lower index (previously added) 
			//when we add a new one, so we need to invoke a style change on all associated styles.
			
			//Record relevant style names
			for (var i = index; i >= 0; i--)
			{
				for (styleName in this._styleDefinitions[i]._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Spoof style changed events for normal handling.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		
		return styleDefinition;
	};
	
/**
 * @function removeStyleDefinition
 * Removes the supplied style definition from the element's style chain.
 * 
 * @param styleDefinition StyleDefinition
 * The StyleDefinition to remove from the element.
 * 
 * @returns StyleDefinition
 * The style definition just removed, or null if the supplied style 
 * definition is not associated with this element.
 */	
CanvasElement.prototype.removeStyleDefinition = 
	function (styleDefinition)
	{
		var index = this._styleDefinitions.indexOf(styleDefinition);
		if (index == -1)
			return null;
	
		return this.removeStyleDefinitionAt(index);
	};
	
/**
 * @function removeStyleDefinitionAt
 * Removes the style definition from the elements definition list at the supplied index.
 * 
 * @param index int
 * Index to be removed.
 * 
 * @returns StyleDefinition
 * Returns the StyleDefinition just removed if successfull, null if the definition could
 * not be removed due it it not being in this elements definition list, or index out of range.
 */		
CanvasElement.prototype.removeStyleDefinitionAt = 
	function (index)
	{
		if (index < 0 || index > this._styleDefinitions.length - 1)
			return null;
		
		if (this._manager != null) //Attached to display chain
		{
			//_onExternalStyleChanged() is expensive! We use the map to make sure we only do each style once.
			var styleNamesMap = Object.create(null);
			var styleName = null;
			
			//We're shifting the priority of all existing style definitions with a lower index (previously added) 
			//when we add a new one, so we need to invoke a style change on all associated styles.
			
			//Record relevant styles
			for (var i = index; i >= 0; i--)
			{
				for (styleName in this._styleDefinitions[i]._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Remove definition
			var styleDefinition = this._styleDefinitions.splice(index, 1)[0]; //Returns array of removed items.
			styleDefinition.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
			
			//Spoof style changed event for relevant styles.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		else //Not attached, just remove the definition
			this._styleDefinitions.splice(index, 1)
		
		return styleDefinition;
	};
	
/**
 * @function clearStyleDefinitions
 * Removes all style definitions from the element. This is more efficient than
 * removing definitions one at a time.
 */		
CanvasElement.prototype.clearStyleDefinitions = 
	function ()
	{
		if (this._manager != null) //Attached to display chain
		{
			//_onExternalStyleChanged() is expensive! We use the map to make sure we only do each style once.
			var styleNamesMap = Object.create(null);
			var styleDefinition = null;
			var styleName = null;
			
			for (var i = 0; i < this._styleDefinitions.length; i++)
			{
				styleDefinition = this._styleDefinitions[i];
				
				styleDefinition.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
				
				//Record removed style names
				for (styleName in styleDefinition._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Clear definitions
			this._styleDefinitions.splice(0, this._styleDefinitions.length);
			
			//Spoof a style changed event on all the styles we removed.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		else //Not attached, just clear the definition list.
			this._styleDefinitions.splice(0, this._styleDefinitions.length);
	};
	
/**
 * @function setStyleDefinitions
 * Replaces the elements current style definition list. This is more effecient than removing or 
 * adding style definitions one at a time.
 * 
 * @param styleDefinitions StyleDefinition
 * May be a StyleDefinition, or an Array of StyleDefinition
 */
CanvasElement.prototype.setStyleDefinitions = 
	function (styleDefinitions)
	{
		if (styleDefinitions == null)
			styleDefinitions = [];
		
		if (Array.isArray(styleDefinitions) == false)
			styleDefinitions = [styleDefinitions];
		
		var i = 0;
		
		//trim the definitions for duplicates
		for (i = styleDefinitions.length - 1; i >= 0; i--)
		{
			//Make sure this style definition is not already in the list (no adding duplicates)
			if (styleDefinitions.indexOf(styleDefinitions[i]) < i || styleDefinitions[i] == this._styleDefinitionDefault)
				styleDefinitions.splice(i, 1);
		}
		
		if (this._manager != null) //Attached to display chain
		{
			//Check if nothing changed before we do a bunch of work.
			if (styleDefinitions.length == this._styleDefinitions.length)
			{
				var changed = false;
				for (i = 0; i < styleDefinitions.length; i++)
				{
					if (styleDefinitions[i] != this._styleDefinitions[i])
					{
						changed = true;
						break;
					}
				}
				
				//No changes.
				if (changed == false)
					return;
			}
			
			var styleName = null;
			var styleNamesMap = Object.create(null);
			var styleDefinition = null;
			
			//Remove old
			while (this._styleDefinitions.length > 0)
			{
				styleDefinition = this._styleDefinitions[this._styleDefinitions.length - 1];
				this._styleDefinitions.splice(this._styleDefinitions.length - 1, 1);
				styleDefinition.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
				
				//Record removed style names
				for (styleName in styleDefinition._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Add new
			for (i = 0; i < styleDefinitions.length; i++)
			{
				styleDefinition = styleDefinitions[i];
				this._styleDefinitions.push(styleDefinition);
				styleDefinition.addEventListener("stylechanged", this._onExternalStyleChangedInstance);
				
				//Record added style names
				for (styleName in styleDefinition._styleMap)
					styleNamesMap[styleName] = true;
			}
			
			//Spoof style changed events for normal style changed handling.
			for (styleName in styleNamesMap)
				this._onExternalStyleChanged(new StyleChangedEvent(styleName));
		}
		else //Not attached to display chain, just swap the definitions
		{
			//Clear the definition list
			this._styleDefinitions.splice(0, this._styleDefinitions.length);
			
			//Add the new definitions.
			for (i = 0; i < styleDefinitions.length; i++)
				this._styleDefinitions.push(styleDefinitions[i]);
		}
	};
	
/**
 * @function getNumStyleDefinitions
 * Gets the number of style definitions associated with this element.
 * 
 * @returns int
 * The number of style definitions.
 */		
CanvasElement.prototype.getNumStyleDefinitions = 
	function ()
	{
		return this._styleDefinitions.length;
	};
	
/**
 * @function getStyleDefinitionAt
 * Gets the style definition at the supplied zero base index.
 * 
 * @param index int
 * Index of the style definition to return;
 * 
 * @returns StyleDefinition
 * The style defenition at the supplied index, or null if index is out of range. 
 */		
CanvasElement.prototype.getStyleDefinitionAt = 
	function (index)
	{
		if (index < 0 || index >= this._styleDefinitions.length)
			return null;
		
		return this._styleDefinitions[index];
	};
	
/**
 * @function getStyle
 * @override
 * 
 * Gets the style value for this element. When retrieving a style, CanvasElements look
 * through their associated style chain, at each step if undefined is returned, they look
 * at the next step until a non-undefined value is found.
 * 
 * 1) Instance - Styles set directly to the element via setStyle()
 * 2) StyleDefinitions - Styles associated via its assigned StyleDefinitions
 * 3) StyleProxy - If proxy element is assigned, move to proxy element and repeat steps 1-3
 * 4) Inheritable - If style is inheritable, move up to parent element and repeat steps 1-4
 * 5) Default styles
 * 
 * @seealso StyleProxy
 * @seealso StyleableBase
 * 
 * @param styleName String
 * String representing the style value to be returned.
 * 
 * @returns Any
 * Returns the associated style value if found, otherwise undefined.
 * 
 */
CanvasElement.prototype.getStyle = 
	function (styleName)
	{
		return CanvasElement.base.prototype.getStyle.call(this, styleName);
	};	
	
//@override
CanvasElement.prototype.getStyleData = 
	function (styleName)
	{
		//Create cache if does not exist.
		var styleCache = this._stylesCache[styleName];
		if (styleCache == null)
		{
			styleCache = {styleData:new StyleData(styleName), cacheInvalid:true};
			this._stylesCache[styleName] = styleCache;
		}
		
		//Check cache
		if (styleCache.cacheInvalid == false)
			return styleCache.styleData.clone();
		
		styleCache.cacheInvalid = false;
		var styleData = styleCache.styleData;
		
		//Reset the cache data.
		styleData.priority = [];
		styleData.value = undefined;
		
		//Check instance
		if (styleName in this._styleMap)
			styleData.value = this._styleMap[styleName];
		
		if (styleData.value !== undefined)
		{
			styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);
			return styleData.clone();
		}
		
		//Counters (priority depth)
		var ctr = 0;
		var ctr2 = 0;
		
		//Check definitions
		for (ctr = this._styleDefinitions.length - 1; ctr >= 0; ctr--)
		{
			styleData.value = this._styleDefinitions[ctr].getStyle(styleName);
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);
				styleData.priority.push((this._styleDefinitions.length - 1) - ctr); //StyleDefinition depth
				
				return styleData.clone();
			}
		}
		
		var proxy = null;
		var styleType = null;
		
		//Check proxy
		proxy = this._styleProxy;
		while (proxy != null)
		{
			styleType = proxy._proxyElement._getStyleType(styleName);
			
			if ((styleType != null && styleName in proxy._proxyMap == false) ||		//Defined & not in proxy map
				(styleType == null && "_Arbitrary" in proxy._proxyMap == false)) 	//Not defined and no _Arbitrary flag
				break;
			
			//Check proxy instance
			if (styleName in proxy._proxyElement._styleMap)
				styleData.value = proxy._proxyElement._styleMap[styleName];
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.PROXY);		
				styleData.priority.push(ctr);	//Proxy depth (chained proxies)
				styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);	
				
				return styleData.clone();
			}
			
			//Check proxy definitions
			for (ctr2 = proxy._proxyElement._styleDefinitions.length - 1; ctr2 >= 0; ctr2--)
			{
				styleData.value = proxy._proxyElement._styleDefinitions[ctr2].getStyle(styleName);
				
				if (styleData.value !== undefined)
				{
					styleData.priority.push(CanvasElement.StylePriorities.PROXY);
					styleData.priority.push(ctr);	//Proxy depth (chained proxies)
					styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);	
					styleData.priority.push((proxy._proxyElement._styleDefinitions.length - 1) - ctr2); //definition depth	
					
					return styleData.clone();
				}
			}
			
			ctr++;
			proxy = proxy._proxyElement._styleProxy;
		}
		
		//Check inherited
		proxy = null;
		styleType = null;
		ctr = 0;
		ctr2 = 0;
		
		var parent = this;
		var ctr3 = 0;
		
		while (true)
		{
			styleType = parent._getStyleType(styleName);
			if (styleType == null || styleType.inheritable == false)
				break;
			
			parent = parent._parent;
			
			if (parent == null)
				break;
			
			//Check parent instance
			if (styleName in parent._styleMap)
				styleData.value = parent._styleMap[styleName];
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.INHERITED);	
				styleData.priority.push(ctr);	//Parent depth
				styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);
				
				return styleData.clone();
			}
			
			//Check style definitions
			for (ctr2 = parent._styleDefinitions.length - 1; ctr2 >= 0; ctr2--)
			{
				styleData.value = parent._styleDefinitions[ctr2].getStyle(styleName);
				
				if (styleData.value !== undefined)
				{
					styleData.priority.push(CanvasElement.StylePriorities.INHERITED);	
					styleData.priority.push(ctr);	//Parent depth
					styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);
					styleData.priority.push((parent._styleDefinitions.length - 1) - ctr2); //Definition depth	
					
					return styleData.clone();
				}
			}
			
			//Check parent proxy
			proxy = parent._styleProxy;
			ctr2 = 0;
			while (proxy != null)
			{
				styleType = proxy._proxyElement._getStyleType(styleName);
				
				if ((styleType != null && styleName in proxy._proxyMap == false) ||		//Defined & not in proxy map
					(styleType == null && "_Arbitrary" in proxy._proxyMap == false)) 	//Not defined and no _Arbitrary flag
					break;
				
				//Check proxy instance
				if (styleName in proxy._proxyElement._styleMap)
					styleData.value = proxy._proxyElement._styleMap[styleName];
				
				if (styleData.value !== undefined)
				{
					styleData.priority.push(CanvasElement.StylePriorities.INHERITED);		
					styleData.priority.push(ctr);	//Parent depth
					styleData.priority.push(CanvasElement.StylePriorities.PROXY);		
					styleData.priority.push(ctr2);	//Proxy depth (chained proxies)
					styleData.priority.push(CanvasElement.StylePriorities.INSTANCE);		
					
					return styleData.clone();
				}
				
				//Check proxy definition
				for (ctr3 = proxy._proxyElement._styleDefinitions.length - 1; ctr3 >= 0; ctr3--)
				{
					styleData.value = proxy._proxyElement._styleDefinitions[ctr3].getStyle(styleName);
					
					if (styleData.value !== undefined)
					{
						styleData.priority.push(CanvasElement.StylePriorities.INHERITED);	
						styleData.priority.push(ctr);	//Parent depth
						styleData.priority.push(CanvasElement.StylePriorities.PROXY);	
						styleData.priority.push(ctr2);	//Proxy depth (chained proxies)
						styleData.priority.push(CanvasElement.StylePriorities.DEFINITION);
						styleData.priority.push((parent._styleDefinitions.length - 1) - ctr3); //Definition depth	
						
						return styleData.clone();
					}
				}

				ctr2++;
				proxy = proxy._proxyElement._styleProxy;
			}
			
			ctr++;
		}
		
		//Check default definition
		if (this._styleDefinitionDefault != null)
			styleData.value = this._styleDefinitionDefault.getStyle(styleName);
			
		if (styleData.value !== undefined)
		{
			styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_DEFINITION);
			return styleData.clone();
		}	
		
		//Check default proxy
		proxy = this._styleProxy;
		ctr = 0;
		while (proxy != null)
		{
			styleType = proxy._proxyElement._getStyleType(styleName);
			
			if ((styleType != null && styleName in proxy._proxyMap == false) ||		//Defined & not in proxy map
				(styleType == null && "_Arbitrary" in proxy._proxyMap == false)) 	//Not defined and no _Arbitrary flag
				break;
			
			if (proxy._proxyElement._styleDefinitionDefault != null)
				styleData.value = proxy._proxyElement._styleDefinitionDefault.getStyle(styleName);
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_PROXY);
				styleData.priority.push(ctr);	//Proxy depth (chained proxies)
				
				return styleData.clone();
			}
			
			ctr++;
			proxy = proxy._proxyElement._styleProxy;
		}
			
		//Check class
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(CanvasElement.StylePriorities.CLASS);
		
		return styleData.clone();		
	};
	
//@override	
CanvasElement.prototype.setStyle = 
	function (styleName, value)
	{
		var oldValue = undefined;
		if (styleName in this._styleMap)
			oldValue = this._styleMap[styleName];

		//No change
		if (oldValue === value)
			return;
		
		if (value === undefined)
			delete this._styleMap[styleName];
		else
			this._styleMap[styleName] = value;
		
		//Spoof a style changed event and pass it to _onExternalStyleChanged for normal handling
		this._onExternalStyleChanged(new StyleChangedEvent(styleName));
	};			

/**
 * @function getManager
 * Gets the CanvasManager currently associated with this element.
 * 
 * @returns CanvasManager
 * The CanvasManager currently associated with this element.
 */	
CanvasElement.prototype.getManager = 
	function ()
	{
		return this._manager;
	};

/**
 * @function setName
 * Sets an arbitrary name to this element. The system does not use this value,
 * it is for use by implementors if a way to differentiate elements is needed.
 * 
 * @param name String
 * A String to use as the element's name.
 */	
CanvasElement.prototype.setName = 
	function (name)
	{
		if (this._name == name)
			return false;
		
		this._name = name;
		return true;
	};
	
/**
 * @function getName
 * Gets the name associated with this element.
 * 
 * @returns String
 * The name associated with this element.
 */		
CanvasElement.prototype.getName = 
	function ()
	{
		return this._name;
	};
	
/**
 * @function getMouseIsDown
 * Gets the state of the mouse for this element.
 * 
 * @returns boolean
 * Returns true if the mouse is currently pressed, false otherwise.
 */		
CanvasElement.prototype.getMouseIsDown = 
	function()
	{
		return this._mouseIsDown;
	};	

/**
 * @function getParent
 * Gets this element's parent element.
 * 
 * @returns CanvasElement
 * This element's parent element.
 */		
CanvasElement.prototype.getParent = 
	function ()
	{
		return this._parent;
	};
	
/**
 * @function rotatePoint
 * Rotates a point point on this element's parent relative to this element's rotation transformation.
 * This is used to transform a point from the parent's coordinate plane to a child's coordinate plane or vice versa.
 * Typically you should use translatePointFrom() or translatePointTo() rather than rotatePoint().
 * 
 * @param point Object
 * Point object {x:0, y:0};
 * 
 * @param reverse boolean
 * When true, rotates a point on the parent's plane, to the childs plane. 
 * When false, rotates a point on the childs plane, to the parents plane.
 */	
CanvasElement.prototype.rotatePoint = 
	function (point, reverse)
	{
		if (this._rotateDegrees == 0)
			return;
		
		var radius = 
			Math.sqrt(
					(Math.abs(point.x - this._rotateCenterX) * Math.abs(point.x - this._rotateCenterX)) +
					(Math.abs(point.y - this._rotateCenterY) * Math.abs(point.y - this._rotateCenterY))
					);
		
		var degrees;
		if (reverse == false)
			degrees = 360 - this._rotateDegrees + CanvasElement.radiansToDegrees(Math.atan2(point.x - this._rotateCenterX, point.y - this._rotateCenterY));
		else
			degrees = 360 + this._rotateDegrees + CanvasElement.radiansToDegrees(Math.atan2(point.x - this._rotateCenterX, point.y - this._rotateCenterY));
			
		point.x = Math.sin(CanvasElement.degreesToRadians(degrees)) * radius + this._rotateCenterX;
		point.y = Math.cos(CanvasElement.degreesToRadians(degrees)) * radius + this._rotateCenterY;
	};

/**
 * @function translatePointFrom
 * Translates a point from an element to this element regardless of this element's transformation,
 * depth, or position in the display hierarchy. For example, you can call this to translate a point on
 * the canvas to the relative point on this element.
 * 
 * @param point Object
 * Point - object containing {x:0, y:0}.
 * 
 * @param relativeFromElement CanvasElement
 * The element that the supplied point is relative too.
 */	
CanvasElement.prototype.translatePointFrom = 
	function (point, relativeFromElement)
	{
		return relativeFromElement.translatePointTo(point, this);
	};

/**
 * @function translatePointTo
 * Translates a point from this element to another element regardless of this element's transformation,
 * depth, or position in the display hierarchy. For example, you can call this to translate a point on
 * this element to a point on the canvas.
 * 
 * @param point Object
 * Point - object containing {x:0, y:0}.
 * 
 * @param relativeToElement CanvasElement
 * The element to translate this element's point too.
 */		
CanvasElement.prototype.translatePointTo = 
	function (point, relativeToElement)
	{
		if (relativeToElement == null || relativeToElement == this)
			return false;
		
		if (this._manager == null || this._manager != relativeToElement._manager)
			return false;
		
		//Build up both parent chains so we can find common parent//
		////////////////////////////////////////////////////////////
		
		var commonParent = null;
		
		//We are a child of relativeElement
		var thisChain = [];
		thisChain.push(this);
		while (commonParent == null && thisChain[thisChain.length - 1]._parent != null)
		{
			if (thisChain[thisChain.length - 1]._parent == relativeToElement)
				commonParent = relativeToElement;
			else
				thisChain.push(thisChain[thisChain.length - 1]._parent);
		}
		
		//Relative element is a child of us.
		var relativeChain = [];
		if (commonParent == null)
		{
			relativeChain.push(relativeToElement);
			while (commonParent == null && relativeChain[thisChain.length - 1]._parent != null)
			{
				if (relativeChain[relativeChain.length - 1]._parent == this)
					commonParent = this;
				else
					relativeChain.push(relativeChain[relativeChain.length - 1]._parent);
			}
		}
		
		//Someone is doing something weird and we're not in each others direct chains so we have to translate up AND down.
		if (commonParent == null)
		{
			//We know we have the same canvas manager, so just keep popping both arrays till we find something different.
			while (thisChain[thisChain.length - 1] == relativeChain[relativeChain.length - 1])
			{
				commonParent = thisChain[thisChain.length - 1];
				
				thisChain.pop();
				relativeChain.pop();
			}
		}
		
		//Translate up to common parent.
		var currentParent = this;
		while (currentParent != null && currentParent != commonParent)
		{
			point.x += currentParent._x;
			point.y += currentParent._y;
			
			currentParent.rotatePoint(point, false);
			
			currentParent = currentParent._parent;
		}
		
		//Translate down to relativeElement
		for (var i = relativeChain.length - 1; i >= 0; i--)
		{
			//Rotate the point backwards so we can translate the point to the element's rotated plane.
			relativeChain[i].rotatePoint(point, true);
			
			//Adjust the mouse point to within this element rather than its position in parent.
			point.x -= relativeChain[i]._x;
			point.y -= relativeChain[i]._y;
		}
		
		return true;
	};
	
/**
 * @function translateMetricsFrom
 * Translates a DrawMetrics from another element's to this element regardless of this element's transformation,
 * depth, or position in the display hierarchy. 
 * 
 * @param metrics DrawMetrics
 * Metrics to transform from the relative to this element.
 * 
 * @param relativeFromElement CanvasElement
 * The element to translate the supplied metrics too. If relativeToElement equals
 * null or this, will return metrics the same as the supplied metrics.
 * 
 * @returns DrawMetrics
 * Translated DrawMetrics relative to the supplied element.
 */	
CanvasElement.prototype.translateMetricsFrom = 	
	function (metrics, relativeFromElement)
	{
		return relativeFromElement.translateMetricsTo(metrics, this);
	};
	
/**
 * @function translateMetricsTo
 * Translates a DrawMetrics from this element's to another element regardless of this element's transformation,
 * depth, or position in the display hierarchy. 
 * 
 * @param metrics DrawMetrics
 * Metrics to transform to from this element to the supplied relative element.
 * 
 * @param relativeToElement CanvasElement
 * The element to translate the supplied metrics too. If relativeToElement equals
 * null or this, will return metrics the same as the supplied metrics.
 * 
 * @returns DrawMetrics
 * Translated DrawMetrics relative to the supplied element.
 */	
CanvasElement.prototype.translateMetricsTo = 
	function (metrics, relativeToElement)
	{
		var translatedMetrics = new DrawMetrics();
		if (relativeToElement == null || relativeToElement == this)
		{
			translatedMetrics._x = metrics._x;
			translatedMetrics._y = metrics._y;
			translatedMetrics._width = metrics._width;
			translatedMetrics._height = metrics._height;
			
			return translatedMetrics;
		}

		if (this._manager == null || this._manager != relativeToElement._manager)
			return null;
		
		//Build up both parent chains so we can find common parent.
		var commonParent = null;
		
		//We are a child of relativeElement
		var thisChain = [];
		thisChain.push(this);
		while (commonParent == null && thisChain[thisChain.length - 1]._parent != null)
		{
			if (thisChain[thisChain.length - 1]._parent == relativeToElement)
				commonParent = relativeToElement;
			else
				thisChain.push(thisChain[thisChain.length - 1]._parent);
		}
		
		//Relative element is a child of us.
		var relativeChain = [];
		if (commonParent == null)
		{
			relativeChain.push(relativeToElement);
			while (commonParent == null && relativeChain[thisChain.length - 1]._parent != null)
			{
				if (relativeChain[relativeChain.length - 1]._parent == this)
					commonParent = this;
				else
					relativeChain.push(relativeChain[relativeChain.length - 1]._parent);
			}
		}
		
		//Someone is doing something weird and we're not in each others direct chains so we have to translate up AND down.
		if (commonParent == null)
		{
			//We know we have the same canvas manager, so just keep popping both arrays till we find something different.
			while (thisChain[thisChain.length - 1] == relativeChain[relativeChain.length - 1])
			{
				commonParent = thisChain[thisChain.length - 1];
				
				thisChain.pop();
				relativeChain.pop();
			}
		}
		
		var pointTl = {x:metrics._x, y:metrics._y};
		var pointTr = {x:metrics._x + metrics._width, y:metrics._y};
		var pointBr = {x:metrics._x + metrics._width, y:metrics._y + metrics._height};
		var pointBl = {x:metrics._x, y:metrics._y + metrics._height};
		
		//Translate up to common parent.
		var currentParent = this;
		while (currentParent != null && currentParent != commonParent)
		{
			pointTl.x += currentParent._x;
			pointTl.y += currentParent._y;
			
			pointTr.x += currentParent._x;
			pointTr.y += currentParent._y;
			
			pointBr.x += currentParent._x;
			pointBr.y += currentParent._y;
			
			pointBl.x += currentParent._x;
			pointBl.y += currentParent._y;
			
			currentParent.rotatePoint(pointTl, false);
			currentParent.rotatePoint(pointTr, false);
			currentParent.rotatePoint(pointBl, false);
			currentParent.rotatePoint(pointBr, false);
			
			currentParent = currentParent._parent;
		}
		
		//Translate down to relativeElement
		for (var i = relativeChain.length - 1; i >= 0; i--) 
		{
			//Rotate the point backwards so we can translate the point to the element's rotated plane.
			relativeChain[i].rotatePoint(pointTl, true);
			relativeChain[i].rotatePoint(pointTr, true);
			relativeChain[i].rotatePoint(pointBl, true);
			relativeChain[i].rotatePoint(pointBr, true);
			
			//Adjust the mouse point to within this element rather than its position in parent.
			pointTl.x -= relativeChain[i]._x;
			pointTl.y -= relativeChain[i]._y;
			
			pointTr.x -= relativeChain[i]._x;
			pointTr.y -= relativeChain[i]._y;
			
			pointBr.x -= relativeChain[i]._x;
			pointBr.y -= relativeChain[i]._y;
			
			pointBl.x -= relativeChain[i]._x;
			pointBl.y -= relativeChain[i]._y;
		}
		
		var minX = Math.min(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
		var maxX = Math.max(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
		var minY = Math.min(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
		var maxY = Math.max(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
		
		translatedMetrics._x = minX;
		translatedMetrics._y = minY;
		translatedMetrics._width = maxX - minX;
		translatedMetrics._height = maxY - minY;
		
		return translatedMetrics;
	};	
	
/**
 * @function getMetrics
 * Gets a DrawMetrics object containing the elements bounding box information
 * x, y, width, height, relative to the supplied element regardless of this element's transformation,
 * depth, or position in the display hierarchy. For example, you can call this get the elements width and height,
 * or to get this element's bounding box relative to the canvas or any other element.
 * 
 * @param relativeToElement CanvasElement
 * The element to translate this elements bounding box too. If relativeToElement equals
 * null or this, will return metrics relative to this element: {x:0, y:0, width:thisWidth, height:thisHeight}.
 * 
 * @returns DrawMetrics
 * DrawMetrics of this element relative to the supplied element.
 */	
CanvasElement.prototype.getMetrics = 
	function (relativeToElement)
	{
		if (relativeToElement == null)
			relativeToElement = this;
	
		if (this._manager == null || this._manager != relativeToElement._manager)
			return null;
	
		var metrics = new DrawMetrics();
		metrics._x = 0;
		metrics._y = 0;
		metrics._width = this._width;
		metrics._height = this._height;
		
		if (relativeToElement == this)
			return metrics;
		
		return this.translateMetricsTo(metrics, relativeToElement);
	};

//@Override
CanvasElement.prototype.addEventListener = 	
	function (type, callback)
	{
		CanvasElement.base.prototype.addEventListener.call(this, type, callback);
	
		//Broadcast events (dispatched only by manager)
		if ((type == "enterframe" || 
			type == "localechanged" || 
			type == "mousemoveex") &&
			this._manager != null)
		{
			this._manager._broadcastDispatcher.addEventListener(type, callback);
		}
		
		return true;
	};

//@Override	
CanvasElement.prototype.removeEventListener = 
	function (type, callback)
	{
		if (CanvasElement.base.prototype.removeEventListener.call(this, type, callback) == true)
		{
			//Broadcast events (dispatched only by manager)
			if ((type == "enterframe" || 
				type == "localechanged" || 
				type == "mousemoveex") &&
				this._manager != null)
			{
				this._manager._broadcastDispatcher.removeEventListener(type, callback);
			}
			
			return true;
		}
		
		return false;
	};	

	
////////////Capture Phase Event Listeners///////////////////////	
	
/**
 * @function addCaptureListener
 * Registers an event listener function to be called during capture phase.
 * 
 * @seealso ElementEvent
 * 
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function to be called when the event occurs.
 */	
CanvasElement.prototype.addCaptureListener = 
	function (type, callback)
	{
		if (this._captureListeners[type] == null)
			this._captureListeners[type] = [];
		
		this._captureListeners[type].push(callback);
		
		return true;
	};

/**
 * @function removeCaptureListener
 * Removes a capture event listener.
 * 
 * @seealso ElementEvent
 * 
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be removed.
 * 
 * @returns boolean
 * Returns true if the callback was successfully removed, otherwise false
 * such as if the function callback was not previously registered.
 */		
CanvasElement.prototype.removeCaptureListener = 
	function (type, callback)
	{
		if (!(type in this._captureListeners))
			return false;
	
		for (var i = 0; i < this._captureListeners[type].length; i++)
		{
			if (this._captureListeners[type][i] == callback)
			{
				this._captureListeners[type].splice(i, 1);
				return true;
			}
		}
		
		return false;
	};

/**
 * @function hasCaptureListener
 * Checks if an event capture listener has been registered with this CanvasElement
 * 
 * @seealso ElementEvent
 * 
 * 
 * @param type String
 * String representing the event type.
 * 
 * @param callback Function
 * Function callback to be called when the event occurs. This may be null to check
 * if the CanvasElement has any capture events registered for the provided type.
 * 
 * @returns boolean
 * Returns true if the CanvasElement has the provided capture callback registered for the 
 * provided type, or any capture callback for the provided type if the callback parameter is null.
 * Otherwise, returns false.
 */		
CanvasElement.prototype.hasCaptureListener = 
	function (type, callback)
	{
		if (!(type in this._captureListeners))
			return false;
	
		if (callback == null && this._captureListeners[type].length > 0)
			return true;
		
		for (var i = 0; i < this._captureListeners[type].length; i++)
		{
			if (this._captureListeners[type][i] == callback)
				return true;
		}
		
		return false;
	};	
	
/////////////CanvasElement Public Static Functions//////////////////

/**
 * @function adjustColorLight
 * @static
 * Adjusts supplied color brightness.
 * 
 * @param color String
 * Hex color value be adjusted. Format like "#FF0000" (red)
 * 
 * @param percent Number
 * Value between -1 and +1. -1 will return white. +1 will return black.
 * 
 * @returns String
 * Adjusted Hex color value.
 */
//Looks complicated... not really. Its using a percentage of the distance between black(neg) or white(pos) on all 3 channels independently.
CanvasElement.adjustColorLight = 
	function (color, percent) 
	{   
	    var f = parseInt(color.slice(1), 16);
	    var t = percent < 0 ? 0 : 255;
	    var p = percent < 0 ? percent * -1 : percent;
	    var R = f >> 16;
	    var G = f >> 8 & 0x00FF;
	    var B = f & 0x0000FF;
	    
	    return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
	};
	
/**
 * @function radiansToDegrees
 * @static
 * Calculates radians to degrees.
 * 
 * @param radians Number
 * Radians to be calculated to degrees.
 * 
 * @returns Number
 * Resulting degrees from supplied radians.
 */	
CanvasElement.radiansToDegrees = 
	function (radians)
	{
		return radians * (180 / Math.PI);
	};
	
/**
 * @function degreesToRadians
 * @static
 * Calculates degrees to radians.
 * 
 * @param degrees Number
 * Degrees to be calculated to degrees.
 * 
 * @returns Number
 * Resulting radians from supplied degrees.
 */		
CanvasElement.degreesToRadians = 
	function (degrees)
	{
		return degrees * (Math.PI / 180);
	};

/**
 * @function normalizeDegrees
 * @static
 * Adjusts degrees less than 0 or greater than 360 to corresponding degrees between 0 and 360. 
 * This is useful when rotating an element by increments.
 * 
 * @param value Number
 * Degrees to normalize.
 * 
 * @returns Number
 * Degrees between 0 and 360.
 */	
CanvasElement.normalizeDegrees = 
	function (value)
	{
		while (value >= 360)
			value = value - 360;
		while (value < 0)
			value = value + 360;
		
		return value;
	};	

/**
 * @function roundToPrecision
 * @static
 * Rounds a number to specified precision (decimal points).
 * 
 * @param value Number
 * Number to round.
 * 
 * @param precision int
 * Number of decimal points.
 * 
 * @returns Number
 * Rounded value.
 */	
CanvasElement.roundToPrecision = 
	function (value, precision)
	{
		if (precision == 0)
			return Math.round(value);
		
		var multiplier = Math.pow(10, precision);
		
		value = value * multiplier;
		value = Math.round(value);
		return value / multiplier;
	};
	
/////////////CanvasElement Internal Static Functions//////////////////	
	
CanvasElement._browserType = "";	
	
//Map of maps for character widths by font size/style. Some browsers render canvas text by pixel rather 
//than character width. For example, an uppercase "T" with a lowercase "e" next to it ("Te"), 
//the "e" will actually render overlapping the "T" since the "e" is not tall enough to collide with the top of the "T". 
//This doesnt work for word processing, we need to be able to identify each character so we measure and 
//store character widths here, and render all text on a character by character basis for consistency.
CanvasElement._characterWidthMap = Object.create(null); 

CanvasElement._characterFillBitmapMap = Object.create(null);
CanvasElement._characterStrokeBitmapMap = Object.create(null);

CanvasElement._measureCharBitmap = null;
CanvasElement._measureCharContext = null;
(	function () 
	{
		CanvasElement._measureCharBitmap = document.createElement("canvas");
		CanvasElement._measureCharBitmap.width = 1;
		CanvasElement._measureCharBitmap.height = 1;
		
		CanvasElement._measureCharContext = CanvasElement._measureCharBitmap.getContext("2d");
	}
)();

/**
 * @function _measureText
 * @static
 * Measures text on a character by character basis. Unfortunately, browsers will give
 * different widths for strings of text, than text measured character by character. It appears
 * text width changes depending on which characters are next to which characters. This behavior
 * cannot be used for text that requires highlighting or editing. This function records the character
 * width per font in a map, and then uses that map to measure text widths. This surprisingly turns out to be 
 * just as fast as measuring full text via the canvas context (since canvas sucks so bad at text rendering).
 * 
 * @param text String
 * The text string to measure.
 * 
 * @param fontString String
 * Font styling to use when measuring. Use _getFontString()
 * 
 * @returns Number
 * Width of the text as measured via characters.
 */
CanvasElement._measureText = 
	function (text, fontString)
	{
		var charMap = CanvasElement._characterWidthMap[fontString];
		if (charMap == null)
		{
			charMap = Object.create(null);
			CanvasElement._characterWidthMap[fontString] = charMap;
		}
		
		var result = 0;
		var charWidth = 0;
		var fontSet = false;
		
		for (var i = 0; i < text.length; i++)
		{
			charWidth = charMap[text[i]];
			if (charWidth == null)
			{
				if (fontSet == false) 
				{
					CanvasElement._measureCharContext.font = fontString;
					fontSet = true;
				}
				
				charWidth = Math.ceil(CanvasElement._measureCharContext.measureText(text[i]).width);
				charMap[text[i]] = charWidth;
			}
			
			result += charWidth;
		}
		
		return result;
	};

/**
 * @function _fillText
 * @static
 * Renders text on a character by character basis. Unfortunately, browsers will give
 * different widths for strings of text, than text measured character by character. It appears
 * text width changes depending on which characters are next to which characters. This behavior
 * cannot be used for text that requires highlighting or editing. This function records character
 * bitmaps per font in a map, and then uses that map to render characters. This surprisingly turns out to be 
 * just as fast as rendering full text via the canvas context (since canvas sucks so bad at text rendering).
 * 
 * @param ctx Canvas2DContext
 * The canvas context to render the text. 
 * 
 * @param text String
 * The text string to render.
 * 
 * @param x Number
 * The X coordinate to render the text.
 * 
 * @param y Number
 * The Y coordinate to render the text.
 * 
 * @param fontString String
 * Font styling to use when measuring. Use _getFontString()
 * 
 * @param color String
 * Hex color value to be used to render the text. Format like "#FF0000" (red).
 * 
 * @param baseline String
 * Text Y position relative to Y coordinate. ("top", "middle", or "bottom")
 */	
CanvasElement._fillText = 
	function (ctx, text, x, y, fontString, color, baseline)
	{
		var bitmapMap = CanvasElement._characterFillBitmapMap[fontString];
		if (bitmapMap == null)
		{
			bitmapMap = Object.create(null);
			CanvasElement._characterFillBitmapMap[fontString] = bitmapMap;
		}
		
		for (var i = 0; i < text.length; i++)
		{
			var bitmapAndContext = bitmapMap[text[i]];
			
			if (bitmapAndContext == null)
			{
				bitmapAndContext = {canvas:null, context:null, fontSize:0};
				bitmapMap[text[i]] = bitmapAndContext;
				
				bitmapAndContext.canvas = document.createElement("canvas");
				
				var fontSplit = fontString.split(" ");
				var fontSize = 0;
				for (var i2 = 0; i2 < fontSplit.length; i2++)
				{
					if (fontSplit[i2].length >= 3)
					{
						var pxString = fontSplit[i2].substr(fontSplit[i2].length - 2, 2);
						if (pxString == "px")
						{
							fontSize = Number(fontSplit[i2].substr(0, fontSplit[i2].length - 2));
							break;
						}
					}
				}
				
				bitmapAndContext.fontSize = fontSize;
				
				bitmapAndContext.canvas.height = fontSize + 4;
				bitmapAndContext.canvas.width = CanvasElement._measureText(text[i], fontString);
				
				bitmapAndContext.context = bitmapAndContext.canvas.getContext("2d");
				bitmapAndContext.context.font = fontString;
				bitmapAndContext.context.textBaseline = "middle";
				bitmapAndContext.context.textAlign = "left";
				bitmapAndContext.context.strokeStyle = "#000000";
				bitmapAndContext.context.fillStyle = "#000000";
				bitmapAndContext.context.fillText(text[i], 0, bitmapAndContext.canvas.height / 2);
				
				bitmapAndContext.context.globalCompositeOperation = "source-atop";
			}
			
			if (bitmapAndContext.context.fillStyle != color) 
			{
				bitmapAndContext.context.fillStyle = color;
				
				bitmapAndContext.context.beginPath();
				bitmapAndContext.context.moveTo(0, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, bitmapAndContext.canvas.height);
				bitmapAndContext.context.lineTo(0, bitmapAndContext.canvas.height);
				bitmapAndContext.context.closePath();
				
				bitmapAndContext.context.fill();
			}
			
			if (baseline == "top")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - ((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2)));
			else if (baseline == "bottom")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2) + bitmapAndContext.fontSize)));
			else //	"middle"
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (bitmapAndContext.canvas.height / 2)));
			
			if (text.length == 1)
				return;
			
			x += CanvasElement._measureText(text[i], fontString);
		}
	};	
	
/**
 * @function _strokeText
 * @static
 * Renders text on a character by character basis. Unfortunately, browsers will give
 * different widths for strings of text, than text measured character by character. It appears
 * text width changes depending on which characters are next to which characters. This behavior
 * cannot be used for text that requires highlighting or editing. This function records character
 * bitmaps per font in a map, and then uses that map to render characters. This surprisingly turns out to be 
 * just as fast as rendering full text via the canvas context (since canvas sucks so bad at text rendering).
 * 
 * @param ctx Canvas2DContext
 * The canvas context to render the text. 
 * 
 * @param text String
 * The text string to render.
 * 
 * @param x Number
 * The X coordinate to render the text (Upper left).
 * 
 * @param y Number
 * The Y coordinate to render the text (Uppder left).
 * 
 * @param fontString String
 * Font styling to use when measuring. Use _getFontString()
 * 
 * @param color String
 * Hex color value to be used to render the text. Format like "#FF0000" (red).
 * 
 * @param baseline String
 * Text Y position relative to Y coordinate. ("top", "middle", or "bottom")
 */	
CanvasElement._strokeText = 
	function (ctx, text, x, y, fontString, color, baseline)
	{
		var bitmapMap = CanvasElement._characterStrokeBitmapMap[fontString];
		if (bitmapMap == null)
		{
			bitmapMap = Object.create(null);
			CanvasElement._characterStrokeBitmapMap[fontString] = bitmapMap;
		}
		
		for (var i = 0; i < text.length; i++)
		{
			var bitmapAndContext = bitmapMap[text[i]];
			
			if (bitmapAndContext == null)
			{
				bitmapAndContext = {canvas:null, context:null};
				bitmapMap[text[i]] = bitmapAndContext;
				
				bitmapAndContext.canvas = document.createElement("canvas");
				
				var fontSplit = fontString.split(" ");
				var fontSize = 0;
				for (var i2 = 0; i2 < fontSplit.length; i2++)
				{
					if (fontSplit[i2].length >= 3)
					{
						var pxString = fontSplit[i2].substr(fontSplit[i2].length - 2, 2);
						if (pxString == "px")
						{
							fontSize = Number(fontSplit[i2].substr(0, fontSplit[i2].length - 2));
							break;
						}
					}
						
				}
				
				bitmapAndContext.fontSize = fontSize;
				
				bitmapAndContext.canvas.height = fontSize + 4;
				bitmapAndContext.canvas.width = CanvasElement._measureText(text[i], fontString);
				
				bitmapAndContext.context = bitmapAndContext.canvas.getContext("2d");
				bitmapAndContext.context.font = fontString;
				bitmapAndContext.context.textBaseline = "middle";
				bitmapAndContext.context.textAlign = "left";
				bitmapAndContext.context.strokeStyle = "#000000";
				bitmapAndContext.context.fillStyle = "#000000";
				bitmapAndContext.context.strokeText(text[i], 0, bitmapAndContext.canvas.height / 2);
				
				bitmapAndContext.context.globalCompositeOperation = "source-atop";
			}
			
			if (bitmapAndContext.context.fillStyle != color) 
			{
				bitmapAndContext.context.fillStyle = color;
				
				bitmapAndContext.context.beginPath();
				bitmapAndContext.context.moveTo(0, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, 0);
				bitmapAndContext.context.lineTo(bitmapAndContext.canvas.width, bitmapAndContext.canvas.height);
				bitmapAndContext.context.lineTo(0, bitmapAndContext.canvas.height);
				bitmapAndContext.context.closePath();
				
				bitmapAndContext.context.fill();
			}
			
			if (baseline == "top")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - ((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2)));
			else if (baseline == "bottom")
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (((bitmapAndContext.canvas.height - bitmapAndContext.fontSize) / 2) + bitmapAndContext.fontSize)));
			else //	"middle"
				ctx.drawImage(bitmapAndContext.canvas, x, Math.round(y - (bitmapAndContext.canvas.height / 2)));
			
			if (text.length == 1)
				return;
			
			x += CanvasElement._measureText(text[i], fontString);
		}
	};		
	
/**
 * @function _calculateMinMaxPercentSizes
 * @static
 * Used to calculate size in pixels that percent sized elements should consume given
 * a supplied size in pixels. Populates .actualSize field on objects in supplied 
 * percentSizedObjects array. This function automatically rounds all sizes to the
 * nearest pixel to prevent anti-aliasing and fuzzy lines.
 * 
 * @param percentSizedObjects Array
 * Array of objects containing size data: {minSize:Number, maxSize:Number, percentSize:Number}
 * 
 * @param size Number
 * Available size in pixels.
 */
CanvasElement._calculateMinMaxPercentSizes = 
	function (percentSizedObjects, size)
	{
		if (percentSizedObjects.length == 0)
			return;
	
		var percentObjects = percentSizedObjects.slice();
		var availableSize = size;
		var totalPercentUsed = 0;
		var i;
		
		//Fix values, record total percent used.
		for (i = 0; i < percentObjects.length; i++)
		{
			if (percentObjects[i].minSize == null)
				percentObjects[i].minSize = 0;
			if (percentObjects[i].maxSize == null)
				percentObjects[i].maxSize = Number.MAX_VALUE;
			if (percentObjects[i].percentSize == null)
				percentObjects[i].percentSize = 100;
			
			totalPercentUsed += percentObjects[i].percentSize;
		}
		
		//Size all percent sized elements.
		var done = false;
		while (done == false)
		{
			var size = 0;
			done = true;
			
			for (i = 0; i < percentObjects.length; i++)
			{
				size = availableSize * (percentObjects[i].percentSize / totalPercentUsed);
				if (size > percentObjects[i].maxSize)
				{
					percentObjects[i].actualSize = percentObjects[i].maxSize;
					totalPercentUsed -= percentObjects[i].percentSize;
					availableSize -= percentObjects[i].maxSize;
					
					percentObjects.splice(i, 1);
					done = false;
					break;
				}
				else if (size < percentObjects[i].minSize)
				{
					percentObjects[i].actualSize = percentObjects[i].minSize;
					totalPercentUsed -= percentObjects[i].percentSize;
					availableSize -= percentObjects[i].minSize;
					
					percentObjects.splice(i, 1);
					done = false;
					break;
				}
				else
					percentObjects[i].actualSize = Math.floor(size);
			}
		}
		
		for (i = 0; i < percentObjects.length; i++)
			availableSize -= percentObjects[i].actualSize;
		
		//Distribute excess pixels (rounding error)
		while (availableSize >= 1 && percentObjects.length > 0)
		{
			for (i = 0; i < percentObjects.length; i++)
			{
				while (percentObjects[i].actualSize + 1 > percentObjects[i].maxSize)
				{
					percentObjects.splice(i, 1);
					if (i == percentObjects.length)
						break;
				}
				
				if (i == percentObjects.length)
					break;
				
				percentObjects[i].actualSize++;
				availableSize--;
				
				if (availableSize <= 0)
					break;
			}
		}
	};
	
///////////////CanvasElement Internal Functions////////////////////////////////////

//@private	
CanvasElement.prototype._onBackgroundShapeStyleChanged = 
	function (styleChangedEvent)
	{
		this._invalidateRender();
	};
	
//@private	
CanvasElement.prototype._onExternalStyleChanged = 
	function (styleChangedEvent)
	{
		//Not attached to display chain, bail.
		if (this._manager == null)
			return;
		
		var isProxy = false;
		var isParent = false;
		var validStyle = false;
		var styleName = styleChangedEvent.getStyleName();	
		var styleType = this._getStyleType(styleName);
		
		if (this._styleProxy != null &&  styleChangedEvent.getTarget() == this._styleProxy._proxyElement)
			isProxy = true;
		if (this._parent != null && styleChangedEvent.getTarget() == this._parent)
			isParent = true;
		
		if (isProxy == true || isParent == true)
		{
			if ((isProxy == true && (styleName in this._styleProxy._proxyMap == true || this._styleProxy._proxyElement._getStyleType(styleName) == null)) ||
				(isParent == true && styleType != null && styleType.inheritable == true))
			{
				validStyle = true;
			}
			else
				validStyle = false;
		}
		else
			validStyle = true;
		
		//Style we dont care about, bail.
		if (validStyle == false)
			return;
		
		var oldStyleData = null;
		var newStyleData = null;
		
		//Get the cache for this style.
		var styleCache = this._stylesCache[styleName];
		
		//Create cache if doesnt exist.
		if (styleCache == null)
		{
			styleCache = {styleData:new StyleData(styleName), cacheInvalid:true};
			this._stylesCache[styleName] = styleCache;
		}
		
		//Cache valid, copy it for later compare.
		if (styleCache.cacheInvalid == false)
			oldStyleData = styleCache.styleData.clone();
		
		//Invalidate the cache
		styleCache.cacheInvalid = true;
		
		//Get updated data.
		newStyleData = this.getStyleData(styleName);
		
		//No change, bail.
		if (oldStyleData != null && oldStyleData.equals(newStyleData) == true)
			return;
		
		if (styleType != null)
			this._invalidateStyle(styleName);
		
		//Re-dispatch from ourself.
		this._dispatchEvent(styleChangedEvent); 
	};
	
//@override
CanvasElement.prototype._getDefaultStyleData = 
	function (styleName)
	{
		var styleData = new StyleData(styleName);
		
		//Check default definition
		if (this._styleDefinitionDefault != null)
			styleData.value = this._styleDefinitionDefault.getStyle(styleName);
			
		if (styleData.value !== undefined)
		{
			styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_DEFINITION);
			return styleData;
		}	
		
		//Check default proxy
		var proxy = this._styleProxy;
		var ctr = 0;
		while (proxy != null)
		{
			if (styleName in proxy._proxyMap == false && proxy._proxyElement._getStyleType(styleName) != null)
				break;
			
			if (proxy._proxyElement._styleDefinitionDefault != null)
				styleData.value = proxy._proxyElement._styleDefinitionDefault.getStyle(styleName);
			
			if (styleData.value !== undefined)
			{
				styleData.priority.push(CanvasElement.StylePriorities.DEFAULT_PROXY);
				styleData.priority.push(ctr);	//Proxy level (chained proxies)
				
				return styleData;
			}
			
			ctr++;
			proxy = proxy._proxyElement._styleProxy;
		}
			
		//Check class
		styleData.value = this._getClassStyle(styleName);
		styleData.priority.push(CanvasElement.StylePriorities.CLASS);
		
		return styleData;			
	};	

/**
 * @function _setStyleDefinitionDefault
 * 
 * Sets the default style definition. Use this when you need to supply a default definition 
 * that differs from the class based definition. For example, you're component uses a Button, 
 * but you need to supply styles to the button (or its skins) that differ from a Button's 
 * class defaults. Default styles do not track changes at runtime so this should always be 
 * called *before* the element is added to its parent and is included in the display chain.
 * 
 * @param styleDefinition StyleDefintion
 * The default style definiton to apply to the element.
 */
CanvasElement.prototype._setStyleDefinitionDefault = 
	function (styleDefinition)
	{
		this._styleDefinitionDefault = styleDefinition;
	};
	
/**
 * @function _setStyleProxy
 * 
 * Sets the element which is to proxy styles to this element. See getStyle() and StyleProxy.
 * 
 * @param styleProxy StyleProxy
 * The StyleProxy element wrapper to use to proxy styles from the proxy element to this element.
 * 
 * @seealso StyleProxy
 */	
CanvasElement.prototype._setStyleProxy = 
	function (styleProxy)
	{
		this._styleProxy = styleProxy;
	};
	
/**
 * @function _onCanvasElementAdded
 * Invoked when the element is added to the canvas. Every CanvasElement already adds its own
 * "added" event listener so overriding this is identical but more efficient than adding your own "added" event listener.
 * You should *always* call the base class function.
 * 
 * @param addedRemovedEvent AddedRemovedEvent
 * The AddedRemovedEvent to process.
 */	
CanvasElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		/////////Added to the Display Chain/////////////
	
		for (var i = 0; i < this._styleDefinitions.length; i++)
		{
			if (this._styleDefinitions[i].hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == false)
				this._styleDefinitions[i].addEventListener("stylechanged", this._onExternalStyleChangedInstance);
		}

		//If proxy is our parent, we dont want duplicate listeners.
		if (this._styleProxy != null && this._styleProxy._proxyElement.hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == false)
			this._styleProxy._proxyElement.addEventListener("stylechanged", this._onExternalStyleChangedInstance);
		
		if (this._backgroundShape != null && this._backgroundShape.hasEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance) == false)
			this._backgroundShape.addEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
		
		//Add broadcast events to manager//
		if ("enterframe" in this._eventListeners && this._eventListeners["enterframe"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["enterframe"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.addEventListener("enterframe", this._eventListeners["enterframe"][i]);
		}
		if ("localechanged" in this._eventListeners && this._eventListeners["localechanged"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["localechanged"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.addEventListener("localechanged", this._eventListeners["localechanged"][i]);
		}
		if ("mousemoveex" in this._eventListeners && this._eventListeners["mousemoveex"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["mousemoveex"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.addEventListener("mousemoveex", this._eventListeners["mousemoveex"][i]);
		}
		
		//Invalidate redraw and composite render
		this._invalidateRedrawRegion();
		this._invalidateCompositeRender();
		
		///////////Invalidate All Styles////////////////
		
		//Invalidate all cache
		for (var prop in this._stylesCache)
			this._stylesCache[prop].cacheInvalid = true;
		
		//Invalidate *all* styles, don't need to propagate, display propagates when attaching.
		var thisProto = Object.getPrototypeOf(this);
		var thisClass = null;
		
		if (thisProto == null || thisProto.hasOwnProperty("constructor") == true)
			thisClass = thisProto.constructor;
		
		while (thisClass != null)
		{
			if ("_StyleTypes" in thisClass)
			{
				for (var styleName in thisClass._StyleTypes)
					this._invalidateStyle(styleName);
			}
			
			thisProto = Object.getPrototypeOf(thisProto);
			if (thisProto == null || thisProto.hasOwnProperty("constructor") == false)
				thisClass = null;
			else
				thisClass = thisProto.constructor;			
		}
		
		//Always dispatch when added.
		if (this.hasEventListener("localechanged", null) == true)
			this._dispatchEvent(new DispatcherEvent("localechanged"));
	};

/**
 * @function _onCanvasElementRemoved
 * Invoked when the element is removed to the canvas. Every CanvasElement already adds its own
 * "removed" event listener so overriding this is identical but more efficient than adding your own "removed" event listener.
 * You should *always* call the base class function.
 * 
 * @param addedRemovedEvent AddedRemovedEvent
 * The AddedRemovedEvent to process.
 */		
CanvasElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		///////Removed from display chain///////////////////
	
		var i = 0;
	
		for (i = 0; i < this._styleDefinitions.length; i++)
		{
			if (this._styleDefinitions[i].hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == false)
				this._styleDefinitions[i].removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
		}
		
		if (this._styleProxy != null && this._styleProxy._proxyElement.hasEventListener("stylechanged", this._onExternalStyleChangedInstance) == true)
			this._styleProxy._proxyElement.removeEventListener("stylechanged", this._onExternalStyleChangedInstance);
		
		if (this._backgroundShape != null && this._backgroundShape.hasEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance) == false)
			this._backgroundShape.removeEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
		
		if (this._rollOverCursorInstance != null)
		{
			addedRemovedEvent.getManager().removeCursor(this._rollOverCursorInstance);
			this._rollOverCursorInstance = null;
		}
		
		//Update the redraw region of any composite parents still attached to the display chain.
		for (i = 0; i < this._compositeMetrics.length; i++)
		{
			if (this._compositeMetrics[i].element._manager != null)
				this._compositeMetrics[i].element._updateRedrawRegion(this._compositeMetrics[i].drawableMetrics);
		}
		
		//Reset cycle flags
		this._stylesInvalid = true;
		this._measureInvalid = true;
		this._layoutInvalid = true;
		this._renderInvalid = true;
		
		//Nuke graphics canvas
		this._graphicsCanvas = null;
		this._graphicsCtx = null;
		this._graphicsClear = true;					
		
		//Nuke composite canvas
		this._compositeCtx = null;																														
		this._compositeCanvas = null;																
		this._compositeCanvasMetrics = null;			 
		
		//Reset redraw flags
		this._renderChanged = true;					
		this._renderVisible = false; 					
		this._compositeEffectChanged = true;
		
		//Nuke composite data
		this._compositeMetrics = [];
		this._compositeVisibleMetrics = null;																						
		this._redrawRegionMetrics = null;																												
		this._transformVisibleMetrics = null;			
		this._transformDrawableMetrics = null;				
		
		//Remove broadcast events from manager//
		if ("enterframe" in this._eventListeners && this._eventListeners["enterframe"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["enterframe"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.removeEventListener("enterframe", this._eventListeners["enterframe"][i]);
		}
		if ("localechanged" in this._eventListeners && this._eventListeners["localechanged"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["localechanged"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.removeEventListener("localechanged", this._eventListeners["localechanged"][i]);
		}
		if ("mousemoveex" in this._eventListeners && this._eventListeners["mousemoveex"].length > 0)
		{
			for (var i = 0; i < this._eventListeners["mousemoveex"].length; i++)
				addedRemovedEvent.getManager()._broadcastDispatcher.removeEventListener("mousemoveex", this._eventListeners["mousemoveex"][i]);
		}
	};	
	
/**
 * @function _getFontString
 * Gets a font string that can be applied to the canvas's Context2D via the element's text styles.
 * This is just a helper to gather and format the styles for the canvas context.
 * 
 * @returns String
 * String to be applied to the canvas contex's font. "bold 14px Arial".
 */	
CanvasElement.prototype._getFontString = 
	function ()
	{
		return this.getStyle("TextStyle") + " " + this.getStyle("TextSize") + "px " + this.getStyle("TextFont");
	};		
	
//@Override
CanvasElement.prototype._dispatchEvent = 
	function (dispatchEvent)
	{
		if (!(dispatchEvent instanceof ElementEvent))
		{
			CanvasElement.base.prototype._dispatchEvent.call(this, dispatchEvent);
			return;
		}
	
		dispatchEvent._canceled = false;
		dispatchEvent._defaultPrevented = false;
		
		//We're transforming the event as we bubble. We shouldn't change the instance given to the dispatcher. 
		var event = dispatchEvent.clone();
	
		event._target = this;
		
		//Clone the event when calling the handlers so they cannot fudge the event data.
		var handlerEvent = null;
		
		if (event._bubbles == true)
		{
			var currentElement = this;
			var currentMousePoint = {x:0, y:0};
			if (event instanceof ElementMouseEvent)
			{
				currentMousePoint.x = event._x;
				currentMousePoint.y = event._y;
			}
			
			//Get parent chain.
			var parentChain = [];
			while (currentElement != null)
			{
				parentChain.push({element:currentElement, 
								x:currentMousePoint.x, 
								y:currentMousePoint.y});
				
				//Adjust mouse point for parent.
				if (event instanceof ElementMouseEvent)
				{
					currentMousePoint.x += currentElement._x;
					currentMousePoint.y += currentElement._y;
					
					currentElement.rotatePoint(currentMousePoint, false);
				}
				
				currentElement = currentElement._parent;
			}
			
			//Dispatch Capture Events.
			event._phase = "capture";
			for (var i = parentChain.length -1; i >= 0; i--)
			{
				currentElement = parentChain[i].element;
				
				if (event._type in currentElement._captureListeners && currentElement._captureListeners[event._type].length > 0)
				{
					event._currentTarget = currentElement;
					if (event instanceof ElementMouseEvent)
					{
						event._x = parentChain[i].x;
						event._y = parentChain[i].y;
					}
					
					//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
					//we dont want to miss an event, or inconsistently dispatch newly added events.
					var listeners = currentElement._captureListeners[event._type].slice();
					
					//TODO: Sort by priority (no priority available yet).
					
					for (var i2 = 0; i2 < listeners.length; i2++)
					{
						handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
						listeners[i2](handlerEvent);
						
						if (handlerEvent._defaultPrevented == true)
							dispatchEvent._defaultPrevented = true;
						
						if (handlerEvent._canceled == true)
						{
							dispatchEvent._canceled = true;
							return;
						}
					}
				}
			}
			
			//Dispatch Bubble Events.
			event._phase = "bubble";
			for (var i = 0; i < parentChain.length; i++)
			{
				currentElement = parentChain[i].element;
				
				if (event._type in currentElement._eventListeners && currentElement._eventListeners[event._type].length > 0)
				{
					event._currentTarget = currentElement;
					if (event instanceof ElementMouseEvent)
					{
						event._x = parentChain[i].x;
						event._y = parentChain[i].y;
					}
					
					//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
					//we dont want to miss an event, or inconsistently dispatch newly added events.
					var listeners = currentElement._eventListeners[event._type].slice();
					
					//TODO: Sort by priority (no priority available yet).
					
					for (var i2 = 0; i2 < listeners.length; i2++)
					{
						handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
						listeners[i2](handlerEvent);
						
						if (handlerEvent._defaultPrevented == true)
							dispatchEvent._defaultPrevented = true;
						
						if (handlerEvent._canceled == true)
						{
							dispatchEvent._canceled = true;
							return;
						}
					}
				}
			}
			
		}
		else //Dispatch only target events.
		{ 
			event._currentTarget = this;

			event._phase = "capture";
			if (event._type in this._captureListeners && this._captureListeners[event._type].length > 0)
			{
				//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
				//we dont want to miss an event, or inconsistently dispatch newly added events.
				var listeners = this._captureListeners[event._type].slice();
				
				//TODO: Sort by priority (no priority available yet).
				
				for (var i2 = 0; i2 < listeners.length; i2++)
				{
					handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
					listeners[i2](handlerEvent);
					
					if (handlerEvent._defaultPrevented == true)
						dispatchEvent._defaultPrevented = true;
					
					if (handlerEvent._canceled == true)
					{
						dispatchEvent._canceled = true;
						return;
					}
				}
			}
			
			event._phase = "bubble";
			if (event._type in this._eventListeners && this._eventListeners[event._type].length > 0)
			{
				//Copy the list of event handlers, if event handlers add/remove other handlers or themselves, 
				//we dont want to miss an event, or inconsistently dispatch newly added events.
				var listeners = this._eventListeners[event._type].slice();
				
				//TODO: Sort by priority (no priority available yet).
				
				for (var i2 = 0; i2 < listeners.length; i2++)
				{
					handlerEvent = event.clone(); //Clone the event so the handler can't fudge our event data.
					listeners[i2](handlerEvent);
					
					if (handlerEvent._defaultPrevented == true)
						dispatchEvent._defaultPrevented = true;
					
					if (handlerEvent._canceled == true)
					{
						dispatchEvent._canceled = true;
						return;
					}
				}
			}
		}
	};

/**
 * @function _addChild
 * Adds a child element to the end of this element's child list.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added.
 */	
CanvasElement.prototype._addChild = 
	function (element)
	{
		return this._addChildAt(element, this._children.length);
	};

/**
 * @function _addChildAt
 * Inserts a child element to this elements child list at the specified index.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a child of this element.
 * 
 * @param index int
 * The index position to insert the child in the elements child list.
 * 
 * @returns CanvasElement
 * Returns the element just added when successfull, null if the element could not
 * be added due to the index being out of range.
 */		
CanvasElement.prototype._addChildAt = 
	function (element, index)
	{
		if (!(element instanceof CanvasElement))
			return null;
		
		if (index < 0 || index > this._children.length)
			return null;
		
		//Elements may only have 1 parent.
		if (element._parent != null)
			element._parent._removeChild(element);
		
		element._parent = this;
		this._children.splice(index, 0, element);
		this.addEventListener("stylechanged", element._onExternalStyleChangedInstance);
		
		element._propagateChildData();
		
		this._invalidateMeasure();
		this._invalidateLayout();
		
		if (this._manager != null)
		{
			this._manager._rollOverInvalid = true;
			this._manager._processAddRemoveDisplayChainQueue();
		}
		
		return element;
	};
	
/**
 * @function _removeChild
 * Removes a child element from this elements child list.
 * 
 * @param element CanvasElement
 * Child to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successfull, null if the
 * element could not be removed due to it not being a child of this element.
 */	
CanvasElement.prototype._removeChild = 
	function (element)
	{
		var childIndex = this._children.indexOf(element);
		if (childIndex == -1)
			return null;
	
		return this._removeChildAt(childIndex);
	};

/**
 * @function _removeChildAt
 * Removes a child element at specified index.
 * 
 * @param index int
 * Index to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successfull, null if the element could
 * not be removed due it it not being a child of this element, or index out of range.
 */		
CanvasElement.prototype._removeChildAt = 
	function (index)
	{
		if (index < 0 || index > this._children.length - 1)
			return null;
		
		var element = this._children.splice(index, 1)[0]; //Returns array of removed items.
		
		//We removed an element that is in mouse-down state. 
		//Change the mouseup target to the parent of this element.
		if (element._mouseIsDown == true)
			element._manager._mouseDownElement = element._parent;
		
		if (element._mouseIsOver == true)
			element._manager._rollOverElement = element._parent;
		
		element._parent = null;
		this.removeEventListener("stylechanged", element._onExternalStyleChangedInstance);
		
		element._propagateChildData();
		
		this._invalidateMeasure();
		this._invalidateLayout();
		
		if (this._manager != null)
		{
			this._manager._rollOverInvalid = true;
			this._manager._processAddRemoveDisplayChainQueue();
		}
		
		return element;
	};	

/**
 * @function _getChildAt
 * Gets the child element at the supplied index.
 * 
 * @param index int
 * Index of child element to return;
 * 
 * @returns CanvasElement
 * The element at the supplied index, or null if index is out of range. 
 */	
CanvasElement.prototype._getChildAt = 
	function (index)
	{
		if (index < 0 || index > this._children.length - 1)
			return null;
		
		return this._children[index];
	};
	
/**
 * @function _getChildIndex
 * Returns the index of the supplied child element.
 * 
 * @param element CanvasElement
 * Child element to return the index.
 * 
 * @returns int
 * Returns the child index or -1 if the element is not
 * a child of this element.
 */	
CanvasElement.prototype._getChildIndex = 
	function (element)
	{
		return this._children.indexOf(element);
	};
	
/**
 * @function _setChildIndex
 * Changes a child element's index. 
 * 
 * @param element CanvasElement
 * Child element to change index.
 * 
 * @param index int
 * New index of the child element.
 * 
 * @returns boolean
 * Returns true if the child's index is successfully changed, false if the element
 * is not a child of this element or the index is out of range.
 */	
CanvasElement.prototype._setChildIndex = 
	function (element, index)
	{
		if (index < 0 || index > this._children.length - 1)
			return false;
		
		var currentIndex = this._getChildIndex(element);
		if (currentIndex == -1 || currentIndex == index)
			return false;
		
		this._children.splice(index, 0, this._children.splice(currentIndex, 1)[0]);
		
		this._invalidateMeasure();
		this._invalidateLayout();
		
		return true;
	};
	
/**
 * @function _getNumChildren
 * Gets this elements number of children.
 * 
 * @returns int
 * The number of child elements.
 */	
CanvasElement.prototype._getNumChildren = 
	function ()
	{
		return this._children.length;
	};
	
//@private	
CanvasElement.prototype._propagateChildData = 
	function ()
	{
		var isManager = (this instanceof CanvasManager);
	
		if ((isManager == false && (this._parent == null || this._parent._displayDepth == 0)) || 
			isManager == true && this._manager != null)
		{//Removed from display chain
			
			//Purge manager data.
			if (this._manager != null)
			{
				if (this._stylesInvalid == true)
					this._manager._updateStylesQueue.removeNode(this._stylesValidateNode, this._displayDepth);
				
				if (this._measureInvalid == true)
					this._manager._updateMeasureQueue.removeNode(this._measureValidateNode, this._displayDepth);
				
				if (this._layoutInvalid == true)
					this._manager._updateLayoutQueue.removeNode(this._layoutValidateNode, this._displayDepth);
				
				if (this._renderInvalid == true)
					this._manager._updateRenderQueue.removeNode(this._renderValidateNode, this._displayDepth);
				
				if (this._compositeRenderInvalid == true)
					this._manager._compositeRenderQueue.removeNode(this._compositeRenderValidateNode, this._displayDepth);
				
				if (this == this._manager._draggingElement)
					this._manager._clearDraggingElement();
				
				if (this == this._manager._focusElement)
					this._manager._focusElement = null;
				
				this._manager._pushAddRemoveDisplayChainQueue(this, "removed");
			}
			
			this._renderFocusRing = false;
			this._isFocused = false;
			this._mouseIsOver = false;
			this._mouseIsDown = false;
			this._displayDepth = 0;
			this._manager = null;
		}
		else
		{//Added to display chain
			
			if (isManager == true)
			{
				this._displayDepth = 1;
				this._manager = this;
			}
			else
			{
				this._displayDepth = this._parent._displayDepth + 1;
				this._manager = this._parent._manager;
			}
			
			//Add manager data.
			if (this._manager != null)
			{
				if (this._stylesInvalid == true)
					this._manager._updateStylesQueue.addNode(this._stylesValidateNode, this._displayDepth);
				
				if (this._measureInvalid == true)
					this._manager._updateMeasureQueue.addNode(this._measureValidateNode, this._displayDepth);
				
				if (this._layoutInvalid == true)
					this._manager._updateLayoutQueue.addNode(this._layoutValidateNode, this._displayDepth);
				
				if (this._renderInvalid == true)
					this._manager._updateRenderQueue.addNode(this._renderValidateNode, this._displayDepth);
				
				if (this._compositeRenderInvalid == true)
					this._manager._compositeRenderQueue.addNode(this._compositeRenderValidateNode, this._displayDepth);
				
				this._manager._pushAddRemoveDisplayChainQueue(this, "added");
			}
		}
		
		for (var i = 0; i < this._children.length; i++)
			this._children[i]._propagateChildData();
	};	

/**
 * @function _setRelativePosition
 * Sets the elements position relative to a supplied element regardless of this element's transformation,
 * depth, or position in the display hierarchy or relation to the supplied relativeToElement. This should typically
 * only be called during the parent element's layout phase. Setting relativeToElement to null has an identical
 * effect to calling _setActualPosition(). This is used by some containers to position the element relative
 * to a parent's coordinate plane rather than the child's transformed plane.
 * 
 * @param x Number
 * The relative X position to move this element's position.
 * 
 * @param y Number
 * The relative Y position to move this element's position.
 * 
 * @param relativeToElement CanvasElement
 * The CanvasElement to move this element relative too.
 */	
CanvasElement.prototype._setRelativePosition = 
	function (x, y, relativeToElement)
	{
		if (relativeToElement == null || relativeToElement == this)
		{
			if (this._x == x && this._y == y)
				return;
			
			this._x = x;
			this._y = y;
			
			if (this._manager != null)
				this._manager._rollOverInvalid = true;
			
			this._invalidateRedrawRegion();
		}
		
		if (this._manager == null || this._manager != relativeToElement._manager)
			return;
		
		//Use relative parent metrics. We want to shift this elements entire plane if its
		//transformed (rotated), we dont want to slide the element around on its transformed plane.
		var parentMetrics = this.getMetrics(this._parent);
		
		//Get the move-to position within our parent element.
		var newPosition = {x:x, y:y};
		relativeToElement.translatePointTo(newPosition, this._parent);
		
		//We haven't moved.
		if (newPosition.x == parentMetrics.getX() && newPosition.y == parentMetrics.getY())
			return;
		
		//Get the delta in its position.
		var deltaX = newPosition.x - parentMetrics.getX();
		var deltaY = newPosition.y - parentMetrics.getY();
		
		this._x = this._x + deltaX;
		this._y = this._y + deltaY;
		
		if (this._rotateDegrees != 0)
		{
			this._rotateCenterX += deltaX;
			this._rotateCenterY += deltaY;
		}
		
		if (this._manager != null)
			this._manager._rollOverInvalid = true;
		
		this._invalidateRedrawRegion();
	};	
		
/**
 * @function _setActualPosition
 * Sets the elements position within its parent. Note that if the element is transformed or rotated,
 * this sets the elements position within its transformed plane. If you wish to position a transformed
 * element relative to its parents coordinate plane, use _setRelativePosition(). This should typically
 * only be called from within the parents layout phase.
 * 
 * @param x int
 * The X position to move the element.
 * 
 * @param y int
 * The Y position to move the element.
 */	
CanvasElement.prototype._setActualPosition = 
	function (x, y)
	{
		x = Math.round(x);
		y = Math.round(y);
		
		if (this._x == x && this._y == y)
			return;
		
		this._x = x;
		this._y = y;
		
		if (this._manager != null)
			this._manager._rollOverInvalid = true;
		
		this._invalidateRedrawRegion();
	};	
	
/**
 * @function _setActualSize
 * Sets this element's size in pixels prior to any transformation or rotation. 
 * This should typically only be called from within the parents layout phase.
 * 
 * @param width Number
 * The width in pixels to size this element.
 * 
 * @param height Number
 * The height in pixels to size this element.
 */	
CanvasElement.prototype._setActualSize = 
	function (width, height)
	{
		//if (typeof width !== "number" || typeof height !== "number" || isNaN(width) || isNaN(height))
		//	throw "Invalid Size";
	
		//TODO: This is BAD!!!  This is effectively a fix for components that arent rounding / drawing on
		//		on even pixel lines causing anti-aliasing fuzz. This *needs* to be removed, and offending components fixed.
		width = Math.round(width);
		height = Math.round(height);
		
		if (this._width == width && this._height == height)
			return false;
		
		this._width = width;
		this._height = height;
		
		this._invalidateLayout();
		this._invalidateRender();
		
		if (this.hasEventListener("resize", null) == true)
			this._dispatchEvent(new DispatcherEvent("resize"), false);
		
		if (this._manager != null)
			this._manager._rollOverInvalid = true;
		
		return true;
	};
	
/**
 * @function _setActualRotation
 * Sets this elements rotation degrees and rotation point relative to its parent. This should typically
 * only be called from within the parent's layout phase.
 * 
 * @param degrees Number
 * Degrees to rotate the element (clockwise).
 * 
 * @param centerX Number
 * The X position relative to the elements parent to rotate around.
 * 
 * @param centerY Number
 * The Y position relative to the elements parent to rotate around.
 */	
CanvasElement.prototype._setActualRotation = 
	function (degrees, centerX, centerY)
	{
		if (centerX == null || centerY == null)
		{
			centerX = 0;
			centerY = 0;
		}
	
		if (this._rotateDegrees != degrees || this._rotateCenterX != centerX || this._rotateCenterY != centerY)
		{
			this._invalidateRedrawRegion();
			
			if (this._rotateDegrees != degrees)
			{
				this._compositeEffectChanged = true;
				this._invalidateCompositeRender();
			}
		}
		
		this._rotateDegrees = degrees;
		this._rotateCenterX = centerX;
		this._rotateCenterY = centerY;
	};
	
//@private
CanvasElement.prototype._setMeasuredSize = 
	function (width, height)
	{
		if (this._measuredWidth == width && this._measuredHeight == height)
			return;
		
		this._measuredWidth = width;
		this._measuredHeight = height;
		
		if (this._parent != null)
		{
			this._parent._invalidateMeasure();
			this._parent._invalidateLayout();
		}
	};
	
//@private	
CanvasElement.prototype._setRenderFocusRing = 
	function (shouldRender)
	{
		if (this._renderFocusRing == shouldRender)
			return;
		
		this._renderFocusRing = shouldRender;
		this._invalidateRender();
	};

//@private	
CanvasElement.prototype._createMetrics = 
	function ()
	{
		return new DrawMetrics();
	};
	
	
/**
 * @function _getGraphicsCtx
 * Returns the canvas context used when rendering this element. This should typically
 * only be called from within the element's _doRender() phase, and only if you intend
 * to actually draw. Calling this will impact the canvas redraw regions.
 *  
 * @returns Canvas2DContext
 * Canvas context used when rendering this element.
 */	
CanvasElement.prototype._getGraphicsCtx = 
	function ()
	{
		if (this._graphicsCanvas == null)
		{
			this._graphicsCanvas = document.createElement("canvas");
			this._graphicsCtx = this._graphicsCanvas.getContext("2d");
			
			this._graphicsCanvas.width = this._width;
			this._graphicsCanvas.height = this._height;
		}
		
		this._renderChanged = true;
		this._graphicsClear = false;
		
		this._invalidateRedrawRegion();
		
		return this._graphicsCtx;
	};
	
	
/**
 * @function _getPaddingSize
 * Helper function that returns the elements total padding width and height per its applied styles.
 * 
 * @returns Object
 * Returns an object containing 
 * {width:paddingWidth, height:paddingHeight,
 * paddingBottom:paddingBottom, paddingTop:paddingTop,
 * paddingLeft:paddingLeft, paddingRight:paddingRight}.
 */	
CanvasElement.prototype._getPaddingSize = 
	function ()
	{
		var paddingData = this.getStyleData("Padding");
		var paddingTopData = this.getStyleData("PaddingTop");
		var paddingBottomData = this.getStyleData("PaddingBottom");
		var paddingLeftData = this.getStyleData("PaddingLeft");
		var paddingRightData = this.getStyleData("PaddingRight");
		
		var paddingTop = paddingTopData.value;
		if (paddingData.comparePriority(paddingTopData) > 0) //Use Padding if higher priority
			paddingTop = paddingData.value;
		
		var paddingBottom = paddingBottomData.value;
		if (paddingData.comparePriority(paddingBottomData) > 0) //Use Padding if higher priority
			paddingBottom = paddingData.value;
		
		var paddingLeft = paddingLeftData.value;
		if (paddingData.comparePriority(paddingLeftData) > 0) //Use Padding if higher priority
			paddingLeft = paddingData.value;
		
		var paddingRight = paddingRightData.value;
		if (paddingData.comparePriority(paddingRightData) > 0) //Use Padding if higher priority
			paddingRight = paddingData.value;
		
		return { width: paddingLeft + paddingRight, 
				height: paddingTop + paddingBottom, 
				paddingBottom:paddingBottom, 
				paddingTop:paddingTop, 
				paddingLeft:paddingLeft, 
				paddingRight:paddingRight};
	};

/**
 * @function _getBorderThickness
 * Helper function that returns the elements border thickness per its applied styles.
 * 
 * @returns Number
 * The elements border thickness.
 */	
CanvasElement.prototype._getBorderThickness = 
	function ()
	{
		var borderThickness = 0;
		var borderType = this.getStyle("BorderType");
		var borderColor = this.getStyle("BorderColor");
		if ((borderType == "solid" || borderType == "inset" || borderType == "outset") && borderColor != null)
		{
			borderThickness = this.getStyle("BorderThickness");
			if (borderThickness < 0)
				borderThickness = 0;
		}
		
		return borderThickness;
	};

/**
 * @function _getStyledOrMeasuredWidth
 * Helper function that returns this elements styled width, or measured width if no style is set. Typically
 * called from within a parent containers layout phase.
 * 
 * @returns Number
 * The elements width.
 */	
CanvasElement.prototype._getStyledOrMeasuredWidth = 
	function ()
	{
		var width = this.getStyle("Width");
		if (width == null)
			width = this._measuredWidth;
		
		return width;
	};

/**
 * @function _getStyledOrMeasuredHeight
 * Helper function that returns this elements styled height, or measured height if no style is set. Typically
 * called from within a parent containers layout phase.
 * 
 * @returns Number
 * The elements height.
 */		
CanvasElement.prototype._getStyledOrMeasuredHeight = 
	function ()
	{
		var height = this.getStyle("Height");
		if (height == null)
			height = this._measuredHeight;
		
		return height;
	};
	
/**
 * @function _getBorderMetrics
 * Helper function that returns a DrawMetrics object whose bounding area is inside this elements border.
 * 
 * @returns DrawMetrics
 * Returns DrawMetrics that define a bounding area inside this elements border.
 */	
CanvasElement.prototype._getBorderMetrics = 
	function ()
	{
		var metrics = this._createMetrics();
		
		var borderThickness = this._getBorderThickness();
		
		metrics._x = borderThickness / 2;
		metrics._y = borderThickness / 2;
		
		metrics._width = this._width - borderThickness;
		metrics._height = this._height - borderThickness;
		
		return metrics;
	};
	
/**
 * @function _getPaddingMetrics
 * Helper function that returns a DrawMetrics object whose bounding area is inside this elements padding area.
 * 
 * @returns DrawMetrics
 * Returns DrawMetrics that define a bounding area inside this elements padding area.
 */		
CanvasElement.prototype._getPaddingMetrics = 
	function()
	{
		var metrics = this._createMetrics();
		var paddingSize = this._getPaddingSize();
		
		metrics._x = paddingSize.paddingLeft;
		metrics._y = paddingSize.paddingTop;
		metrics._width = this._width -  paddingSize.paddingLeft - paddingSize.paddingRight;
		metrics._height = this._height - paddingSize.paddingTop - paddingSize.paddingBottom;
		
		return metrics;
	};

/**
 * @function _getAutoGradientFill
 * Helper function that returns a Context2D linear or radial CanvasGradient depending on this elements
 * auto gradient styles. This gradient uses 1 color and lightens and darkens the supplied color. 
 * The gradient is always oriented in the same direction regardless of the elements rotation or transformation. 
 * This is used for a consistent light source. 
 * 
 * @param color String
 * Hex color to lighten and darken for gradient. Format "#FF0000" (red).
 * 
 * @param context Canvas2DContext
 * Canvas2DContext to use to generate the gradient.
 * 
 * @returns CanvasGradient
 * Returns CanvasGradient to be applied to canvas Context2D.
 */		
CanvasElement.prototype._getAutoGradientFill = 
	function (color, context)
	{
		var gradientType = this.getStyle("AutoGradientType");
		
		if (gradientType == "radial")
			return this._getAutoGradientRadial(color, context);
		else if (gradientType == "linear")
			return this._getAutoGradientLinear(color, context);
		
		return null;
	};

/**
 * @function _getAutoGradientMetrics
 * Helper function that returns a metrics object to be used for generating a consistent gradient
 * relative to the canvas regardless of the elements rotation, transformation or position in the
 * display hierarchy. Currently this always generates a gradient at 10 degrees from the upper left
 * to the lower right for consistency with inset/outset borders. This is used by the auto-gradient
 * to create a consistent light source. More styles should be added to allow changing the degrees
 * for more flexibility.
 * 
 * @returns Object
 * Gradient metrics object containing {startPoint:{x,y}, endPoint:{x, y}, width, height}
 */	
CanvasElement.prototype._getAutoGradientMetrics = 
	function ()
	{
		//Get metrics relative to the canvas. Regardless of transform, 
		//light source should always be consistent.
		var metrics = this.getMetrics(this._manager);
	
		//For convienience
		var canvasX = metrics.getX();
		var canvasY = metrics.getY();
		var canvasWidth = metrics.getWidth();
		var canvasHeight = metrics.getHeight();
		
		//Calculate the gradient line based on the element's canvas metrics.
		var gradientWidth = canvasHeight * Math.tan(CanvasElement.degreesToRadians(8));
		
		var gradientStart = {x:0, y:canvasY};
		if (gradientWidth <= canvasWidth)
			gradientStart.x = canvasX + (canvasWidth / 2) - (gradientWidth / 2);
		else
			gradientStart.x = canvasX - ((gradientWidth - canvasWidth) / 2);
		
		var gradientEnd = {x:0, y:canvasY + canvasHeight};
		if (gradientWidth <= canvasWidth)
			gradientEnd.x = canvasX + (canvasWidth / 2) + (gradientWidth / 2);
		else
			gradientEnd.x = canvasX + canvasWidth + ((gradientWidth - canvasWidth) / 2);
		
		//Translate the gradient line start/stop back down to the element's coordinate plane.
		this._manager.translatePointTo(gradientStart, this);
		this._manager.translatePointTo(gradientEnd, this);
		
		return {startPoint:gradientStart, endPoint:gradientEnd, width:canvasWidth, height:canvasHeight};
	};

/**
 * @function _getAutoGradientLinear
 * Helper function that returns a Context2D linear CanvasGradient depending on this elements
 * auto gradient styles. See _getAutoGradientFill().
 * 
 * @param color String
 * Hex color to lighten and darken for gradient. Format "#FF0000" (red).
 * 
 * @param context Canvas2DContext
 * Canvas2DContext to use to generate the gradient.
 * 
 * @returns CanvasGradient
 * Returns CanvasGradient to be applied to canvas Context2D.
 */		
CanvasElement.prototype._getAutoGradientLinear = 
	function (color, context)
	{
		var lighterFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStart"));
		var darkerFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStop"));
		
		var gradientMetrics = this._getAutoGradientMetrics();
		
		var fillGradient = context.createLinearGradient(
									gradientMetrics.startPoint.x, gradientMetrics.startPoint.y, 
									gradientMetrics.endPoint.x, gradientMetrics.endPoint.y);
		try
		{
			fillGradient.addColorStop(0, lighterFill);
			fillGradient.addColorStop(1, darkerFill);
		}
		catch (ex)
		{
			//Swallow, invalid color
			return null;
		}
		
		return fillGradient;
	};	
	
/**
 * @function _getAutoGradientRadial
 * Helper function that returns a Context2D linear CanvasGradient depending on this elements
 * auto gradient styles. See _getAutoGradientFill().
 * 
 * @param color String
 * Hex color to lighten and darken for gradient. Format "#FF0000" (red).
 * 
 * @param context Canvas2DContext
 * Canvas2DContext to use to generate the gradient.
 * 
 * @returns CanvasGradient
 * Returns CanvasGradient to be applied to canvas Context2D.
 */		
CanvasElement.prototype._getAutoGradientRadial = 
	function (color, context)
	{
		var lighterFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStart"));
		var darkerFill = CanvasElement.adjustColorLight(color, this.getStyle("AutoGradientStop"));
		
		var gradientMetrics = this._getAutoGradientMetrics();
		
		var xSpan = gradientMetrics.endPoint.x - gradientMetrics.startPoint.x;
		var ySpan = gradientMetrics.endPoint.y - gradientMetrics.startPoint.y;
		
		var gradientPoint = {x:gradientMetrics.startPoint.x + (xSpan * .42), 
							y:gradientMetrics.startPoint.y + (ySpan * .42)};
		
		var fillGradient = context.createRadialGradient(
				gradientPoint.x, gradientPoint.y, 
				(Math.max(gradientMetrics.width, gradientMetrics.height) / 2) + (Math.max(xSpan, ySpan) * .08), 
				gradientPoint.x, gradientPoint.y, 
				0);
		
		fillGradient.addColorStop(0, darkerFill);
		fillGradient.addColorStop(1, lighterFill);
		
		return fillGradient;
	};	

/**
 * @function _drawBackgroundShape
 * Used to draw the path to the Canvas2DContext that is to be used to render the focus ring,
 * fill the background, and draw the border. You should never need to explicitly call this. 
 * The system calls this during render phase.
 * Typically you should use the BackgroundShape style
 * for this, but may override it under more complex scenarios.
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to draw the background shape path.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */	
CanvasElement.prototype._drawBackgroundShape = 
	function (ctx, borderMetrics)
	{
		if (this._backgroundShape == null)
		{
			//Full rectangle
			var x = borderMetrics.getX();
			var y = borderMetrics.getY();
			var w = borderMetrics.getWidth();
			var h = borderMetrics.getHeight();
			
			ctx.moveTo(x, y);
			ctx.lineTo(x + w, y);
			ctx.lineTo(x + w, y + h);
			ctx.lineTo(x, y + h);
			ctx.closePath();
		}
		else
		{
			this._backgroundShape.drawShape(ctx, borderMetrics);
		}
	};

/**
 * @function _drawFocusRing
 * Used to draw the focus ring when a tab-able element gains focus due to a tab stop per the elements styles.
 * You should never need to explicitly call this. The system calls this during
 * the render phase. You may override if you wish to draw a more complex focus indicator.
 * Focus ring is drawn *outside* the elements bounding box. Focus ring is rendered
 * before the background and border. 
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to render the focus ring.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */		
CanvasElement.prototype._drawFocusRing = 
	function (ctx, borderMetrics)
	{
		var focusRingThickness = this.getStyle("FocusThickness");
		if (focusRingThickness <= 0)
			return;
		
		var focusRingColor = this.getStyle("FocusColor");
		if (focusRingColor == null)
			return;		
		
		var metrics = this.getMetrics(this);
		
		var x = metrics.getX() - focusRingThickness;
		var y = metrics.getY() - focusRingThickness;
		var w = metrics.getWidth() + (focusRingThickness * 2);
		var h = metrics.getHeight() + (focusRingThickness * 2);
		
		ctx.beginPath();
		
		//Draw anticlockwise
		ctx.moveTo(x, y);
		ctx.lineTo(x, y + h);
		ctx.lineTo(x + w, y + h);
		ctx.lineTo(x + w, y);
		ctx.closePath();
		
		//Draws clockwise (shape inside shape)
		this._drawBackgroundShape(ctx, borderMetrics);
		
		//Clip the *inside* of the background shape
		ctx.clip();

		//Draw border
		ctx.beginPath();
		this._drawBackgroundShape(ctx, borderMetrics);
		
		ctx.strokeStyle = focusRingColor;

		//Increase thickness
		ctx.lineWidth = this._getBorderThickness() + (focusRingThickness * 2);
		ctx.stroke();
	};
	
/**
 * @function _fillBackground
 * Used to fill the elements background shape according to the elements background color and gradient settings.
 * You should never need to explicitly call this. The system calls this during
 * the render phase. You may override if you need to do a more complex background fill. The background fill
 * is rendered after the focus ring and before the border. 
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to fill the background shape.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */	
CanvasElement.prototype._fillBackground = 
	function (borderMetrics)
	{
		var backgroundColor = this.getStyle("BackgroundColor");
		if (backgroundColor == null)
			return;
	
		var ctx = this._getGraphicsCtx();
		var gradientFill = this._getAutoGradientFill(backgroundColor, ctx);
		
		if (gradientFill != null)
			ctx.fillStyle = gradientFill;
		else
			ctx.fillStyle = backgroundColor;
		
		ctx.beginPath();
		this._drawBackgroundShape(ctx, borderMetrics);

		ctx.fill();
	};

//@private	
CanvasElement.prototype._drawSolidBorder = 
	function (ctx, borderMetrics)
	{
		var borderColor = this.getStyle("BorderColor");
		if (borderColor == null)
			return;
		
		var borderThickness = this.getStyle("BorderThickness");
		if (borderThickness < 0)
			return;
	
		ctx.beginPath();
		this._drawBackgroundShape(ctx, borderMetrics);
		ctx.strokeStyle = borderColor;

		ctx.lineWidth = borderThickness;
		ctx.stroke();
	};
	
/**
 * @function _drawBorder
 * Used to render the elements border according to the element's style settings.
 * You should never need to explicitly call this. The system calls this during
 * the render phase. You may override if you need to do a more complex border. The border
 * is rendered last, on top of the focus ring and background fill.
 * 
 * @param ctx Canvas2DContext
 * Canvas2DContext to render the border.
 * 
 * @param borderMetrics DrawMetrics
 * The DrawMetrics containing x,y,width,height used to draw the background. These
 * metrics should be the same as the ones used to stroke a solid border.
 */		
CanvasElement.prototype._drawBorder = 
	function (borderMetrics)
	{
		var borderType = this.getStyle("BorderType");
	
		if (borderType != "solid" && borderType != "inset" && borderType != "outset")
			return;			
	
		var ctx = this._getGraphicsCtx();
		
		if (borderType == "solid")
		{
			this._drawSolidBorder(ctx, borderMetrics);
		}
		else //inset || outset
		{
			var borderColor = this.getStyle("BorderColor");
			var borderThickness = this.getStyle("BorderThickness");
			
			if (borderColor == null || borderThickness <= 0)
				return;
			
			var x = 0;
			var y = 0;
			var w = this._width;
			var h = this._height;
			
			var lighterColor = CanvasElement.adjustColorLight(borderColor, .3);
			var darkerColor = CanvasElement.adjustColorLight(borderColor, .3 * -1);
			
			var tlColor = borderType == "inset" ? darkerColor : lighterColor;
			var brColor = borderType == "inset" ? lighterColor : darkerColor;
			
			ctx.beginPath();
			ctx.moveTo(x, y + h);
			ctx.lineTo(x, y);
			ctx.lineTo(x + w, y);
			
			ctx.lineTo(x + w - borderThickness, y + borderThickness);
			ctx.lineTo(x + borderThickness, y + borderThickness);
			ctx.lineTo(x + borderThickness, y + h - borderThickness);
			ctx.closePath();
			
			ctx.fillStyle = tlColor;
			ctx.fill();
			
			ctx.beginPath();
			ctx.moveTo(x, y + h);
			ctx.lineTo(x + w, y + h);
			ctx.lineTo(x + w, y);
			
			ctx.lineTo(x + w - borderThickness, y + borderThickness);
			ctx.lineTo(x + w - borderThickness, y + h - borderThickness);
			ctx.lineTo(x + borderThickness, y + h - borderThickness);
			ctx.closePath();
			
			ctx.fillStyle = brColor;
			ctx.fill();
			
			ctx.lineWidth = 1;
			ctx.globalAlpha= .15;
			ctx.strokeStyle = "#000000";
			
			ctx.beginPath();
			ctx.moveTo(x, y);
			ctx.lineTo(x + borderThickness, y + borderThickness);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.moveTo(x + w, y + h);
			ctx.lineTo(x + w - borderThickness, y + h - borderThickness);
			ctx.stroke();
		}
	};

//@private	
CanvasElement.prototype._validateStyles = 
	function ()
	{
		this._stylesInvalid = false;
	
		//Reset and record the current set of invalid styles
		var stylesInvalidMap = Object.create(null);
		
		for (var prop in this._stylesInvalidMap)
		{
			if (this._stylesInvalidMap[prop] == true)
			{
				stylesInvalidMap[prop] = true; //Record
				this._stylesInvalidMap[prop] = false; //Reset
			}
		}
		
		this._doStylesUpdated(stylesInvalidMap);
	};
	
//@private	
CanvasElement.prototype._validateMeasure = 
	function ()
	{
		this._measureInvalid = false;
	
		var paddingSize = this._getPaddingSize();
		var measuredSize = this._doMeasure(paddingSize.width, paddingSize.height);
			
		this._setMeasuredSize(measuredSize.width, measuredSize.height);
	};
	
//@private	
CanvasElement.prototype._validateLayout = 
	function ()
	{
		this._layoutInvalid = false;
		this._doLayout(this._getPaddingMetrics());
		
		if (this._layoutInvalid == false && this.hasEventListener("layoutcomplete", null))
			this._dispatchEvent(new DispatcherEvent("layoutcomplete"));
	};	
	
//@private
CanvasElement.prototype._validateRender = 
	function ()
	{
		this._renderInvalid = false;
		
		if (this._graphicsCanvas != null)
		{
			this._graphicsCanvas.width = this._width;
			this._graphicsCanvas.height = this._height;
			this._graphicsCtx.clearRect(0, 0, this._graphicsCanvas.width, this._graphicsCanvas.height);
		}
		
		if (this._graphicsClear == false)
		{
			this._renderChanged = true;
			this._graphicsClear = true;
			
			this._invalidateRedrawRegion();
		}
		
		this._doRender();
	};

//@private
CanvasElement.prototype._getCompositeMetrics = 
	function (compositeParent)
	{
		for (var i = 0; i < this._compositeMetrics.length; i++)
		{
			if (this._compositeMetrics[i].element == compositeParent)
				return this._compositeMetrics[i];
		}
		
		return null;
	};
	
//@private
CanvasElement.prototype._validateCompositeRender = 
	function ()
	{
		if (this._isCompositeElement() == true)
		{
			this._updateCompositeCanvas();
			
			if (this._redrawRegionMetrics != null && this._compositeCanvasMetrics != null)
			{
				//Add a 1 pixel buffer to the redraw region. 
				//This accounts for rounding errors considering redraw regions are calculated per element
				//and composite layers calculated are rendered as an aggregate.
				this._redrawRegionMetrics._x -= 1;
				this._redrawRegionMetrics._y -= 1;
				this._redrawRegionMetrics._width += 2;
				this._redrawRegionMetrics._height += 2;
				this._redrawRegionMetrics.roundUp();
				
				//Composite canvas may have shrunk to smaller than the redraw region, adjust the redraw region
				this._redrawRegionMetrics.mergeReduce(this._compositeCanvasMetrics);
				
				if (this._redrawRegionMetrics._width > 0 && this._redrawRegionMetrics._height > 0)
				{
					this._compositeCtx.clearRect(this._redrawRegionMetrics._x, this._redrawRegionMetrics._y, this._redrawRegionMetrics._width, this._redrawRegionMetrics._height);
					this._renderRedrawRegion(this);
				}
			}
		}
		else //No longer a composite element, nuke the compositing canvases
		{
			this._compositeCanvas = null;				
			this._compositeCtx = null;				
			this._compositeCanvasMetrics = null;		
		}
		
		this._compositeRenderInvalid = false;
		this._compositeEffectChanged = false;
		this._redrawRegionMetrics = null;
	};	
	
//@private	
CanvasElement.prototype._updateCompositeCanvas = 
	function ()
	{
		if (this._compositeVisibleMetrics == null)
		{
			this._compositeCanvas = null;
			this._compositeCtx = null;
			this._compositeCanvasMetrics = null;
		}
		else 
		{
			var newMetrics = this._compositeVisibleMetrics.clone();
			newMetrics.roundUp();
			
			if (this._compositeCanvas == null || this._compositeCanvasMetrics.equals(newMetrics) == false)
			{
				if (this._compositeCanvas == null)
				{
					this._compositeCanvas = document.createElement("canvas");
					this._compositeCtx = this._compositeCanvas.getContext("2d");
				}
				
				if (this._compositeCanvasMetrics == null)
					this._compositeCanvasMetrics = newMetrics;
				else
					this._compositeCanvasMetrics.copyFrom(newMetrics);
				
				this._compositeCanvas.width = this._compositeCanvasMetrics._width;
				this._compositeCanvas.height = this._compositeCanvasMetrics._height;
				
				//Translate x / y
				this._compositeCtx.setTransform(1, 0, 0, 1, this._compositeCanvasMetrics._x * -1, this._compositeCanvasMetrics._y * -1);
				
				//Expand the redraw region to this whole canvas.
				if (this._redrawRegionMetrics == null)
					this._redrawRegionMetrics = this._compositeCanvasMetrics.clone();
				else
					this._redrawRegionMetrics.mergeExpand(this._compositeCanvasMetrics);
			}
		}
	};
	
//@private	
CanvasElement.prototype._isCompositeElement = 
	function ()
	{
		if (this == this._manager)
			return true;
		
		var alpha = this.getStyle("Alpha");
		if (alpha > 0 && alpha < 1)
			return true;
		
		var rotateDegrees = CanvasElement.normalizeDegrees(this._rotateDegrees);
		if (rotateDegrees != 0)
			return true;
		
		if (this.getStyle("ShadowSize") > 0 && this.getStyle("ShadowColor") != null)
			return true;
		
		if (this.getStyle("CompositeLayer") == true)
			return true;
		
		return false;
	};
	
//@private	
CanvasElement.prototype._updateRedrawRegion = 
	function (changedMetrics)
	{
		if (changedMetrics == null || changedMetrics._width <= 0 || changedMetrics._height <= 0)
			return;
	
		if (this._redrawRegionMetrics == null)
			this._redrawRegionMetrics = changedMetrics.clone();
		else
			this._redrawRegionMetrics.mergeExpand(changedMetrics);
		
		this._invalidateCompositeRender();
	};	
	
//@private - This is here to handle a firefox bug. FF ignores clipping if shadow is applied prior to any other
//			 rendering. We draw one pixel outside the canvas bounds to make sure the clipping region gets applied.
CanvasElement.prototype._primeShadow = 
	function ()
	{
		this._compositeCtx.beginPath();
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x - 1, this._compositeCanvasMetrics._y - 1);
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x, this._compositeCanvasMetrics._y - 1);
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x, this._compositeCanvasMetrics._y);
		this._compositeCtx.moveTo(this._compositeCanvasMetrics._x - 1, this._compositeCanvasMetrics._y);
		this._compositeCtx.closePath();
		
		this._compositeCtx.fillStyle = "#000000";
		this._compositeCtx.fill();
	};
	
//@private	
CanvasElement.prototype._renderRedrawRegion = 
	function (element)
	{
		if (element._renderVisible == false)
			return;
	
		var isCompositeChildElement = false;
		if (this != element && element._isCompositeElement() == true)
			isCompositeChildElement = true;
		
		var elementGraphics = null;
		var drawableMetrics = null;
		var compositeMetrics = null;
		
		if (isCompositeChildElement == true && element._transformDrawableMetrics != null)
		{
			compositeMetrics = element._transformVisibleMetrics;
			drawableMetrics = element._transformDrawableMetrics;
			elementGraphics = element._compositeCanvas;
			
			this._compositeCtx.globalAlpha = element.getStyle("Alpha");
		}
		else if (element._compositeMetrics.length > 0 && element._graphicsClear == false)
		{
			compositeMetrics = element._compositeMetrics[0].metrics;
			drawableMetrics = element._compositeMetrics[0].drawableMetrics;
			elementGraphics = element._graphicsCanvas;
			
			this._compositeCtx.globalAlpha = 1;
		}
		
		if (elementGraphics != null &&
			drawableMetrics._width > 0 && drawableMetrics._height > 0 &&
			drawableMetrics._x < this._redrawRegionMetrics._x + this._redrawRegionMetrics._width && 
			drawableMetrics._x + drawableMetrics._width > this._redrawRegionMetrics._x && 
			drawableMetrics._y < this._redrawRegionMetrics._y + this._redrawRegionMetrics._height && 
			drawableMetrics._y + drawableMetrics._height > this._redrawRegionMetrics._y)
		{
			if (isCompositeChildElement == true && CanvasElement.normalizeDegrees(element._rotateDegrees) != 0)
			{
				var clipMetrics = drawableMetrics.clone();
				clipMetrics.mergeReduce(this._redrawRegionMetrics);
				
				this._compositeCtx.save();
				
				//Clip the region we need to re-draw
				this._compositeCtx.beginPath();
				this._compositeCtx.moveTo(clipMetrics._x, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.lineTo(clipMetrics._x, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.closePath();
				this._compositeCtx.clip();
				
				//Translate canvas to actual position
				var parent = element._parent;
				while (parent._isCompositeElement() == false)
				{
					this._compositeCtx.translate(parent._x, parent._y);
					parent = parent._parent;
				} 
				
				//Do rotation
				this._compositeCtx.translate(element._rotateCenterX, element._rotateCenterY);
				this._compositeCtx.rotate(CanvasElement.degreesToRadians(element._rotateDegrees));
				this._compositeCtx.translate(-element._rotateCenterX, -element._rotateCenterY);
			
				//Account for composite canvas translation.
				this._compositeCtx.translate(element._compositeCanvasMetrics._x, element._compositeCanvasMetrics._y);
				
				//Handle shadow
				if (element.getStyle("ShadowSize") > 0 && element.getStyle("ShadowColor") != null)
				{
					//Handle firefox bug.
					this._primeShadow();
					
					this._compositeCtx.shadowBlur = element.getStyle("ShadowSize");
					this._compositeCtx.shadowColor = element.getStyle("ShadowColor");
					
					//We need to rotate the shadow to match the element's rotation
					var shadowOffsetX = element.getStyle("ShadowOffsetX");
					var shadowOffsetY = element.getStyle("ShadowOffsetY");
					var radius = Math.sqrt((shadowOffsetX * shadowOffsetX) + (shadowOffsetY * shadowOffsetY));
					var degrees = 360 - element._rotateDegrees + CanvasElement.radiansToDegrees(Math.atan2(shadowOffsetX, shadowOffsetY));
					
					this._compositeCtx.shadowOffsetX = Math.sin(CanvasElement.degreesToRadians(degrees)) * radius;
					this._compositeCtx.shadowOffsetY = Math.cos(CanvasElement.degreesToRadians(degrees)) * radius;
				}
				
				this._compositeCtx.drawImage(
					elementGraphics, 
					0, 0, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height, 
					element._x, element._y, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height);
				
				this._compositeCtx.restore();
			}
			else if (isCompositeChildElement == true && element.getStyle("ShadowSize") > 0 && element.getStyle("ShadowColor") != null)
			{
				this._compositeCtx.save();
				
				var clipMetrics = drawableMetrics.clone();
				clipMetrics.mergeReduce(this._redrawRegionMetrics);
				
				//Clip the region we need to re-draw
				this._compositeCtx.beginPath();
				this._compositeCtx.moveTo(clipMetrics._x, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y);
				this._compositeCtx.lineTo(clipMetrics._x + clipMetrics._width, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.lineTo(clipMetrics._x, clipMetrics._y + clipMetrics._height);
				this._compositeCtx.closePath();
				this._compositeCtx.clip();
				
				//Handle firefox bug.
				this._primeShadow();
				
				this._compositeCtx.shadowBlur = element.getStyle("ShadowSize");
				this._compositeCtx.shadowColor = element.getStyle("ShadowColor");
				this._compositeCtx.shadowOffsetX = element.getStyle("ShadowOffsetX");
				this._compositeCtx.shadowOffsetY = element.getStyle("ShadowOffsetY");
				
				//Account for canvas edge buffer (visible - canvas)
				var destX = compositeMetrics._x - (element._compositeVisibleMetrics._x - element._compositeCanvasMetrics._x);
				var destY = compositeMetrics._y - (element._compositeVisibleMetrics._y - element._compositeCanvasMetrics._y);
				
				this._compositeCtx.drawImage(
						elementGraphics, 
						0, 0, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height, 
						destX, destY, element._compositeCanvasMetrics._width, element._compositeCanvasMetrics._height);
				
				this._compositeCtx.restore();
			}
			else
			{
				var sourceX = 0;
				var sourceY = 0;
				
				var destX = 0;
				var destY = 0;

				var width = 0;
				var height = 0;
				
				if (drawableMetrics._x >= this._redrawRegionMetrics._x)
				{
					sourceX = drawableMetrics._x - compositeMetrics._x;
					destX = drawableMetrics._x;
					
					width = Math.min(drawableMetrics._width,  this._redrawRegionMetrics._width - (drawableMetrics._x - this._redrawRegionMetrics._x));
				}
				else
				{
					sourceX = this._redrawRegionMetrics._x - compositeMetrics._x;
					destX = this._redrawRegionMetrics._x;
					
					width = Math.min(this._redrawRegionMetrics._width,  drawableMetrics._width - (this._redrawRegionMetrics._x - drawableMetrics._x));
				}
				
				if (drawableMetrics._y >= this._redrawRegionMetrics._y)
				{
					sourceY = drawableMetrics._y - compositeMetrics._y;
					destY = drawableMetrics._y;
					
					height = Math.min(drawableMetrics._height,  this._redrawRegionMetrics._height - (drawableMetrics._y - this._redrawRegionMetrics._y));
				}
				else
				{
					sourceY = this._redrawRegionMetrics._y - compositeMetrics._y;
					destY = this._redrawRegionMetrics._y;
					
					height = Math.min(this._redrawRegionMetrics._height,  drawableMetrics._height - (this._redrawRegionMetrics._y - drawableMetrics._y));
				}
				
				this._compositeCtx.drawImage(
					elementGraphics, 
					sourceX, sourceY, width, height, 
					destX, destY, width, height);
			}
		}
		
		if (isCompositeChildElement == false)
		{
			for (var i = 0; i < element._children.length; i++)
				this._renderRedrawRegion(element._children[i]);
		}
	};			
	
/**
 * @function _invalidateStyle
 * Invalidates the supplied style and causes the system to invoke the _doStylesChanged() function.
 * This should never concievably be called and is exclusively handled by the system. 
 * This is the starting point for the element lifecycle. If you're program is dependent on 
 * _doStylesChanged() when no styles have actually changed, you might have a design issue. 
 * Do not override this function.
 * 
 * @param styleName String
 * String representing the style to be invalidated.
 */	
CanvasElement.prototype._invalidateStyle = 
	function (styleName)
	{
		if (this._stylesInvalid == false)
		{
			this._stylesInvalid = true;
			
			if (this._manager != null)
				this._manager._updateStylesQueue.addNode(this._stylesValidateNode, this._displayDepth);
		}
		
		this._stylesInvalidMap[styleName] = true;
	};	
	
/**
 * @function _invalidateMeasure
 * Invalidates the element's measured sizes and causes the system to invoke 
 * doMeasure() on the next measure phase. The system calls this automatically for all
 * existing components, this is only necessary for custom component development. 
 * This should only be called when a change is made
 * to the element that will impact its measurement. Such as property changes or from within the elements doStylesUpdated() 
 * when a style change impacts the elements measurement (such as Padding).  On rare occasions
 * you may need to re-invalidate measurement from within the doMeasure() function (such as wrapping text).
 * This will cause a 2nd measurement pass for that element which is valid (but expensive).
 * Do not override this function.
 */	
CanvasElement.prototype._invalidateMeasure = 
	function()
	{
		//Only invalidate once.
		if (this._measureInvalid == false)
		{
			this._measureInvalid = true;
			
			if (this._manager != null)
				this._manager._updateMeasureQueue.addNode(this._measureValidateNode, this._displayDepth);
		}
	};
	
/**
 * @function _invalidateLayout
 * Invalidates the elements child layout and causes the system to invoke doLayout() on
 * the next layout phase. The system calls this automatically for all existing components,
 * this is only necessary for custom component development.
 * This should only be called when a change is made to the element that will impact its layout.
 * Such as property changes or from within the elements doStylesUpdated() when a style change impacts
 * the element's layout (such as Padding). On rare occasions you may need to re-invalidate layout
 * from within the doLayout() function. An example is when a DataList adds a new DataRenderer it
 * re-invalidates layout to allow the renderer to measure before continuing layout.
 * Do not override this function.
 */	
CanvasElement.prototype._invalidateLayout = 
	function()
	{
		//Only invalidate once.
		if (this._layoutInvalid == false)
		{
			this._layoutInvalid = true;
			
			if (this._manager != null)
				this._manager._updateLayoutQueue.addNode(this._layoutValidateNode, this._displayDepth);
		}
	};	
	
/**
 * @function _invalidateRender
 * Invalidates the elements child render and causes the system to invoke doRender() on
 * the next render phase. The system calls this automatically for all existing components,
 * this is only necessary for custom component development.
 * This should only be called when a change is made to the element that will impact its rendering.
 * Such as property changes or from within the elements doStylesUpdated() when a style change impacts
 * the element's rendering (such as BackgroundColor). 
 * Do not override this function.
 */	
CanvasElement.prototype._invalidateRender =
	function ()
	{
		//Only invalidate once.
		if (this._renderInvalid == false)
		{
			this._renderInvalid = true;
			
			if (this._manager != null)
				this._manager._updateRenderQueue.addNode(this._renderValidateNode, this._displayDepth);
		}
	};	
	
//@private	
CanvasElement.prototype._invalidateRedrawRegion = 
	function ()
	{
		if (this._manager != null)
			this._manager._redrawRegionInvalid = true;
	};	
	
//@private
CanvasElement.prototype._invalidateCompositeRender = 
	function ()
	{
		if (this._compositeRenderInvalid == false)
		{
			this._compositeRenderInvalid = true;
			
			if (this._manager != null)
				this._manager._compositeRenderQueue.addNode(this._compositeRenderValidateNode, this._displayDepth);
		}
	};
	
/**
 * @function _doStylesUpdated
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to style changes or elements being added to the display hierarchy.
 * Override this function to handle style changes to the element. Style changes may impact other styles,
 * event listeners, layout, measurement, rendering, etc. You should call appropriate _invalidate() method per style.
 * Note that style handling should not be dependent on the *current* state of a style. This function
 * should be able to run repeatedly with the same values. An example of when this may happen is if
 * an element is temporarily removed from the display hierarchy then added back. Whenever an element is added
 * all of its styles are invalidated. This is necessary as when an element is *not* part of the display chain
 * style changes are not tracked. So when an element is added there is no way to know which styles may have changed
 * hence all of them are invalidated. 
 * 
 * @param stylesMap Object
 * An Object map containing all the style names that have been updated. Map contains entries {styleName:true}.
 * Elements should typically check this map before assuming a style has changed for performance reasons. 
 * You should always call the base method. If you wish to override the style handling behavior of a specific style, 
 * you can simply delete it from the map before passing it to the base function.
 */	
CanvasElement.prototype._doStylesUpdated = 
	function (stylesMap)
	{
		if (this._parent != null && 
			(this._parent._measureInvalid == false || this._parent._layoutInvalid == false))
		{
			if ("X" in stylesMap ||
				"Y" in stylesMap ||
				"Width" in stylesMap ||
				"Height" in stylesMap ||
				"PercentWidth" in stylesMap ||
				"PercentHeight" in stylesMap ||
				"MinWidth" in stylesMap ||
				"MinHeight" in stylesMap ||
				"MaxWidth" in stylesMap ||
				"MaxHeight" in stylesMap ||
				"Top" in stylesMap ||
				"Left" in stylesMap ||
				"Bottom" in stylesMap ||
				"Right" in stylesMap ||
				"HorizontalCenter" in stylesMap ||
				"VerticalCenter" in stylesMap ||
				"IncludeInLayout" in stylesMap ||
				"RotateDegrees" in stylesMap ||
				"RotateCenterX" in stylesMap ||
				"RotateCenterY" in stylesMap)
			{
				this._parent._invalidateMeasure();
				this._parent._invalidateLayout();
			}
		}
		
		if (this._measureInvalid == false || this._layoutInvalid == false)
		{
			if ("Padding" in stylesMap ||
				"PaddingTop" in stylesMap ||
				"PaddingBottom" in stylesMap ||
				"PaddingLeft" in stylesMap ||
				"PaddingRight" in stylesMap)
			{
				this._invalidateMeasure();
				this._invalidateLayout();
			}
		}
		
		if ("BorderThickness" in stylesMap || 
			"BorderType" in stylesMap || 
			"BorderColor" in stylesMap || 
			"BackgroundColor" in stylesMap || 
			"AutoGradientType" in stylesMap || 
			"AutoGradientStart" in stylesMap || 
			"AutoGradientStop" in stylesMap ||
			(this._renderFocusRing == true && ("FocusColor" in stylesMap || "FocusThickness" in stylesMap)))
		{
			this._invalidateRender();
		}
		
		if ("Visible" in stylesMap ||
			"ClipContent" in stylesMap)
		{
			this._invalidateRedrawRegion();
		}
		
		if ("Alpha" in stylesMap ||
			"ShadowSize" in stylesMap)
		{
			this._compositeEffectChanged = true;
			this._invalidateRedrawRegion();
			this._invalidateCompositeRender();
		}
		
		if ("BackgroundShape" in stylesMap)
		{
			var bgShape = this.getStyle("BackgroundShape");
			
			//Only handle if changed, attached/detached handles initial add/remove listener.
			if (bgShape != this._backgroundShape)
			{
				if (this._backgroundShape != null)
					this._backgroundShape.removeEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
				
				this._backgroundShape = bgShape;
				
				if (this._backgroundShape != null)
					this._backgroundShape.addEventListener("stylechanged", this._onBackgroundShapeStyleChangedInstance);
				
				this._invalidateRender();
			}
		}
		
		if ("Cursor" in stylesMap)
		{
			var cursorDef = this.getStyle("Cursor");
			
			if (cursorDef == null && this.hasEventListener("rollover", this._onCanvasElementCursorOverOutInstance) == true)
			{
				this.removeEventListener("rollover", this._onCanvasElementCursorOverOutInstance);
				this.removeEventListener("rollout", this._onCanvasElementCursorOverOutInstance);
			}
			else if (cursorDef != null && this.hasEventListener("rollover", this._onCanvasElementCursorOverOutInstance) == false)
			{
				this.addEventListener("rollover", this._onCanvasElementCursorOverOutInstance);
				this.addEventListener("rollout", this._onCanvasElementCursorOverOutInstance);
			}
			
			this._updateRolloverCursorDefinition();
		}
		
		//Kill focus ring if disabled.
		if ("Enabled" in stylesMap && this.getStyle("Enabled") == false)
			this._setRenderFocusRing(false);
		
		if ("Visible" in stylesMap || "MouseEnabled" in stylesMap)
			this._manager._rollOverInvalid = true;
	};

//@private	
CanvasElement.prototype._updateRolloverCursorDefinition = 
	function ()
	{
		var cursorDef = this.getStyle("Cursor");
		
		if (this._rollOverCursorInstance != null && 
			(cursorDef == null || this._mouseIsOver == false))
		{
			this._manager.removeCursor(this._rollOverCursorInstance);
			this._rollOverCursorInstance = null;
		}
		else if (this._mouseIsOver == true && cursorDef != null)
		{
			if (this._rollOverCursorInstance == null)
				this._rollOverCursorInstance = this._manager.addCursor(cursorDef, 0);
			else if (this._rollOverCursorInstance.data != cursorDef)
			{
				this._manager.removeCursor(this._rollOverCursorInstance);
				this._rollOverCursorInstance = this._manager.addCursor(cursorDef, 0);
			}
		}
	};

/**
 * @function _doMeasure
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to changes that effect measurement or elements being added to the display hierarchy.
 * Override this function to calculate the measured size of the element based on its styling, children, etc. 
 * Return a object containing {width, height}.
 * 
 * @param padWidth Number
 * Simply a convienence as padding typically effects measurement (but not always) depending on the component.
 * Use any supporting functions such as _getBorderThickness that are needed to measure the element.
 * 
 * @param padHeight Number
 * Simply a convienence as padding typically effects measurement (but not always) depending on the component.
 * Use any supporting functions such as _getBorderThickness that are needed to measure the element.
 * 
 * @returns Object
 * An object containing the elements measured size. {width, height}
 */		
CanvasElement.prototype._doMeasure = 
	function (padWidth, padHeight)
	{
		//Stub for override.
	
		//Always return a size... 
		return {width: padWidth, height: padHeight};
	};
	
/**
 * @function _doLayout
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to changes that effect layout or elements being added to the display hierarchy.
 * Override this function to layout its children. You should call layout functions such as _setActualPosition() and
 * _setActualSize() on child elements from within this function. Sometimes you may need to add/remove additional elements
 * during layout such as when a Datagrid or Viewport adds/removes scroll bars. Keep in mind that adding/removing elements
 * automatically re-invalidates layout, so its best to bail out and wait for the next layout pass for best performance
 * under this scenario.
 * 
 * @param paddingMetrics DrawMetrics
 * Contains metrics to use after considering the element's padding. Simply a convienence as padding typically 
 * effects layout (but not always) depending on the component. Use any supporting functions such as _getBorderMetrics()
 * that are needed to layout the element.
 */		
CanvasElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		//Stub for override.
	};	
	
/**
 * @function _doRender
 * Lifecycle method for custom component development. Never call this function directly. The system
 * calls this function in response to changes that effect rendering or elements being added to the display hierarchy.
 * Override this function to render the element. Keep in mind that any child elements are rendered on top of this
 * element. This function is typically not needed unless rendering a very primitive object such as a custom skin or 
 * a display object that cannot be handled via a BackgroundShape class and/or _fillBackground() function.
 * Most advanced objects should use skins and other means to render themselves.
 * 
 * CanvasElement draws its background and border via supplied shape and gradient settings.
 */		
CanvasElement.prototype._doRender =
	function()
	{
		var borderMetrics = this._getBorderMetrics();
		
		if (this._renderFocusRing == true)
		{
			//ctx.save();
			//this._drawFocusRing(borderMetrics);
			//ctx.restore();
		}
		
		this._fillBackground(borderMetrics);
		
		this._drawBorder(borderMetrics);
	};
	
	
//////////DataRenderer Dynamic Properties/////////////////
	
/**
 * @function _setListData
 * This function is called when the element is being used as a DataRenderer for containers
 * like DataList and DataGrid. Override this function to make any changes to the DataRenderer
 * per the supplied DataListData and itemData objects. Update any styles, states, add/remove children, call any
 * necessary _invalidate() functions, etc.
 * 
 * @param listData DataListData
 * A DataListData or subclass object passed by the parent DataList or subclass with data necessary
 * to update the DataRender like the parent DataList reference and row/column index being rendered.
 * 
 * @param itemData Object
 * The data Object (such as row data) supplied by the implementor's ListCollection to render the row/column DataRenderer.
 */	
CanvasElement.prototype._setListData = 
	function (listData, itemData)
	{
		this._listData = listData;
		this._itemData = itemData;
	};

/**
 * @function _setListSelected
 * This function is called when the element is being used as a DataRenderer for containers
 * like DataList and DataGrid to change the DataRenderer's selection state. 
 * Override this function to make any changes to the DataRenderer per the selection state.
 * Update any styles, states, add/remove children, call any necessary _invalidate() functions, etc.
 * 
 * @param selected boolean
 * True if the DataRenderer is selected, otherwise false.
 */	
CanvasElement.prototype._setListSelected = 
	function (selected)
	{
		this._listSelected = selected;
	};	
	
	


/**
 * @depends CanvasElement.js
 */

///////Internal class for rendering lines of text/////////////////

//This class is only used for rendering lines. 
//No measure() or layout() needed (handled by parent TextField).
function TextFieldLineElement()
{
	TextFieldLineElement.base.prototype.constructor.call(this);
	
	this._text = "";
	
	this._highlightMinIndex = 0;
	this._highlightMaxIndex = 0;
	
	this._parentTextField = null;
	this._charMetricsStartIndex = -1;
	this._charMetricsEndIndex = -1;	//Non-inclusive
}
	
//Inherit from CanvasElement
TextFieldLineElement.prototype = Object.create(CanvasElement.prototype);
TextFieldLineElement.prototype.constructor = TextFieldLineElement;
TextFieldLineElement.base = CanvasElement;	

TextFieldLineElement.prototype.setParentLineMetrics = 
	function (parentTextField, charStartIndex, charEndIndex)
	{
		this._parentTextField = parentTextField;
		this._charMetricsStartIndex = charStartIndex;
		this._charMetricsEndIndex = charEndIndex;
		
		var newText = parentTextField._text.substring(charStartIndex, charEndIndex);
		if (newText != this._text)
		{
			this._text = newText;
			this._invalidateRender();
		}
	};

TextFieldLineElement.prototype.setParentSelection = 
	function (startIndex, endIndex)
	{
		var minIndex = Math.min(startIndex, endIndex);
		var maxIndex = Math.max(startIndex, endIndex);
		
		if (minIndex < this._charMetricsStartIndex)
			minIndex = this._charMetricsStartIndex;
		if (maxIndex > this._charMetricsEndIndex)
			maxIndex = this._charMetricsEndIndex;
		
		//Highlight is outside of bounds, nuke it.
		if (minIndex > maxIndex || minIndex == maxIndex)
		{
			minIndex = 0;
			maxIndex = 0;
		}
		
		if (this._highlightMinIndex == minIndex && this._highlightMaxIndex == maxIndex)
			return;
		
		this._highlightMinIndex = minIndex;
		this._highlightMaxIndex = maxIndex;
		
		this._invalidateRender();
	};

TextFieldLineElement.prototype.getLineWidth = 
	function ()
	{
		if (this._charMetricsStartIndex > -1 && this._charMetricsEndIndex > -1)
			return this._parentTextField._charMetrics[this._charMetricsEndIndex].x - this._parentTextField._charMetrics[this._charMetricsStartIndex].x;
		
		return 0;
	};	
	
//@Override
TextFieldLineElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextFieldLineElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap ||
			"TextColor" in stylesMap ||
			"TextFillType" in stylesMap)
		{
			this._invalidateRender();
		}
		else if ("TextHighlightedColor" in stylesMap ||
				"TextHighlightedBackgroundColor" in stylesMap)
		{
			//Only re-render if in fact we have a highlighted selection.
			if (this._highlightMinIndex != this._highlightMaxIndex)
				this._invalidateRender();
		}
	};		
	
//@Override
TextFieldLineElement.prototype._doRender =
	function()
	{
		TextFieldLineElement.base.prototype._doRender.call(this);
		
		if (this._text.length == 0)
			return;
		
		var paddingMetrics = this._getPaddingMetrics();
		var ctx = this._getGraphicsCtx();
		
		//Get styles
		var textFillType = this.getStyle("TextFillType");
		var textColor = this.getStyle("TextColor");
		var highlightTextColor = this.getStyle("TextHighlightedColor");
		var backgroundHighlightTextColor = this.getStyle("TextHighlightedBackgroundColor");
		var fontString = this._getFontString();
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY() + (paddingMetrics.getHeight() / 2); 
		
		if (this._highlightMinIndex == this._highlightMaxIndex)
		{
			if (textFillType == "stroke")
				CanvasElement._strokeText(ctx, this._text, x, y, fontString, textColor, "middle");
			else
				CanvasElement._fillText(ctx, this._text, x, y, fontString, textColor, "middle");
		}
		else
		{
			for (var i = 0; i < this._text.length; i++)
			{
				var charWidth = CanvasElement._measureText(this._text[i], fontString);
				
				if (this._highlightMinIndex <= i && this._highlightMaxIndex > i)
				{
					ctx.fillStyle = backgroundHighlightTextColor;
					
					ctx.beginPath();
					ctx.moveTo(x, 0);
					ctx.lineTo(x + charWidth, 0);
					ctx.lineTo(x + charWidth, this._height);
					ctx.lineTo(x, this._height);
					ctx.closePath();
					ctx.fill();
					
					if (textFillType == "stroke")
						CanvasElement._strokeText(ctx, this._text[i], x, y, fontString, highlightTextColor, "middle");
					else
						CanvasElement._fillText(ctx, this._text[i], x, y, fontString, highlightTextColor, "middle");
				}
				else
				{
					if (textFillType == "stroke")
						CanvasElement._strokeText(ctx, this._text[i], x, y, fontString, textColor, "middle");
					else
						CanvasElement._fillText(ctx, this._text[i], x, y, fontString, textColor, "middle");
				}
				
				x += charWidth;
			}
		}
	};	

/////////////////////////////////////////////////////////
/////////////////TextFieldElement////////////////////////

/**
 * @class TextFieldElement
 * @inherits CanvasElement
 * 
 * Internal class used for consistently rendering text used by controls like TextElement and TextInput.
 * You typically should not use this class directly it is designed to be wrapped by a higher level control. 
 * This class allows text to be selected and edited, it renders a text position caret and watches
 * focus/mouse/keyboard events, maintains position of individual characters and allows copy/cut/paste.
 * 
 * TextField also normalizes text width. The canvas natively will give
 * different widths for strings than when measuring and adding character widths 
 * which will not work for highlighting or editing. 
 * 
 * 
 * @constructor TextFieldElement 
 * Creates new TextFieldElement instance.
 */
function TextFieldElement()
{
	TextFieldElement.base.prototype.constructor.call(this);
	
	//Element used as the blinky text caret when focused.
	this._textCaret = null;
	
	this._textHighlightStartIndex = 0;
	this._caretIndex = 0;
	this._caretEnabled = false;
	this._caretBlinkTime = 0;
	this._caretBlinkVisible = false;
	
	this._text = "";
	
	this._charMetrics = null; 	// array of {x, w}
	this._spaceSpans = null; 	// array of {start, end, type} _charMetric positions of spaces for wrapping text.
	
	this._dragHighlightScrollCharacterTime = 0;
	this._dragHighlightScrollCharacterDuration = 0;
	this._dragHighlightScrollCharacterDirection = 0;
	
	//Container for storing / clipping lines of text.
	this._textLinesContainer = new CanvasElement();
	this._textLinesContainer.setStyle("ClipContent", true);
	this._addChild(this._textLinesContainer);
	
	var _self = this;
	
	//Private event handlers, need different instance for each TextField. Proxy to prototype.
	this._onTextFieldFocusEventInstance = 
		function (event)
		{
			if (event.getType() == "focusin")
				_self._onTextFieldFocusIn(event);
			else
				_self._onTextFieldFocusOut(event);
		};
	
	this._onTextFieldKeyDownInstance = 
		function (keyboardEvent)
		{
			_self._onTextFieldKeyDown(keyboardEvent);
		};
		
	this._onTextFieldMouseEventInstance =
		function (mouseEvent)
		{
			if (mouseEvent.getType() == "mousedown")
				_self._onTextFieldMouseDown(mouseEvent);
			else if (mouseEvent.getType() == "mouseup")
				_self._onTextFieldMouseUp(mouseEvent);
			else if (mouseEvent.getType() == "mousemoveex")
				_self._onTextFieldCanvasMouseMoveEx(mouseEvent); 
		};
	
	this._onTextFieldEnterFrameInstance =
		function (event)
		{
			_self._onTextFieldEnterFrame(event);
		};
	
	this._onTextFieldCopyPasteInstance = 
		function (event)
		{
			window.removeEventListener(event.type, _self._onTextFieldCopyPasteInstance);
		
			try
			{
				if (event.clipboardData)
				{
					if (event.type == "copy")
						_self._onTextFieldCopy(event.clipboardData);
					else if (event.type == "paste")
						_self._onTextFieldPaste(event.clipboardData);
					else // "cut"
						_self._onTextFieldCut(event.clipboardData);
				}
				
				if (event.preventDefault)
					event.preventDefault();
				
				return false;
			}
			catch (ex)
			{
				
			}
		};
}

//Inherit from CanvasElement
TextFieldElement.prototype = Object.create(CanvasElement.prototype);
TextFieldElement.prototype.constructor = TextFieldElement;
TextFieldElement.base = CanvasElement;	


/////////////Events///////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the text is changed due to user interaction.
 */


/////////////Style Types///////////////////////////////

TextFieldElement._StyleTypes = Object.create(null);

/**
 * @style Selectable boolean
 * 
 * When true, the text can be highlighted and copied.
 */
TextFieldElement._StyleTypes.Selectable = 				{inheritable:false};		// true || false

/**
 * @style MaxChars int
 * 
 * The maximum number of characters allowed for this TextField. When 0 unlimited characters are allowed.
 */
TextFieldElement._StyleTypes.MaxChars = 				{inheritable:false};		// number

/**
 * @style Multiline boolean
 * 
 * When true, text will be rendered on multiple lines when width is constrained rather than horizontal scrolling.
 */
TextFieldElement._StyleTypes.Multiline = 				{inheritable:false};		// true || false



////////////Default Styles////////////////////////////

TextFieldElement.StyleDefault = new StyleDefinition();

TextFieldElement.StyleDefault.setStyle("Selectable", 					false);
TextFieldElement.StyleDefault.setStyle("MaxChars", 						0);
TextFieldElement.StyleDefault.setStyle("Multiline", 					false);

TextFieldElement.StyleDefault.setStyle("Enabled", 						false);
TextFieldElement.StyleDefault.setStyle("TabStop",						0);
TextFieldElement.StyleDefault.setStyle("Cursor", 						"text");			

TextFieldElement.StyleDefault.setStyle("BorderType", 					"none");
TextFieldElement.StyleDefault.setStyle("PaddingTop", 					0);
TextFieldElement.StyleDefault.setStyle("PaddingBottom",					0);
TextFieldElement.StyleDefault.setStyle("PaddingLeft", 					3);
TextFieldElement.StyleDefault.setStyle("PaddingRight", 					2);
TextFieldElement.StyleDefault.setStyle("BackgroundColor",				null);


////////Public///////////////////////

/**
 * @function setText
 * Sets the text string to be rendered.
 * 
 * @param text String
 * Text string to be rendered
 */
TextFieldElement.prototype.setText = 
	function (text)
	{
		if (text == null)
			text = "";
	
		//Make sure we have an actual string
		if (typeof text !== "string")
		{
			try
			{
				text = text.toString();
			}
			catch (ex)
			{
				text = "";
			}
		}
		
		var maxChars = this.getStyle("MaxChars");
		
		if (maxChars > 0 && text.length > maxChars)
			text = text.substring(0, maxChars);
		
		if (text != this._text)
		{
			this._text = text;
			
			this._charMetrics = null;
			
			this.setSelection(0, 0);
			
			//Reset scroll position
			if (this._textLinesContainer._getNumChildren() > 0 && this.getStyle("Multiline") == false)
				this._textLinesContainer._getChildAt(0)._setActualPosition(0, 0);
			
			this._invalidateMeasure();
			this._invalidateLayout();
		}
	};

/**
 * @function getText
 * Gets the current text string.
 * 
 * @returns String
 * Current text string.
 */	
TextFieldElement.prototype.getText = 
	function ()
	{
		return this._text;
	};

/**
 * @function setSelection
 * Sets the text selection or text caret position. When startIndex and endIndex are the same
 * it places the text caret at that position, when different, it selects / highlights that range of characters.
 * 
 * @param startIndex int
 * Character index to begin the selection.
 * 
 * @param endIndex int
 * Character index to end the selection.
 */	
TextFieldElement.prototype.setSelection = 
	function (startIndex, endIndex)
	{
		if (startIndex < 0)
			startIndex = 0;
		if (startIndex > this._text.length)
			startIndex = this._text.length;
		
		if (endIndex < 0)
			endIndex = 0;
		if (endIndex > this._text.length)
			endIndex = this._text.length;
		
		if (startIndex == this._textHighlightStartIndex && endIndex == this._caretIndex)
			return;
		
		this._textHighlightStartIndex = startIndex;
		this._caretIndex = endIndex;
		
		if (this._caretEnabled == true && startIndex == endIndex)
		{
			this._caretBlinkVisible = true;
			this._caretBlinkTime = Date.now() + 800;
		}
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
		
		this._invalidateLayout();
	};
	
/**
 * @function getSelection
 * Gets the current text selection or text caret position.
 * 
 * @returns Object
 * Object containing the start and end selection indexes. {startIndex, endIndex}
 */	
TextFieldElement.prototype.getSelection = 
	function ()
	{
		return {startIndex:this._textHighlightStartIndex, endIndex:this._caretIndex};
	};	
	
////////Internal/////////////////////	

/**
 * @function _createTextCaret
 * Generates a CanvasElement to be used as the text caret.
 * 
 * @returns CanvasElement
 * New CanvasElement instance to be used as the text caret.
 */
TextFieldElement.prototype._createTextCaret = 
	function ()
	{
		var textCaret = new CanvasElement();
		textCaret.setStyle("MouseEnabled", false);
		textCaret.setStyle("BackgroundColor", "TextCaretColor");
		textCaret.setStyle("AutoGradientStart", 0);
		textCaret.setStyle("AutoGradientStop", 0);
		
		return textCaret;
	};
	
//@private
TextFieldElement.prototype._updateCaretVisibility = 
	function ()
	{
		if (this._caretEnabled == true &&
			this._caretBlinkVisible == true && 
			this._caretIndex > -1 && this._caretIndex <= this._text.length && //Dont think this line is necessary
			this._caretIndex == this._textHighlightStartIndex)
		{
			if (this._textCaret == null)
			{
				this._textCaret = this._createTextCaret();
				this._addChild(this._textCaret);
			}
			
			this._textCaret.setStyle("Visible", true);
		}
		else if (this._textCaret != null)
			this._textCaret.setStyle("Visible", false);
	};
	
//@private - only active when caret is enabled or dragging highlight selection is scrolling.
TextFieldElement.prototype._onTextFieldEnterFrame = 
	function (event)
	{
		var currentTime = Date.now();
		
		if (currentTime > this._caretBlinkTime && 
			this._caretEnabled == true &&
			this._caretIndex > -1 && this._caretIndex <= this._text.length && //Dont think this line is necessary
			this._caretIndex == this._textHighlightStartIndex)
		{	
			if (this._caretBlinkVisible == true)
			{//Shutting off caret
				
				if (this._caretBlinkTime + 400 < currentTime)
					this._caretBlinkTime = currentTime + 400;
				else
					this._caretBlinkTime += 400; 
			}
			else
			{//Turning on caret
				
				if (this._caretBlinkTime + 800 < currentTime)
					this._caretBlinkTime = currentTime + 800;
				else
					this._caretBlinkTime += 800; 
			}
			
			this._caretBlinkVisible = !(this._caretBlinkVisible);
			this._updateCaretVisibility();
		}
		
		if (currentTime > this._dragHighlightScrollCharacterTime && 
			this._dragHighlightScrollCharacterDuration > 0)
		{
			this._dragHighlightScrollCharacterTime += this._dragHighlightScrollCharacterDuration;
			var caretIndexChanged = false;
				
			if (this._dragHighlightScrollCharacterDirection == "left" && this._caretIndex > 0)
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex - 1);
				caretIndexChanged = true;
			}
			else if (this._dragHighlightScrollCharacterDirection == "right" && this._caretIndex < this._text.length)
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex + 1);
				caretIndexChanged = true;
			}
			
			if (caretIndexChanged == true)
			{
				var w = this._textLinesContainer._width;
				var textFieldLine1 = this._textLinesContainer._getChildAt(0);
				
				//Adjust text scroll position if cursor is out of bounds.
				var scrollDistance = 3;
				var caretPosition = this._charMetrics[this._caretIndex].x + textFieldLine1._x;
						
				//Adjust scroll position.
				if (caretPosition < 1)
				{
					textFieldLine1._setActualPosition(
							Math.min(0, (this._charMetrics[this._caretIndex].x * -1) + scrollDistance), 
							textFieldLine1._y);
				}
				else if (caretPosition > w - 1)
				{
					textFieldLine1._setActualPosition(
							Math.max(w - textFieldLine1._width, (this._charMetrics[this._caretIndex].x * -1) + w - scrollDistance), 
							textFieldLine1._y);
				}
			}
		}
	};
	
//@private	
TextFieldElement.prototype._enableCaret = 
	function ()
	{
		if (this._caretEnabled == true)
			return;
	
		this._caretEnabled = true;
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
	};
	
//@private	
TextFieldElement.prototype._disableCaret = 
	function ()
	{
		if (this._caretEnabled == false)
			return;
	
		this._caretEnabled = false;
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
	};

//@private - Only active if TextField is Enabled or Selectable.
TextFieldElement.prototype._onTextFieldFocusIn = 
	function (elementEvent)
	{
		//Tab focus (mouse would have already set caret)
		if (this._caretEnabled == true || this.getStyle("Enabled") == false)
			return;
	
		this._enableCaret();
		this.setSelection(0, this._text.length);
	};
	
//@private - Only active if TextField is Enabled or Selectable.	
TextFieldElement.prototype._onTextFieldFocusOut = 
	function (event)
	{
		this._disableCaret();
		this.setSelection(0, 0);
	};

/**
 * @function _getCaretIndexFromMouse
 * Gets the position to place the text caret based on the position of the mouse.
 * 
 * @param mouseX Number
 * Current X position of the mouse.
 * 
 * @param mouseY Number
 * Current Y position of the mouse.
 * 
 * @returns int
 * Corresponding caret character index.
 */	
TextFieldElement.prototype._getCaretIndexFromMouse = 
	function (mouseX, mouseY)
	{
		if (this._charMetrics == null || this._charMetrics.length == 0)
			return 0;
	
		var x = this._textLinesContainer._x;
		var w = this._textLinesContainer._width;
		mouseX += 2; //Text cursor is slightly offset. TODO: make this a style
		
		var textFieldLine1 = this._textLinesContainer._getChildAt(0);
		
		var charX = 0;
		var charW = 0;
		
		var newCaretIndex = 0;
		for (var i = 0; i <= this._text.length; i++)
		{
			charX = this._charMetrics[i].x + x + textFieldLine1._x;
			charW = this._charMetrics[i].width;
			
			if (charX < x)
				continue;
			
			if (charX > x + w)
				break;
			
			newCaretIndex = i;
			
			if (mouseX <= charX + (charW / 2))
				break;
		}
		
		return newCaretIndex;
	};

	
//@private - Only active if TextField is Enabled or Selectable.		
TextFieldElement.prototype._onTextFieldMouseDown = 
	function (mouseEvent)
	{
		if (this.hasEventListener("mousemoveex", this._onTextFieldMouseEventInstance) == false)
			this.addEventListener("mousemoveex", this._onTextFieldMouseEventInstance);

		var caretIndex = this._getCaretIndexFromMouse(mouseEvent.getX(), mouseEvent.getY());
		
		if (this.getStyle("Enabled") == true)
			this._enableCaret();
		
		this.setSelection(caretIndex, caretIndex);
	};
	
//@private - Only active if TextField is Enabled or Selectable.		
TextFieldElement.prototype._onTextFieldMouseUp = 
	function (mouseEvent)
	{
		if (this.hasEventListener("mousemoveex", this._onTextFieldMouseEventInstance) == true)
			this.removeEventListener("mousemoveex", this._onTextFieldMouseEventInstance);
		
		this._dragHighlightScrollCharacterDuration = 0;
		this._updateEnterFrameListener();
	};	
	
//@private - Only active if selectable or enabled and mouse is down.	
TextFieldElement.prototype._onTextFieldCanvasMouseMoveEx = 
	function (mouseEvent)
	{
		var mousePoint = {x:mouseEvent.getX(), y:mouseEvent.getY()};
		this.translatePointFrom(mousePoint, this._manager);
		
		var x = this._textLinesContainer._x;
		var w = this._textLinesContainer._width;
		
		var scrollDuration = 0;
		
		var caretIndex = this._getCaretIndexFromMouse(mousePoint.x, mousePoint.y);
		if (caretIndex == this._caretIndex)
		{
			if (mousePoint.x <= x + 2 && this._caretIndex > 0)
			{
				var range = Math.abs(x + 2 - mousePoint.x) * 3;
				scrollDuration = Math.max(20, 120 - range);
				
				if (this._dragHighlightScrollCharacterDuration == 0)
					this._dragHighlightScrollCharacterTime = Date.now() + scrollDuration;
				
				this._dragHighlightScrollCharacterDirection = "left";
			}
			else if (mousePoint.x >= x + w - 2 && this._caretIndex < this._text.length)
			{
				var range = Math.abs(x + w - 2 - mousePoint.x) * 3;
				scrollDuration = Math.max(20, 120 - range);
				
				if (this._dragHighlightScrollCharacterDuration == 0)
					this._dragHighlightScrollCharacterTime = Date.now() + scrollDuration;
				
				this._dragHighlightScrollCharacterDirection = "right";
			}
		}
		else
			this.setSelection(this._textHighlightStartIndex, caretIndex);
		
		this._dragHighlightScrollCharacterDuration = scrollDuration;
		this._updateEnterFrameListener();
	};
	
//@private	
TextFieldElement.prototype._updateCharXPositions = 
	function (startAfterIndex)
	{
		if (this._charMetrics == null || this._charMetrics.length == 0)
			return;
		
		if (startAfterIndex > this._charMetrics.length - 2)
			return;
		
		if (startAfterIndex < 0)
		{
			startAfterIndex = 0;
			this._charMetrics[0].x = 0;
		}
			
		var currentPos = this._charMetrics[startAfterIndex].x + this._charMetrics[startAfterIndex].width;
		for (var i = startAfterIndex + 1; i < this._charMetrics.length; i++)
		{
			this._charMetrics[i].x = currentPos;
			currentPos += this._charMetrics[i].width;
		}
	};

//@private	
TextFieldElement.prototype._deleteHighlightChars = 
	function ()
	{
		if (this._textHighlightStartIndex == this._caretIndex)
			return;
	
		var highlightBegin = Math.min(this._caretIndex, this._textHighlightStartIndex);
		var highlightEnd = Math.max(this._caretIndex, this._textHighlightStartIndex);
	
		//Fix char metrics
		this._charMetrics.splice(highlightBegin, highlightEnd - highlightBegin);
		this._updateCharXPositions(highlightBegin - 1);
		
		//Update string
		var strLeft = this._text.substring(0, highlightBegin);
		var strRight = this._text.substring(highlightEnd);
		this._text = strLeft + strRight;
		
		//Move caret
		this.setSelection(highlightBegin, highlightBegin);
	};	
	
/**
 * @function _onTextFieldKeyDown
 * Event handler for "keydown" event. Only active when TextField is enabled and focused.
 * Handles editing and cursor navigation / selection.
 * 
 * @param keyboardEvent ElementKeyboardEvent
 * ElementKeyboardEvent to process.
 */	
TextFieldElement.prototype._onTextFieldKeyDown = 
	function (keyboardEvent)
	{
		if (keyboardEvent.getDefaultPrevented() == true)
			return;
	
		var enabled = this.getStyle("Enabled");
		var keyString = keyboardEvent.getKey();
		var dispatchChanged = false;
		
		if (keyString == "c" && keyboardEvent.getCtrl() == true)
		{
			if (this._textHighlightStartIndex == this._caretIndex)
			{
				keyboardEvent.preventDefault();
				return;
			}
			
			//IE
			if (window.clipboardData)
			{
				this._onTextFieldCopy(window.clipboardData);
				keyboardEvent.preventDefault();
			} 
			else //FF, Chrome, Webkit (Allow keyboard event to invoke the copy / paste listener)
			{
				window.addEventListener("copy", this._onTextFieldCopyPasteInstance);
				this._invalidateLayout(); //Purges the listener if something upstream cancels the keyboard event.
			}
			
			return;
		}
		else if (keyString == "ArrowLeft")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex - 1);
			}
			else if (enabled == true)
			{
				if (this._textHighlightStartIndex != this._caretIndex)
					this.setSelection(Math.min(this._caretIndex, this._textHighlightStartIndex), Math.min(this._caretIndex, this._textHighlightStartIndex));
				else
					this.setSelection(this._caretIndex - 1, this._caretIndex - 1);
			}
		}
		else if (keyString == "ArrowRight")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, this._caretIndex + 1);
			}
			else if (enabled == true)
			{
				if (this._textHighlightStartIndex != this._caretIndex)
					this.setSelection(Math.max(this._caretIndex, this._textHighlightStartIndex), Math.max(this._caretIndex, this._textHighlightStartIndex));
				else
					this.setSelection(this._caretIndex + 1, this._caretIndex + 1);
			}
		}
		else if (keyString == "End")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, this._text.length);
			}
			else if (enabled == true)
				this.setSelection(this._text.length, this._text.length);
		}
		else if (keyString == "Home")
		{
			if (keyboardEvent.getShift() == true && 
				(this._textHighlightStartIndex != this._caretIndex || enabled == true))
			{
				this.setSelection(this._textHighlightStartIndex, 0);
			}
			else if (enabled == true)
				this.setSelection(0, 0);
		}
		else if (enabled == false) 
		{
			return;
		}
		else if (keyString == "Backspace")
		{
			if (this._textHighlightStartIndex != this._caretIndex)
				this._deleteHighlightChars();
			else
			{
				if (this._text.length == 0 || this._caretIndex == 0)
				{
					keyboardEvent.preventDefault();
					return;
				}
				
				//Fix char metrics
				this._charMetrics.splice(this._caretIndex - 1, 1);
				this._updateCharXPositions(this._caretIndex - 2);
				
				//Update string
				var strLeft = this._text.substring(0, this._caretIndex - 1);
				var strRight = this._text.substring(this._caretIndex);
				this._text = strLeft + strRight;
				
				//Move caret
				this.setSelection(this._caretIndex - 1, this._caretIndex - 1);
			}
			
			dispatchChanged = true;
		}
		else if (keyString == "Delete")
		{
			if (this._textHighlightStartIndex != this._caretIndex)
				this._deleteHighlightChars();
			else
			{
				if (this._text.length == 0 || this._caretIndex == this._text.length)
				{
					keyboardEvent.preventDefault();
					return;
				}
	
				//Fix char metrics
				this._charMetrics.splice(this._caretIndex, 1);
				this._updateCharXPositions(this._caretIndex - 1);
				
				//Update string
				var strLeft = this._text.substring(0, this._caretIndex);
				var strRight = this._text.substring(this._caretIndex + 1);
				this._text = strLeft + strRight;
			}
			
			dispatchChanged = true;
		}
		else if (keyString == "v" && keyboardEvent.getCtrl() == true)
		{
			//IE
			if (window.clipboardData)
			{
				this._onTextFieldPaste(window.clipboardData);
				keyboardEvent.preventDefault();
			} 
			else //FF, Chrome, Webkit (Allow keyboard event to invoke the copy / paste listener)
			{
				window.addEventListener("paste", this._onTextFieldCopyPasteInstance);
				this._invalidateLayout(); //Purges the listener if something upstream cancels the keyboard event.
			}
			
			return;
		}
		else if (keyString == "x" && keyboardEvent.getCtrl() == true)
		{
			if (this._textHighlightStartIndex == this._caretIndex)
			{
				keyboardEvent.preventDefault();
				return;
			}
			
			//IE
			if (window.clipboardData)
			{
				this._onTextFieldCut(window.clipboardData);
				keyboardEvent.preventDefault();
			} 
			else //FF, Chrome, Webkit (Allow keyboard event to invoke the copy / paste listener)
			{
				window.addEventListener("cut", this._onTextFieldCopyPasteInstance);
				this._invalidateLayout(); //Purges the listener if something upstream cancels the keyboard event.
			}
			
			return;
		}
		else if (keyString.length == 1)
		{
			this._deleteHighlightChars();
			
			var maxChars = this.getStyle("MaxChars");
			
			if (maxChars > 0 && maxChars <= this._text.length)
			{
				keyboardEvent.preventDefault();
				return;
			}
			
			//Measure new char
			var newCharMetrics = {x:0, width:CanvasElement._measureText(keyString, this._getFontString())};
			
			//Fix char metrics
			this._charMetrics.splice(this._caretIndex, 0, newCharMetrics);
			this._updateCharXPositions(this._caretIndex - 1);
			
			//Update string
			var strLeft = this._text.substring(0, this._caretIndex);
			var strRight = this._text.substring(this._caretIndex);
			this._text = strLeft + keyString + strRight;
			
			//Move caret
			this.setSelection(this._caretIndex + 1, this._caretIndex + 1);
			
			dispatchChanged = true;
		}
		else
			return;
		
		this._scrollIfCaretOutOfBounds();
		this._invalidateLayout();
		
		if (dispatchChanged == true)
			this._dispatchEvent(new ElementEvent("changed", false));
		
		keyboardEvent.preventDefault();
	};

//@private	
TextFieldElement.prototype._scrollIfCaretOutOfBounds = 
	function ()
	{
		var textFieldLine1 = this._textLinesContainer._getChildAt(0);
		var w = this._textLinesContainer._width;
		var scrollDistance = Math.min(Math.floor(w * 0.3), 35);
		
		//Adjust text scroll position if cursor is out of bounds.
		var caretPosition = this._charMetrics[this._caretIndex].x + textFieldLine1._x;
				
		//Adjust scroll position (we dont know the width of the text line yet...) layout will fix if we overshoot
		if (caretPosition < 2)
		{
			textFieldLine1._setActualPosition(
				(this._charMetrics[this._caretIndex].x * -1) + scrollDistance,
				textFieldLine1._y);
		}
		else if (caretPosition > w - 2)
		{
			textFieldLine1._setActualPosition(
				(this._charMetrics[this._caretIndex].x * -1) + w - scrollDistance, 
				textFieldLine1._y);
		}
	};
	
/**
 * @function _onTextFieldCopy
 * Event handler for native browser "copy" event. Copies selected text to clipboard.
 * 
 * @param clipboardData BrowserClipboard
 * The browser clipboard object to copy text too.
 */	
TextFieldElement.prototype._onTextFieldCopy = 
	function (clipboardData)
	{
		var highlightBegin = Math.min(this._caretIndex, this._textHighlightStartIndex);
		var highlightEnd = Math.max(this._caretIndex, this._textHighlightStartIndex);
		
		var copyText = this._text.substring(highlightBegin, highlightEnd);
		
		clipboardData.setData("Text", copyText);
	};
	
/**
 * @function _onTextFieldCopy
 * Event handler for native browser "paste" event. Pastes clipboard text into TextField.
 * 
 * @param clipboardData BrowserClipboard
 * The browser clipboard object to copy text from.
 */		
TextFieldElement.prototype._onTextFieldPaste = 
	function (clipboardData)
	{
		var pasteString = clipboardData.getData("Text");
		
		if (pasteString == null || pasteString.length == 0)
			return;
		
		var maxChars = this.getStyle("MaxChars");
		if (maxChars > 0 && this._text.length >= maxChars && this._caretIndex >= maxChars)
			return;
		
		this._deleteHighlightChars();
		
		//Measure new chars
		var fontString = this._getFontString();
		for (var i = 0; i < pasteString.length; i++)
		{
			this._charMetrics.splice(this._caretIndex + i, 0, 
					{x:0, width:CanvasElement._measureText(pasteString[i], fontString)});
		}

		//Fix char metrics
		this._updateCharXPositions(this._caretIndex - 1);
		
		//Update string
		var strLeft = this._text.substring(0, this._caretIndex);
		var strRight = this._text.substring(this._caretIndex);
		this._text = strLeft + pasteString + strRight;
		
		//Move caret
		this.setSelection(this._caretIndex + pasteString.length, this._caretIndex + pasteString.length);
		
		//Truncate if exceeding max characters
		if (maxChars > 0 && this._text.length > maxChars)
		{
			this._text = this._text.subString(0, maxChars);
			this._charMetrics.splice(0, this._text.length - maxChars);
			this.setSelection(this._text.length, this._text.length);
		}
		
		this._scrollIfCaretOutOfBounds();
		this._invalidateLayout();
		
		this._dispatchEvent(new ElementEvent("changed", false));
	};

/**
 * @function _onTextFieldCut
 * Event handler for native browser "cut" event. Copies selected text to clipboard and deletes from TextField.
 * 
 * @param clipboardData BrowserClipboard
 * The browser clipboard object to copy text too.
 */		
TextFieldElement.prototype._onTextFieldCut = 
	function (clipboardData)
	{
		var highlightBegin = Math.min(this._caretIndex, this._textHighlightStartIndex);
		var highlightEnd = Math.max(this._caretIndex, this._textHighlightStartIndex);
		
		var copyText = this._text.substring(highlightBegin, highlightEnd);
		
		clipboardData.setData("Text", copyText);
		
		this._deleteHighlightChars();
		
		this._scrollIfCaretOutOfBounds();
		this._invalidateLayout();
		
		this._dispatchEvent(new ElementEvent("changed", false));
	};
	
//@Override	
TextFieldElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		TextFieldElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		this._disableCaret();
		
		if (this.hasEventListener("mousemoveex", this._onTextFieldMouseEventInstance) == true)
			this.removeEventListener("mousemoveex", this._onTextFieldMouseEventInstance);
		
		if (this.hasEventListener("enterframe", this._onTextFieldEnterFrameInstance) == true)
			this.removeEventListener("enterframe", this._onTextFieldEnterFrameInstance);
	};		
	
//@private	
TextFieldElement.prototype._updateEnterFrameListener = 
	function ()
	{
		if (this._dragHighlightScrollCharacterDuration > 0 ||
			(this._caretEnabled == true && this._textHighlightStartIndex == this._caretIndex))
		{
			if (this.hasEventListener("enterframe", this._onTextFieldEnterFrameInstance) == false)
				this.addEventListener("enterframe", this._onTextFieldEnterFrameInstance);
		}
		else
		{
			if (this.hasEventListener("enterframe", this._onTextFieldEnterFrameInstance) == true)
				this.removeEventListener("enterframe", this._onTextFieldEnterFrameInstance);
		}
	};
	
/**
 * @function _updateEventListeners
 * Adds removes mouse, keyboard, and focus event listeners based on Enabled and Selectable styles.
 * Called in response to style changes.
 */	
TextFieldElement.prototype._updateEventListeners = 
	function ()
	{
		var enabled = this.getStyle("Enabled");
		var selectable = this.getStyle("Selectable");
		
		if (selectable == true || enabled == true)
		{
			if (this.hasEventListener("keydown", this._onTextFieldKeyDownInstance) == false)
				this.addEventListener("keydown", this._onTextFieldKeyDownInstance);
			
			if (this.hasEventListener("mousedown", this._onTextFieldMouseEventInstance) == false)
				this.addEventListener("mousedown", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("mouseup", this._onTextFieldMouseEventInstance) == false)
				this.addEventListener("mouseup", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("focusin", this._onTextFieldFocusEventInstance) == false)
				this.addEventListener("focusin", this._onTextFieldFocusEventInstance);
			
			if (this.hasEventListener("focusout", this._onTextFieldFocusEventInstance) == false)
				this.addEventListener("focusout", this._onTextFieldFocusEventInstance);
		}
		else
		{
			if (this.hasEventListener("keydown", this._onTextFieldKeyDownInstance) == true)
				this.removeEventListener("keydown", this._onTextFieldKeyDownInstance);
			
			if (this.hasEventListener("mousedown", this._onTextFieldMouseEventInstance) == true)
				this.removeEventListener("mousedown", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("mouseup", this._onTextFieldMouseEventInstance) == true)
				this.removeEventListener("mouseup", this._onTextFieldMouseEventInstance);
			
			if (this.hasEventListener("focusin", this._onTextFieldFocusEventInstance) == true)
				this.removeEventListener("focusin", this._onTextFieldFocusEventInstance);
			
			if (this.hasEventListener("focusout", this._onTextFieldFocusEventInstance) == true)
				this.removeEventListener("focusout", this._onTextFieldFocusEventInstance);
		}
		
		if (enabled == false)
			this._disableCaret();
	};

	
//@Override
TextFieldElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextFieldElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap)
		{
			this._charMetrics = null;
			
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("Multiline" in stylesMap ||
			"TextLinePaddingTop" in stylesMap ||
			"TextLinePaddingBottom" in stylesMap)
		{
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("TextAlign" in stylesMap ||
			"TextBaseline" in stylesMap || 
			"TextLineSpacing" in stylesMap)
		{
			this._invalidateLayout();
		}
		
		if ("MaxChars" in stylesMap)
			this.setText(this._text); //Will trim if needed.
		
		if ("TextCaretColor" in stylesMap && this._textCaret != null)
			this._textCaret.setStyle("BackgroundColor", this.getStyle("TextCaretColor"));
		
		if ("Enabled" in stylesMap || "Selectable" in stylesMap)
			this._updateEventListeners();
		
		this._updateEnterFrameListener();
		this._updateCaretVisibility();
	};	
	
///**
// * @function _getCharMetrics
// * Gets a DrawMetrics object containing position and size data of character at supplied index.
// * 
// * @param charIndex int
// * Index of character to return metrics.
// * 
// * @returns DrawMetrics
// * DrawMetrics object containing position and size data of character at supplied index.
// */	
//TextFieldElement.prototype._getCharMetrics = 
//	function (charIndex)
//	{
//		if (this._charMetrics == null || 
//			charIndex < 0 ||
//			charIndex >= this._text.length)
//		{
//			return null;
//		}
//		
//		var metrics = new DrawMetrics();
//		metrics._height = this._textHeight;
//		metrics._width = this._charMetrics[charIndex].width;
//		metrics._x = this._charMetrics[charIndex].x + this._textXScrollPosition;
//		metrics._y = this._textYPosition;
//		
//		return metrics;
//	};
	
//@private	
TextFieldElement.prototype._createCharMetrics = 
	function ()
	{
		if (this._charMetrics != null)
			return;
	
		var currentX = 0;
		var currentWidth = 0;
		
		this._charMetrics = [];
		this._spaceSpans = [];
		
		var currentSpaceSpan = null;
		
		if (this._text.length > 0)
		{
			var fontString = this._getFontString();	
			
			for (var i = 0; i < this._text.length; i++)
			{
				currentWidth = CanvasElement._measureText(this._text[i], fontString);
				
				this._charMetrics.push(
					{
						x:		currentX,
						width: 	currentWidth
					});
				
				if (this._text[i] == " ")
				{
					if (currentSpaceSpan == null)
						currentSpaceSpan = {start:i, end:i, type:"space"};
					else
						currentSpaceSpan.end = i;
				}
				else if (currentSpaceSpan != null)
				{
					this._spaceSpans.push(currentSpaceSpan);
					currentSpaceSpan = null;
				}
				
				if (this._text[i] == '\n')
					this._spaceSpans.push({start:i, end:i, type:"nline"});
				
				currentX += currentWidth;
			}
		}
		
		if (currentSpaceSpan != null)
			this._spaceSpans.push(currentSpaceSpan);
		
		//Dummy for caret at end of string
		this._charMetrics.push( { x:currentX, width:0 }); 
		this._invalidateLayout();
	};
	
//@Override
TextFieldElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		this._createCharMetrics();
	
		var measuredSize = {width:0, height:0};
		var singleLineTextWidth = this._charMetrics[this._text.length].x;
		
		var linePadTop = this.getStyle("TextLinePaddingTop");
		var linePadBottom = this.getStyle("TextLinePaddingBottom");
		var textSize = this.getStyle("TextSize");
		
		//Always add 1 for text caret 
		//TODO: This should be the text caret's width only when editable
		measuredSize.width = 1 + singleLineTextWidth + padWidth;
		measuredSize.height = textSize + linePadTop + linePadBottom + padHeight;

		//If using multi-line, height is dependent on actual width so layout
		//must run and do the actual measurment...
		if (this.getStyle("Multiline") == true)
			this._invalidateLayout();
		
		return measuredSize;
	};	
	
//@Override	
TextFieldElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		TextFieldElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		//Adjust text x position per scroll / align.
		var availableWidth = w - 1; // account for caret width - TODO: width should be width of caret element, always 1 for now.
		
		//Size / Position the line container.
		this._textLinesContainer._setActualPosition(x, y);
		this._textLinesContainer._setActualSize(availableWidth, h);
		
		var isMultiline = this.getStyle("Multiline");
		var textAlign = this.getStyle("TextAlign");
		var textBaseline = this.getStyle("TextBaseline");
		var textSize = this.getStyle("TextSize");
		var lineSpacing = this.getStyle("TextLineSpacing");
		var linePaddingTop = this.getStyle("TextLinePaddingTop");
		var linePaddingBottom = this.getStyle("TextLinePaddingBottom");
		var lineHeight = textSize + linePaddingTop + linePaddingBottom;
		
		var spaceSpanIndex = 0;
		var lineStartCharIndex = 0;
		var lineEndCharIndex = 0;
		
		var newLineData = null;
		var lines = [];
		
		var caretLineIndex = 0;
		var newlineFound = false;
		
		while (lineStartCharIndex < this._charMetrics.length)
		{
			newLineData = {charMetricsStartIndex:-1, charMetricsEndIndex:-1};
			
			if (isMultiline == false)
			{
				newLineData.charMetricsStartIndex = 0; 
				newLineData.charMetricsEndIndex = this._charMetrics.length - 1;
				caretLineIndex = 0;
				lineStartCharIndex = this._charMetrics.length;
			}
			else
			{
				newLineData.charMetricsStartIndex = lineStartCharIndex;
				newlineFound = false;
				
				for (var i = spaceSpanIndex; i < this._spaceSpans.length; i++)
				{
					if (textAlign == "left")
						lineEndCharIndex = this._spaceSpans[i].end;
					else
						lineEndCharIndex = this._spaceSpans[i].start;
					
					if (this._charMetrics[lineEndCharIndex].x - this._charMetrics[newLineData.charMetricsStartIndex].x <= availableWidth ||
						newLineData.charMetricsEndIndex == -1)
					{
						newLineData.charMetricsEndIndex = lineEndCharIndex;
						
						spaceSpanIndex++;
						lineStartCharIndex = lineEndCharIndex + 1;
						
						if (this._spaceSpans[i].type == "nline")
						{
							newlineFound = true;
							break;
						}
					}
					else
						break;
				}
				
				//Last line, no more spaces for breaks.
				if (newLineData.charMetricsEndIndex == -1 || 
					(this._charMetrics[ this._charMetrics.length - 1].x - this._charMetrics[newLineData.charMetricsStartIndex].x <= availableWidth && newlineFound == false))
				{
					newLineData.charMetricsEndIndex = this._charMetrics.length - 1;
					lineStartCharIndex = this._charMetrics.length;
				}
			}
			
			lines.push(newLineData);
		}
		
		var totalTextHeight = (lines.length * lineHeight) + ((lines.length - 1) * lineSpacing); 
		
		//Update the measured size now that we know the height. (May cause another layout pass)
		if (isMultiline == true)
			this._setMeasuredSize(this._width, totalTextHeight + this._getPaddingSize().height);
			
		var textYPosition;
		if (textBaseline == "top")
			textYPosition = 0;
		else if (textBaseline == "bottom")
			textYPosition = h - totalTextHeight;
		else //middle
			textYPosition = Math.round((h / 2) - (totalTextHeight / 2));
		 
		//Update actual line data
		var totalNewOldLines = Math.max(lines.length, this._textLinesContainer._getNumChildren());
		var textFieldLine = null;
		var lineWidth = 0;
		var lineXPosition;
		for (var i = 0; i < totalNewOldLines; i++)
		{
			//Line removed
			if (lines[i] == null)
				this._textLinesContainer._removeChildAt(i);
			else
			{
				textFieldLine = this._textLinesContainer._getChildAt(i);
				if (textFieldLine == null) //Line added
				{
					textFieldLine = new TextFieldLineElement();
					this._textLinesContainer._addChild(textFieldLine);
				}
				
				//Update line
				textFieldLine.setParentLineMetrics(this, lines[i].charMetricsStartIndex, lines[i].charMetricsEndIndex);
				textFieldLine.setParentSelection(this._textHighlightStartIndex, this._caretIndex);
				
				textFieldLine.setStyle("PaddingTop", linePaddingTop);
				textFieldLine.setStyle("PaddingBottom", linePaddingBottom);
				
				lineWidth = textFieldLine.getLineWidth();
				textFieldLine._setActualSize(lineWidth, lineHeight);
				
				if (lineWidth < availableWidth || isMultiline == true) //align
				{
					if (textAlign == "right")
						lineXPosition = availableWidth - lineWidth;
					else if (textAlign == "center")
						lineXPosition = Math.round((availableWidth / 2) - (lineWidth / 2));
					else // "left"
						lineXPosition = 0;
				}
				else //fill excess (over-scroll or resize)
				{
					if (textFieldLine._x > 0)
						lineXPosition = 0;					
					else if (textFieldLine._x + lineWidth < availableWidth)
						lineXPosition = availableWidth - lineWidth;
					else
						lineXPosition = textFieldLine._x;
				}
				
				textFieldLine._setActualPosition(lineXPosition, textYPosition);
				
				textYPosition += (lineHeight + lineSpacing);
			}
		}
		
		
		if (this._textCaret != null)
		{
			if (this._caretIndex < 0 || this._caretIndex > this._text.length)
				this._textCaret._setActualSize(0, lineHeight);
			else
			{
				//Find the line the caret is on.
				textFieldLine = this._textLinesContainer._getChildAt(caretLineIndex);

				var caretXPosition = this._charMetrics[this._caretIndex].x + textFieldLine._x + x;
				
				if (caretXPosition >= x && caretXPosition <= x + w - 1) //account for caret width
				{		
					this._textCaret._setActualPosition(caretXPosition, textFieldLine._y + y);
					this._textCaret._setActualSize(1, lineHeight);
				}
				else
					this._textCaret._setActualSize(0, lineHeight);
			}
		}
		
		//If we added a global listener, but a parent canceled the keyboard event, we need to purge these.
		window.removeEventListener("copy", this._onTextFieldCopyPasteInstance);
		window.removeEventListener("paste", this._onTextFieldCopyPasteInstance);
		window.removeEventListener("cut", this._onTextFieldCopyPasteInstance);
	};		
	
	


/**
 * @depends CanvasElement.js
 */

/////////////////////////////////////////////////////////
/////////////////TextElement/////////////////////////////	
	
/**
 * @class TextElement
 * @inherits CanvasElement
 * 
 * Renders mutli-line style-able select-able text. 
 * TextElement respects newline characters and will
 * wrap text when width is constrained. If only a single
 * line of text is needed, you should use LabelElement.
 * 
 * @constructor TextElement 
 * Creates new TextElement instance.
 */
function TextElement()
{
	TextElement.base.prototype.constructor.call(this);
	
	this._textField = new TextFieldElement();
	this._textField.setStyle("Multiline", true);
	this._textField.setStyle("Cursor", null);
	this._textField.setStyle("TabStop", -1);
	this._addChild(this._textField);
}

//Inherit from CanvasElement
TextElement.prototype = Object.create(CanvasElement.prototype);
TextElement.prototype.constructor = TextElement;
TextElement.base = CanvasElement;

/////////////Style Types///////////////////////////////

TextElement._StyleTypes = Object.create(null);

/**
 * @style Text String
 * Text to be rendered by the TextElement.
 */
TextElement._StyleTypes.Text = 				{inheritable:false};		// "any string" || null

/**
 * @style Selectable boolean
 * When true, text can be highlighted and copied.
 */
TextElement._StyleTypes.Selectable = 			{inheritable:false};		// true || false


////////////Default Styles////////////////////////////

TextElement.StyleDefault = new StyleDefinition();

//Override base class styles
TextElement.StyleDefault.setStyle("PaddingTop", 					2);
TextElement.StyleDefault.setStyle("PaddingBottom", 					2);
TextElement.StyleDefault.setStyle("PaddingLeft", 					2);
TextElement.StyleDefault.setStyle("PaddingRight", 					2);

//TextElement specific styles
TextElement.StyleDefault.setStyle("Text", 							null);
TextElement.StyleDefault.setStyle("Selectable", 					false);


/////////////Internal Functions///////////////////

//@Override
TextElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("Text" in stylesMap)
			this._textField.setText(this.getStyle("Text"));
		
		if ("Selectable" in stylesMap)
			this._textField.setStyle("Selectable", this.getStyle("Selectable"));
		
		//Proxy padding to TextField for proper mouse handling
		if ("Padding" in stylesMap ||
			"PaddingTop" in stylesMap ||
			"PaddingBottom" in stylesMap ||
			"PaddingLeft" in stylesMap ||
			"PaddingRight" in stylesMap)
		{
			var paddingSize = this._getPaddingSize();
			
			this._textField.setStyle("PaddingTop", paddingSize.paddingTop);
			this._textField.setStyle("PaddingBottom", paddingSize.paddingBottom);
			this._textField.setStyle("PaddingLeft", paddingSize.paddingLeft);
			this._textField.setStyle("PaddingRight", paddingSize.paddingRight);
		}
	};
	
//@Override
TextElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		//Ignore padding, proxied to TextField
		return {width:this._textField._measuredWidth, height:this._textField._measuredHeight};
	};	

//@Override	
TextElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		TextElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//Ignore padding, proxied to TextField for mouse handling.
		this._textField._setActualPosition(0, 0);
		this._textField._setActualSize(this._width, this._height);
	};



/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////////ScrollButtonSkinElement///////////////////////////

/**
 * @class ScrollButtonSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the ScrollButton.
 * 
 * 
 * @constructor ScrollButtonSkinElement 
 * Creates new ScrollButtonSkinElement instance.
 */
function ScrollButtonSkinElement()
{
	ScrollButtonSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
ScrollButtonSkinElement.prototype = Object.create(CanvasElement.prototype);
ScrollButtonSkinElement.prototype.constructor = ScrollButtonSkinElement;
ScrollButtonSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
ScrollButtonSkinElement._StyleTypes = Object.create(null);

/**
 * @style ArrowColor String
 * 
 * Hex color value to be used for the arrow icon. Format like "#FF0000" (red).
 */
ScrollButtonSkinElement._StyleTypes.ArrowColor =					{inheritable:false};		//"#000000"

/**
 * @style ArrowDirection String
 * 
 * Determines the arrow direction. Allowable values are "up", "down", "left", "right". 
 * Note that ScrollBar sets this style directly to the parent button depending on the scroll bar orientation.
 */
ScrollButtonSkinElement._StyleTypes.ArrowDirection =						{inheritable:false};	//"up" || "down" || "left" || "right"


////////Default Styles//////////////////

ScrollButtonSkinElement.StyleDefault = new StyleDefinition();

ScrollButtonSkinElement.StyleDefault.setStyle("ArrowColor", 						"#000000");
ScrollButtonSkinElement.StyleDefault.setStyle("ArrowDirection", 					"up");


/////////Internal Functions////////////////////////

//@Override
ScrollButtonSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ScrollButtonSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ArrowColor" in stylesMap || 
			"ArrowDirection" in stylesMap)
		{
			this._invalidateRender();
		}
	};

//@Override
ScrollButtonSkinElement.prototype._doRender = 
	function()
	{
		ScrollButtonSkinElement.base.prototype._doRender.call(this);
		
		var ctx = this._getGraphicsCtx();
		
		var arrowDirection = this.getStyle("ArrowDirection");
		var arrowColor = this.getStyle("ArrowColor");
		
		var borderThickness = this._getBorderThickness();
		
		var x = borderThickness;
		var y = borderThickness;
		var width = this._width - (borderThickness * 2);
		var height = this._height - (borderThickness * 2);
		
		ctx.beginPath();
		
		if (arrowDirection == "up")
		{
			ctx.moveTo(x + (width / 2), y + (height * .35));
			ctx.lineTo(x + (width * .80), y + (height * .65));
			ctx.lineTo(x + (width * .20), y + (height * .65));
		}
		else if (arrowDirection == "down")
		{
			ctx.moveTo(x + (width / 2), y + (height * .65));
			ctx.lineTo(x + (width * .80), y + (height * .35));
			ctx.lineTo(x + (width * .20), y + (height * .35));
		}
		else if (arrowDirection == "left")
		{
			ctx.moveTo(x + (width * .35), y + (height / 2));
			ctx.lineTo(x + (width * .65), y + (height * .20));
			ctx.lineTo(x + (width * .65), y + (height * .80));
		}
		else if (arrowDirection == "right")
		{
			ctx.moveTo(x + (width * .65), y + (height / 2));
			ctx.lineTo(x + (width * .35), y + (height * .20));
			ctx.lineTo(x + (width * .35), y + (height * .80));
		}
		
		ctx.closePath();
		
		ctx.fillStyle = arrowColor;
		ctx.fill();
		
	};		
	
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////////RadioButtonSkinElement////////////////////////////

/**
 * @class RadioButtonSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the RadioButtonElement.  
 * Renders an inner selected indicator using the BackgroundShape style.
 * 
 * 
 * @constructor RadioButtonSkinElement 
 * Creates new RadioButtonSkinElement instance.
 */
function RadioButtonSkinElement()
{
	RadioButtonSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
RadioButtonSkinElement.prototype = Object.create(CanvasElement.prototype);
RadioButtonSkinElement.prototype.constructor = RadioButtonSkinElement;
RadioButtonSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
RadioButtonSkinElement._StyleTypes = Object.create(null);

/**
 * @style CheckColor String
 * 
 * Hex color value to be used for the check icon. Format like "#FF0000" (red).
 */
RadioButtonSkinElement._StyleTypes.CheckColor =						{inheritable:false};		//"#000000"

/**
 * @style CheckSize Number
 * 
 * Value between 0 and 1 used to determine the size that the "selected" indicator 
 * should be rendered relative to this element's size.
 */
RadioButtonSkinElement._StyleTypes.CheckSize = 						{inheritable:false};


////////Default Styles////////////////
RadioButtonSkinElement.StyleDefault = new StyleDefinition();

//RadioButtonSkinElement specific styles
RadioButtonSkinElement.StyleDefault.setStyle("CheckColor", 			"#000000");
RadioButtonSkinElement.StyleDefault.setStyle("CheckSize", 			.35);


/////////Protected Functions////////////////////////

//@Override
RadioButtonSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		RadioButtonSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SkinState" in stylesMap || "CheckColor" in stylesMap)
			this._invalidateRender();
	};

//@Override
RadioButtonSkinElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:14, height:14};
	};

//@Override
RadioButtonSkinElement.prototype._doRender = 
	function()
	{
		RadioButtonSkinElement.base.prototype._doRender.call(this);
		
		var currentState = this.getStyle("SkinState");
		
		//Draw indicator.
		if (currentState.indexOf("selected") == 0)
		{
			var ctx = this._getGraphicsCtx();
			
			var checkSize = this.getStyle("CheckSize");
			
			var indicatorMetrics = new DrawMetrics();
			indicatorMetrics._width = this._width * checkSize;
			indicatorMetrics._height = this._height * checkSize;
			indicatorMetrics._x = (this._width - indicatorMetrics._width) / 2;
			indicatorMetrics._y = (this._height - indicatorMetrics._height) / 2;
			
			if (indicatorMetrics._width <= 0 || indicatorMetrics._height <= 0)
				return;
			
			ctx.beginPath();
			this._drawBackgroundShape(ctx, indicatorMetrics);
			
			ctx.fillStyle = this.getStyle("CheckColor");
			ctx.fill();
		}
	};		
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////DropdownArrowButtonSkinElement////////////////////////

/**
 * @class DropdownArrowButtonSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for Arrow button in the DropdownElement.
 * Renders the divider line and an arrow.
 *  
 * 
 * @constructor DropdownArrowButtonSkinElement 
 * Creates new DropdownArrowButtonSkinElement instance.
 */
function DropdownArrowButtonSkinElement()
{
	DropdownArrowButtonSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
DropdownArrowButtonSkinElement.prototype = Object.create(CanvasElement.prototype);
DropdownArrowButtonSkinElement.prototype.constructor = DropdownArrowButtonSkinElement;
DropdownArrowButtonSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
DropdownArrowButtonSkinElement._StyleTypes = Object.create(null);

/**
 * @style ArrowColor String
 * 
 * Hex color value to be used for the arrow. Format like "#FF0000" (red).
 */
DropdownArrowButtonSkinElement._StyleTypes.ArrowColor =				{inheritable:false};		//"#000000"

/**
 * @style LineColor String
 * 
 * Hex color value to be used for the divider line. Format like "#FF0000" (red).
 */
DropdownArrowButtonSkinElement._StyleTypes.LineColor =				{inheritable:false};		//"#000000"


//////Default Styles///////////////////

DropdownArrowButtonSkinElement.StyleDefault = new StyleDefinition();

DropdownArrowButtonSkinElement.StyleDefault.setStyle("ArrowColor", 				"#000000"); 		
DropdownArrowButtonSkinElement.StyleDefault.setStyle("LineColor", 				"#000000"); 


/////////Internal Functions////////////////////////

//@Override
DropdownArrowButtonSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DropdownArrowButtonSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ArrowColor" in stylesMap || 
			"LineColor" in stylesMap)
		{
			this._invalidateRender();
		}
	};

//@Override
DropdownArrowButtonSkinElement.prototype._doRender = 
	function()
	{
		DropdownArrowButtonSkinElement.base.prototype._doRender.call(this);
		
		var ctx = this._getGraphicsCtx();
		var paddingMetrics = this._getPaddingMetrics();
		
		var lineColor = this.getStyle("LineColor");
		var arrowColor = this.getStyle("ArrowColor");
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var width = paddingMetrics.getWidth();
		var height = paddingMetrics.getHeight();
		
		ctx.beginPath();
		
		ctx.moveTo(x + (width / 2), y + (height * .60));
		ctx.lineTo(x + (width * .70), y + (height * .40));
		ctx.lineTo(x + (width * .30), y + (height * .40));
		
		ctx.closePath();
		
		ctx.fillStyle = arrowColor;
		ctx.fill();
		

		var lineHeight = height * .65;
		
		ctx.beginPath();

		ctx.moveTo(x, y + (height / 2) - (lineHeight / 2));
		ctx.lineTo(x, y + (height / 2) + (lineHeight / 2));
		ctx.lineTo(x + 1, y + (height / 2) + (lineHeight / 2));
		ctx.lineTo(x + 1, y + (height / 2) - (lineHeight / 2));
		
		ctx.closePath();
		
		ctx.fillStyle = lineColor;
		ctx.fill();
	};	
	
	


/**
 * @depends CanvasElement.js
 */

//////////////////////////////////////////////////////////////////
//////DataGridHeaderColumnDividerSkinElement//////////////////////		
	
/**
 * @class DataGridHeaderColumnDividerSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the draggable DataGrid column dividers.
 * Renders a line, and drag arrows when mouse is over.
 * 
 * 
 * @constructor DataGridHeaderColumnDividerSkinElement 
 * Creates new DataGridHeaderColumnDividerSkinElement instance.
 */
function DataGridHeaderColumnDividerSkinElement()
{
	DataGridHeaderColumnDividerSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
DataGridHeaderColumnDividerSkinElement.prototype = Object.create(CanvasElement.prototype);
DataGridHeaderColumnDividerSkinElement.prototype.constructor = DataGridHeaderColumnDividerSkinElement;
DataGridHeaderColumnDividerSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
DataGridHeaderColumnDividerSkinElement._StyleTypes = Object.create(null);

/**
 * @style DividerLineColor String
 * 
 * Hex color value to be used for the divider line. Format like "#FF0000" (red).
 */
DataGridHeaderColumnDividerSkinElement._StyleTypes.DividerLineColor =			{inheritable:false};		//"#000000"

/**
 * @style DividerArrowColor String
 * 
 * Hex color value to be used for the arrows. Format like "#FF0000" (red).
 */
DataGridHeaderColumnDividerSkinElement._StyleTypes.DividerArrowColor =			{inheritable:false};		//"up" || "down" || "left" || "right"


////////Default Styles////////////////

DataGridHeaderColumnDividerSkinElement.StyleDefault = new StyleDefinition();

DataGridHeaderColumnDividerSkinElement.StyleDefault.setStyle("DividerLineColor", 		"#777777");
DataGridHeaderColumnDividerSkinElement.StyleDefault.setStyle("DividerArrowColor", 		"#444444");



//@Override
DataGridHeaderColumnDividerSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridHeaderColumnDividerSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("DividerLineColor" in stylesMap ||
			"DividerArrowColor" in stylesMap)
		{
			this._invalidateRender();
		}
	};

//@Override
DataGridHeaderColumnDividerSkinElement.prototype._doRender = 
	function()
	{
		DataGridHeaderColumnDividerSkinElement.base.prototype._doRender.call(this);
		
		var ctx = this._getGraphicsCtx();
		
		var lineColor = this.getStyle("DividerLineColor");
		var arrowColor = this.getStyle("DividerArrowColor");
		var currentState = this.getStyle("SkinState");
		
		var x = 0;
		var y = 0;
		var w = this._width;
		var h = this._height;
		
		ctx.beginPath();

		ctx.moveTo(x + (w / 2) - .5, y);
		ctx.lineTo(x + (w / 2) - .5, y + h);
		ctx.lineTo(x + (w / 2) + .5, y + h);
		ctx.lineTo(x + (w / 2) + .5, y);
		
		ctx.closePath();
		
		ctx.fillStyle = lineColor;
		ctx.fill();
		
		////////////////////////////
		
		if (currentState == "over" || currentState == "down")
		{
			var arrowHeight = h / 2;
			
			ctx.fillStyle = arrowColor;
			
			ctx.beginPath();
			
			ctx.moveTo(x + (w / 2) - .5 - 1, (h / 2) - (arrowHeight / 2));
			ctx.lineTo(x + (w / 2) - .5 - 1, (h / 2) + (arrowHeight / 2));
			ctx.lineTo(x, y + (h / 2));
			
			ctx.closePath();
			ctx.fill();
			
			ctx.beginPath();
			
			ctx.moveTo(x + (w / 2) + .5 + 1, (h / 2) - (arrowHeight / 2));
			ctx.lineTo(x + (w / 2) + .5 + 1, (h / 2) + (arrowHeight / 2));
			ctx.lineTo(x + w, y + (h / 2));
			
			ctx.closePath();
			ctx.fill();
		}
	};
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////CheckboxSkinElement/////////////////////////////

/**
 * @class CheckboxSkinElement
 * @inherits CanvasElement
 * 
 * Default skin class for the CheckboxElement.
 * 
 * 
 * @constructor CheckboxSkinElement 
 * Creates new CheckboxSkinElement instance.
 */
function CheckboxSkinElement()
{
	CheckboxSkinElement.base.prototype.constructor.call(this);
}

//Inherit from CanvasElement
CheckboxSkinElement.prototype = Object.create(CanvasElement.prototype);
CheckboxSkinElement.prototype.constructor = CheckboxSkinElement;
CheckboxSkinElement.base = CanvasElement;		
	
//////Style Types//////////////////////
CheckboxSkinElement._StyleTypes = Object.create(null);

/**
 * @style CheckColor String
 * 
 * Hex color value to be used for the check icon. Format like "#FF0000" (red).
 */
CheckboxSkinElement._StyleTypes.CheckColor =				{inheritable:false};		//"#000000"


////////Default Styles////////////////

CheckboxSkinElement.StyleDefault = new StyleDefinition();

//CheckboxSkinElement specific styles
CheckboxSkinElement.StyleDefault.setStyle("CheckColor", 						"#000000");


/////////Protected Functions////////////////////////

//@Override
CheckboxSkinElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		CheckboxSkinElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SkinState" in stylesMap || "CheckColor" in stylesMap)
			this._invalidateRender();
	};

//@Override
CheckboxSkinElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:14, height:14};
	};

//@Override
CheckboxSkinElement.prototype._doRender = 
	function()
	{
		CheckboxSkinElement.base.prototype._doRender.call(this);
		
		var currentState = this.getStyle("SkinState");
		
		//Draw check or dash.
		if (currentState.indexOf("selected") == 0 || 
			currentState.indexOf("half") == 0)
		{
			var ctx = this._getGraphicsCtx();
			
			var borderThickness = this._getBorderThickness();
			var checkColor = this.getStyle("CheckColor");
			
			var x = borderThickness;
			var y = borderThickness;
			var width = this._width - (borderThickness * 2);
			var height = this._height - (borderThickness * 2);
			
			if (currentState.indexOf("selected") == 0) //Draw check
			{
				ctx.beginPath();
				
				ctx.moveTo(x + (width * .10), 
							y + (height * .60));
				
				ctx.lineTo(x + (width * .40),
							y + height * .90);
				
				ctx.lineTo(x + (width * .90),
							y + (height * .26));
				
				ctx.lineTo(x + (width * .78),
							y + (height * .10));
				
				ctx.lineTo(x + (width * .38),
							y + height * .65);
				
				ctx.lineTo(x + (width * .20),
							y + height * .45);
				
				ctx.closePath();
			}
			else //Half selected - Draw dash
			{
				ctx.beginPath();
				
				ctx.moveTo(x + (width * .12), 
							y + (height * .42));
				
				ctx.lineTo(x + (width * .12),
							y + height * .58);
				
				ctx.lineTo(x + (width * .88),
							y + (height * .58));
				
				ctx.lineTo(x + (width * .88),
							y + (height * .42));
				
				ctx.closePath();
			}
			
			ctx.fillStyle = checkColor;
			ctx.fill();
		}
	};		
	
	


/**
 * @depends CanvasElement.js
 */

//////////////////////////////////////////////////////////////////////
///////////////////////SkinnableElement///////////////////////////////	
	
/**
 * @class SkinnableElement
 * @inherits CanvasElement
 * 
 * Abstract base class for skin-able components. Allows changing states, stores a list
 * of skins per state and toggles skin visibility per the current state. 
 * Any states may be used. As an example, ButtonElement uses "up", "over", "down", and "disabled" states.
 * Override appropriate functions to return skin classes and style definitions per the element's states. 
 * SkinnableElement does not render itself, its skins do. It proxies all rendering 
 * related styles to its skins (such as BackgroundColor).
 * 
 * @seealso StyleProxy
 * 
 * 
 * @constructor SkinnableElement 
 * Creates new SkinnableElement instance.
 */
function SkinnableElement()
{
	SkinnableElement.base.prototype.constructor.call(this);
	
	this._skins = Object.create(null);
	this._currentSkin = null;
	
	/**
	 * @member _currentSkinState String
	 * Read only - String representing the current state.
	 */
	this._currentSkinState = "";
	
}

//Inherit from CanvasElement
SkinnableElement.prototype = Object.create(CanvasElement.prototype);
SkinnableElement.prototype.constructor = SkinnableElement;
SkinnableElement.base = CanvasElement;


//Proxy map for styles we want to pass to skins.
SkinnableElement._SkinProxyMap = Object.create(null);

//Proxy styles that affect rendering.
SkinnableElement._SkinProxyMap.BorderType = 				true;
SkinnableElement._SkinProxyMap.BorderColor = 				true;
SkinnableElement._SkinProxyMap.BorderThickness = 			true;
SkinnableElement._SkinProxyMap.BackgroundColor = 			true;
SkinnableElement._SkinProxyMap.AutoGradientType = 			true;
SkinnableElement._SkinProxyMap.AutoGradientStart = 			true;
SkinnableElement._SkinProxyMap.AutoGradientStop = 			true;
SkinnableElement._SkinProxyMap.BackgroundShape = 			true;

//Proxy styles that are not defined by the element.
SkinnableElement._SkinProxyMap._Arbitrary =					true;


//////////////////Internal Functions///////////////////
/**
 * @function _getSkinClass
 * Gets the skin class to use per the provided state. 
 * Override this to return different skin classes for different states.
 * 
 * @param state String
 * The state for which to return a skin class.
 * 
 * @returns Function
 * Return the constructor of the appropriate skin class.
 */
SkinnableElement.prototype._getSkinClass = 
	function (state)
	{
		return null;
	};

/**
 * @function _getSkinStyleDefinitions
 * Gets an array of StyleDefinitions to be applied to the skin class per the provided state.
 * Override this to return different StyleDefinitions for different states.
 * 
 * @param state String
 * The state for which to return an array of StyleDefinitions.
 * 
 * @returns Array
 * Return the appropriate array of StyleDefinitions for the provided state.
 */	
SkinnableElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		return null;
	};

/**
 * @function _getSkinStyleDefinitionDefault
 * Gets the default StyleDefinition to be applied to the skin class per the provided state.
 * Override this to return different default StyleDefinitions for different states. Use 
 * _getDefaultStyle() to return the appropriate default style definition.
 * 
 * @param state String
 * The state for which to return a default StyleDefinition.
 * 
 * @returns StyleDefinition
 * Return the appropriate default StyleDefinition per _getDefaultStyle("MyStyleNameForMyState") for the provided state.
 */	
SkinnableElement.prototype._getSkinStyleDefinitionDefault = 
	function (state)
	{
		return null;
	};
	
/**
 * @function _getSkinStyleProxyMap
 * Gets the Style proxy map to pass to skins. Override this if you need to pass additional styles
 * to custom skins. You should include all the styles provided in the default SkinnableElement style map.
 * 
 * @returns Object
 * Return a style proxy map to be applied to this element to all skins. Formatted as:
 * 
 * MyProxyMap = Object.create(null);
 * MyProxyMap.StyleName1 = true;
 * MyProxyMap.StyleName2 = true;
 * 
 * @seealso StyleProxy
 */	
SkinnableElement.prototype._getSkinStyleProxyMap = 
	function ()
	{
		return SkinnableElement._SkinProxyMap;
	};
	
/**
 * @function _updateSkinStyleDefinitions
 * Updates the StyleDefinition for the skin of the provided state. Subclasses should call
 * this within their _doStylesUpdated() when skin style definitions change.
 * 
 * @param state String
 * The state for which to update the StyleDefinition.
 */	
SkinnableElement.prototype._updateSkinStyleDefinitions = 
	function (state)
	{
		var skinElement = this._skins[state];
		
		//Skin instance not yet created.
		if (skinElement == null)
			return;
	
		skinElement.setStyleDefinitions(this._getSkinStyleDefinitions(state));
	};
	
/**
 * @function _updateSkinClass
 * Updates the skin class for the skin of the provided state. Subclasses should call
 * this within their _doStylesUpdated() when skin style class changes.
 * 
 * @param state String
 * The state for which to update the skin class.
 */		
SkinnableElement.prototype._updateSkinClass = 
	function (state)
	{
		//If the skin hasnt been created bail. State change will create later.
		if (this._skins[state] == null && state != this._currentSkinState)
			return;
		
		var newSkinClass = this._getSkinClass(state);
		var currentSkinClass = null;
		
		if (this._skins[state] != null)
			currentSkinClass = this._skins[state].constructor;
		
		//Skin class has not changed.
		if (newSkinClass == currentSkinClass)
			return;
		
		//Nuke the old skin
		if (this._skins[state] != null)
		{
			this._removeChild(this._skins[state]);
			this._skins[state] = null;
		}
		
		//Only create the new skin if its active, otherwise state change will create later.
		if (this._currentSkinState == state)
		{
			//Create new and adjust visibility if needed
			var newSkin = this._createSkin(state);
			this._currentSkin = newSkin;
			
			if (newSkin != null)
				newSkin.setStyle("Visible", true);
		}
	};	
	
//@private	
SkinnableElement.prototype._createSkin = 
	function (state)
	{
		var skinClass = this._getSkinClass(state);
		if (skinClass == null)
		{
			this._skins[state] = null;
			return null;
		}
	
		var newSkin = new (skinClass)();
		
		this._skins[state] = newSkin;
		
		newSkin._setStyleDefinitionDefault(this._getSkinStyleDefinitionDefault(state));
		newSkin._setStyleProxy(new StyleProxy(this, this._getSkinStyleProxyMap()));
		
		newSkin.setStyle("MouseEnabled", false);
		newSkin.setStyle("SkinState", state);
		this._updateSkinStyleDefinitions(state);
		
		this._addChildAt(newSkin, 0);
		
		return newSkin;
	};
	
/**
 * @function _changeState
 * Called when the element changes skin state. Do not call this function directly.
 * You may override this if you need to make additional changes to your component
 * when the skin state changes (such as updating a label color).
 * 
 * @param state String
 * The skin state that this element is changing too.
 * 
 * @returns boolean
 * Returns true if the element state has actually changed, false if it is the same state. 
 * Subclasses can check what this base function returns before making additional changes for better performance.
 */	
SkinnableElement.prototype._changeState = 
	function (state)
	{
		if (this._currentSkinState == state || state == "" || state == null)
			return false;
	
		this._currentSkinState = state;
		
		var foundSkin = false;
		for (var skinState in this._skins)
		{
			//Ignore null skins.
			if (this._skins[skinState] == null)
				continue;
			
			if (skinState == state)
			{
				this._currentSkin = this._skins[skinState];
				this._skins[skinState].setStyle("Visible", true);
				foundSkin = true;
			}
			else 
				this._skins[skinState].setStyle("Visible", false);
		}
		
		//Attempt to create the skin (this may be null anyway)
		if (foundSkin == false)
		{
			this._currentSkin = this._createSkin(state);
			
			if (this._currentSkin != null)
				this._currentSkin.setStyle("Visible", true);
		}
		
		return true;
	};

//@Override
SkinnableElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		SkinnableElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SkinState" in stylesMap)
			this._changeState(this.getStyle("SkinState"));
	};	
	
//@Override	
SkinnableElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		SkinnableElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//We have to size all skins, not just the current skin. Otherwise if multiple skins 
		//are created within 1 cycle (multiple immediate state changes) we could end up with 
		//a skin that never gets sized unless we invalidate layout on every skin change.
		for (var prop in this._skins)
		{
			if (this._skins[prop] == null)
				continue;
			
			this._skins[prop]._setActualSize(this._width, this._height);
			this._skins[prop]._setActualPosition(0, 0);
		}
	};	

//@Override
SkinnableElement.prototype._doRender = 
	function ()
	{
		//Do nothing, don't call base. SkinnableElement does not render itself, its skins do.
	
		//TODO: Use the active skin metrics & shape to render the focus ring.
		//if (this._renderFocusRing == true)
		//	this._drawFocusRing(ctx, this._getBorderMetrics());
	};	
	
	


/**
 * @depends SkinnableElement.js
 */

/////////////////////////////////////////////////////////
///////////////TextInputElement//////////////////////////	
	
/**
 * @class TextInputElement
 * @inherits SkinnableElement
 * 
 * TextInput is an edit-able single line text box.
 * 
 * 
 * @constructor TextInputElement 
 * Creates new TextInputElement instance.
 */
function TextInputElement()
{
	TextInputElement.base.prototype.constructor.call(this);
	
	this._textField = new TextFieldElement();
	this._textField.setStyle("Selectable", true);
	this._textField.setStyle("Cursor", null);
	this._textField.setStyle("TabStop", -1);
	this._addChild(this._textField);
	
	var _self = this;
	
	//Private event handlers, need different instance for each TextInput. Proxy to prototype.
	this._onTextInputFocusEventInstance = 
		function (event)
		{
			if (event.getType() == "focusin")
				_self._onTextInputFocusIn(event);
			else
				_self._onTextInputFocusOut(event);
		};
	
	this._onTextInputKeyDownInstance = 
		function (keyboardEvent)
		{
			_self._onTextInputKeyDown(keyboardEvent);
		};
		
	this._onTextInputTextFieldChangedInstance = 
		function (event)
		{
			_self._onTextInputTextFieldChanged(event);
		};
		
	this.addEventListener("focusin", this._onTextInputFocusEventInstance);
	this.addEventListener("focusout", this._onTextInputFocusEventInstance);	
}

//Inherit from SkinnableElement
TextInputElement.prototype = Object.create(SkinnableElement.prototype);
TextInputElement.prototype.constructor = TextInputElement;
TextInputElement.base = SkinnableElement;

/////////////Events////////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the text is modified as a result of user input.
 */


/////////////Style Types///////////////////////////////

TextInputElement._StyleTypes = Object.create(null);

/**
 * @style MaxChars int
 * 
 * Maximum number of characters allowed.
 */
TextInputElement._StyleTypes.MaxChars = 								{inheritable:false};		// number

/**
 * @style SkinClass CanvasElement
 * 
 * The CanvasElement constructor type to apply to all skin states. 
 * Specific states such as UpSkinClass will override SkinClass.
 */
TextInputElement._StyleTypes.SkinClass =								{inheritable:false};		//Element constructor()

/**
 * @style UpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the skin when in the "up" state. 
 * This will override SkinClass.
 */
TextInputElement._StyleTypes.UpSkinClass = 								{inheritable:false};		//Element constructor()

/**
 * @style UpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "up" state skin element.
 */
TextInputElement._StyleTypes.UpSkinStyle = 								{inheritable:false};		//StyleDefinition

/**
 * @style UpTextColor String
 * 
 * Hex color value to be used for the button TextInput is in the "up" state. Format like "#FF0000" (red).
 * This will override the TextColor style.
 */
TextInputElement._StyleTypes.UpTextColor = 								{inheritable:false};		// color "#000000"

/**
 * @style UpTextHighlightedColor String
 * 
 * Hex color value to be used for highlighted text when the TextInput is in the "up" state. Format like "#FF0000" (red).
 * This will override the TextHighlightedColor style.
 */
TextInputElement._StyleTypes.UpTextHighlightedColor = 					{inheritable:false};		// color "#FFFFFF"

/**
 * @style UpTextHighlightedBackgroundColor String
 * 
 * Hex color value to be used for highlighted text background when the TextInput is in the "up" state. Format like "#FF0000" (red).
 * This will override the TextHighlightedBackgroundColor style.
 */
TextInputElement._StyleTypes.UpTextHighlightedBackgroundColor = 	{inheritable:false};			// color "#000000"

/**
 * @style DisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the TextInput is in the "disabled" state.
 * When this is null, the base SkinClass style will be used.
 */
TextInputElement._StyleTypes.DisabledSkinClass = 						{inheritable:false};		// Element constructor()

/**
 * @style DisabledSkinStyle StyleDefinition
 * The StyleDefinition to apply to the "disabled" state skin element.
 * When this is null, the base SkinTyle will be used.
 */
TextInputElement._StyleTypes.DisabledSkinStyle = 						{inheritable:false};		// StyleDefinition

/**
 * @style DisabledTextColor String
 * 
 * Hex color value to be used for the button TextInput is in the "disabled" state. Format like "#FF0000" (red).
 * This will override the TextColor style.
 */
TextInputElement._StyleTypes.DisabledTextColor = 						{inheritable:false};		// color "#000000"

/**
 * @style DisabledTextHighlightedColor String
 * 
 * Hex color value to be used for highlighted text when the TextInput is in the "disabled" state. Format like "#FF0000" (red).
 * When this is null, the base TextHighlightedColor style will be used.
 */
TextInputElement._StyleTypes.DisabledTextHighlightedColor = 			{inheritable:false};		// color "#FFFFFF"

/**
 * @style DisabledTextHighlightedBackgroundColor String
 * 
 * Hex color value to be used for highlighted text background when the TextInput is in the "disabled" state. Format like "#FF0000" (red).
 * When this is null, the base TextHighlightedBackgroundColor style will be used.
 */
TextInputElement._StyleTypes.DisabledTextHighlightedBackgroundColor = 	{inheritable:false};		// color "#000000"


/////////////Default Styles///////////////////////////

TextInputElement.StyleDefault = new StyleDefinition();

TextInputElement.StyleDefault.setStyle("MaxChars", 									0);
TextInputElement.StyleDefault.setStyle("Enabled", 									true);

TextInputElement.StyleDefault.setStyle("UpTextColor", 								"#000000");
TextInputElement.StyleDefault.setStyle("UpTextHighlightedColor", 					"#FFFFFF");
TextInputElement.StyleDefault.setStyle("UpTextHighlightedBackgroundColor", 			"#000000");

TextInputElement.StyleDefault.setStyle("DisabledTextColor", 						"#888888");
TextInputElement.StyleDefault.setStyle("DisabledTextHighlightedColor", 				"#FFFFFF");
TextInputElement.StyleDefault.setStyle("DisabledTextHighlightedBackgroundColor", 	"#000000");

TextInputElement.StyleDefault.setStyle("PaddingTop",								3);
TextInputElement.StyleDefault.setStyle("PaddingBottom",								3);
TextInputElement.StyleDefault.setStyle("PaddingLeft",								3);
TextInputElement.StyleDefault.setStyle("PaddingRight",								3);

TextInputElement.StyleDefault.setStyle("TabStop", 									0);
TextInputElement.StyleDefault.setStyle("Cursor", 									"text");

TextInputElement.StyleDefault.setStyle("SkinClass", 								CanvasElement);
TextInputElement.StyleDefault.setStyle("UpSkinClass", 								CanvasElement);
TextInputElement.StyleDefault.setStyle("DisabledSkinClass", 						CanvasElement);

/////Skin styles//
TextInputElement.DisabledSkinStyleDefault = new StyleDefinition();

TextInputElement.DisabledSkinStyleDefault.setStyle("BorderType", 					"inset");
TextInputElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 				1);
TextInputElement.DisabledSkinStyleDefault.setStyle("BorderColor", 					"#999999");
TextInputElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 				"#ECECEC");
TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
TextInputElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));

TextInputElement.UpSkinStyleDefault = new StyleDefinition();

TextInputElement.UpSkinStyleDefault.setStyle("BorderType", 							"inset");
TextInputElement.UpSkinStyleDefault.setStyle("BorderThickness", 					1);
TextInputElement.UpSkinStyleDefault.setStyle("BorderColor", 						"#606060");
TextInputElement.UpSkinStyleDefault.setStyle("BackgroundColor", 					"#F5F5F5");

//Apply skin defaults
TextInputElement.StyleDefault.setStyle("UpSkinStyle", 								TextInputElement.UpSkinStyleDefault);
TextInputElement.StyleDefault.setStyle("DisabledSkinStyle", 						TextInputElement.DisabledSkinStyleDefault);



////////Public///////////////////////

/**
 * @function setText
 * Sets the text to be displayed.
 * 
 * @param text String
 * Text to be displayed.
 */
TextInputElement.prototype.setText = 
	function (text)
	{
		this._textField.setText(text);
	};

/**
 * @function getText
 * Gets the text currently displayed.
 * 
 * @returns String
 * Text currently displayed.
 */	
TextInputElement.prototype.getText = 
	function ()
	{
		return this._textField.getText();
	};


////////Internal/////////////////////

/**
 * @function _onTextInputTextFieldChanged
 * Event handler for the internal TextField "changed" event. Only active when TextInput is Enabled.
 * Dispatches a "changed" event from this TextInput element.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to be processed.
 */	
TextInputElement.prototype._onTextInputTextFieldChanged = 
	function (elementEvent)
	{
		//Pass on the changed event
	
		if (this.hasEventListener("changed", null) == true)
			this._dispatchEvent(new ElementEvent("changed", false));
	};
	
/**
 * @function _onTextInputKeyDown
 * Event handler for "keydown" event. Only active when TextInput is enabled. 
 * Proxies keyboard event to internal TextField.
 * 
 * @param keyboardEvent ElementKeyboardEvent
 * ElementKeyboardEvent to process.
 */	
TextInputElement.prototype._onTextInputKeyDown = 
	function (keyboardEvent)
	{
		if (keyboardEvent.getDefaultPrevented() == true)
			return;
		
		var clonedEvent = keyboardEvent.clone();
		clonedEvent._bubbles = false; //Dont bubble.
		
		//Dispatch non-bubbling keyboard event to our text field.
		this._textField._dispatchEvent(clonedEvent);
		
		if (clonedEvent.getIsCanceled() == true)
			keyboardEvent.cancelEvent();
			
		if (clonedEvent.getDefaultPrevented() == true)
			keyboardEvent.preventDefault();
	};

/**
 * @function _onTextInputFocusIn
 * Event handler for "focusin" event. 
 * Proxies focus event to internal TextField.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to process.
 */		
TextInputElement.prototype._onTextInputFocusIn = 
	function (elementEvent)
	{
		//This only works because TextField doesnt look at _isFocused (manages caret state with different flag)
		this._textField._dispatchEvent(elementEvent.clone()); 
	};

/**
 * @function _onTextInputFocusOut
 * Event handler for "focusout" event. 
 * Proxies focus event to internal TextField.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to process.
 */		
TextInputElement.prototype._onTextInputFocusOut = 
	function (elementEvent)
	{
		//This only works because TextField doesnt look at _isFocused (manages caret state with different flag)
		this._textField._dispatchEvent(elementEvent.clone());
	};
	
//@Override
TextInputElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
		
		if (state == "up")
			stateSkinClass = this.getStyleData("UpSkinClass");
		else if (state == "disabled")
			stateSkinClass = this.getStyleData("DisabledSkinClass");
		
		var skinClass = this.getStyleData("SkinClass");
		
		//Shouldnt have null stateSkinClass
		if (stateSkinClass == null || skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
	
//@override	
TextInputElement.prototype._getSkinStyleDefinitions = 
function (state)
{
	if (state == "up")
		return this.getStyle("UpSkinStyle");
	else if (state == "disabled")
		return this.getStyle("DisabledSkinStyle");
	
	return TextInputElement.base.prototype._getSkinStyleDefinitions.call(this, state);
};	

//@Override
TextInputElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "up")
			return this._getDefaultStyle("UpSkinStyle");
		else if (state == "disabled")
			return this._getDefaultStyle("DisabledSkinStyle");
		
		return TextInputElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};		
	
/**
 * @function _updateState
 * Updates the current SkinState in response to style changes.
 */	
TextInputElement.prototype._updateState = 
	function ()
	{
		var newState = "up";

		if (this.getStyle("Enabled") == false)
			newState = "disabled";
		
		this.setStyle("SkinState", newState);
	};	
	
//@Override
TextInputElement.prototype._changeState = 
	function (state)
	{
		TextInputElement.base.prototype._changeState.call(this, state);
	
		this._updateTextColors();
	};
	
/**
 * @function _updateTextColors
 * Updates the text colors based on the current state. Called when state changes and when added to display hierarchy.
 */	
TextInputElement.prototype._updateTextColors = 
	function ()
	{
		this._textField.setStyle("TextColor", this._getTextColor(this._currentSkinState));
		this._textField.setStyle("TextHighlightedColor", this._getTextHighlightedColor(this._currentSkinState));
		this._textField.setStyle("TextHighlightedBackgroundColor", this._getTextHighlightedBackgroundColor(this._currentSkinState));
	};
	
/**
 * @function _getTextColor
 * Gets the text color for the supplied state based on text styles.
 * 
 * @param state String
 * The skin state to return the text color.
 * 
 * @returns String
 * Hex color value.
 */	
TextInputElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextColor");
	
		var textColor = this.getStyleData("TextColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};
	
/**
 * @function _getTextHighlightedColor
 * Gets the highlighted text color for the supplied state based on text styles.
 * 
 * @param state String
 * The skin state to return the highlighted text color.
 * 
 * @returns String
 * Hex color value.
 */		
TextInputElement.prototype._getTextHighlightedColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextHighlightedColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextHighlightedColor");
	
		var textColor = this.getStyleData("TextHighlightedColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};
	
/**
 * @function _getTextHighlightedBackgroundColor
 * Gets the highlighted text background color for the supplied state based on text styles.
 * 
 * @param state String
 * The skin state to return the highlighted text background color.
 * 
 * @returns String
 * Hex color value.
 */		
TextInputElement.prototype._getTextHighlightedBackgroundColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextHighlightedBackgroundColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextHighlightedBackgroundColor");
	
		var textColor = this.getStyleData("TextHighlightedBackgroundColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};
	
//@Override
TextInputElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		TextInputElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("MaxChars" in stylesMap)
			this._textField.setStyle("MaxChars", this.getStyle("MaxChars"));
		
		if ("Enabled" in stylesMap)
		{
			var enabled = this.getStyle("Enabled");
			this._textField.setStyle("Enabled", enabled);
			
			if (enabled == true)
			{
				if (this.hasEventListener("keydown", this._onTextInputKeyDownInstance) == false)
					this.addEventListener("keydown", this._onTextInputKeyDownInstance);
				
				if (this._textField.hasEventListener("changed", this._onTextInputTextFieldChangedInstance) == false)
					this._textField.addEventListener("changed", this._onTextInputTextFieldChangedInstance);					
			}
			else
			{
				if (this.hasEventListener("keydown", this._onTextInputKeyDownInstance) == true)
					this.removeEventListener("keydown", this._onTextInputKeyDownInstance);
				
				if (this._textField.hasEventListener("changed", this._onTextInputTextFieldChangedInstance) == true)
					this._textField.removeEventListener("changed", this._onTextInputTextFieldChangedInstance);
			}
		}
		
		if ("TextLinePaddingTop" in stylesMap || 
			"TextLinePaddingBottom" in stylesMap)
		{
			this._invalidateMeasure();
		}
		
		if ("Padding" in stylesMap ||
			"PaddingTop" in stylesMap ||
			"PaddingBottom" in stylesMap ||
			"PaddingLeft" in stylesMap ||
			"PaddingRight" in stylesMap)
		{
			var paddingSize = this._getPaddingSize();
			
			this._textField.setStyle("PaddingTop", paddingSize.paddingTop);
			this._textField.setStyle("PaddingBottom", paddingSize.paddingBottom);
			this._textField.setStyle("PaddingLeft", paddingSize.paddingLeft);
			this._textField.setStyle("PaddingRight", paddingSize.paddingRight);
			
			this._invalidateMeasure();
		}
		
		this._updateSkinClass("up");
		this._updateSkinStyleDefinitions("up");
		
		this._updateSkinClass("disabled");
		this._updateSkinStyleDefinitions("disabled");
		
		this._updateState();
		this._updateTextColors();
	};
	
//@Override
TextInputElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width:0, height:this.getStyle("TextSize") + this.getStyle("TextLinePaddingTop") + this.getStyle("TextLinePaddingBottom")};
		measuredSize.width = measuredSize.height * 10;
		
		measuredSize.width += padWidth;
		measuredSize.height += padHeight;
	
		return measuredSize;
	};
	
//@Override	
TextInputElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		TextInputElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//Ignore padding, proxied to TextField for proper mouse handling.		
		this._textField._setActualPosition(0, 0);
		this._textField._setActualSize(this._width, this._height);
	};
	
	


/**
 * @depends CanvasElement.js
 */

/////////////////////////////////////////////////////////
/////////////////LabelElement////////////////////////////	
	
/**
 * @class LabelElement
 * @inherits CanvasElement
 * 
 * Basic label for rendering single line style-able text. 
 * Can be styled to automatically truncate text to fit the available 
 * space with a supplied string like ellipses "...".
 * 
 * 
 * @constructor LabelElement 
 * Creates new LabelElement instance.
 */
function LabelElement()
{
	LabelElement.base.prototype.constructor.call(this);
	
	this._textWidth = null;
	this._textHeight = null;
	this._truncateStringWidth = null;
}

//Inherit from CanvasElement
LabelElement.prototype = Object.create(CanvasElement.prototype);
LabelElement.prototype.constructor = LabelElement;
LabelElement.base = CanvasElement;

/////////////Style Types///////////////////////////////

LabelElement._StyleTypes = Object.create(null);

/**
 * @style Text String
 * Text to be rendered by the Label.
 */
LabelElement._StyleTypes.Text = 				{inheritable:false};		// "any string" || null

/**
 * @style TruncateToFit String
 * String to use when truncating a label that does not fit the available area. Defaults to "...".
 */
LabelElement._StyleTypes.TruncateToFit = 		{inheritable:false};		// null || "string" ("...")


////////////Default Styles////////////////////////////

LabelElement.StyleDefault = new StyleDefinition();

//Override base class styles
LabelElement.StyleDefault.setStyle("PaddingTop",					2);
LabelElement.StyleDefault.setStyle("PaddingBottom",					2);
LabelElement.StyleDefault.setStyle("PaddingLeft",					2);
LabelElement.StyleDefault.setStyle("PaddingRight",					2);

//LabelElement specific styles
LabelElement.StyleDefault.setStyle("Text", 							null);
LabelElement.StyleDefault.setStyle("TruncateToFit", 				"...");


/////////////LabelElement Internal Functions///////////////////

//@Override
LabelElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		LabelElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap ||
			"Text" in stylesMap ||
			"TextLinePaddingTop" in stylesMap || 
			"TextLinePaddingBottom" in stylesMap)
		{
			this._textWidth = null;
			this._textHeight = null;
			
			this._invalidateMeasure();
			this._invalidateRender();
		}
		
		if ("TruncateToFit" in stylesMap)
		{
			this._truncateStringWidth = null;
			
			this._invalidateRender();
		}
		
		if ("TextAlign" in stylesMap ||
			"TextBaseline" in stylesMap ||
			"TextColor" in stylesMap ||
			"TextFillType" in stylesMap)
		{
			this._invalidateRender();
		}
	};	
	
//@Override
LabelElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		if (this._textWidth == null || this._textHeight == null)
		{
			var measureText = this.getStyle("Text");
			if (measureText == null)
				measureText = "";
		
			this._textHeight = this.getStyle("TextSize") + this.getStyle("TextLinePaddingTop") + this.getStyle("TextLinePaddingBottom");
			this._textWidth = CanvasElement._measureText(measureText, this._getFontString());
		}
		
		return {width:this._textWidth + padWidth, height:this._textHeight + padHeight};
	};	

//@override
LabelElement.prototype._doRender = 
	function ()
	{
		LabelElement.base.prototype._doRender.call(this);
		
		var text = this.getStyle("Text");
		if (text == null || text.length == 0)
			return;
		
		var ctx = this._getGraphicsCtx();
		var paddingMetrics = this._getPaddingMetrics();
		
		//For convienence
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var fontString = this._getFontString();
		var totalWidth =  this._textWidth;
		
		//Truncate if necessary
		if (totalWidth > w)
		{
			var truncateString = this.getStyle("TruncateToFit");
			
			//Get number of truncate chars
			var numTruncateChars = 0;
			if (truncateString != null)
				numTruncateChars = truncateString.length;
			
			//Get truncate chars width
			if (this._truncateStringWidth == null)
			{
				if (truncateString == null)
					this._truncateStringWidth = 0;
				else
					this._truncateStringWidth = CanvasElement._measureText(truncateString, fontString);
			}
			
			var charWidth = 0;
			var numTextChars = text.length;
			totalWidth = this._textWidth + this._truncateStringWidth;
			
			//Remove text characters until we fit or run out.
			while (numTextChars > 0 && totalWidth > w)
			{
				charWidth = CanvasElement._measureText(text[numTextChars - 1], fontString);
				
				numTextChars--;
				totalWidth -= charWidth;
			}
			
			//Remove truncate characters until we fit or run out
			while (numTruncateChars > 0 && totalWidth > w)
			{
				charWidth = CanvasElement._measureText(truncateString[numTruncateChars - 1], fontString);
				
				numTruncateChars--;
				totalWidth -= charWidth;
			}
			
			text = text.substring(0, numTextChars) + truncateString.substring(0, numTruncateChars);
		}
		
		var linePaddingTop = this.getStyle("TextLinePaddingTop");
		var linePaddingBottom = this.getStyle("TextLinePaddingBottom");
		
		var textBaseline = this.getStyle("TextBaseline");
		var textAlign = this.getStyle("TextAlign");
		var textFillType = this.getStyle("TextFillType");
		var textColor = this.getStyle("TextColor");
		
		//Get x position
		var textXPosition;
		if (textAlign == "left")
			textXPosition = x;
		else if (textAlign = "right")
			textXPosition = x + w - totalWidth;
		else //center
			textXPosition = Math.round(x + (w / 2) - (totalWidth / 2));
		
		//Get y position
		var textYPosition;
		if (textBaseline == "top")
			textYPosition = y + linePaddingTop;
		else if (textBaseline == "bottom")
			textYPosition = y + h - linePaddingBottom;
		else //middle
			textYPosition = Math.round(y + (h / 2) + (linePaddingTop / 2) - (linePaddingBottom / 2));
		
		//Render text
		if (textFillType == "stroke")
			CanvasElement._strokeText(ctx, text, textXPosition, textYPosition, fontString, textColor, textBaseline);
		else
			CanvasElement._fillText(ctx, text, textXPosition, textYPosition, fontString, textColor, textBaseline);
	};
	
	
	


/**
 * @depends CanvasElement.js
 */

////////////////////////////////////////////////////
//////////////////ImageElement//////////////////////

/**
 * @class ImageElement
 * @inherits CanvasElement
 * 
 * ImageElement renders an image (imagine that). 
 * Images can be loaded via "url" or pre-loaded via DOM image reference and can be stretched, tiled, or aligned. 
 * 
 * @constructor ImageElement 
 * Creates new ImageElement instance.
 */
function ImageElement()
{
	ImageElement.base.prototype.constructor.call(this);
	
	this._imageLoader = null;
	
	this._imageSource = null;
	
	/**
	 * @member _imageLoadComplete boolean
	 * Read Only - True if the image has completed loading, otherwise false.
	 */
	this._imageLoadComplete = false;
	
	var _self = this;
	
	//Private event handler, need different instance for each element.
	this._onImageElementLoadCompleteInstance = 
		function (event)
		{
			_self._imageLoader.removeEventListener("load", _self._onImageElementLoadCompleteInstance);
			_self._imageLoadComplete = true;
			
			_self._invalidateMeasure();
			_self._invalidateLayout();
			_self._invalidateRender();
		};
}

//Inherit from CanvasElement
ImageElement.prototype = Object.create(CanvasElement.prototype);
ImageElement.prototype.constructor = ImageElement;
ImageElement.base = CanvasElement;


/////////////Style Types///////////////////////////////

ImageElement._StyleTypes = Object.create(null);

/**
 * @style ImageSource String
 * Image to render. This may be a String URL, or a reference to a DOM image or canvas.
 */
ImageElement._StyleTypes.ImageSource = 					{inheritable:false};		// null || image || "url" 

/**
 * @style ImageSourceClipX Number
 * X position in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipX = 			{inheritable:false};		// null || number

/**
 * @style ImageSourceClipY Number
 * Y position in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipY = 			{inheritable:false};		// null || number

/**
 * @style ImageSourceClipWidth Number
 * Width in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipWidth = 		{inheritable:false};		// null || number

/**
 * @style ImageSourceClipHeight Number
 * Height in pixels of the clip area for the source image.
 */
ImageElement._StyleTypes.ImageSourceClipHeight = 		{inheritable:false};		// null || number

/**
 * @style ImageScaleType String
 * Determines how the image should be stretched or scaled. Allowable values are "none", "fit", "stretch", "tile", or "tilefit".
 * "none" will not modify the original image, 
 * "fit" stretches the image but maintains the aspect ratio to fit the available area's minimum width/height constraint,
 * "stretch" stretches the image to fit the entire available area disregarding aspect ratio,
 * "tile" will not modify the original image but repeat it in both directions to fill the available area.
 * "tilefit" stretches the image but maintains the aspect ratio, any remaining space in the areas maximum width/height constraint is tiled with the stretched image.
 */
ImageElement._StyleTypes.ImageScaleType = 				{inheritable:false};		// "none" || "fit" || "stretch" || "tile" || "tilefit"

/**
 * @style ImageVerticalAlign String
 * Aligns the image vertically when using ImageScaleType "none" or "fit" and not all of the available space is consumed.
 * Allowable values are "top", "middle", "bottom".
 */
ImageElement._StyleTypes.ImageVerticalAlign = 			{inheritable:false};		// "top" || "middle" || "bottom"

/**
 * @style ImageHorizontalAlign String
 * Aligns the image horizontally when using ImageScaleType "none" or "fit" and not all of the available space is consumed.
 * Allowable values are "left", "center", "right".
 */
ImageElement._StyleTypes.ImageHorizontalAlign = 		{inheritable:false};		// "left" || "center" || "right"


////////////Default Styles////////////////////////////

ImageElement.StyleDefault = new StyleDefinition();

ImageElement.StyleDefault.setStyle("ImageSource", 						null);			// null || image || "url"
ImageElement.StyleDefault.setStyle("ImageSourceClipX", 					null);			// null || number
ImageElement.StyleDefault.setStyle("ImageSourceClipY", 					null);			// null || number
ImageElement.StyleDefault.setStyle("ImageSourceClipWidth", 				null);			// null || number
ImageElement.StyleDefault.setStyle("ImageSourceClipHeight", 			null);			// null || number

ImageElement.StyleDefault.setStyle("ImageScaleType", 					"stretch");		// "none" || "fit" || "stretch" || "tile" || "tilefit"
ImageElement.StyleDefault.setStyle("ImageHorizontalAlign", 				"left");		// "left" || "center" || "right"
ImageElement.StyleDefault.setStyle("ImageVerticalAlign", 				"top");			// "top" || "middle" || "bottom"


/////////////ImageElement Protected Functions///////////////////

//@Override
ImageElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ImageElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if ("ImageSource" in stylesMap)
		{
			var newSource = this.getStyle("ImageSource");
			if (this._imageSource != newSource)
			{
				//Clean up old loader
				if (this._imageLoader != null && this._imageLoadComplete == false)
					this._imageLoader.removeEventListener("load", this._onImageElementLoadCompleteInstance);
				
				this._imageLoader = null;
				this._imageLoadComplete = false;
				
				//May be img, string, TODO: Canvas / Video
				this._imageSource = newSource;
				
				if (this._imageSource instanceof HTMLImageElement)
				{
					this._imageLoader = this._imageSource;
					this._imageLoadComplete = this._imageSource.complete;
					
					if (this._imageLoadComplete == false)
						this._imageLoader.addEventListener("load", this._onImageElementLoadCompleteInstance, false);
				}
				else
				{
					this._imageLoader = new Image();
					this._imageLoader.addEventListener("load", this._onImageElementLoadCompleteInstance, false);
					this._imageLoader.src = this._imageSource;
				}
				
				this._invalidateMeasure();
				this._invalidateRender();
			}
		}
		else
		{
			if ("ImageSourceClipX" in stylesMap ||
				"ImageSourceClipY" in stylesMap ||
				"ImageSourceClipWidth" in stylesMap ||
				"ImageSourceClipHeight" in stylesMap)
			{
				this._invalidateMeasure();
				this._invalidateRender();
			}
			else if ("ImageScaleType" in stylesMap ||
					"ImageVerticalAlign" in stylesMap ||
					"ImageHorizontalAlign" in stylesMap)
			{
				this._invalidateRender();
			}
		}
	};
	
//@Override
ImageElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width: padWidth, height: padHeight};
		
		var clipX = this.getStyle("ImageSourceClipX");
		var clipY = this.getStyle("ImageSourceClipY");
		
		var clipWidth = this.getStyle("ImageSourceClipWidth");
		var clipHeight = this.getStyle("ImageSourceClipHeight");
		
		if (clipX == null)
			clipX = 0;
		
		if (clipY == null)
			clipY = 0;
		
		if (clipWidth != null)
			measuredSize.width += clipWidth;
		else if (this._imageLoadComplete == true)
			measuredSize.width += (this._imageLoader.naturalWidth - clipX);

		if (clipHeight != null)
			measuredSize.height += clipHeight;
		else if (this._imageLoadComplete == true)
			measuredSize.height += (this._imageLoader.naturalHeight - clipY);
		
		return measuredSize;
	};	
	
//@Override
ImageElement.prototype._doRender =
	function()
	{
		ImageElement.base.prototype._doRender.call(this);
		
		if (this._imageLoadComplete == false)
			return;
		
		var paddingMetrics = this._getPaddingMetrics();
		var ctx = this._getGraphicsCtx();
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		if (w <= 0 || h <= 0)
			return;
		
		var clipX = this.getStyle("ImageSourceClipX");
		var clipY = this.getStyle("ImageSourceClipY");
		var clipW = this.getStyle("ImageSourceClipWidth");
		var clipH = this.getStyle("ImageSourceClipHeight");
		
		var scaleType = this.getStyle("ImageScaleType");
		
		if (clipX == null)
			clipX = 0;
		if (clipY == null)
			clipY = 0;
		
		if (clipW == null)
			clipW = this._imageLoader.naturalWidth - clipX;
		if (clipH == null)
			clipH = this._imageLoader.naturalHeight - clipY;
		
		if (clipW <= 0 || clipH <= 0)
			return;
		
		if (scaleType == "stretch")
		{
			ctx.drawImage(
				this._imageLoader, 
				clipX, clipY, clipW, clipH, 
				x, y, w, h);
		}
		else if (scaleType == "tile")
		{
			var currentX = x;
			var currentY = y;
			
			var drawWidth = clipW;
			var drawHeight = clipH;
			
			while (true)
			{
				drawWidth = Math.min(clipW, x + w - currentX);
				drawHeight = Math.min(clipH, y + h - currentY);
				
				ctx.drawImage(
					this._imageLoader, 
					clipX, clipY, drawWidth, drawHeight, 
					currentX, currentY, drawWidth, drawHeight);
				
				currentX += drawWidth;
				if (currentX >= x + w)
				{
					currentX = x;
					currentY += drawHeight;
					
					if (currentY >= y + h)
						break;
				}
			}
		}
		else if (scaleType == "tilefit")
		{
			var thisRatio = w / h;
			var imageRatio = clipW / clipH;
			
			var drawWidth = clipW;
			var drawHeight = clipH;
			
			//Size to our height
			if (thisRatio > imageRatio)
			{
				var currentX = x;
				
				drawHeight = h;
				drawWidth = h * imageRatio;
				
				while (true)
				{
					if (currentX + drawWidth > x + w)
					{
						var availableWidth = x + w - currentX;
						var widthRatio = availableWidth / drawWidth;
						
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW * widthRatio, clipH, 
							currentX, y, drawWidth * widthRatio, drawHeight);
						
						break;
					}
					else
					{
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW, clipH, 
							currentX, y, drawWidth, drawHeight);
						
						currentX += drawWidth;
						if (currentX == x + w)
								break;
					}
				}
			}
			else //Size to our width
			{
				var currentY = y;
				
				drawWidth = w;
				drawHeight = w / imageRatio;
				
				while (true)
				{
					if (currentY + drawHeight > y + h)
					{
						var availableHeight = y + h - currentY;
						var heightRatio = availableHeight / drawHeight;
						
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW, clipH * heightRatio, 
							x, currentY, drawWidth, drawHeight * heightRatio);
						
						break;
					}
					else
					{
						ctx.drawImage(
							this._imageLoader, 
							clipX, clipY, clipW, clipH, 
							x, currentY, drawWidth, drawHeight);
						
						currentY += drawHeight;
						if (currentY == y + h)
							break;
					}
				}
			}
		}
		else if (scaleType == "fit" || scaleType == "none")
		{
			var verticalAlign = this.getStyle("ImageVerticalAlign");
			var horizontalAlign = this.getStyle("ImageHorizontalAlign");
			
			var drawWidth = clipW;
			var drawHeight = clipH;
			
			if (scaleType == "fit")
			{
				var thisRatio = w / h;
				var imageRatio = clipW / clipH;
				
				//Size to our height
				if (thisRatio > imageRatio)
				{
					drawHeight = h;
					drawWidth = h * imageRatio;
				}
				else //Size to our width
				{
					drawWidth = w;
					drawHeight = w / imageRatio;
				}
			}
			else //scaleType == "none"
			{
				//Reduce image clipping area to render size.
				if (w < clipW)
				{
					if (horizontalAlign == "right")
						clipX += (clipW - w);
					else if (horizontalAlign == "center")
						clipX += ((clipW - w) / 2);
					
					clipW = w;
					drawWidth = w;
				}
				if (h < clipH)
				{
					if (verticalAlign == "bottom")
						clipY += (clipH - h);
					else if (verticalAlign == "middle")
						clipY += ((clipH - h) / 2);
					
					clipH = h;
					drawHeight = h;
				}
			}
			
			var drawX = x;
			var drawY = y;
			
			if (horizontalAlign == "right")
				drawX += w - drawWidth;
			else if (horizontalAlign == "center")
				drawX += ((w - drawWidth) / 2);
			
			if (verticalAlign == "bottom")
				drawY += h - drawHeight;
			else if (verticalAlign == "middle")
				drawY += ((h - drawHeight) / 2);
			
			ctx.drawImage(
				this._imageLoader, 
				clipX, clipY, clipW, clipH, 
				drawX, drawY, drawWidth, drawHeight);
		}
		
	};
	
	
	


/**
 * @depends SkinnableElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataRendererBaseElement/////////////////////////
	
/**
 * @class DataRendererBaseElement
 * @inherits SkinnableElement
 * 
 * Abstract base class for DataList item rendering. Any CanvasElement
 * can be a data renderer. This class is just here for convenience as it
 * implements some commonly used functionality if you wish to subclass it. 
 * 
 * Adds skin states and styles for "up", "alt", "over", and "selected" states. 
 *  
 * 
 * @constructor DataRendererBaseElement 
 * Creates new DataRendererBaseElement instance.
 */
function DataRendererBaseElement()
{
	DataRendererBaseElement.base.prototype.constructor.call(this);
	
	var _self = this;
	
	//Private event handler, proxy to prototype.
	this._onDataRendererBaseEventInstance = 
		function (elementEvent)
		{
			if (elementEvent.getType() == "rollover")
				_self._onDataRendererRollover(elementEvent);
			else if (elementEvent.getType() == "rollout")
				_self._onDataRendererRollout(elementEvent);
		};
		
	this.addEventListener("rollover", this._onDataRendererBaseEventInstance);
	this.addEventListener("rollout", this._onDataRendererBaseEventInstance);
}
	
//Inherit from SkinnableElement
DataRendererBaseElement.prototype = Object.create(SkinnableElement.prototype);
DataRendererBaseElement.prototype.constructor = DataRendererBaseElement;
DataRendererBaseElement.base = SkinnableElement;


/////////////Style Types////////////////////////////////////////////

DataRendererBaseElement._StyleTypes = Object.create(null);

/**
 * @style SkinClass CanvasElement
 * 
 * The CanvasElement constructor type to apply to all skin states. 
 * Specific states such as UpSkinClass will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.SkinClass =					{inheritable:false};		//Element constructor()

/**
 * @style UpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "up" state. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.UpSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style UpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "up" state skin element.
 */
DataRendererBaseElement._StyleTypes.UpSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style AltSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "alt" state. 
 * This is used to create different styles for alternating rows. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.AltSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style AltSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "alt" state skin element.
 */
DataRendererBaseElement._StyleTypes.AltSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style OverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "over" state. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.OverSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style OverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "over" state skin element.
 */
DataRendererBaseElement._StyleTypes.OverSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style SelectedSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the data renderer skin when in the "selected" state. 
 * This will override SkinClass.
 */
DataRendererBaseElement._StyleTypes.SelectedSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style SelectedSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selected" state skin element.
 */
DataRendererBaseElement._StyleTypes.SelectedSkinStyle = 		{inheritable:false};		//StyleDefinition

//Proxied from DataList (intended only for reading)
/**
 * @style Selectable boolean
 * 
 * When false, prevents "over" and "selected" states. Proxied from parent DataList.
 */
DataRendererBaseElement._StyleTypes.Selectable = 				{inheritable:false};		// true || false


///////////Default Styles///////////////////////////////////////////

DataRendererBaseElement.StyleDefault = new StyleDefinition();

//Skin Defaults////////////////////////////
DataRendererBaseElement.OverSkinStyleDefault = new StyleDefinition();

DataRendererBaseElement.OverSkinStyleDefault.setStyle("BackgroundColor", 			"#E0E0E0");
DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 			(+.03));
DataRendererBaseElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 			(-.03));

DataRendererBaseElement.SelectedSkinStyleDefault = new StyleDefinition();

DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("BackgroundColor", 			"#CDCDCD");
DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientStart", 			(+.03));
DataRendererBaseElement.SelectedSkinStyleDefault.setStyle("AutoGradientStop", 			(-.03));
//////////////////////////////////////////

DataRendererBaseElement.StyleDefault.setStyle("Selectable", 			true);												// intended only for reading, its proxied from DataList

DataRendererBaseElement.StyleDefault.setStyle("SkinClass", 				CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("UpSkinClass", 			CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("AltSkinClass", 			CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("OverSkinClass", 			CanvasElement);										// Element constructor()
DataRendererBaseElement.StyleDefault.setStyle("SelectedSkinClass", 		CanvasElement);										// Element constructor()

DataRendererBaseElement.StyleDefault.setStyle("UpSkinStyle", 			null);												// StyleDefinition
DataRendererBaseElement.StyleDefault.setStyle("AltSkinStyle", 			null);												// StyleDefinition
DataRendererBaseElement.StyleDefault.setStyle("OverSkinStyle", 			DataRendererBaseElement.OverSkinStyleDefault);		// StyleDefinition
DataRendererBaseElement.StyleDefault.setStyle("SelectedSkinStyle", 		DataRendererBaseElement.SelectedSkinStyleDefault);	// StyleDefinition


/////////////Internal///////////////////////////

/**
 * @function _updateState
 * Updates the SkinState style in response to mouse and ListData changes.
 */
DataRendererBaseElement.prototype._updateState = 
	function ()
	{
		var newState = "";
	
		if (this._listSelected == true)
			newState = "selected";
		else if (this._mouseIsOver == true && this.getStyle("Selectable") == true)
			newState = "over";
		else // "up"
		{
			if (this._listData == null || this._listData._itemIndex % 2 == 0)
				newState = "up";
			else
				newState = "alt";
		}
		
		this.setStyle("SkinState", newState);
	};

//@Override
DataRendererBaseElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
		
		if (state == "up")
			stateSkinClass = this.getStyleData("UpSkinClass");
		else if (state == "alt")
			stateSkinClass = this.getStyleData("AltSkinClass");
		else if (state == "over")
			stateSkinClass = this.getStyleData("OverSkinClass");
		else if (state == "selected")
			stateSkinClass = this.getStyleData("SelectedSkinClass");
		
		var skinClass = this.getStyleData("SkinClass");
		
		//Shouldnt have null stateSkinClass
		if (stateSkinClass == null || skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
		
//@override	
DataRendererBaseElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "up")
			return this.getStyle("UpSkinStyle");
		else if (state == "alt")
			return this.getStyle("AltSkinStyle");
		else if (state == "over")
			return this.getStyle("OverSkinStyle");
		else if (state == "selected")
			return this.getStyle("SelectedSkinStyle");
		
		return DataRendererBaseElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};

//@Override
DataRendererBaseElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "up")
			return this._getDefaultStyle("UpSkinStyle");
		else if (state == "alt")
			return this._getDefaultStyle("AltSkinStyle");
		else if (state == "over")
			return this._getDefaultStyle("OverSkinStyle");
		else if (state == "selected")
			return this._getDefaultStyle("SelectedSkinStyle");
		
		return DataRendererBaseElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};	
	
/**
 * @function _onDataRendererRollover
 * Event handler for "rollover" event. Updates the skin state.
 * Overriding this is more efficient than adding an additional "rollover" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
DataRendererBaseElement.prototype._onDataRendererRollover = 
	function (elementEvent)
	{
		this._updateState();
	};
	
/**
 * @function _onDataRendererRollout
 * Event handler for "rollout" event. Updates the skin state.
 * Overriding this is more efficient than adding an additional "rollout" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
DataRendererBaseElement.prototype._onDataRendererRollout = 
	function (elementEvent)
	{
		this._updateState();
	};

//@Override	
DataRendererBaseElement.prototype._setListSelected = 
	function (selected)
	{
		DataRendererBaseElement.base.prototype._setListSelected.call(this, selected);
		
		this._updateState();
	};
	
//@Override	
DataRendererBaseElement.prototype._setListData = 
	function (listData, itemData)
	{
		DataRendererBaseElement.base.prototype._setListData.call(this, listData, itemData);
		
		this._updateState();
	};

//@Override
DataRendererBaseElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataRendererBaseElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		//Always update these, they dont do anything if no changes
		//and cheaper to call this than to check SkinClass inheritance.
		this._updateSkinClass("up");
		this._updateSkinStyleDefinitions("up");
		
		this._updateSkinClass("alt");
		this._updateSkinStyleDefinitions("alt");
		
		this._updateSkinClass("over");
		this._updateSkinStyleDefinitions("over");
		
		this._updateSkinClass("selected");
		this._updateSkinStyleDefinitions("selected");
		
		if ("Selectable" in stylesMap)
			this._updateState();
	};
	
	


/**
 * @depends DataRendererBaseElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataRendererLabelElement////////////////////////

/**
 * @class DataRendererLabelElement
 * @inherits DataRendererBaseElement
 * 
 * DataList DataRenderer for a basic label.
 * Adds text color styles for DataRenderer states and 
 * sets label text when the parent DataList sets our list data.
 * 
 * @constructor DataRendererLabelElement 
 * Creates new DataRendererLabelElement instance.
 */
function DataRendererLabelElement()
{
	DataRendererLabelElement.base.prototype.constructor.call(this);
	
	this._labelElement = new LabelElement();
	this._labelElement.setStyle("Padding", 0); //Wipe out default padding (no doubly padding, only this elements padding is necessary)
	
	this._addChild(this._labelElement);
}
	
//Inherit from DataRendererBaseElement
DataRendererLabelElement.prototype = Object.create(DataRendererBaseElement.prototype);
DataRendererLabelElement.prototype.constructor = DataRendererLabelElement;
DataRendererLabelElement.base = DataRendererBaseElement;


/////////////Style Types/////////////////////////

DataRendererLabelElement._StyleTypes = Object.create(null);

/**
 * @style UpTextColor String
 * 
 * Hex color value to be used for the label when in the "up" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.UpTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style AltTextColor String
 * 
 * Hex color value to be used for the label when in the "alt" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.AltTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style OverTextColor String
 * 
 * Hex color value to be used for the label when in the "over" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.OverTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style SelectedTextColor String
 * 
 * Hex color value to be used for the label when in the "selected" state. Format like "#FF0000" (red).
 * This will override the TextColor style of equal priority.
 */
DataRendererLabelElement._StyleTypes.SelectedTextColor = 		{inheritable:false};		//"#000000"


////////////Default Styles///////////////////////

DataRendererLabelElement.StyleDefault = new StyleDefinition();

DataRendererLabelElement.StyleDefault.setStyle("PaddingTop", 				4);
DataRendererLabelElement.StyleDefault.setStyle("PaddingBottom", 			4);
DataRendererLabelElement.StyleDefault.setStyle("PaddingLeft", 				4);
DataRendererLabelElement.StyleDefault.setStyle("PaddingRight", 				4);
DataRendererLabelElement.StyleDefault.setStyle("BorderType", 				"none");

DataRendererLabelElement.StyleDefault.setStyle("UpTextColor", 				"#000000");
DataRendererLabelElement.StyleDefault.setStyle("AltTextColor", 				"#000000");
DataRendererLabelElement.StyleDefault.setStyle("OverTextColor", 			"#000000");
DataRendererLabelElement.StyleDefault.setStyle("SelectedTextColor", 		"#000000");


////////////Internal/////////////////////////////

//@Override
DataRendererLabelElement.prototype._changeState = 
	function (state)
	{
		DataRendererLabelElement.base.prototype._changeState.call(this, state);
		
		this._updateLabelTextColor();
	};
	
/**
 * @function _getTextColor
 * Gets the text color style for the supplied state.
 * 
 * @param state String
 * The current state.
 * 
 * @returns String
 * Text color style for the supplied state.
 */	
DataRendererLabelElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextColor");
		else if (state == "alt")
			stateTextColor = this.getStyleData("AltTextColor");
		else if (state == "over")
			stateTextColor = this.getStyleData("OverTextColor");
		else if (state == "selected")
			stateTextColor = this.getStyleData("SelectedTextColor");
	
		var textColor = this.getStyleData("TextColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

/**
 * @function _updateLabelTextColor
 * Updates the text color base on the current state.
 */	
DataRendererLabelElement.prototype._updateLabelTextColor = 
	function ()
	{
		var color = this._getTextColor(this._currentSkinState);
		if (color != null)
			this._labelElement.setStyle("TextColor", color);
	};
	
/**
 * @function _updateLabelTextColor
 * Updates the label text base on the list data and ItemLabelFunction.
 */		
DataRendererLabelElement.prototype._updateLabelText = 
	function ()
	{
		if (this._itemData == null)
			this._labelElement.setStyle("Text", "");
		else
		{
			var labelFunction = this._listData._parentList.getStyle("ItemLabelFunction");
			this._labelElement.setStyle("Text", labelFunction(this._itemData));
		}
	};
	
//@Override
DataRendererLabelElement.prototype._setListData = 
	function (listData, itemData)
	{
		DataRendererLabelElement.base.prototype._setListData.call(this, listData, itemData);
		
		this._updateLabelText();
	};

//@Override
DataRendererLabelElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataRendererLabelElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		this._updateLabelTextColor();
	};

//@Override
DataRendererLabelElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width: this._labelElement._getStyledOrMeasuredWidth() + padWidth, 
				height: this._labelElement._getStyledOrMeasuredHeight() + padHeight};
	};

//@Override	
DataRendererLabelElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataRendererLabelElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		this._labelElement._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
		this._labelElement._setActualSize(paddingMetrics.getWidth(), paddingMetrics.getHeight());
	};
	
	


/**
 * @depends CanvasElement.js
 * @depends DataRendererLabelElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataListElement/////////////////////////////////		
	
/**
 * @class DataListElement
 * @inherits CanvasElement
 * 
 * DataListElement is a data-driven container that renders items in a 
 * horizontal or vertical orientation via a supplied ListCollection and a supplied DataRenderer class.
 * A DataRenderer is any CanvasElement that implements _setListData() and _setListSelected()
 * and is used to render the corresponding ListCollection item. A scroll bar will be added
 * if the collection size exceeds the available area. DataListElement only renders visible 
 * DataRenderers so collection size does not impact performance.
 * 
 * DataRendereBaseElement is an abstract base class that implements common
 * features and can be sub-classed if desired.
 * 
 * The default DataRenderer is the DataRendererLabelElement which renders
 * a text label per the LabelFunction style. 
 * 
 * @seealso DataRendererBaseElement
 * @seealso DataRendererLabelElement
 * 
 * 
 * @constructor DataListElement 
 * Creates new DataListElement instance.
 */
function DataListElement()
{
	DataListElement.base.prototype.constructor.call(this);
	
	this._listCollection = null; //Data collection
	
	this._contentSize = 0;
	
	this._scrollBar = null;
	this._scrollIndex = 0;
	
	this._selectedIndex = -1;
	this._selectedItem = null;
	
	this._contentPane = new CanvasElement();
	this._contentPane.setStyle("ClipContent", true);
	this._addChild(this._contentPane);
	
	var _self = this;
	
	//Private event listener, need an instance for each DataList, proxy to prototype.
	this._onDataListCollectionChangedInstance = 
		function (collectionChangedEvent)
		{
			_self._onDataListCollectionChanged(collectionChangedEvent);
		};
		
	this._onDataListScrollBarChangedInstance = 
		function (elementEvent)
		{
			_self._onDataListScrollBarChanged(elementEvent);
		};
		
	this._onDataListMouseWheelEventInstance = 
		function (elementMouseWheelEvent)
		{
			_self._onDataListMouseWheelEvent(elementMouseWheelEvent);
		};
	
	this._onDataListRendererClickInstance = 
		function (elementMouseEvent)
		{
			_self._onDataListRendererClick(elementMouseEvent);
		};
		
	this.addEventListener("wheel", this._onDataListMouseWheelEventInstance);	
}

//Inherit from SkinnableElement
DataListElement.prototype = Object.create(CanvasElement.prototype);
DataListElement.prototype.constructor = DataListElement;
DataListElement.base = CanvasElement;

/**
 * @function DefaultItemLabelFunction
 * @static
 * Default ItemLabelFunction function. Looks for typeof String or "label" property of supplied itemData.
 * 
 * @param itemData Object
 * Collection item to extract label text.
 * 
 * @returns String
 * Label text.
 */
DataListElement.DefaultItemLabelFunction = 
	function (itemData)
	{
		if (itemData == null)
			return "";
		
		if (typeof itemData === "string" || itemData instanceof String)
			return itemData;
	
		if ("label" in itemData)
			return itemData["label"];
		
		return itemData.toString();
	};


/////////////Events///////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the selected item/index changes as a result of user interaction.
 * 
 * @event listitemclick ElementListItemClickEvent
 * Dispatched when a DataRenderer is clicked. Includes associated collection item/index.
 */



/////////////Style Types////////////////////////////////////////////

DataListElement._StyleTypes = Object.create(null);

/**
 * @style ListDirection String
 * 
 * Determines the layout direction of this DataList. Allowable values are "horizontal" or "vertical".
 */
DataListElement._StyleTypes.ListDirection = 					{inheritable:false};		// "horizontal" || "vertical

/**
 * @style ListAlign String
 * 
 * Determines the alignment of content when there is not enough data in the ListCollection to fill the DataList.
 * Allowable values are "left", "center", "right" for horizontal layout, and "top", "middle", "bottom" for vertical layout. 
 */
DataListElement._StyleTypes.ListAlign = 						{inheritable:false};		// "left" || "center" || "right" / "top" || "middle" || "bottom"

/**
 * @style Selectable boolean
 * 
 * When true, list items can be selected and the DataList will dispatch "changed" events.
 */
DataListElement._StyleTypes.Selectable = 						{inheritable:false};		// true || false

/**
 * @style ScrollBarDisplay String
 * 
 * Determines the behavior of the scroll bar. Allowable values are "on", "off", and "auto".
 */
DataListElement._StyleTypes.ScrollBarDisplay = 					{inheritable:false};		// "on" || "off" || "auto"

/**
 * @style ScrollBarPlacement String
 * 
 * Determines the placement of the scroll bar. 
 * Allowable values are "top" or "bottom" for horizontal layout and "left" or "right" for vertical layout.
 */
DataListElement._StyleTypes.ScrollBarPlacement = 				{inheritable:false};		// "top" || "bottom" / "left || "right"

/**
 * @style ScrollBarStyle StyleDefinition
 * 
 * The StyleDefinition to be applied to the scroll bar.
 */
DataListElement._StyleTypes.ScrollBarStyle = 					{inheritable:false};		// StyleDefinition

//Returns the string to use for the label per provided data.
/**
 * @style ItemLabelFunction Function
 * 
 * A function that returns a text string per a supplied collection item.
 * function (itemData) { return "" }
 */
DataListElement._StyleTypes.ItemLabelFunction = 				{inheritable:false}; 		// function (itemData) { return "" }

/**
 * @style ListItemClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataRenderer.
 */
DataListElement._StyleTypes.ListItemClass = 					{inheritable:false};		//DataRendererBaseElement constructor()

/**
 * @style ListItemStyle StyleDefinition
 * 
 * The StyleDefinition to be applied to the DataRenderer.
 */
DataListElement._StyleTypes.ListItemStyle = 					{inheritable:false};		//StyleDefinition


///////////Default Styles////////////////////////////////////

DataListElement.StyleDefault = new StyleDefinition();

DataListElement.StyleDefault.setStyle("ListDirection", 				"vertical");								// "horizontal" || "vertical
DataListElement.StyleDefault.setStyle("ListAlign", 					"top");										// "left" || "center" || "right" / "top" || "middle" || "bottom"

DataListElement.StyleDefault.setStyle("ItemLabelFunction", 			DataListElement.DefaultItemLabelFunction);	// function (data) { return "" }

DataListElement.StyleDefault.setStyle("ListItemClass", 				DataRendererLabelElement); 					// Element constructor()
DataListElement.StyleDefault.setStyle("ListItemStyle", 				null);										// StyleDefinition

DataListElement.StyleDefault.setStyle("Selectable", 				true);										// true || false

DataListElement.StyleDefault.setStyle("ScrollBarDisplay", 			"auto");									// "on" || "off" || "auto"
DataListElement.StyleDefault.setStyle("ScrollBarPlacement", 		"right");									// "top" || "bottom" / "left || "right"
DataListElement.StyleDefault.setStyle("ScrollBarStyle", 			null);										// StyleDefinition


/////////DataRenderer Proxy Map/////////////////////////////

//Proxy map for styles we want to pass to the DataRenderer.
DataListElement._DataRendererProxyMap = Object.create(null);

DataListElement._DataRendererProxyMap.Selectable = 				true;
DataListElement._DataRendererProxyMap._Arbitrary = 				true;


/////////////Public///////////////////////////////

/**
 * @function setSelectedIndex
 * Sets the selected collection index/item.
 * 
 * @param index int
 * The collection index to be selected.
 */	
DataListElement.prototype.setSelectedIndex = 
	function (index)
	{
		if (this._selectedIndex == index)
			return true;
		
		if (index > this._listCollection.length -1)
			return false;
		
		if (index < -1)
			index = -1;
		
		var oldIndex = this._selectedIndex;
		
		this._selectedIndex = index;
		this._selectedItem = this._listCollection.getItemAt(index);
		
		//Update renderer data.
		if (this._contentPane._children.length > 0)
		{
			var firstIndex = this._contentPane._children[0]._listData._itemIndex;
			var lastIndex = this._contentPane._children[this._contentPane._children.length - 1]._listData._itemIndex;
			
			if (index != null && index >= firstIndex && index <= lastIndex)
				this._contentPane._children[index - firstIndex]._setListSelected(true);
			if (oldIndex != null && oldIndex >= firstIndex && oldIndex <= lastIndex)
				this._contentPane._children[oldIndex - firstIndex]._setListSelected(false);
		}
		
		return true;
	};

/**
 * @function getSelectedIndex
 * Gets the selected collection index. 
 * 
 * @returns int
 * The selected collection index or -1 if none selected.
 */		
DataListElement.prototype.getSelectedIndex = 
	function ()
	{
		return this._selectedIndex;
	};
	
/**
 * @function setSelectedItem
 * Sets the selected collection item/index.
 * 
 * @param item Object
 * The collection item to be selected.
 */	
DataListElement.prototype.setSelectedItem = 
	function (item)
	{
		var index = this._listCollection.getItemIndex(item);
		this.setSelectedIndex(index);
	};
	
/**
 * @function getSelectedItem
 * Gets the selected collection item. 
 * 
 * @returns Object
 * The selected collection item or null if none selected.
 */		
DataListElement.prototype.getSelectedItem = 
	function ()
	{
		return this._selectedItem;
	};
	
/**
 * @function setScrollIndex
 * Sets the collection item index to scroll too. 
 * 
 * @param scrollIndex int
 * Collection item index.
 */	
DataListElement.prototype.setScrollIndex = 
	function (scrollIndex)
	{
		this._invalidateLayout();
		
		if (this._contentPane._children.length == 0 || this._listCollection == null)
		{
			this._scrollIndex = 0;
			
			//No data, purge the renderers.
			while (this._contentPane._children.length > 0)
				this._contentPane._removeChildAt(0);
			
			return;
		}
		
		if (scrollIndex >= this._listCollection.getLength())
			scrollIndex = this._listCollection.getLength() - 1;
		if (scrollIndex < 0)
			scrollIndex = 0;		
		
		this._scrollIndex = scrollIndex;
		
		var itemIndex = Math.floor(scrollIndex);
		var currentIndex = this._contentPane._children[0]._listData._itemIndex;
		
		var renderer = null;
		
		if (itemIndex == currentIndex - 1) //Move bottom renderer to top
		{
			renderer = this._contentPane._children[this._contentPane._children.length - 1];
			this._contentPane._setChildIndex(renderer, 0);
			
			this._updateRendererData(renderer, itemIndex);
		}
		else if (itemIndex == currentIndex + 1) //Move top renderer to bottom (or delete)
		{
			if (this._listCollection.getLength() >= itemIndex + this._contentPane._children.length)
			{
				renderer = this._contentPane._children[0];
				this._contentPane._setChildIndex(renderer, this._contentPane._children.length - 1);
				
				this._updateRendererData(renderer, itemIndex + this._contentPane._children.length - 1);
			}
			else //No more data, purge the renderer.
				this._contentPane._removeChildAt(0);
		}
		else //Reset renderer data. (Even if index hasnt changed, we call this if the collection is sorted or changed)
		{
			for (var i = 0; i < this._contentPane._children.length; i++)
			{
				if (this._listCollection.getLength() > itemIndex + i)
				{
					//Update list data
					renderer = this._contentPane._children[i];
					this._updateRendererData(renderer, itemIndex + i);
				}
				else
				{
					//No more data, purge the rest of the renderers.
					while (this._contentPane._children.length > i)
						this._contentPane._removeChildAt(i);
				}
			}
		}
	};

/**
 * @function setListCollection
 * Sets the DataLists's associated ListCollection to generate DataRenderers.
 * 
 * @param listCollection ListCollection
 * The ListCollection to be used as the data-provider.
 */	
DataListElement.prototype.setListCollection = 
	function (listCollection)
	{
		if (this._listCollection == listCollection)
			return;
	
		if (this._manager == null)
		{
			this._listCollection = listCollection;
		}
		else
		{
			if (this._listCollection != null)
				this._listCollection.removeEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
			
			this._listCollection = listCollection;
			
			if (this._listCollection != null)
				this._listCollection.addEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
		}
		
		//Fix selected index/item
		if (this._listCollection == null)
		{
			this._selectedIndex = -1;
			this._selectedItem = null;
		}
		else
		{
			if (this._selectedItem != null)
			{
				this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
				
				if (this._selectedIndex == -1)
					this._selectedItem = null;
			}
		}
		
		this.setScrollIndex(this._scrollIndex); //Reset renderer data.
		this._invalidateLayout();
	};
	
/**
 * @function getListCollection
 * Gets the DataLists's associated ListCollection. 
 * 
 * @returns ListCollection
 * The associated ListCollection or null if none assigned.
 */		
DataListElement.prototype.getListCollection = 
	function ()
	{
		return this._listCollection;
	};	
	
///////////Internal//////////////////////////////
	
/**
 * @function _getContentSize
 * Gets the content size of the DataList. This is only accurate after the DataList
 * has finished its layout phase. Currently only used by the Dropdown to fix the
 * vertical height of the drop down pop-up list when there are too few items.
 * 
 * @returns Number
 * Content size in pixels of the DataListElement. Only valid after layout phase completed.
 */	
//Helpers function (currently only used by dropdown) ///
DataListElement.prototype._getContentSize = 
	function ()
	{
		var paddingSize = this._getPaddingSize();
	
		if (this.getStyle("ListDirection") == "vertical")
			return this._contentSize + paddingSize.height;
		else //if (this.getStyle("ListDirection") == "horizontal")
			return this._contentSize + paddingSize.width;
	};

/**
 * @function _getNumRenderers
 * Gets the number of DataRenderers that are currently being rendered.
 * 
 * @returns int
 * the number of DataRenderers that are currently being rendered.
 */	
DataListElement.prototype._getNumRenderers = 
	function ()
	{
		return this._contentPane._children.length;
	};	
	
/**
 * @function _onDataListMouseWheelEvent
 * Event handler for the DataList "wheel" event. Starts the scroll bar tween.
 * 
 * @param elementMouseWheelEvent ElementMouseWheelEvent
 * The ElementMouseWheelEvent to process.
 */		
DataListElement.prototype._onDataListMouseWheelEvent = 
	function (elementMouseWheelEvent)
	{
		if (elementMouseWheelEvent.getDefaultPrevented() == true)
			return;
	
		//No renderers or event prevented.
		if (this._contentPane._children.length == 0 || this._listCollection.getLength() == 0)
			return;
	
		var delta = 0;
		var listDirection = this.getStyle("ListDirection");
		
		var minScrolled = false;
		var maxScrolled = false;
		
		var firstRenderer = this._contentPane._children[0];
		var lastRenderer = this._contentPane._children[this._contentPane._children.length - 1];
		
		if (listDirection == "horizontal")
		{
			delta = elementMouseWheelEvent.getDeltaX();
			
			if (delta == 0)
				return;
			
			if (firstRenderer._listData._itemIndex == 0 && 
				firstRenderer._x >= 0)
			{
				minScrolled = true;
			}
			
			if (minScrolled == true && delta < 0)
				return;
			
			if (lastRenderer._listData._itemIndex == this._listCollection.getLength() - 1 && 
				lastRenderer._x <= this._contentPane._width - lastRenderer._width)
			{
				maxScrolled = true;
			}
			
			if (maxScrolled == true && delta > 0)
				return;
		}
		else //if (listDirection == "vertical")
		{
			delta = elementMouseWheelEvent.getDeltaY();
			
			if (delta == 0)
				return;
			
			if (firstRenderer._listData._itemIndex == 0 && 
				firstRenderer._y >= 0)
			{
				minScrolled = true;
			}
			
			if (minScrolled == true && delta < 0)
				return;
			
			if (lastRenderer._listData._itemIndex == this._listCollection.getLength() - 1 && 
				lastRenderer._y <= this._contentPane._height - lastRenderer._height)
			{
				maxScrolled = true;
			}
			
			if (maxScrolled == true && delta > 0)
				return;
		}
		
		if (this._scrollBar != null)
		{
			var tweeningTo = this._scrollBar.getTweenToValue();
			if (tweeningTo == null)
				tweeningTo = this._scrollIndex;
			
			this._scrollBar.startScrollTween(tweeningTo + delta);
		}
		else
			this.setScrollIndex(this._scrollIndex + delta);
		
		//We've consumed the wheel event, don't want parents double scrolling.
		elementMouseWheelEvent.preventDefault();
	};	

/**
 * @function _onDataListScrollBarChanged
 * Event handler for the scroll bar "changed" event. Updates DataRenderers.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
DataListElement.prototype._onDataListScrollBarChanged = 
	function (elementEvent)
	{
		var scrollValue = this._scrollBar.getScrollValue();
		var scrollPageSize = this._scrollBar.getScrollPageSize();
		var scrollViewSize = this._scrollBar.getScrollViewSize();
		
		//Fix for issue where last renderer is larger than first, resulting in exponential adjustments 
		//due to view size shrinking / scroll range increasing at the same time as scroll. We check if the
		//scroll bar hit the end and increment the Lists scroll index rather than taking the scroll bar value.
		if (scrollValue == scrollPageSize - scrollViewSize && scrollValue - this._scrollIndex < 1)
			scrollValue = this._scrollIndex + 1;
	
		this.setScrollIndex(scrollValue);
	};
	
/**
 * @function _onDataListCollectionChanged
 * Event handler for the ListCollection "collectionchanged" event. Updates DataRenderers.
 * 
 * @param collectionChangedEvent CollectionChangedEvent
 * The CollectionChangedEvent to process.
 */		
DataListElement.prototype._onDataListCollectionChanged = 
	function (collectionChangedEvent)
	{
		var type = collectionChangedEvent.getKind();
		var index = collectionChangedEvent.getIndex();
	
		//Always invalidate layout (we need to adjust the scroll bar)
		this._invalidateLayout();
		
		if (this._contentPane._children.length == 0)
			return;
	
		//Reset all renderers (collection was cleared, or swapped)
		if (type == "reset")
		{
			//Fix selected index/item
			if (this._selectedItem != null)
			{
				this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
				
				if (this._selectedIndex == -1)
					this._selectedItem = null;
			}
			
			this.setScrollIndex(this._scrollIndex); //Reset renderer data.
		}
		else
		{
			var firstIndex = 0;
			var lastIndex = 0;
			
			if (this._contentPane._children.length > 0)
			{
				firstIndex = this._contentPane._children[0]._listData._itemIndex;
				lastIndex = this._contentPane._children[this._contentPane._children.length - 1]._listData._itemIndex;
			}
			
			if (this._selectedIndex == index && type == "remove") //We removed the selected item.
			{
				this._selectedIndex = -1;
				this._selectedItem = null;
			}
			
			if (index <= lastIndex && (type == "add" || type == "remove"))
			{
				//Adjust selected index
				if (index <= this._selectedIndex)
				{
					if (type == "add")
						this._selectedIndex++;
					else // if (type == "remove)
						this._selectedIndex--;
				}
				
				if (index < firstIndex)
				{
					var newIndex;
					var indexAdjust;
					
					//Fix scroll/item indexes (we added/removed an item on top thats out of the view)
					//Dont invalidate, only the index has changed, not the data, we dont want renderers shuffling around.
					if (type == "add")
						indexAdjust = 1;
					else // "remove"
						indexAdjust = -1;
					
					this._scrollIndex = this._scrollIndex + indexAdjust;
					
					//Adjust all indexes
					for (var i = 0; i < this._contentPane._children.length; i++)
					{
						newIndex = this._contentPane._children[i]._listData._itemIndex + indexAdjust;
						this._updateRendererData(this._contentPane._children[i], newIndex);
					}
				}
				else //Visible renderers changed
				{
					if (type == "add")
					{
						var newRenderer = this._createRenderer(index);
						
						//Push in a new renderer, layout will deal with purging excess if necessary
						this._contentPane._addChildAt(newRenderer, index - firstIndex);
						index++;
					}
					else // if (type == "remove")
					{
						//Pop the removed renderer, layout will deal with adding more if necessary
						this._contentPane._removeChildAt(index - firstIndex);
					}
					
					//Adjust downstream indexes.
					for (var i = index - firstIndex; i < this._contentPane._children.length; i++)
					{
						this._updateRendererData(this._contentPane._children[i], index);
						index++;
					}
				}
			}
			else if (type == "update" && index >= firstIndex && index <= lastIndex)
				this._updateRendererData(this._contentPane._children[index - firstIndex], index);
		}
	};
	
//@Override	
DataListElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		DataListElement.base.prototype._onCanvasElementAdded.call(this, addedRemovedEvent);
	
		if (this._listCollection != null)
			this._listCollection.addEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
	};

//@Override	
DataListElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		DataListElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		if (this._listCollection != null)
			this._listCollection.removeEventListener("collectionchanged", this._onDataListCollectionChangedInstance);
	};	

/**
 * @function _invalidateListRenderersLayout
 * Calls _invalidateLayout() on all DataRenderers.
 */	
DataListElement.prototype._invalidateListRenderersLayout = 
	function ()
	{
		for (var i = 0; i < this._contentPane._children.length; i++)
			this._contentPane._children[i]._invalidateLayout();
	};
	
/**
 * @function _invalidateListRenderersMeasure
 * Calls _invalidateMeasure() on all DataRenderers.
 */		
DataListElement.prototype._invalidateListRenderersMeasure = 
	function ()
	{
		for (var i = 0; i < this._contentPane._children.length; i++)
			this._contentPane._children[i]._invalidateMeasure();
	};
	
//@Override
DataListElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataListElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ListItemClass" in stylesMap)
		{
			//Check if class changed
			if (this._contentPane._children.length > 0 && 
				this._contentPane._children[0].constructor != this.getStyle("ListItemClass"))
			{
				//Purge all renderers
				while (this._contentPane._children.length > 0)
					this._contentPane._removeChildAt(0);
				
				this._invalidateLayout();
			}
		}
		else if ("ListItemStyle" in stylesMap)
		{
			var listItemStyle = this.getStyle("ListItemStyle");
			
			for (var i = 0; i < this._contentPane._children.length; i++)
				this._contentPane._children[i].setStyleDefinitions(listItemStyle);
			
			this._invalidateLayout();
		}
		
		if ("ListDirection" in stylesMap)
		{
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("ScrollBarPlacement" in stylesMap || "ScrollBarDisplay" in stylesMap ||  "ListAlign" in stylesMap)
			this._invalidateLayout();
		
		if ("ScrollBarStyle" in stylesMap && this._scrollBar != null)
			this._scrollBar.setStyleDefinitions(this.getStyle("ScrollBarStyle"));
		
		if ("ItemLabelFunction" in stylesMap)
			this.setScrollIndex(this._scrollIndex); //Reset renderer data.
	};

//@Override
DataListElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:16, height:16};
	};

/**
 * @function _onDataListRendererClick
 * Event handler for the DataRenderer "click" event. Updates selected index/item and dispatches "listitemclick" and "changed" events.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */		
DataListElement.prototype._onDataListRendererClick = 
	function (elementMouseEvent)
	{
		var itemIndex = elementMouseEvent.getCurrentTarget()._listData._itemIndex;
		var itemData = elementMouseEvent.getCurrentTarget()._itemData;
		
		var dispatchChanged = false;
		
		if (this.getStyle("Selectable") == true && this.setSelectedIndex(itemIndex) == true)
			dispatchChanged = true;
		
		this._dispatchEvent(new ElementListItemClickEvent(itemData, itemIndex));
		
		if (dispatchChanged == true)
			this._dispatchEvent(new ElementEvent("changed", false));
	};
	
/**
 * @function _createRenderer
 * Generates a DataRenderer based on the ListItemClass style.
 * 
 * @param itemIndex int
 * Collection index associated with the DataRenderer.
 * 
 * @returns CanvasElement
 * The new DataRenderer instance.
 */	
DataListElement.prototype._createRenderer = 
	function (itemIndex)
	{
		var newRenderer = new (this.getStyle("ListItemClass"))();
		newRenderer._setStyleDefinitionDefault(this._getDefaultStyle("ListItemStyle"));
		newRenderer._setStyleProxy(new StyleProxy(this, DataListElement._DataRendererProxyMap));
		newRenderer.setStyleDefinitions(this.getStyle("ListItemStyle"));
		
		this._updateRendererData(newRenderer, itemIndex);
		
		newRenderer.addEventListener("click", this._onDataListRendererClickInstance);
		
		return newRenderer;
	};

/**
 * @function _updateRendererData
 * Updates the DataRenderer list data and selected state.
 * 
 * @param renderer CanvasElement
 * DataRenderer to update.
 * 
 * @param itemIndex int
 * Collection index to associate with the DataRenderer.
 */	
DataListElement.prototype._updateRendererData = 
	function (renderer, itemIndex)
	{
		var listData = null;
		
		//Optimize, dont create new data unless its actually changed.
		if (renderer._listData != null && renderer._listData._itemIndex == itemIndex)
			listData = renderer._listData;
		else
			listData = new DataListData(this, itemIndex);
	
		//Always call the function even if data has not changed, this indicates to the
		//renderer to inspect its parent related data and it may make changes even if
		//this data is the same. An example is changes to a DataGrid's columns.
		renderer._setListData(
			listData,
			this._listCollection.getItemAt(itemIndex));
		
		if (this._selectedIndex == itemIndex)
			renderer._setListSelected(true);
		else
			renderer._setListSelected(false);
	};
	
//@Override	
DataListElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataListElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var availableSize = h;
		var listItem = null;
		var i;
		
		var listDirection = this.getStyle("ListDirection");
		var itemIndex = Math.floor(this._scrollIndex);
		
		var collectionLength = 0;
		if (this._listCollection != null)
			collectionLength = this._listCollection.getLength();
		
		if (collectionLength == 0)
		{
			itemIndex = 0;
			this._scrollIndex = itemIndex;
		}
		else if (itemIndex > collectionLength -1)
		{
			itemIndex = collectionLength -1;
			this._scrollIndex = itemIndex;
		}
		
		var clipFirst = 0;
		var clipLast = 0;
		
		this._contentSize = 0;
		var itemSize = 0;
		
		//Measure existing content & clipping amounts.
		for (i = 0; i < this._contentPane._children.length; i++)
		{
			listItem = this._contentPane._children[i];
			
			if (listDirection == "horizontal")
				itemSize = listItem._getStyledOrMeasuredWidth();
			else // if (listDirection == "vertical")
				itemSize = listItem._getStyledOrMeasuredHeight();
				
			this._contentSize += itemSize;
			
			if (listItem._listData._itemIndex <= itemIndex)
			{
				if (listItem._listData._itemIndex < itemIndex)
					clipFirst += itemSize;
				else
					clipFirst += itemSize * (this._scrollIndex - itemIndex);
			}
			
			if (this._contentSize - clipFirst >= availableSize)
			{
				clipLast = (this._contentSize - clipFirst - availableSize);
				
				//Purge Excess renderers.
				while (this._contentPane._children.length - 1 > i)
					this._contentPane._removeChildAt(this._contentPane._children.length - 1);
			}
		}
		
		//Adjust scroll index due to new renderer added on top.
		//Happens when we're max scrolled and DataList size increases.
		if (this._contentPane._children.length > 0 && 
			this._contentPane._children[0]._listData._itemIndex < itemIndex)
		{
			clipFirst += clipLast;
			clipLast = 0; //No clipping last item (scrolled to bottom)
			
			itemIndex = this._contentPane._children[0]._listData._itemIndex;
			
			//Fix scroll index
			if (listDirection == "horizontal")
				this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredWidth());
			else // if (listDirection == "vertical")
				this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredHeight());
			
			//Handle rounding errors
			this._scrollIndex = CanvasElement.roundToPrecision(this._scrollIndex, 3);
		}
		
		//Extra space - need another renderer or scroll shift
		if (this._contentSize - clipFirst - clipLast < availableSize)
		{
			if (itemIndex + this._contentPane._children.length < collectionLength)
			{//Create a new renderer and put it on bottom.
				
				var newRenderer = this._createRenderer(itemIndex + this._contentPane._children.length);
				this._contentPane._addChild(newRenderer);
				
				//Wait for the new renderer to measure.
				//Re-invalidate ourself, (content pane doesnt measure so wont do it for us).
				this._invalidateLayout();
				return;
			}
			else
			{//Add before (or shift up scroll position)
				
				var excessSize = availableSize - (this._contentSize - clipFirst - clipLast);
				
				if (clipFirst >= excessSize) 
				{//We have enough clipping to cover the gap, un-clip and adjust scroll index
					
					clipFirst -= excessSize;
					
					if (listDirection == "horizontal")
						this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredWidth());
					else // if (listDirection == "vertical")
						this._scrollIndex = itemIndex + (clipFirst / this._contentPane._children[0]._getStyledOrMeasuredHeight());
					
					//Handle rounding errors
					this._scrollIndex = CanvasElement.roundToPrecision(this._scrollIndex, 3);
				}
				else if (clipFirst > 0 && collectionLength == this._contentPane._children.length)
				{//We dont have enough clipping, but we're out of data (cannot make new renderer)
					
					clipFirst = 0;
					this._scrollIndex = 0;
				}
				else if (collectionLength > this._contentPane._children.length)
				{//Create a new renderer and put it on top
					
					var newRenderer = this._createRenderer(itemIndex - 1);
					this._contentPane._addChildAt(newRenderer, 0);
					
					//Wait for the new renderer to measure.
					//Re-invalidate ourself, (content pane doesnt measure so wont do it for us).
					this._invalidateLayout();
					return;
				}
			}
		}
		
		var needsScrollBar = false;
		var scrollDisplay = this.getStyle("ScrollBarDisplay");
		
		if (scrollDisplay == "on" || 
			(scrollDisplay == "auto" && availableSize > 0 && (this._contentSize > availableSize || this._contentPane._children.length < collectionLength)))
		{
			needsScrollBar = true;
		}
		
		//Create ScrollBar
		if (needsScrollBar == true && this._scrollBar == null)
		{
			this._scrollBar = new ScrollBarElement();
			this._scrollBar._setStyleDefinitionDefault(this._getDefaultStyle("ScrollBarStyle"));
			this._scrollBar.setStyleDefinitions(this.getStyle("ScrollBarStyle"));
			this._scrollBar.setStyle("ScrollBarDirection", listDirection);
			this._scrollBar.setScrollLineSize(1);
			
			this._scrollBar.addEventListener("changed", this._onDataListScrollBarChangedInstance);
			this._addChild(this._scrollBar);
			
			//Wait for measure.
			return;
		}
		
		//Destroy ScrollBar
		if (needsScrollBar == false && this._scrollBar != null)
		{			
			this._removeChild(this._scrollBar);
			this._scrollBar = null;
			
			//Wait for measure
			return;
		}
		
		//Size / Position the scroll bar and content pane.
		if (this._scrollBar != null)
		{
			var scrollBarPlacement = this.getStyle("ScrollBarPlacement");
			
			if (listDirection == "horizontal")
			{
				this._scrollBar._setActualSize(w, this._scrollBar._getStyledOrMeasuredHeight());
				this._contentPane._setActualSize(w, h - this._scrollBar._height);
				
				if (scrollBarPlacement == "top" || scrollBarPlacement == "left")
				{
					this._contentPane._setActualPosition(x, y + this._scrollBar._height);
					this._scrollBar._setActualPosition(x, y);
				}
				else //if (scrollBarPlacement == "bottom" || scrollBarPlacement == "right")
				{
					this._contentPane._setActualPosition(x, y);
					this._scrollBar._setActualPosition(x, y + this._contentPane._height);
				}
			}
			else // if (listDirection == "vertical")
			{
				this._scrollBar._setActualSize(this._scrollBar._getStyledOrMeasuredWidth(), h);
				this._contentPane._setActualSize(w - this._scrollBar._width, h);
				
				if (scrollBarPlacement == "top" || scrollBarPlacement == "left")
				{
					this._scrollBar._setActualPosition(x, y);
					this._contentPane._setActualPosition(x + this._scrollBar._width, y);
				}
				else //if (scrollBarPlacement == "bottom" || scrollBarPlacement == "right")
				{
					this._scrollBar._setActualPosition(x + this._contentPane._width, y);
					this._contentPane._setActualPosition(x, y);
				}
			}
		}
		else
		{
			this._contentPane._setActualPosition(x, y);
			this._contentPane._setActualSize(w, h);
		}

		//Layout content pane children.
		var currentPosition = clipFirst * -1;
		if (this._contentSize < availableSize)
		{
			var listAlign = this.getStyle("ListAlign");
			
			if (listAlign == "top" || listAlign == "left")
				currentPosition = 0;
			else if (listAlign == "center" || listAlign == "middle")
				currentPosition = (availableSize / 2) - (this._contentSize / 2);
			else //if (listAlign == "bottom" || listAlign == "right")
				currentPosition = availableSize - this._contentSize;
		}
		
		for (i = 0; i < this._contentPane._children.length; i++)
		{
			listItem = this._contentPane._children[i];
			
			if (listDirection == "horizontal")
			{
				listItem._setActualSize(listItem._getStyledOrMeasuredWidth(), this._contentPane._height);
				listItem._setActualPosition(currentPosition, 0);
				
				currentPosition += listItem._width;
			}
			else // if (listDirection == "vertical")
			{
				listItem._setActualSize(this._contentPane._width, listItem._getStyledOrMeasuredHeight());
				listItem._setActualPosition(0, currentPosition);
				
				currentPosition += listItem._height;
			}
		}
		
		//Adjust scroll bar parameters.
		if (this._scrollBar != null)
		{
			var viewSize = this._contentPane._children.length;
			
			if (this._contentPane._children.length)
			{
				if (listDirection == "horizontal")
				{
					viewSize -= clipFirst / this._contentPane._children[0]._width;
					viewSize -= clipLast / this._contentPane._children[this._contentPane._children.length - 1]._width;
				}
				else // if (listDirection == "vertical")
				{
					viewSize -= clipFirst / this._contentPane._children[0]._height;
					viewSize -= clipLast / this._contentPane._children[this._contentPane._children.length - 1]._height;
				}
			}
			
			this._scrollBar.setScrollPageSize(collectionLength);
			this._scrollBar.setScrollViewSize(viewSize);
			
			if (this._scrollBar.getScrollValue() != this._scrollIndex)
			{
				this._scrollBar.endScrollTween();
				this._scrollBar.setScrollValue(this._scrollIndex);
			}
		}
	};
	
	


/**
 * @depends LabelElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////DataGridLabelItemRenderer/////////////////////////	
	
/**
 * @class DataGridLabelItemRenderer
 * @inherits LabelElement
 * 
 * DataGrid ItemRenderer for a basic label. Updates label text via 
 * DataGridColumnDefiniton RowItemLabelFunction.
 * 
 * This class needs more work to add  text color styles for DataRenderer states.
 * 
 * @constructor DataGridLabelItemRenderer 
 * Creates new DataGridLabelItemRenderer instance.
 */
function DataGridLabelItemRenderer()
{
	DataGridLabelItemRenderer.base.prototype.constructor.call(this);
}

//Inherit from LabelElement
DataGridLabelItemRenderer.prototype = Object.create(LabelElement.prototype);
DataGridLabelItemRenderer.prototype.constructor = DataGridLabelItemRenderer;
DataGridLabelItemRenderer.base = LabelElement;


///////////Default Styles//////////////////////

DataGridLabelItemRenderer.StyleDefault = new StyleDefinition();

DataGridLabelItemRenderer.StyleDefault.setStyle("Padding", 				5);			// Override


//////////////Internal//////////////////////////////////////////

//@Override
DataGridLabelItemRenderer.prototype._setListData = 
	function (listData, itemData)
	{
		DataGridLabelItemRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		this._updateLabelText();
	};

/**
 * @function _updateLabelText
 * Updates the label text in response to list data changes using the associated parent grid column's RowItemLabelFunction.
 */	
DataGridLabelItemRenderer.prototype._updateLabelText = 
	function ()
	{
		if (this._itemData == null || this._listData == null)
			this.setStyle("Text", "");
		else
		{
			var parentGrid = this._listData._parentGrid;
			var columnDefinition = parentGrid._gridColumns[this._listData._columnIndex];
			var labelFunction = columnDefinition.getStyle("RowItemLabelFunction");
			
			this.setStyle("Text", labelFunction(this._itemData, this._listData._columnIndex));
		}
	};
	
	


/**
 * @depends DataRendererBaseElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataGridDataRenderer////////////////////////////

/**
 * @class DataGridDataRenderer
 * @inherits DataRendererBaseElement
 * 
 * Default DataGrid ListItemClass used to render DataGrid rows. Renders
 * column items per the parent DataGrid's column definitions. 
 * 
 * @constructor DataGridDataRenderer 
 * Creates new DataGridDataRenderer instance.
 */

//Used to render the DataGrid rows. 
function DataGridDataRenderer()
{
	DataGridDataRenderer.base.prototype.constructor.call(this);
	
	//Use a containing element for the renderers so we dont interfere with our skins.
	this._itemRenderersContainer = new CanvasElement();
	this._addChild(this._itemRenderersContainer);
}
	
//Inherit from DataRendererBaseElement
DataGridDataRenderer.prototype = Object.create(DataRendererBaseElement.prototype);
DataGridDataRenderer.prototype.constructor = DataGridDataRenderer;
DataGridDataRenderer.base = DataRendererBaseElement;

//////////Default Styles/////////////////////////

DataGridDataRenderer.StyleDefault = new StyleDefinition();

//Skin Defaults///////
DataGridDataRenderer.UpSkinStyleDefault = new StyleDefinition();
DataGridDataRenderer.UpSkinStyleDefault.setStyle("BackgroundColor", 			"#FFFFFF");
DataGridDataRenderer.UpSkinStyleDefault.setStyle("AutoGradientType", 			"none");

DataGridDataRenderer.AltSkinStyleDefault = new StyleDefinition();
DataGridDataRenderer.AltSkinStyleDefault.setStyle("BackgroundColor", 			"#F0F0F0");
DataGridDataRenderer.AltSkinStyleDefault.setStyle("AutoGradientType", 			"none");
/////////////////////

DataGridDataRenderer.StyleDefault.setStyle("UpSkinStyle", 						DataGridDataRenderer.UpSkinStyleDefault);	// StyleDefinition
DataGridDataRenderer.StyleDefault.setStyle("AltSkinStyle", 						DataGridDataRenderer.AltSkinStyleDefault);	// StyleDefinition


//@Override
DataGridDataRenderer.prototype._setListData = 
	function (listData, itemData)
	{
		DataGridDataRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		var renderer = null;
		for (var i = 0; i < listData._parentList._gridColumns.length; i++)
		{
			renderer = this._itemRenderersContainer._getChildAt(i);
			
			if (renderer == null)
			{
				renderer = listData._parentList._createRowItemRenderer(listData._itemIndex, i);
				this._itemRenderersContainer._addChildAt(renderer, i);
			}
			else
			{
				columnDef = listData._parentList._gridColumns[i];
				
				if (renderer.constructor != columnDef.getStyle("RowItemClass"))
				{ //Renderer Class changed
					
					this._itemRenderersContainer._removeChildAt(i);
					renderer = listData._parentList._createRowItemRenderer(listData._itemIndex, i);
					this._itemRenderersContainer._addChildAt(renderer, i);
				}
				else
				{ //Update DataGridData
					
					listData._parentList._updateRowItemRendererData(renderer, listData._itemIndex, i);
				}
			}
		}
		
		//Purge excess renderers.
		while (this._itemRenderersContainer._children.length > this._listData._parentList._gridColumns.length)
			this._itemRenderersContainer._removeChildAt(this._itemRenderersContainer._children.length - 1);
		
		//Invalidate, the item renderer container doesnt measure so wont do it for us.
		this._invalidateMeasure();
		this._invalidateLayout();
	};
	
//@Override
DataGridDataRenderer.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width: 0, height: 0};
		var childSize = 0;
		
		for (var i = 0; i < this._itemRenderersContainer._children.length; i++)
		{
			childSize = this._itemRenderersContainer._children[i]._getStyledOrMeasuredHeight();
			
			if (measuredSize.height < childSize)
				measuredSize.height = childSize;
			
			measuredSize.width += this._itemRenderersContainer._children[i]._getStyledOrMeasuredWidth();
		}
	
		measuredSize.width += padWidth;
		measuredSize.height += padHeight;
		
		return measuredSize;
	};
	
//@Override	
DataGridDataRenderer.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataGridDataRenderer.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._listData == null)
			return;
		
		this._itemRenderersContainer._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
		this._itemRenderersContainer._setActualSize(paddingMetrics.getWidth(), paddingMetrics.getHeight());
		
		var parentGrid = this._listData._parentList;
		var rowItemRenderer = null;
		var currentPosition = 0;
		var columnSize = 0;
		
		var paddingSize = this._getPaddingSize();
		
		for (var i = 0; i < parentGrid._columnSizes.length; i++)
		{
			rowItemRenderer = this._itemRenderersContainer._children[i];
			columnSize = parentGrid._columnSizes[i];
			
			if (i == 0)
				columnSize -= paddingSize.paddingLeft;
			else if (i == parentGrid._columnSizes.length - 1) //Consume the rest available.
				columnSize = this._itemRenderersContainer._width - currentPosition;
			
			rowItemRenderer._setActualPosition(currentPosition, 0);
			rowItemRenderer._setActualSize(columnSize, this._itemRenderersContainer._height);
			
			currentPosition += columnSize;
		}
	};	
	
	


/**
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////ContainerBaseElement////////////////////////////////

/**
 * @class ContainerBaseElement
 * @inherits CanvasElement
 * 
 * Abstract base class for Container elements. Wraps internal child modification functions
 * such as _addChild() and _removeChild() with public functions such as addElement() and removeElement() 
 * for proper index management when using skins and overlays in conjunction with content children. 
 * 
 * Container children are not all considered equal. Content children added via the addElement() and removeElement()
 * functions maintain their own indexes and are placed in between raw children, such as skins, which render
 * underneath and overlay children which render above (elements intended to always be on top of content children).
 * 
 * Raw children added via _addChild() or _addChildAt() will be indexed before content children.
 * Content children added via addElement() or addElementAt() will be indexed after raw children and before overlay children.
 * Overlay children added via _addOverlayChild() will be index last, after content children.
 * All 3 lists maintain their own indexes.
 * 
 * @constructor ContainerBaseElement 
 * Creates new ContainerBaseElement instance.
 */

function ContainerBaseElement()
{
	ContainerBaseElement.base.prototype.constructor.call(this);
	
	//Storage for user added elements.
	this._elements = [];
	
	//Children that come after user added elements
	this._overlayChildren = [];
}	
	
//Inherit from CanvasElement
ContainerBaseElement.prototype = Object.create(CanvasElement.prototype);
ContainerBaseElement.prototype.constructor = ContainerBaseElement;
ContainerBaseElement.base = CanvasElement;
	

/////////////Default Styles///////////////////////////////

ContainerBaseElement.StyleDefault = new StyleDefinition();
ContainerBaseElement.StyleDefault.setStyle("ClipContent",						true);


////////////ContainerBaseElement Public Functions//////////////////////////

//Expose child modification functions.

/**
 * @function addElement
 * Adds a content child element to the end of this element's content child list.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a content child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added.
 */	
ContainerBaseElement.prototype.addElement = 
	function (element)
	{
		return this.addElementAt(element, this._elements.length);
	};

/**
 * @function addElementAt
 * Inserts a content child element to this element's content child list at the specified index.
 * 
 * @param element CanvasElement
 * CanvasElement to be added as a content child of this element.
 * 
 * @param index int
 * Child index to insert the element.
 * 
 * @returns CanvasElement
 * Returns the element just added when successful, null if the element could not
 * be added due to the index being out of range.
 */		
ContainerBaseElement.prototype.addElementAt = 
	function (element, index)
	{
		if (!(element instanceof CanvasElement))
			return null;
	
		if (index < 0 || index > this._elements.length)
			return null;
		
		var childIndex = this._children.length - this._overlayChildren.length - this._elements.length + index;
		
		this._elements.splice(index, 0, element);
		ContainerBaseElement.base.prototype._addChildAt.call(this, element, childIndex);
		
		return element;
	};
	
/**
 * @function removeElement
 * Removes a content child element from this element's content children list.
 * 
 * @param element CanvasElement
 * Content child to be removed.
 * 
 * @returns CanvasElement
 * Returns the CanvasElement just removed if successful, null if the
 * element could not be removed due to it not being a content child of this element.
 */		
ContainerBaseElement.prototype.removeElement = 
	function (element)
	{
		var index = this._elements.indexOf(element);
		return this.removeElementAt(index);
	};
	
/**
 * @function removeElementAt
 * Removes a content child element at specified index.
 * 
 * @param index int
 * Content index to be removed.
 * 
 * @returns CanvasElement
 * Returns the CanvasElement just removed if successful, null if the element could
 * not be removed due it it not being a child of this element, or index out of range.
 */			
ContainerBaseElement.prototype.removeElementAt = 
	function (index)
	{
		if (index < 0 || index >= this._elements.length)
			return null;
	
		var childIndex = this._children.length - this._overlayChildren.length - this._elements.length + index;

		this._elements.splice(index, 1);
		return ContainerBaseElement.base.prototype._removeChildAt.call(this, childIndex);
	};

/**
 * @function getElementAt
 * Gets the content child element at the supplied index.
 * 
 * @param index int
 * Content index of child element to return;
 * 
 * @returns CanvasElement
 * The CanvasElement at the supplied index, or null if index is out of range. 
 */		
ContainerBaseElement.prototype.getElementAt = 
	function (index)
	{
		if (index < 0 || index >= this._elements.length)
			return null;
		
		return this._elements[index];
	};
	
/**
 * @function getElementIndex
 * Returns the index of the supplied content child element.
 * 
 * @param element CanvasElement
 * Content child element to return the index.
 * 
 * @returns int
 * Returns the child index or -1 if the element is not
 * a content child of this element.
 */		
ContainerBaseElement.prototype.getElementIndex = 
	function (element)
	{
		return this._elements.indexOf(element);
	};

/**
 * @function setElementIndex
 * Changes a content child element's index. 
 * 
 * @param element CanvasElement
 * Content child element to change index.
 * 
 * @param index int
 * New content index of the content child element.
 * 
 * @returns boolean
 * Returns true if the child's index is successfully changed, false if the element
 * is not a content child of this element or the index is out of range.
 */		
ContainerBaseElement.prototype.setElementIndex = 
	function (element, index)
	{
		if (index < 0 || index >= this._elements.length)
			return false;
		
		var currentIndex = this._elements.indexOf(element);
		if (currentIndex == -1 || currentIndex == index)
			return false;
		
		var childIndex = this._children.length - this._overlayChildren.length - this._elements.length + index;
		
		this._elements.splice(index, 0, this._elements.splice(currentIndex, 1)[0]);
		ContainerBaseElement.base.prototype._setChildIndex.call(this, element, childIndex);
		
		return true;
	};
	
/**
 * @function getNumElements
 * Gets this elements number of content children.
 * 
 * @returns int
 * The number of content child elements.
 */		
ContainerBaseElement.prototype.getNumElements = 
	function ()
	{
		return this._elements.length;
	};

/**
 * @function _addOverlayChild
 * Adds an overlay child element to the end of this element's overlay child list.
 * 
 * @param element CanvasElement
 * Element to be added as an overlay child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added.
 */		
ContainerBaseElement.prototype._addOverlayChild = 
	function (element)
	{
		return this._addOverlayChildAt(element, this._overlayChildren.length);
	};
	
/**
 * @function _addOverlayChildAt
 * Inserts an overlay child element to this elements overlay child list at the specified index.
 * 
 * @param element CanvasElement
 * Element to be added as an overlay child of this element.
 * 
 * @returns CanvasElement
 * Returns the element just added when successful, null if the element could not
 * be added due to the index being out of range.
 */			
ContainerBaseElement.prototype._addOverlayChildAt = 
	function (element, index)
	{
		if (!(element instanceof CanvasElement))
			return null;
	
		if (index < 0 || index > this._overlayChildren.length)
			return null;
		
		var childIndex = this._children.length - this._overlayChildren.length + index;
		
		this._overlayChildren.splice(index, 0, element);
		ContainerBaseElement.base.prototype._addChildAt.call(this, element, childIndex);
		
		return element;
	};	

/**
 * @function _removeOverlayChild
 * Removes an overlay child element from this elements overlay child list.
 * 
 * @param element CanvasElement
 * Overlay child to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successful, null if the
 * element could not be removed due to it not being an overlay child of this element.
 */		
ContainerBaseElement.prototype._removeOverlayChild = 
	function (element)
	{
		var index = this._overlayChildren.indexOf(element);
		return this._removeOverlayChildAt(index);
	};

/**
 * @function _removeOverlayChildAt
 * Removes an overlay child element at specified index.
 * 
 * @param index int
 * Overlay index to be removed.
 * 
 * @returns CanvasElement
 * Returns the element just removed if successful, null if the element could
 * not be removed due it it not being an overlay child of this element, or index out of range.
 */			
ContainerBaseElement.prototype._removeOverlayChildAt = 
	function (index)
	{
		if (index < 0 || index >= this._overlayChildren.length)
			return null;
		
		var childIndex = this._children.length - this._overlayChildren.length + index;

		this._overlayChildren.splice(index, 1);
		return ContainerBaseElement.base.prototype._removeChildAt.call(this, childIndex);
	};	

/**
 * @function _getOverlayChildAt
 * Gets the overlay child element at the supplied index.
 * 
 * @param index int
 * Overlay index of child element to return;
 * 
 * @returns CanvasElement
 * The element at the supplied overlay index, or null if index is out of range. 
 */		
ContainerBaseElement.prototype._getOverlayChildAt = 
	function (index)
	{
		if (index < 0 || index >= this._overlayChildren.length)
			return null;
		
		return this._overlayChildren[index];
	};	
	
/**
 * @function _getOverlayChildIndex
 * Returns the overlay index of the supplied child element.
 * 
 * @param element CanvasElement
 * Child element to return the overlay index.
 * 
 * @returns int
 * Returns the child's overlay index or -1 if the element is not
 * an overlay child of this element.
 */		
ContainerBaseElement.prototype._getOverlayChildIndex = 
	function (element)
	{
		return this._overlayChildren.indexOf(element);
	};	
	
/**
 * @function _setOverlayChildIndex
 * Changes an overlay child element's overlay index. 
 * 
 * @param element CanvasElement
 * Overlay child element to change index.
 * 
 * @param index int
 * New overlay index of the child element.
 * 
 * @returns boolean
 * Returns true if the child's index is successfully changed, false if the element
 * is not an overlay child of this element or the index is out of range.
 */		
ContainerBaseElement.prototype._setOverlayChildIndex = 
	function (element, index)
	{
		if (index < 0 || index >= this._overlayChildren.length)
			return false;
		
		var currentIndex = this._overlayChildren.indexOf(element);
		if (currentIndex < 0 || currentIndex == index)
			return false;
		
		var childIndex = this._children.length - this._overlayChildren.length + index;
		
		this._overlayChildren.splice(index, 0, this._overlayChildren.splice(currentIndex, 1)[0]);
		ContainerBaseElement.base.prototype._setChildIndex.call(this, element, childIndex);
		
		return true;
	}; 	
	
/**
 * @function _getNumOverlayChildren
 * Gets this elements number of overlay children.
 * 
 * @returns int
 * The number of overlay child elements.
 */		
ContainerBaseElement.prototype._getNumOverlayChildren = 
	function ()
	{
		return this._overlayChildren.length;
	};
	
//Override - Add the child before elements & overlay
ContainerBaseElement.prototype._addChild = 
	function (element)
	{
		var index = this._children.length - this._elements.length - this._overlayChildren.length;
		return ContainerBaseElement.base.prototype._addChildAt.call(this, element, index);
	};
	
//Override - Dont allow insertion into elements or overlay range
ContainerBaseElement.prototype._addChildAt = 
	function (element, index)
	{
		var maxIndex = this._children.length - this._elements.length - this._overlayChildren.length;
		
		if (index < 0 || index > maxIndex)
			return null;
		
		return ContainerBaseElement.base.prototype._addChildAt.call(this, element, index);
	};

//Override - Remove from element or overlay if necessary
ContainerBaseElement.prototype._removeChildAt = 
	function (index)
	{
		if (index < 0 || index >= this._children.length)
			return null;
		
		var element = this._children.splice(index, 1)[0]; //Returns array of removed items.
		
		var subIndex = this._elements.indexOf(element);
		if (subIndex >= 0)
			return this.removeElementAt(subIndex);
		
		subIndex = this._overlayChildren.indexOf(element);
		if (subIndex >= 0)
			return this._removeOverlayChildAt(subIndex);
		
		return ContainerBaseElement.base.prototype._removeChildAt.call(this, index);
	};

//@Override	- Dont allow swapping in or out of element & overlay ranges.
ContainerBaseElement.prototype._setChildIndex = 
	function (element, index)
	{
		var maxIndex = this._children.length - this._elements.length - this._overlayChildren.length;
	
		if (index < 0 || index >= maxIndex)
			return false;
		
		var currentIndex = this._getChildIndex(element);
		if (currentIndex < 0 || currentIndex >= maxIndex || currentIndex == index)
			return false;
		
		return ContainerBaseElement.base.prototype._setChildIndex.call(this, element, index);
	};
	
	


/**
 * @depends ContainerBaseElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////ListContainerElement////////////////////////////////

/**
 * @class ListContainerElement
 * @inherits ContainerBaseElement
 * 
 * The ListContainer can be used to lay out children in a vertical or horizontal fashion.
 * This container uses children's styles Width, Height, PercentWidth, and PercentHeight.
 * Nesting containers is the best way to quickly and simply build complex layouts.
 * 
 * Width, and Height are treated as highest priority and will override PercentWidth and PercentHeight styles.
 * Exact behavior of conflicting styles is not defined and subject to change. 
 * 
 * See the associated style documentation for additional details.
 * 
 * @constructor ListContainerElement 
 * Creates new ListContainerElement instance.
 */
function ListContainerElement()
{
	ListContainerElement.base.prototype.constructor.call(this);
}

//Inherit from ContainerBaseElement
ListContainerElement.prototype = Object.create(ContainerBaseElement.prototype);
ListContainerElement.prototype.constructor = ListContainerElement;
ListContainerElement.base = ContainerBaseElement;	
	
/////////////Style Types///////////////////////////////

ListContainerElement._StyleTypes = Object.create(null);

/**
 * @style LayoutDirection String
 * 
 * Determines the layout direction of this ListContainer. Allowable values are "horizontal" or "vertical".
 */
ListContainerElement._StyleTypes.LayoutDirection = 			{inheritable:false};		// "horizontal" || "vertical"

/**
 * @style LayoutGap Number
 * 
 * Space in pixels to leave between child elements.
 */
ListContainerElement._StyleTypes.LayoutGap = 				{inheritable:false};		// number

/**
 * @style LayoutVerticalAlign String
 * 
 * Child vertical alignment to be used when children do not fill all available space. Allowable values are "top", "bottom", or "middle". 
 */
ListContainerElement._StyleTypes.LayoutVerticalAlign = 		{inheritable:false};		// "top" || "bottom" || "middle" 

/**
 * @style LayoutHorizontalAlign String
 * 
 * Child horizontal alignment to be used when children do not fill all available space. Allowable values are "left", "right", or "center". 
 */
ListContainerElement._StyleTypes.LayoutHorizontalAlign = 	{inheritable:false};		//"left" || "right" || "center"


////////////Default Styles////////////////////////////

ListContainerElement.StyleDefault = new StyleDefinition();

//ListContainerElement specific styles
ListContainerElement.StyleDefault.setStyle("LayoutDirection", 			"vertical");
ListContainerElement.StyleDefault.setStyle("LayoutGap", 				0);
ListContainerElement.StyleDefault.setStyle("LayoutVerticalAlign", 		"top");
ListContainerElement.StyleDefault.setStyle("LayoutHorizontalAlign", 	"left");


//////////////ListContainerElement Protected Functions//////////////

//@Override
ListContainerElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ListContainerElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("LayoutDirection" in stylesMap ||
			"LayoutGap" in stylesMap)
		{
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		else if ("LayoutAlign" in stylesMap)
			this._invalidateLayout();
	};

//@Override
ListContainerElement.prototype._doMeasure = 
	function (padWidth, padHeight)
	{
		var contentSize = {width:0, height:0};
		
		var layoutGap = this.getStyle("LayoutGap");
		var layoutDirection = this.getStyle("LayoutDirection");
		
		var child = null;
		var width = null;
		var height = null;
		var pWidth = null;
		var pHeight = null;
		var maxWidth = null;
		var maxHeight = null;
		var minWidth = null;
		var minHeight = null;
		var rotateDegrees = null;

		var tempWidth;
		var tempHeight;
		var tempRotateDegrees;		
		
		var insertGap = false;
		
		for (var i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			width = child.getStyle("Width");
			height = child.getStyle("Height");
			maxWidth = child.getStyle("MaxWidth");
			maxHeight = child.getStyle("MaxHeight");
			minWidth = child.getStyle("MinWidth");
			minHeight = child.getStyle("MinHeight");			
			rotateDegrees = child.getStyle("RotateDegrees");
			
			if (minWidth == null)
				minWidth = 0;
			if (minHeight == null)
				minHeight = 0;
			if (maxWidth == null)
				maxWidth = Number.MAX_VALUE;
			if (maxHeight == null)
				maxHeight = Number.MAX_VALUE;			
			
			if (rotateDegrees != 0)
			{
				if (width == null)
				{
					width = child._measuredWidth;
					width = Math.min(width, maxWidth);
					width = Math.max(width, minWidth);
				}
				
				if (height == null)
				{
					height = child._measuredHeight;
					height = Math.min(height, maxHeight);
					height = Math.max(height, minHeight);
				}
				
				//Record child's current w/h & rotation
				tempWidth = child._width;
				tempHeight = child._height;
				tempRotateDegrees = child._rotateDegrees;
				
				//TODO: Update getMetrics() so we can pass child values.
				//Spoof the rotation position/size so we can get parent metrics.
				child._width = width;
				child._height = height;
				child._rotateDegrees = rotateDegrees;
				
				//Get parent metrics for spoof position
				rotatedMetrics = child.getMetrics(this);
				
				//Put back current values
				child._width = tempWidth;
				child._height = tempHeight;
				child._rotateDegrees = tempRotateDegrees;
				
				width = Math.ceil(rotatedMetrics.getWidth());
				height = Math.ceil(rotatedMetrics.getHeight());
			}
			else //Non-Rotated Element
			{
				pWidth = child.getStyle("PercentWidth");
				pHeight = child.getStyle("PercentHeight");
								
				//No explicit sizing
				if (width == null)
				{
					//Add size for measured or min
					if (pWidth == null)
					{
						width = child._measuredWidth;
						width = Math.min(width, maxWidth);
						width = Math.max(width, minWidth);
					}
					else
						width = minWidth;
				}
				
				if (height == null)
				{
					if (pHeight == null)
					{
						height = child._measuredHeight;
						height = Math.min(height, maxHeight);
						height = Math.max(height, minHeight);
					}
					else
						height = minHeight;
				}
			}
		
			if (layoutDirection == "horizontal")
			{
				//Increment width
				contentSize.width += width;
				
				//Use maximum child height
				if (height > contentSize.height)
					contentSize.height = height;
			}
			else //if (layoutDirection == "vertical")
			{
				//Increment height
				contentSize.height += height;
				
				//Use maximum child height
				if (width > contentSize.width)
					contentSize.width = width;
			}
			
			if (insertGap == true)
			{
				if (layoutDirection == "horizontal")
					contentSize.width += layoutGap;
				else //if (layoutDirection == "vertical")
					contentSize.height += layoutGap;
			}
			else
				insertGap = true;
		}
		
		contentSize.width += padWidth;
		contentSize.height += padHeight;
		
		return contentSize;		
	};

//@Override
ListContainerElement.prototype._doLayout =
	function(paddingMetrics)
	{
		ListContainerElement.base.prototype._doLayout.call(this, paddingMetrics);
	
		var layoutGap = this.getStyle("LayoutGap");
		var layoutDirection = this.getStyle("LayoutDirection");
		var layoutVerticalAlign = this.getStyle("LayoutVerticalAlign");
		var layoutHorizontalAlign = this.getStyle("LayoutHorizontalAlign");
	
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var i;
		
		var child = null;
		var childSizeData = [];
		
		var totalPercentUsed = 0;
		var numRenderables = 0;
		
		//Record element sizing data.
		for (i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			numRenderables++;
			
			var sizeData = {
				element:child,
				width:null, 
				height:null, 
				pWidth:null, 
				pHeight:null, 
				maxWidth:null, 
				maxHeight:null, 
				minWidth:null, 
				minHeight:null,
				rotateDegrees:null};
			
			sizeData.rotateDegrees = child.getStyle("RotateDegrees");
			
			sizeData.width = child.getStyle("Width");
			if (sizeData.width == null)
			{
				//Percent sizing not supported on transformed elements.
				if (sizeData.rotateDegrees == 0)
					sizeData.pWidth = child.getStyle("PercentWidth");
				
				sizeData.minWidth = child.getStyle("MinWidth");
				sizeData.maxWidth = child.getStyle("MaxWidth");
				
				if (sizeData.pWidth != null && layoutDirection == "horizontal")
					totalPercentUsed += sizeData.pWidth;
			}
			
			sizeData.height = child.getStyle("Height");
			if (sizeData.height == null)
			{
				//Percent sizing not supported on transformed elements.
				if (sizeData.rotateDegrees == 0)
					sizeData.pHeight = child.getStyle("PercentHeight");
				
				sizeData.minHeight = child.getStyle("MinHeight");
				sizeData.maxHeight = child.getStyle("MaxHeight");
				
				if (sizeData.pHeight != null && layoutDirection == "vertical")
					totalPercentUsed += sizeData.pHeight;
			}
			
			if (sizeData.minWidth == null)
				sizeData.minWidth = 0;
			if (sizeData.minHeight == null)
				sizeData.minHeight = 0;
			if (sizeData.maxWidth == null)
				sizeData.maxWidth = Number.MAX_VALUE;
			if (sizeData.maxHeight == null)
				sizeData.maxHeight = Number.MAX_VALUE;
			
			childSizeData.push(sizeData);
		}
		
		var totalGap = 0;
		if (numRenderables > 1)
			totalGap = (numRenderables - 1) * layoutGap;
		
		//Available space for children in layout axis.
		var availableSize = 0;
		if (layoutDirection == "horizontal")
			availableSize = w - totalGap;
		else
			availableSize = h - totalGap;
		
		////////////Calculate element sizes//////////////////
		
		var rotatedMetrics = null;
		var percentSizedElements = [];
		
		//Size all explicitly sized elements, record percent sized, and adjust available size for percent elements.
		for (i = 0; i < childSizeData.length; i++)
		{
			child = childSizeData[i];
			
			//Percent sized elements cannot be rotated
			child.element._setActualRotation(child.rotateDegrees, 0, 0);
			
			if (layoutDirection == "horizontal" && childSizeData[i].width == null && childSizeData[i].pWidth != null)
			{
				child.percentSize = child.pWidth;
				child.minSize = child.minWidth;
				child.maxSize = child.maxWidth;
				percentSizedElements.push(child);
				
				if (child.height == null)
				{
					if (child.pHeight != null)
						child.height = Math.round(h * (child.pHeight / 100));
					else
						child.height = child.element._measuredHeight;
					
					child.height = Math.min(child.maxHeight, child.height);
					child.height = Math.max(child.minHeight, child.height);
				}
			}
			else if (layoutDirection == "vertical" && childSizeData[i].height == null && childSizeData[i].pHeight != null)
			{
				child.percentSize = child.pHeight;
				child.minSize = child.minHeight;
				child.maxSize = child.maxHeight;
				percentSizedElements.push(child);
				
				if (child.width == null)
				{
					if (child.pWidth != null)
						child.width = Math.round(w * (child.pWidth / 100));
					else
						child.width = child.element._measuredWidth;
					
					child.width = Math.min(child.maxWidth, child.width);
					child.width = Math.max(child.minWidth, child.width);
				}
			}
			else
			{
				if (child.width == null)
				{
					if (child.pWidth != null)
						child.width = Math.round(w * (child.pWidth / 100));
					else
						child.width = child.element._measuredWidth;
					
					child.width = Math.min(child.maxWidth, child.width);
					child.width = Math.max(child.minWidth, child.width);
				}
				
				if (child.height == null)
				{
					if (child.pHeight != null)
						child.height = Math.round(h * (child.pHeight / 100));
					else
						child.height = child.element._measuredHeight;
					
					child.height = Math.min(child.maxHeight, child.height);
					child.height = Math.max(child.minHeight, child.height);
				}
				
				child.element._setActualSize(child.width, child.height);
				
				//Update the sizing to reflect size after rotation transform (for layout).
				if (child.rotateDegrees != 0)
				{
					rotatedMetrics = child.element.getMetrics(this);
					
					child.width = Math.ceil(rotatedMetrics.getWidth());
					child.height = Math.ceil(rotatedMetrics.getHeight());
				}
				
				if (layoutDirection == "horizontal")
					availableSize -= child.width;
				else // "vertical"
					availableSize -= child.height;
			}
		
		}
		
		//We're not using all the space, shrink us.
		if (totalPercentUsed < 100)
			availableSize = Math.round(availableSize * (totalPercentUsed / 100));
		
		//Calculate percent sized elements actual size.
		CanvasElement._calculateMinMaxPercentSizes(percentSizedElements, availableSize);
			
		//Size the percent sized elements.
		for (i = 0; i < percentSizedElements.length; i++)
		{
			child = percentSizedElements[i];
			
			if (layoutDirection == "horizontal")
				child.width = child.actualSize;
			else // "vertical"
				child.height = child.actualSize;
			
			child.element._setActualSize(child.width, child.height);
		}
			
		//Get total content size (gap + elements).
		var totalContentSize = totalGap;
		for (i = 0; i < childSizeData.length; i++)
		{
			if (layoutDirection == "horizontal")
				totalContentSize += childSizeData[i].width;
			else // "vertical"
				totalContentSize += childSizeData[i].height;
		}
		
		var actualX = x;
		var actualY = y;
		
		//Adjust starting position.
		if (layoutDirection == "horizontal" && totalContentSize != w)
		{
			if (layoutHorizontalAlign == "center")
				actualX += Math.round((w / 2) - (totalContentSize / 2));
			else if (layoutHorizontalAlign == "right")
				actualX += (w - totalContentSize);
		}
		else if (layoutDirection == "vertical" && totalContentSize != h)
		{
			if (layoutVerticalAlign == "middle")
				actualY += Math.round((h / 2) - (totalContentSize / 2));
			else if (layoutVerticalAlign == "bottom")
				actualY += (h - totalContentSize);
		}

		//Place elements.
		var insertGap = false;
		for (i = 0; i < childSizeData.length; i++)
		{
			child = childSizeData[i];
			
			if (layoutDirection == "horizontal")
			{
				if (insertGap == true)
					actualX += layoutGap;
				else
					insertGap = true;
				
				if (layoutVerticalAlign == "top")
					actualY = y;
				else if (layoutVerticalAlign == "bottom")
					actualY = y + h - child.height;
				else //middle
					actualY = Math.round(y + (h / 2) - (child.height / 2));
				
				if (child.rotateDegees == 0)
					child.element._setActualPosition(actualX, actualY);
				else
					child.element._setRelativePosition(actualX, actualY, this);
				
				actualX += child.width;
			}
			else // "vertical"
			{
				if (insertGap == true)
					actualY += layoutGap;
				else
					insertGap = true;
				
				if (layoutHorizontalAlign == "left")
					actualX = x;
				else if (layoutHorizontalAlign == "right")
					actualX = x + w - child.width;
				else //center
					actualX = Math.round(x + (w / 2) - (child.width / 2));
				
				if (child.rotateDegrees == 0)
					child.element._setActualPosition(actualX, actualY);
				else
					child.element._setRelativePosition(actualX, actualY, this);				
				
				actualY += child.height;
			}
		}
	};
	
	


/**
 * @depends SkinnableElement.js
 */

/////////////////////////////////////////////////
//////////////////ButtonElement//////////////////

/**
 * @class ButtonElement
 * @inherits SkinnableElement
 * 
 * Button is a skin-able element that supports 4 states corresponding to mouse states
 * "up", "over", "down" and "disabled". It also has an optional label. 
 * 
 * Being a SkinnableElement, Button proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the Button itself. 
 * 
 * Button is used as a base class for many click-able elements such as
 * ToggleButton, Checkbox, RadioButton, etc. 
 * 
 * 
 * @constructor ButtonElement 
 * Creates new ButtonElement instance.
 */
function ButtonElement()
{
	ButtonElement.base.prototype.constructor.call(this);

	var _self = this;
	
	this._labelElement = null;
	
	//Private handler, need different instance for each button, proxy to prototype.	
	this._onButtonEventInstance = 
		function (elementEvent)
		{
			if (elementEvent.getType() == "mousedown")
				_self._onButtonMouseDown(elementEvent);
			else if (elementEvent.getType() == "mouseup")
				_self._onButtonMouseUp(elementEvent);
			else if (elementEvent.getType() == "click")
				_self._onButtonClick(elementEvent);
			else if (elementEvent.getType() == "rollover")
				_self._onButtonRollover(elementEvent);
			else if (elementEvent.getType() == "rollout")
				_self._onButtonRollout(elementEvent);
		};
		
	this.addEventListener("mousedown", this._onButtonEventInstance);
	this.addEventListener("mouseup", this._onButtonEventInstance);
	this.addEventListener("rollover", this._onButtonEventInstance);
	this.addEventListener("rollout", this._onButtonEventInstance);
	this.addEventListener("click", this._onButtonEventInstance);
}

//Inherit from SkinnableElement
ButtonElement.prototype = Object.create(SkinnableElement.prototype);
ButtonElement.prototype.constructor = ButtonElement;
ButtonElement.base = SkinnableElement;


/////////////Style Types///////////////////////////////

ButtonElement._StyleTypes = Object.create(null);

//New button specific styles.

/**
 * @style Text String
 * 
 * Text string to be displayed as the button label.
 */
ButtonElement._StyleTypes.Text = 						{inheritable:false};		// "any string" || null

/**
 * @style SkinClass CanvasElement
 * 
 * The CanvasElement constructor type to apply to all skin states. 
 * Specific states such as UpSkinClass will override SkinClass when they are equal priority.
 */
ButtonElement._StyleTypes.SkinClass =					{inheritable:false};	//Element constructor()

/**
 * @style UpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "up" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.UpSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style UpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "up" state skin element.
 */
ButtonElement._StyleTypes.UpSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style UpTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "up" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.UpTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style OverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "over" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.OverSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style OverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "over" state skin element.
 */
ButtonElement._StyleTypes.OverSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style OverTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "over" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.OverTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style DownSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "down" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.DownSkinClass = 				{inheritable:false};		//Element constructor()

/**
 * @style DownSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "down" state skin element.
 */
ButtonElement._StyleTypes.DownSkinStyle = 				{inheritable:false};		//StyleDefinition

/**
 * @style DownTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "down" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.DownTextColor = 				{inheritable:false};		//"#000000"

/**
 * @style DisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "disabled" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ButtonElement._StyleTypes.DisabledSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style DisabledSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "disabled" state skin element.
 */
ButtonElement._StyleTypes.DisabledSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style DisabledTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "disabled" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ButtonElement._StyleTypes.DisabledTextColor = 			{inheritable:false};		//"#000000"


//Change some of the text styles not to inherit, we'll set these to the label 
//so the label will use button defaults if no style explicitly set.

/**
 * @style TextAlign String
 * 
 * Determines alignment when rendering text. Available values are "left", "center", and "right".
 */
ButtonElement._StyleTypes.TextAlign =					{inheritable:false};		// "left" || "center" || "right"

/**
 * @style TextBaseline String
 * 
 * Determines the baseline when rendering text. Available values are "top", "middle", or "bottom".
 */
ButtonElement._StyleTypes.TextBaseline =				{inheritable:false};  		// "top" || "middle" || "bottom"


/////////Default Styles//////////////////////////////

ButtonElement.StyleDefault = new StyleDefinition();

//Override base class styles
ButtonElement.StyleDefault.setStyle("PaddingTop",						2);
ButtonElement.StyleDefault.setStyle("PaddingBottom",                    2);
ButtonElement.StyleDefault.setStyle("PaddingLeft",                      3);
ButtonElement.StyleDefault.setStyle("PaddingRight",                     3);

ButtonElement.StyleDefault.setStyle("TextAlign", 						"center"); 
ButtonElement.StyleDefault.setStyle("TextBaseline",                     "middle");

ButtonElement.StyleDefault.setStyle("TabStop", 							0);			// number

//ButtonElement specific styles.
ButtonElement.StyleDefault.setStyle("Text", 							null);
ButtonElement.StyleDefault.setStyle("SkinClass", 						CanvasElement); //Not necessary, just for completeness

ButtonElement.StyleDefault.setStyle("UpSkinClass", 						CanvasElement);
ButtonElement.StyleDefault.setStyle("OverSkinClass", 					CanvasElement);
ButtonElement.StyleDefault.setStyle("DownSkinClass", 					CanvasElement);
ButtonElement.StyleDefault.setStyle("DisabledSkinClass", 				CanvasElement);

ButtonElement.StyleDefault.setStyle("UpTextColor", 						"#000000");
ButtonElement.StyleDefault.setStyle("OverTextColor", 					"#000000");
ButtonElement.StyleDefault.setStyle("DownTextColor", 					"#000000");
ButtonElement.StyleDefault.setStyle("DisabledTextColor", 				"#888888");

//Skin Defaults////////////////////////////
ButtonElement.UpSkinStyleDefault = new StyleDefinition();

ButtonElement.UpSkinStyleDefault.setStyle("BorderType", 				"solid");
ButtonElement.UpSkinStyleDefault.setStyle("BorderThickness", 			1);
ButtonElement.UpSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ButtonElement.UpSkinStyleDefault.setStyle("BackgroundColor", 			"#EBEBEB");
ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
ButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStop", 			(-.05));

ButtonElement.OverSkinStyleDefault = new StyleDefinition();

ButtonElement.OverSkinStyleDefault.setStyle("BorderType", 				"solid");
ButtonElement.OverSkinStyleDefault.setStyle("BorderThickness", 			1);
ButtonElement.OverSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ButtonElement.OverSkinStyleDefault.setStyle("BackgroundColor", 			"#DDDDDD");
ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 		(+.05));
ButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 		(-.05));

ButtonElement.DownSkinStyleDefault = new StyleDefinition();

ButtonElement.DownSkinStyleDefault.setStyle("BorderType", 				"solid");
ButtonElement.DownSkinStyleDefault.setStyle("BorderThickness", 			1);
ButtonElement.DownSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ButtonElement.DownSkinStyleDefault.setStyle("BackgroundColor", 			"#CCCCCC");
ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStart", 		(-.06));
ButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStop", 		(+.02));

ButtonElement.DisabledSkinStyleDefault = new StyleDefinition();

ButtonElement.DisabledSkinStyleDefault.setStyle("BorderType", 			"solid");
ButtonElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 		1);
ButtonElement.DisabledSkinStyleDefault.setStyle("BorderColor", 			"#999999");
ButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 		"#ECECEC");
ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 	"linear");
ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 	(+.05));
ButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 	(-.05));
//Not used by button, used by scrollbutton, but want button, scrollbutton to use the same style.
ButtonElement.DisabledSkinStyleDefault.setStyle("ArrowColor", 			"#777777");
/////////////////////////////////////////////////

//Apply Skin Defaults
ButtonElement.StyleDefault.setStyle("UpSkinStyle", 						ButtonElement.UpSkinStyleDefault);
ButtonElement.StyleDefault.setStyle("OverSkinStyle", 					ButtonElement.OverSkinStyleDefault);
ButtonElement.StyleDefault.setStyle("DownSkinStyle", 					ButtonElement.DownSkinStyleDefault);
ButtonElement.StyleDefault.setStyle("DisabledSkinStyle", 				ButtonElement.DisabledSkinStyleDefault);


	
/////////////ButtonElement Protected Functions/////////////////////	
	
/**
 * @function _updateState
 * Called in response to mouse events, and when the Button is added to the display hierarchy (if mouse is enabled).
 * Updates the Button skin state.
 */
ButtonElement.prototype._updateState = 
	function ()
	{
		var newState = "up";
	
		if (this.getStyle("Enabled") == false)
			newState = "disabled";
		else
		{
			if (this._mouseIsDown == true)
				newState = "down";
			else if (this._mouseIsOver == true)
				newState = "over";
		}
		
		this.setStyle("SkinState", newState);
	};

/**
 * @function _onButtonMouseDown
 * Event handler for "mousedown" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "mousedown" event listener.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */	
ButtonElement.prototype._onButtonMouseDown = 
	function (elementMouseEvent)
	{
		this._updateState();
	};
	
/**
 * @function _onButtonMouseUp
 * Event handler for "mouseup" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "mouseup" event listener.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */		
ButtonElement.prototype._onButtonMouseUp = 
	function (elementMouseEvent)
	{
		this._updateState();
	};		

/**
 * @function _onButtonRollover
 * Event handler for "rollover" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "rollover" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ButtonElement.prototype._onButtonRollover = 
	function (elementEvent)
	{
		this._updateState();
	};

/**
 * @function _onButtonRollout
 * Event handler for "rollout" event. Updates the Button skin state.
 * Overriding this is more efficient than adding an additional "rollout" event listener.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ButtonElement.prototype._onButtonRollout = 
	function (elementEvent)
	{
		this._updateState();
	};	
	
/**
 * @function _onButtonClick
 * Event handler for "click" event. Cancels the event if the Button is disabled.
 * Overriding this is more efficient than adding an additional "click" event listener.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */			
ButtonElement.prototype._onButtonClick = 
	function (elementMouseEvent)
	{
		//Implementor will not expect a click event when button is disabled. 
		if (this.getStyle("Enabled") == false)
			elementMouseEvent.cancelEvent();
	};
	
//@override
ButtonElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
	
		if (state == "up")
			stateSkinClass = this.getStyleData("UpSkinClass");
		else if (state == "over")
			stateSkinClass = this.getStyleData("OverSkinClass");
		else if (state == "down")
			stateSkinClass = this.getStyleData("DownSkinClass");
		else if (state == "disabled")
			stateSkinClass = this.getStyleData("DisabledSkinClass");
		
		var skinClass = this.getStyleData("SkinClass");
		
		//Shouldnt have null stateSkinClass
		if (stateSkinClass == null || skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
	
//@override	
ButtonElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "up")
			return this.getStyle("UpSkinStyle");
		else if (state == "over")
			return this.getStyle("OverSkinStyle");
		else if (state == "down")
			return this.getStyle("DownSkinStyle");
		else if (state == "disabled")
			return this.getStyle("DisabledSkinStyle");
		
		return ButtonElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};

//@override
ButtonElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "up")
			return this._getDefaultStyle("UpSkinStyle");
		else if (state == "over")
			return this._getDefaultStyle("OverSkinStyle");
		else if (state == "down")
			return this._getDefaultStyle("DownSkinStyle");
		else if (state == "disabled")
			return this._getDefaultStyle("DisabledSkinStyle");
		
		return ButtonElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};
	
//@override
ButtonElement.prototype._changeState = 
	function (state)
	{
		ButtonElement.base.prototype._changeState.call(this, state);
		
		this._updateTextColor();
	};
	
/**
 * @function _getTextColor
 * Gets the text color to be used for the supplied state. 
 * Override this to add styles for additional states.
 * 
 * @param state String
 * String representing the state to return the text color style.
 * 
 * @returns string
 * Text color for the supplied state.
 */	
ButtonElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "up")
			stateTextColor = this.getStyleData("UpTextColor");
		else if (state == "over")
			stateTextColor = this.getStyleData("OverTextColor");
		else if (state == "down")
			stateTextColor = this.getStyleData("DownTextColor");
		else if (state == "disabled")
			stateTextColor = this.getStyleData("DisabledTextColor");

		var textColor = this.getStyleData("TextColor");
		
		//Shouldnt have null stateTextColor
		if (stateTextColor == null || textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

/**
 * @function _updateTextColor
 * Updates the text color in response to state changes.
 */		
ButtonElement.prototype._updateTextColor = 
	function ()
	{
		if (this._labelElement == null)
			return;
		
		this._labelElement.setStyle("TextColor", this._getTextColor(this._currentSkinState));
	};
	
/**
 * @function _updateText
 * Updates the buttons label text in response to style changes.
 */	
ButtonElement.prototype._updateText = 
	function ()
	{
		var text = this.getStyle("Text");
		if (text == null || text == "")
		{
			if (this._labelElement != null)
			{
				this._removeChild(this._labelElement);
				this._labelElement = null;
			}
		}
		else
		{
			if (this._labelElement == null)
			{
				this._labelElement = this._createLabel();
				if (this._labelElement != null)
				{
					this._updateTextColor();
					this._addChild(this._labelElement);
				}
			}
			
			if (this._labelElement != null)
				this._labelElement.setStyle("Text", text);
		}	
	};
	
//@override
ButtonElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ButtonElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		//Always update these, they dont do anything if no changes
		//and cheaper to call this than to check SkinClass inheritance.
		this._updateSkinClass("up");
		this._updateSkinStyleDefinitions("up");
		
		this._updateSkinClass("over");
		this._updateSkinStyleDefinitions("over");
		
		this._updateSkinClass("down");
		this._updateSkinStyleDefinitions("down");
		
		this._updateSkinClass("disabled");
		this._updateSkinStyleDefinitions("disabled");
		
		//Create / Destroy and proxy text to label.
		if ("Text" in stylesMap)
			this._updateText();
		
		//Only update the state if mouse is enabled, when disabled it means states are being manually controlled.
		if ("Enabled" in stylesMap && this.getStyle("MouseEnabled") == true)
			this._updateState();
		
		if ("TextAlign" in stylesMap && this._labelElement != null)
			this._labelElement.setStyle("TextAlign", this.getStyle("TextAlign"));
		
		if ("TextBaseline" in stylesMap && this._labelElement != null)
			this._labelElement.setStyle("TextBaseline", this.getStyle("TextBaseline"));
		
		//Always call (can optimize by checking for all text color styles)
		this._updateTextColor();
	};	
	
/**
 * @function _createLabel
 * Creates the Button's label instance when Text style is not null or empty.
 * 
 * @returns LabelElement
 * New LabelElement instance
 */	
ButtonElement.prototype._createLabel = 
	function ()
	{
		var label = new LabelElement();
	
		label.setStyle("MouseEnabled", false);
		label.setStyle("TextAlign", this.getStyle("TextAlign"));
		label.setStyle("TextBaseline", this.getStyle("TextBaseline"));
		
		label.setStyle("Padding", 0); //Wipe out default padding (no doubly padding, only this elements padding is necessary)
		
		return label;
	};
	
//@override
ButtonElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = null;
	
		//Base size off of label.
		if (this._labelElement != null)
		{
			var labelWidth = this._labelElement._getStyledOrMeasuredWidth();
			var labelHeight = this._labelElement._getStyledOrMeasuredHeight();
			
			measuredSize = {width:labelWidth + padWidth, height:labelHeight + padHeight};
		}
		else
			measuredSize = ButtonElement.base.prototype._doMeasure.call(this, padWidth, padHeight);

		return measuredSize;
	};

//@override	
ButtonElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		ButtonElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._labelElement != null)
		{
			this._labelElement._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
			this._labelElement._setActualSize(paddingMetrics.getWidth(), paddingMetrics.getHeight());
		}
	};	
	


/**
 * @depends ButtonElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////ToggleButtonElement/////////////////////////////////

/**
 * @class ToggleButtonElement
 * @inherits ButtonElement
 * 
 * ToggleButton is identical to a button except that it adds "selected" versions of
 * the 4 button states and Toggles from selected to not-selected when clicked. It also
 * dispatches a "changed" event when the selected state changes.
 * 
 * ToggleButton selected states:
 * "selectedUp", "selectedOver", "selectedDown", "selectedDisabled".
 * 
 * Being a SkinnableElement, ToggleButton proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the ToggleButton itself. 
 * 
 * ToggleButton is a base class for components such as Checkbox and RadioButton.
 * 
 * 
 * @constructor ToggleButtonElement 
 * Creates new ToggleButtonElement instance.
 */
function ToggleButtonElement()
{
	ToggleButtonElement.base.prototype.constructor.call(this);
	
	this._isSelected = false;
}

//Inherit from ButtonElement
ToggleButtonElement.prototype = Object.create(ButtonElement.prototype);
ToggleButtonElement.prototype.constructor = ToggleButtonElement;
ToggleButtonElement.base = ButtonElement;

////////////Events/////////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the ToggleButton's selection state changes as a result of user interaction.
 */


/////////////Style Types///////////////////////////////

ToggleButtonElement._StyleTypes = Object.create(null);

//New toggle button specific styles.

/**
 * @style AllowDeselect boolean
 * 
 * When false, the ToggleButton cannot be de-selected by the user and the "selectedOver" and "selectedDown" states are not used, 
 * as with the case for most tab or radio button type elements.
 */
ToggleButtonElement._StyleTypes.AllowDeselect = 				{inheritable:false};		// true || false

/**
 * @style SelectedUpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedUp" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedUpSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style SelectedUpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedUp" state skin element.
 */
ToggleButtonElement._StyleTypes.SelectedUpSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style SelectedUpTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedUp" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedUpTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style SelectedOverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedOver" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedOverSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style SelectedOverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedOver" state skin element. 
 */
ToggleButtonElement._StyleTypes.SelectedOverSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style SelectedOverTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedOver" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedOverTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style SelectedDownSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedDown" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedDownSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style SelectedDownSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedDown" state skin element. 
 */
ToggleButtonElement._StyleTypes.SelectedDownSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style SelectedDownTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedDown" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedDownTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style SelectedDisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the button skin when the button is in the "selectedDisabled" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
ToggleButtonElement._StyleTypes.SelectedDisabledSkinClass = 	{inheritable:false};		//Element constructor()

/**
 * @style SelectedDisabledSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "selectedDisabled" state skin element. 
 */
ToggleButtonElement._StyleTypes.SelectedDisabledSkinStyle = 	{inheritable:false};		//StyleDefinition

/**
 * @style SelectedDisabledTextColor String
 * 
 * Hex color value to be used for the button label when the button is in the "selectedDisabled" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
ToggleButtonElement._StyleTypes.SelectedDisabledTextColor = 	{inheritable:false};		//"#000000"


////////////Default Styles/////////////////////////////

ToggleButtonElement.StyleDefault = new StyleDefinition();

//ToggleButtonElement specific styles
ToggleButtonElement.StyleDefault.setStyle("AllowDeselect", 							true);

ToggleButtonElement.StyleDefault.setStyle("SelectedUpSkinClass", 					CanvasElement);
ToggleButtonElement.StyleDefault.setStyle("SelectedOverSkinClass", 					CanvasElement);
ToggleButtonElement.StyleDefault.setStyle("SelectedDownSkinClass", 					CanvasElement);
ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledSkinClass", 				CanvasElement);

ToggleButtonElement.StyleDefault.setStyle("SelectedOverTextColor", 					"#000000");
ToggleButtonElement.StyleDefault.setStyle("SelectedUpTextColor", 					"#000000");
ToggleButtonElement.StyleDefault.setStyle("SelectedDownTextColor", 					"#000000");
ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledTextColor", 				"#888888");

//Skin Defaults /////////////////////////////////////
ToggleButtonElement.SelectedUpSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderType", 				"solid");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderThickness", 			1);
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BorderColor", 				"#333333");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("BackgroundColor", 			"#CCCCCC");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientStart", 		(-.06));
ToggleButtonElement.SelectedUpSkinStyleDefault.setStyle("AutoGradientStop", 		(+.02));

ToggleButtonElement.SelectedOverSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderType", 			"solid");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderThickness", 		1);
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BorderColor", 			"#333333");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("BackgroundColor", 		"#BDBDBD");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientStart", 		(-.08));
ToggleButtonElement.SelectedOverSkinStyleDefault.setStyle("AutoGradientStop", 		(+.05));

ToggleButtonElement.SelectedDownSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderType", 			"solid");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderThickness", 		1);
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BorderColor", 			"#333333");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("BackgroundColor", 		"#B0B0B0");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientStart", 		(-.08));
ToggleButtonElement.SelectedDownSkinStyleDefault.setStyle("AutoGradientStop", 		(+.05));

ToggleButtonElement.SelectedDisabledSkinStyleDefault = new StyleDefinition();

ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderType", 		"solid");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderThickness", 	1);
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BorderColor", 		"#777777");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("BackgroundColor", 	"#C7C7C7");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientType", 	"linear");
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientStart", 	(-.08));
ToggleButtonElement.SelectedDisabledSkinStyleDefault.setStyle("AutoGradientStop", 	(+.05));
///////////////////////////////////////////////////////

ToggleButtonElement.StyleDefault.setStyle("SelectedUpSkinStyle", 					ToggleButtonElement.SelectedUpSkinStyleDefault);
ToggleButtonElement.StyleDefault.setStyle("SelectedOverSkinStyle", 					ToggleButtonElement.SelectedOverSkinStyleDefault);
ToggleButtonElement.StyleDefault.setStyle("SelectedDownSkinStyle", 					ToggleButtonElement.SelectedDownSkinStyleDefault);
ToggleButtonElement.StyleDefault.setStyle("SelectedDisabledSkinStyle", 				ToggleButtonElement.SelectedDisabledSkinStyleDefault);


//////////////Public Functions/////////////////////////////////////////

/**
 * @function setSelected
 * Sets the selected state of the ToggleButton.
 * 
 * @param isSelected boolean
 * When true the toggle button is selected.
 */	
ToggleButtonElement.prototype.setSelected = 
	function (isSelected)
	{
		if (this._isSelected == isSelected)
			return;
		
		this._isSelected = isSelected;
		this._updateState();
	};
	
/**
 * @function getSelected
 * Gets the selected state of the ToggleButton.
 * 
 * @returns boolean
 * When true the toggle button is selected.
 */	
ToggleButtonElement.prototype.getSelected = 
	function ()
	{
		return this._isSelected;
	};



/////////////Internal Functions/////////////////////	

//@Override
ToggleButtonElement.prototype._updateState = 
	function ()
	{
		if (this._isSelected == false)
		{
			//Call base if we're not selected, handles non-selected states.
			ToggleButtonElement.base.prototype._updateState.call(this);
		}
		else
		{
			var newState = "selectedUp";
			
			if (this.getStyle("Enabled") == false)
				newState = "selectedDisabled";
			else if (this.getStyle("AllowDeselect") == true)
			{
				if (this._mouseIsDown == true)
					newState = "selectedDown";
				else if (this._mouseIsOver == true)
					newState = "selectedOver";
			}
			
			this.setStyle("SkinState", newState);
		}
	};

//@Override	
ToggleButtonElement.prototype._onButtonClick = 
	function (elementMouseEvent)
	{
		//Not calling base
	
		//Implementor will not expect a click event when button is disabled. 
		if (this.getStyle("Enabled") == false)
			elementMouseEvent.cancelEvent();
		else
		{
			if (this._isSelected == false || this.getStyle("AllowDeselect") == true) 
			{
				//Toggle selected state.
				this._isSelected = !this._isSelected;
				
				this._updateState();
				
				//Dispatch changed event.
				if (this.hasEventListener("changed", null) == true)
					this._dispatchEvent(new ElementEvent("changed", false));
			}	
		}
	};
	
//@override
ToggleButtonElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
	
		if (state == "selectedUp")
			stateSkinClass = this.getStyleData("SelectedUpSkinClass");
		else if (state == "selectedOver")
			stateSkinClass = this.getStyleData("SelectedOverSkinClass");
		else if (state == "selectedDown")
			stateSkinClass = this.getStyleData("SelectedDownSkinClass");
		else if (state == "selectedDisabled")
			stateSkinClass = this.getStyleData("SelectedDisabledSkinClass");
		else //base class state
			return ToggleButtonElement.base.prototype._getSkinClass.call(this, state);
		
		var skinClass = this.getStyleData("SkinClass");
		
		if (skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};	
	
//@override	
ToggleButtonElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "selectedUp")
			return this.getStyle("SelectedUpSkinStyle");
		else if (state == "selectedOver")
			return this.getStyle("SelectedOverSkinStyle");
		else if (state == "selectedDown")
			return this.getStyle("SelectedDownSkinStyle");
		else if (state == "selectedDisabled")
			return this.getStyle("SelectedDisabledSkinStyle");
		
		return ToggleButtonElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};	
	
//@Override
ToggleButtonElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "selectedUp")
			return this._getDefaultStyle("SelectedUpSkinStyle");
		else if (state == "selectedOver")
			return this._getDefaultStyle("SelectedOverSkinStyle");
		else if (state == "selectedDown")
			return this._getDefaultStyle("SelectedDownSkinStyle");
		else if (state == "selectedDisabled")
			return this._getDefaultStyle("SelectedDisabledSkinStyle");
		
		return ToggleButtonElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};	
	
//@Override
ToggleButtonElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
	
		if (state == "selectedUp")
			stateTextColor = this.getStyleData("SelectedUpTextColor");
		else if (state == "selectedOver")
			stateTextColor = this.getStyleData("SelectedOverTextColor");
		else if (state == "selectedDown")
			stateTextColor = this.getStyleData("SelectedDownTextColor");
		else if (state == "selectedDisabled")
			stateTextColor = this.getStyleData("SelectedDisabledTextColor");
		else //base class state
			return ToggleButtonElement.base.prototype._getTextColor.call(this, state);
	
		var textColor = this.getStyleData("TextColor");
		
		if (textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

//@Override
ToggleButtonElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ToggleButtonElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		//Always update these, they dont do anything if no changes
		//and cheaper to call this than to check SkinClass inheritance.
		this._updateSkinClass("selectedUp");
		this._updateSkinStyleDefinitions("selectedUp");
		
		this._updateSkinClass("selectedOver");
		this._updateSkinStyleDefinitions("selectedOver");
		
		this._updateSkinClass("selectedDown");
		this._updateSkinStyleDefinitions("selectedDown");
		
		this._updateSkinClass("selectedDisabled");
		this._updateSkinStyleDefinitions("selectedDisabled");
		
		if ("AllowDeselect" in stylesMap)
			this._updateState();
	};	
	

	
	


/**
 * @depends CanvasElement.js
 * @depends ScrollButtonSkinElement.js
 * @depends ButtonElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////ScrollBarElement/////////////////////////////////

/**
 * @class ScrollBarElement
 * @inherits CanvasElement
 * 
 * ScrollBarElement renders a skin-able scroll bar that can be
 * oriented horizontally or vertically and assigns a default
 * skin to the scroll buttons. 
 * 
 * See the default skin ScrollButtonSkinElement for additional skin styles.
 * 
 * @seealso ScrollButtonSkinElement
 * 
 * 
 * @constructor ScrollBarElement 
 * Creates new ScrollBarElement instance.
 */
function ScrollBarElement()
{
	ScrollBarElement.base.prototype.constructor.call(this);
	
	this._buttonIncrement = null;
	this._buttonDecrement = null;
	this._buttonTrack = null;
	this._buttonTab = null;
	
	this._scrollPageSize = 0;
	this._scrollViewSize = 0;
	this._scrollLineSize = 1;
	
	this._scrollValue = 0;
	
	this._scrollTween = null;
	
	var _self = this;
	
	//Private event handlers, need different instance for each ScrollBar, proxy to prototype.
	this._onScrollButtonClickInstance = 
		function (elementMouseEvent)
		{
			_self._onScrollButtonClick(elementMouseEvent);
		};
		
	this._onScrollTabDragInstance = 
		function (elementEvent)
		{
			_self._onScrollTabDrag(elementEvent);
		};
		
	this._onScrollBarEnterFrameInstance = 
		function (event)
		{
			_self._onScrollBarEnterFrame(event);
		};
}

//Inherit from CanvasElement
ScrollBarElement.prototype = Object.create(CanvasElement.prototype);
ScrollBarElement.prototype.constructor = ScrollBarElement;
ScrollBarElement.base = CanvasElement;

/////////////Events////////////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the scroll position changes as a result of user interation or tween.
 */


/////////////Style Types///////////////////////////////

ScrollBarElement._StyleTypes = Object.create(null);

/**
 * @style ScrollBarDirection String
 * Determines the orientation of the scroll bar. Allowable values are "horizontal" or "vertical".
 */
ScrollBarElement._StyleTypes.ScrollBarDirection = 			{inheritable:false};		// "horizontal" || "vertical"

/**
 * @style ScrollTweenDuration Number
 * Time in milliseconds the scroll tween animation should run.
 */
ScrollBarElement._StyleTypes.ScrollTweenDuration =			{inheritable:false};		// number (milliseconds)

//ScrollButton / Button styles.
/**
 * @style ScrollButtonIncrementStyle StyleDefinition
 * StyleDefinition to be applied to the Scroll increment Button.
 * ScrollBar automatically sets an inline "ArrowDirection" style to this button which is either "down" or "right" depending on ScrollBarDirection.
 */
ScrollBarElement._StyleTypes.ScrollButtonIncrementStyle = 	{inheritable:false};		// StyleDefinition

/**
 * @style ScrollButtonDecrementStyle StyleDefinition
 * StyleDefinition to be applied to the Scroll decrement Button.
 * ScrollBar automatically sets an inline "ArrowDirection" style to this button which is either "up" or "left" depending on ScrollBarDirection.
 */
ScrollBarElement._StyleTypes.ScrollButtonDecrementStyle = 	{inheritable:false};		// StyleDefinition

/**
 * @style ButtonTrackStyle StyleDefinition
 * StyleDefinition to be applied to the scroll bar track Button.
 */
ScrollBarElement._StyleTypes.ButtonTrackStyle = 			{inheritable:false};		// StyleDefinition

/**
 * @style ButtonTabStyle StyleDefinition
 * StyleDefinition to be applied to the scroll bar tab (draggable) Button.
 */
ScrollBarElement._StyleTypes.ButtonTabStyle = 				{inheritable:false};		// StyleDefinition


////////////Default Styles////////////////////////////

ScrollBarElement.StyleDefault = new StyleDefinition();

//Button style defaults
ScrollBarElement.ButtonTrackStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonTrackStyleDefault.setStyle("BorderType", 					"none");
ScrollBarElement.ButtonTrackStyleDefault.setStyle("UpSkinStyle", 					ButtonElement.UpSkinStyleDefault);  //Dont need this same as button default
ScrollBarElement.ButtonTrackStyleDefault.setStyle("OverSkinStyle", 					ButtonElement.UpSkinStyleDefault); 
ScrollBarElement.ButtonTrackStyleDefault.setStyle("DownSkinStyle", 					ButtonElement.UpSkinStyleDefault);
ScrollBarElement.ButtonTrackStyleDefault.setStyle("DisabledSkinStyle", 				ButtonElement.DisabledSkinStyleDefault); //Dont need this same as button default

ScrollBarElement.ButtonTabStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonTabStyleDefault.setStyle("UpSkinStyle", 						ButtonElement.UpSkinStyleDefault);		//Dont actually need these (could be null)	
ScrollBarElement.ButtonTabStyleDefault.setStyle("OverSkinStyle", 					ButtonElement.OverSkinStyleDefault);
ScrollBarElement.ButtonTabStyleDefault.setStyle("DownSkinStyle", 					ButtonElement.DownSkinStyleDefault);
ScrollBarElement.ButtonTabStyleDefault.setStyle("DisabledSkinStyle", 				ButtonElement.DisabledSkinStyleDefault);

ScrollBarElement.ButtonScrollArrowIncStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("SkinClass", 			ScrollButtonSkinElement);			
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("ArrowColor", 			"#000000");
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("UpSkinStyle", 			ButtonElement.UpSkinStyleDefault);		//Dont actually need these (could be null)	
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("OverSkinStyle", 		ButtonElement.OverSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("DownSkinStyle", 		ButtonElement.DownSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowIncStyleDefault.setStyle("DisabledSkinStyle", 	ButtonElement.DisabledSkinStyleDefault);

ScrollBarElement.ButtonScrollArrowDecStyleDefault = new StyleDefinition();
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("SkinClass", 			ScrollButtonSkinElement);			
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("ArrowColor", 			"#000000");
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("UpSkinStyle", 			ButtonElement.UpSkinStyleDefault);		//Dont actually need these (could be null)	
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("OverSkinStyle", 		ButtonElement.OverSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("DownSkinStyle", 		ButtonElement.DownSkinStyleDefault);
ScrollBarElement.ButtonScrollArrowDecStyleDefault.setStyle("DisabledSkinStyle", 	ButtonElement.DisabledSkinStyleDefault);

ScrollBarElement.StyleDefault.setStyle("ScrollButtonIncrementStyle", 				ScrollBarElement.ButtonScrollArrowIncStyleDefault); 
ScrollBarElement.StyleDefault.setStyle("ScrollButtonDecrementStyle", 				ScrollBarElement.ButtonScrollArrowDecStyleDefault); 
ScrollBarElement.StyleDefault.setStyle("ButtonTrackStyle", 							ScrollBarElement.ButtonTrackStyleDefault);
ScrollBarElement.StyleDefault.setStyle("ButtonTabStyle", 							ScrollBarElement.ButtonTabStyleDefault);
ScrollBarElement.StyleDefault.setStyle("ScrollTweenDuration", 						180); 			// number (milliseconds)

ScrollBarElement.StyleDefault.setStyle("ScrollBarDirection", 						"vertical");	// "vertical" || "horizontal"



/////////////ScrollBarElement Public Functions///////////////////

/**
 * @function setScrollPageSize
 * Sets the total number of scroll lines.
 * 
 * @param pageSize int
 * The total number of scroll lines.
 */
ScrollBarElement.prototype.setScrollPageSize = 
	function (pageSize)
	{
		if (this._scrollPageSize == pageSize)
			return;
	
		this._scrollPageSize = pageSize;
		this._invalidateLayout();
	};

/**
 * @function getScrollPageSize
 * Gets the total number of scroll lines.
 * 
 * @returns int
 * The total number of scroll lines.
 */	
ScrollBarElement.prototype.getScrollPageSize = 
	function ()
	{
		return this._scrollPageSize;
	};
	
/**
 * @function setScrollViewSize
 * Sets the number of scroll lines that fit within the view.
 * 
 * @param viewSize int
 * The number of scroll lines that fit within the view.
 */	
ScrollBarElement.prototype.setScrollViewSize = 
	function (viewSize)
	{
		if (this._scrollViewSize == viewSize)
			return;
		
		this._scrollViewSize = viewSize;
		this._invalidateLayout();
	};
	
/**
 * @function getScrollViewSize
 * Gets the number of scroll lines that fit within the view.
 * 
 * @returns int
 * The number of scroll lines that fit within the view.
 */	
ScrollBarElement.prototype.getScrollViewSize = 
	function ()
	{
		return this._scrollViewSize;
	};
	
/**
 * @function setScrollLineSize
 * Sets the number of lines to scroll when a scroll button is pressed.
 * 
 * @param lineSize int
 * The number of lines to scroll when a scroll button is pressed.
 */	
ScrollBarElement.prototype.setScrollLineSize = 
	function (lineSize)
	{
		this._scrollLineSize = lineSize;
	};		
	
/**
 * @function getScrollLineSize
 * Gets the number of lines to scroll when a scroll button is pressed.
 * 
 * @returns int
 * The number of lines to scroll when a scroll button is pressed.
 */	
ScrollBarElement.prototype.getScrollLineSize = 
	function ()
	{
		return this._scrollLineSize;
	};
	
/**
 * @function setScrollValue
 * Sets the position to scroll too. Range is 0 to (page size - view size).
 * 
 * @param value int
 * The position to scroll too.
 */	
ScrollBarElement.prototype.setScrollValue = 
	function (value)
	{
		if (this._scrollValue == value)
			return;
		
		this._scrollValue = value;
		this._invalidateLayout();
	};

/**
 * @function getScrollValue
 * Gets the scroll position.  Range is 0 to (page size - view size).
 * 
 * @returns int
 * The scroll position.
 */	
ScrollBarElement.prototype.getScrollValue = 
	function ()
	{
		return this._scrollValue;
	};

/**
 * @function startScrollTween
 * Starts a tween animation to scroll bar to the supplied scroll position.
 * 
 * @param tweenToValue int
 * The position to scroll too.
 */	
ScrollBarElement.prototype.startScrollTween = 
	function (tweenToValue)
	{
		var tweenDuration = this.getStyle("ScrollTweenDuration");
		if (tweenDuration > 0)
		{
			if (this._scrollTween == null)
			{
				this._scrollTween = new Tween();
				this._scrollTween.startVal = this._scrollValue;
				this._scrollTween.endVal = tweenToValue;
				this._scrollTween.duration = tweenDuration;
				this._scrollTween.startTime = Date.now();
				this._scrollTween.easingFunction = Tween.easeInOutSine;
				
				this.addEventListener("enterframe", this._onScrollBarEnterFrameInstance);
			}
			else
			{
				this._scrollTween.startVal = this._scrollValue;
				this._scrollTween.endVal = tweenToValue;
				this._scrollTween.startTime = Date.now();
				this._scrollTween.easingFunction = Tween.easeOutSine;
			}
		}
		else
		{
			this.endScrollTween();
			this.setScrollValue(tweenToValue);
			this._dispatchEvent(new ElementEvent("changed", false));
		}
	};
	
/**
 * @function endScrollTween
 * Ends the scroll tween animation. Immediately moves the scroll position to
 * the ending position if the tween is still running.
 */		
ScrollBarElement.prototype.endScrollTween = 
	function ()
	{
		if (this._scrollTween != null)
		{
			this.setScrollValue(this._scrollTween.endVal);
			this.removeEventListener("enterframe", this._onScrollBarEnterFrameInstance);
			this._scrollTween = null;
		}
	};	
	
/**
 * @function getTweenToValue
 * Gets the scroll position being tweened too.
 * 
 * @returns int
 * The scroll position beeing tweened too or null if no tween is running.
 */	
ScrollBarElement.prototype.getTweenToValue = 
	function ()
	{
		if (this._scrollTween == null)
			return null;
		
		return this._scrollTween.endVal;
	};
	
/////////////ScrollBarElement Internal Functions///////////////////

//@private - only active when a tween is running.
ScrollBarElement.prototype._onScrollBarEnterFrame = 
	function (event)
	{
		var scrollValue = this._scrollTween.getValue(Date.now());
		
		if (scrollValue == this._scrollTween.endVal)
			this.endScrollTween();
		else
			this.setScrollValue(scrollValue);
		
		this._dispatchEvent(new ElementEvent("changed", false));
	};
	
//@Override	
ScrollBarElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		ScrollBarElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		this.endScrollTween();
	};		
	
/**
 * @function _onScrollButtonClick
 * Event handler for Buttons (increment, decrement, and track) "click" event. 
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */		
ScrollBarElement.prototype._onScrollButtonClick = 
	function (elementMouseEvent)
	{
		var incrementSize = null;
		
		var startScrollValue = this._scrollValue;
		if (this._scrollTween != null)
			startScrollValue = this._scrollTween.endVal;
		
		startScrollValue = Math.min(this._scrollPageSize - this._scrollViewSize, startScrollValue);
		startScrollValue = Math.max(0, startScrollValue);
		
		if (elementMouseEvent.getTarget() == this._buttonIncrement || 
			elementMouseEvent.getTarget() == this._buttonDecrement)
		{
			incrementSize = this.getScrollLineSize();
			
			if (elementMouseEvent.getTarget() == this._buttonDecrement)
				incrementSize = incrementSize * -1;
		}
		else if (elementMouseEvent.getTarget() == this._buttonTrack)
		{
			incrementSize = this._scrollViewSize * .75;
			
			if (this.getStyle("ScrollBarDirection") == "horizontal")
			{
				if (elementMouseEvent.getX() <= this._buttonTab._x + (this._buttonTab._width / 2))
					incrementSize = incrementSize * -1;
			}
			else //vertical
			{
				if (elementMouseEvent.getY() <= this._buttonTab._y + (this._buttonTab._height / 2))
					incrementSize = incrementSize * -1;
			}
		}
		
		var endScrollValue = startScrollValue + incrementSize;
		
		endScrollValue = Math.min(this._scrollPageSize - this._scrollViewSize, endScrollValue);
		endScrollValue = Math.max(0, endScrollValue);
		
		if (endScrollValue != startScrollValue)
			this.startScrollTween(endScrollValue);
	};

/**
 * @function _onScrollTabDrag
 * Event handler for Tab Button's "dragging" event. 
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ScrollBarElement.prototype._onScrollTabDrag = 
	function (elementEvent)
	{
		var tabPosition = null;
		var trackSize = null;
		var tabSize = null;
		
		var direction = this.getStyle("ScrollBarDirection");
		var oldScrollValue = this._scrollValue;
		
		if (direction == "horizontal")
		{
			trackSize = this._buttonTrack._width;
			tabPosition = this._buttonTab._x - this._buttonTrack._x;
			tabSize = this._buttonTab._width;
		}
		else
		{
			trackSize = this._buttonTrack._height;
			tabPosition = this._buttonTab._y - this._buttonTrack._y;
			tabSize = this._buttonTab._height;
		}
		
		//Correct position
		if (tabPosition > trackSize - tabSize)
			tabPosition = trackSize - tabSize;
		if (tabPosition < 0)
			tabPosition = 0;
		
		trackSize = trackSize - tabSize;
		
		//Calculate new ScrollValue
		var scrollRange = this._scrollPageSize - this._scrollViewSize;
		var pixelsPerScaleUnit = trackSize / scrollRange;
		
		var newScrollValue = (tabPosition / pixelsPerScaleUnit);
		if (oldScrollValue != newScrollValue)
		{
			this.setScrollValue(newScrollValue);
			this._dispatchEvent(new ElementEvent("changed", false));
		}
		
		//Always invalidate layout, need to correct drag position.
		this._invalidateLayout();
	};

/**
 * @function _createChildren
 * Creates the scroll bar child buttons when the ScrollBar is first added to the display hierarchy.
 */	
ScrollBarElement.prototype._createChildren = 
	function ()
	{
		this._buttonIncrement = new ButtonElement();
		this._buttonIncrement._setStyleDefinitionDefault(this._getDefaultStyle("ScrollButtonIncrementStyle"));
		
		this._buttonIncrement.addEventListener("click", this._onScrollButtonClickInstance);
		this._addChild(this._buttonIncrement);

		this._buttonDecrement = new ButtonElement();
		this._buttonDecrement._setStyleDefinitionDefault(this._getDefaultStyle("ScrollButtonDecrementStyle"));
		
		this._buttonDecrement.addEventListener("click", this._onScrollButtonClickInstance);
		this._addChild(this._buttonDecrement);

		this._buttonTrack = new ButtonElement();
		this._buttonTrack._setStyleDefinitionDefault(this._getDefaultStyle("ButtonTrackStyle"));
		
		this._buttonTrack.addEventListener("click", this._onScrollButtonClickInstance);
		this._addChild(this._buttonTrack);

		this._buttonTab = new ButtonElement();
		this._buttonTab._setStyleDefinitionDefault(this._getDefaultStyle("ButtonTabStyle"));
		this._buttonTab.setStyle("Draggable", true);
		
		this._buttonTab.addEventListener("dragging", this._onScrollTabDragInstance);
		this._addChild(this._buttonTab);
	};
	
//@Override
ScrollBarElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ScrollBarElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		if (this._buttonIncrement == null)
			this._createChildren();
		
		if ("ScrollButtonIncrementStyle" in stylesMap)
			this._buttonIncrement.setStyleDefinitions(this.getStyle("ScrollButtonIncrementStyle"));
		
		if ("ScrollButtonDecrementStyle" in stylesMap)
			this._buttonDecrement.setStyleDefinitions(this.getStyle("ScrollButtonDecrementStyle"));
		
		if ("ButtonTrackStyle" in stylesMap)
			this._buttonTrack.setStyleDefinitions(this.getStyle("ButtonTrackStyle"));
		
		if ("ButtonTabStyle" in stylesMap)
			this._buttonTab.setStyleDefinitions(this.getStyle("ButtonTabStyle"));
		
		if ("ScrollBarDirection" in stylesMap)
		{
			if (this.getStyle("ScrollBarDirection") == "horizontal")
			{
				this._buttonIncrement.setStyle("ArrowDirection", "right");
				this._buttonDecrement.setStyle("ArrowDirection", "left");
			}
			else
			{
				this._buttonIncrement.setStyle("ArrowDirection", "down");
				this._buttonDecrement.setStyle("ArrowDirection", "up");
			}
			
			this._invalidateMeasure();
			this._invalidateLayout();
		}
		
		if ("ScrollTweenDuration" in stylesMap && this.getStyle("ScrollTweenDuration") == 0)
			this.endScrollTween();
	};
	
	
//@Override
ScrollBarElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var largestSize = 0;
		if (this.getStyle("ScrollBarDirection") == "horizontal")
		{
			var buttonDecHeight = this._buttonDecrement.getStyle("Height");
			var buttonIncHeight = this._buttonIncrement.getStyle("Height");
			var buttonTrackHeight = this._buttonTrack.getStyle("Height");
			var buttonTabHeight = this._buttonTab.getStyle("Height");
			
			largestSize = Math.max(largestSize, buttonDecHeight);
			largestSize = Math.max(largestSize, buttonIncHeight);
			largestSize = Math.max(largestSize, buttonTrackHeight);
			largestSize = Math.max(largestSize, buttonTabHeight);

			if (largestSize == 0)
				largestSize = 15;
			
			var buttonDecWidth = this._buttonDecrement.getStyle("Width");
			var buttonIncWidth = this._buttonIncrement.getStyle("Width");
			var buttonTabWidth = this._buttonTab.getStyle("Width");
			
			if (buttonDecWidth == null)
				buttonDecWidth = largestSize;
			if (buttonIncWidth == null)
				buttonIncWidth = largestSize;
			if (buttonTabWidth == null)
				buttonTabWidth = buttonDecWidth + buttonIncWidth;			
			
			return {width: padWidth + buttonDecWidth + buttonIncWidth + (buttonTabWidth * 2),
					height: padHeight + largestSize};
		}
		else
		{
			var buttonDecWidth = this._buttonDecrement.getStyle("Width");
			var buttonIncWidth = this._buttonIncrement.getStyle("Width");
			var buttonTrackWidth = this._buttonTrack.getStyle("Width");
			var buttonTabWidth = this._buttonTab.getStyle("Width");
			
			largestSize = Math.max(largestSize, buttonDecWidth);
			largestSize = Math.max(largestSize, buttonIncWidth);
			largestSize = Math.max(largestSize, buttonTrackWidth);
			largestSize = Math.max(largestSize, buttonTabWidth);
			
			if (largestSize == 0)
				largestSize = 15;
			
			var buttonDecHeight = this._buttonDecrement.getStyle("Height");
			var buttonIncHeight = this._buttonIncrement.getStyle("Height");
			var buttonTabHeight = this._buttonTab.getStyle("Height");
			
			if (buttonDecHeight == null)
				buttonDecHeight = largestSize;
			if (buttonIncHeight == null)
				buttonIncHeight = largestSize;
			if (buttonTabHeight == null)
				buttonTabHeight = buttonDecWidth + buttonIncWidth;			
			
			return {width: padWidth + largestSize,
					height: padHeight + buttonDecHeight + buttonIncHeight + (buttonTabHeight * 2)};
		}
	};	
	
//@Override	
ScrollBarElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		ScrollBarElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		var direction = this.getStyle("ScrollBarDirection");

		//Correct the scroll value (size reduction forces us to scroll up)
		this._scrollValue = Math.min(this._scrollValue, this._scrollPageSize - this._scrollViewSize);
		this._scrollValue = Math.max(this._scrollValue, 0);
		
		//Disable / Enable components
		if (this._scrollViewSize >= this._scrollPageSize)
		{
			this._buttonIncrement.setStyle("Enabled", false);
			this._buttonDecrement.setStyle("Enabled", false);
			this._buttonTrack.setStyle("Enabled", false);
			this._buttonTab.setStyle("Visible", false);
		}
		else
		{
			this._buttonIncrement.setStyle("Enabled", true);
			this._buttonDecrement.setStyle("Enabled", true);
			this._buttonTrack.setStyle("Enabled", true);
			this._buttonTab.setStyle("Visible", true);
		}
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		var w = paddingMetrics.getWidth();
		var h = paddingMetrics.getHeight();
		
		var buttonDecWidth = this._buttonDecrement.getStyle("Width");
		var buttonDecHeight = this._buttonDecrement.getStyle("Height");
		
		var buttonIncWidth = this._buttonIncrement.getStyle("Width");
		var buttonIncHeight = this._buttonIncrement.getStyle("Height");
		
		var buttonTabWidth = this._buttonTab.getStyle("Width");
		var buttonTabHeight = this._buttonTab.getStyle("Height");
		
		var minTabSize = null;
		var availableTrackSize = null;
		var pixelsPerScaleUnit = null;
		
		if (direction == "horizontal")
		{
			if (buttonDecWidth == null)
				buttonDecWidth = h;
			if (buttonDecHeight == null)
				buttonDecHeight = h;
			
			if (buttonIncWidth == null)
				buttonIncWidth = h;
			if (buttonIncHeight == null)
				buttonIncHeight = h;
			
			var trackHeight = this._buttonTrack.getStyle("Height");
			if (trackHeight == null)
				trackHeight = h;
			
			//Center vertically
			this._buttonDecrement._setActualPosition(x, y + (h / 2) - (buttonDecHeight / 2));
			this._buttonDecrement._setActualSize(buttonDecWidth, buttonDecHeight);
			
			this._buttonIncrement._setActualPosition(x + w - buttonIncWidth, y + (h / 2) - (buttonIncHeight / 2));
			this._buttonIncrement._setActualSize(buttonIncWidth, buttonIncHeight);
			
			this._buttonTrack._setActualPosition(x + buttonDecWidth, y + (h / 2) - (trackHeight / 2));
			this._buttonTrack._setActualSize(w - buttonDecWidth - buttonIncWidth, trackHeight);
			
			if (buttonTabHeight == null)
				buttonTabHeight = h;
			if (buttonTabWidth == null)
			{
				minTabSize = (buttonDecWidth + buttonIncWidth);
				
				if (this._scrollPageSize > 0)
					buttonTabWidth = this._buttonTrack._width * (this._scrollViewSize / this._scrollPageSize);
				else
					buttonTabWidth = 0;
				
				buttonTabWidth = Math.max(minTabSize, buttonTabWidth);
			}
			
			availableTrackSize = this._buttonTrack._width - buttonTabWidth;
			pixelsPerScaleUnit = availableTrackSize / (this._scrollPageSize - this._scrollViewSize);
			
			this._buttonTab._setActualPosition(x + buttonDecWidth + (this._scrollValue * pixelsPerScaleUnit), y + (h / 2) - (buttonTabHeight / 2));
			this._buttonTab._setActualSize(buttonTabWidth, buttonTabHeight);
		}
		else
		{
			if (buttonDecWidth == null)
				buttonDecWidth = w;
			if (buttonDecHeight == null)
				buttonDecHeight = w;
			
			if (buttonIncWidth == null)
				buttonIncWidth = w;
			if (buttonIncHeight == null)
				buttonIncHeight = w;
			
			var trackWidth = this._buttonTrack.getStyle("Width");
			if (trackWidth == null)
				trackWidth = w;
			
			//Center horizontally
			this._buttonDecrement._setActualPosition(x + (w / 2) - (buttonDecWidth / 2), y);
			this._buttonDecrement._setActualSize(buttonDecWidth, buttonDecHeight);
			
			this._buttonIncrement._setActualPosition(x + (w / 2) - (buttonIncWidth / 2), y + h - buttonIncHeight);
			this._buttonIncrement._setActualSize(buttonIncWidth, buttonIncHeight);
			
			this._buttonTrack._setActualPosition(x + (w / 2) - (trackWidth / 2), y + buttonDecHeight);
			this._buttonTrack._setActualSize(trackWidth, h - buttonDecHeight - buttonIncHeight);
			
			if (buttonTabWidth == null)
				buttonTabWidth = w;
			if (buttonTabHeight == null)
			{
				minTabSize = (buttonDecHeight + buttonIncHeight);
				
				if (this._scrollPageSize > 0)
					buttonTabHeight = this._buttonTrack._height * (this._scrollViewSize / this._scrollPageSize);
				else
					buttonTabHeight = 0;
				
				buttonTabHeight = Math.max(minTabSize, buttonTabHeight);
			}
			
			availableTrackSize = this._buttonTrack._height - buttonTabHeight;
			pixelsPerScaleUnit = availableTrackSize / (this._scrollPageSize - this._scrollViewSize);
			
			this._buttonTab._setActualPosition(x + (w / 2) - (buttonTabWidth / 2), y + buttonDecHeight + (this._scrollValue * pixelsPerScaleUnit));
			this._buttonTab._setActualSize(buttonTabWidth, buttonTabHeight);
		}
	};	
	
	


/**
 * @depends ToggleButtonElement.js
 * @depends RadioButtonSkinElement.js
 * @depends EllipseShape.js
 */

///////////////////////////////////////////////////////////////////////
/////////////////////RadioButtonElement////////////////////////////////

/**
 * @class RadioButtonElement
 * @inherits ToggleButtonElement
 * 
 * RadioButton is a skinned ToggleButton that adjusts the placement of the skin and label. 
 * ToggleButtonGroup may be used to group radio buttons so only 1 may be selected at a time.
 * 
 * When a label is in use, the skin is placed next to the label rather than underneath and is assumed to be square. 
 * When a label is not in use, the skin will span the entire bounding box.
 * 
 * Being a SkinnableElement, RadioButton proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the RadioButton itself. 
 * 
 * See the default skin RadioButtonSkinElement for additional skin styles.
 * 
 * @seealso RadioButtonSkinElement
 * @seealso ToggleButtonGroup
 * 
 * 
 * @constructor RadioButtonElement 
 * Creates new RadioButtonElement instance.
 */
function RadioButtonElement()
{
	RadioButtonElement.base.prototype.constructor.call(this);
}

//Inherit from ToggleButtonElement
RadioButtonElement.prototype = Object.create(ToggleButtonElement.prototype);
RadioButtonElement.prototype.constructor = RadioButtonElement;
RadioButtonElement.base = ToggleButtonElement;	


/////////////Style Types///////////////////////////////

RadioButtonElement._StyleTypes = Object.create(null);

//New RadioButtonElement specific styles

/**
 * @style LabelPlacement String
 * 
 * Determines if the label should be placed to the left or right of the skin. 
 * Allowable values are "left" or "right".
 */
RadioButtonElement._StyleTypes.LabelPlacement =						{inheritable:false};		// "left" || "right"

/**
 * @style LabelGap Number
 * 
 * Determines distance in pixels the label should be placed from the skin.
 */
RadioButtonElement._StyleTypes.LabelGap =							{inheritable:false};		// number



////////////Default Styles//////////////////////

RadioButtonElement.StyleDefault = new StyleDefinition();

//New RadioButton styles
RadioButtonElement.StyleDefault.setStyle("LabelPlacement", 						"right");
RadioButtonElement.StyleDefault.setStyle("LabelGap", 							5);

//Override base class styles
RadioButtonElement.StyleDefault.setStyle("AllowDeselect", 						false);

RadioButtonElement.StyleDefault.setStyle("PaddingTop",                          0);
RadioButtonElement.StyleDefault.setStyle("PaddingBottom",                       0);
RadioButtonElement.StyleDefault.setStyle("PaddingLeft",                         0);
RadioButtonElement.StyleDefault.setStyle("PaddingRight",                        0);

RadioButtonElement.StyleDefault.setStyle("TextAlign", 							"left");
RadioButtonElement.StyleDefault.setStyle("TextBaseline", 						"middle");

RadioButtonElement.StyleDefault.setStyle("SkinClass", 							RadioButtonSkinElement); //Not necessary, just for completeness

RadioButtonElement.StyleDefault.setStyle("UpSkinClass", 						RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("OverSkinClass", 						RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("DownSkinClass", 						RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("DisabledSkinClass", 					RadioButtonSkinElement);

RadioButtonElement.StyleDefault.setStyle("SelectedUpSkinClass", 				RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("SelectedOverSkinClass", 				RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("SelectedDownSkinClass", 				RadioButtonSkinElement);
RadioButtonElement.StyleDefault.setStyle("SelectedDisabledSkinClass", 			RadioButtonSkinElement);


//Skin Defaults
RadioButtonElement.UpSkinStyleDefault = new StyleDefinition();

RadioButtonElement.UpSkinStyleDefault.setStyle("BackgroundShape",				new EllipseShape());
RadioButtonElement.UpSkinStyleDefault.setStyle("BorderType", 					"solid");
RadioButtonElement.UpSkinStyleDefault.setStyle("BorderThickness", 				1);
RadioButtonElement.UpSkinStyleDefault.setStyle("BorderColor", 					"#333333");
RadioButtonElement.UpSkinStyleDefault.setStyle("BackgroundColor", 				"#EBEBEB");
RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
RadioButtonElement.UpSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));
RadioButtonElement.UpSkinStyleDefault.setStyle("CheckColor", 					"#000000");

RadioButtonElement.OverSkinStyleDefault = new StyleDefinition();

RadioButtonElement.OverSkinStyleDefault.setStyle("BackgroundShape",				new EllipseShape());
RadioButtonElement.OverSkinStyleDefault.setStyle("BorderType", 					"solid");
RadioButtonElement.OverSkinStyleDefault.setStyle("BorderThickness", 			1);
RadioButtonElement.OverSkinStyleDefault.setStyle("BorderColor", 				"#333333");
RadioButtonElement.OverSkinStyleDefault.setStyle("BackgroundColor", 			"#DDDDDD");
RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
RadioButtonElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 			(-.05));
RadioButtonElement.OverSkinStyleDefault.setStyle("CheckColor", 					"#000000");

RadioButtonElement.DownSkinStyleDefault = new StyleDefinition();

RadioButtonElement.DownSkinStyleDefault.setStyle("BackgroundShape",				new EllipseShape());
RadioButtonElement.DownSkinStyleDefault.setStyle("BorderType", 					"solid");
RadioButtonElement.DownSkinStyleDefault.setStyle("BorderThickness", 			1);
RadioButtonElement.DownSkinStyleDefault.setStyle("BorderColor", 				"#333333");
RadioButtonElement.DownSkinStyleDefault.setStyle("BackgroundColor", 			"#CCCCCC");
RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStart", 			(-.06));
RadioButtonElement.DownSkinStyleDefault.setStyle("AutoGradientStop", 			(+.02));
RadioButtonElement.DownSkinStyleDefault.setStyle("CheckColor", 					"#000000");

RadioButtonElement.DisabledSkinStyleDefault = new StyleDefinition();

RadioButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundShape",			new EllipseShape());
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderType", 				"solid");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 		1);
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BorderColor", 			"#999999");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 		"#ECECEC");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 		"linear");
RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 		(+.05));
RadioButtonElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 		(-.05));
RadioButtonElement.DisabledSkinStyleDefault.setStyle("CheckColor", 				"#777777");

//Apply Skin Defaults
RadioButtonElement.StyleDefault.setStyle("UpSkinStyle", 						RadioButtonElement.UpSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("OverSkinStyle", 						RadioButtonElement.OverSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("DownSkinStyle", 						RadioButtonElement.DownSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("DisabledSkinStyle", 					RadioButtonElement.DisabledSkinStyleDefault);

RadioButtonElement.StyleDefault.setStyle("SelectedUpSkinStyle", 				RadioButtonElement.UpSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("SelectedOverSkinStyle", 				RadioButtonElement.OverSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("SelectedDownSkinStyle", 				RadioButtonElement.DownSkinStyleDefault);
RadioButtonElement.StyleDefault.setStyle("SelectedDisabledSkinStyle", 			RadioButtonElement.DisabledSkinStyleDefault);


/////////////Internal Functions/////////////////////	

//@override
RadioButtonElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var measuredSize = {width: padWidth, height: padHeight};
	
		if (this._labelElement != null)
		{
			var labelWidth = this._labelElement._getStyledOrMeasuredWidth();
			var labelHeight = this._labelElement._getStyledOrMeasuredHeight();
			
			measuredSize.height = padHeight + labelHeight;
			measuredSize.width = measuredSize.height + padWidth + labelWidth + this.getStyle("LabelGap");
		}
		else
		{
		    measuredSize.height = padHeight + 14;
		    measuredSize.width = padWidth + 14;
		}
		
		return measuredSize;
	};

//@override	
RadioButtonElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		if (this._labelElement != null)
		{
			var labelPlacement = this.getStyle("LabelPlacement");
			var labelGap = this.getStyle("LabelGap");
			
			for (var prop in this._skins)
			{
				this._skins[prop]._setActualSize(this._height, this._height);
				
				if (labelPlacement == "left")
					this._skins[prop]._setActualPosition(this._width - this._height, 0);
				else
					this._skins[prop]._setActualPosition(0, 0);
			}
			
			if (labelPlacement == "left")
				this._labelElement._setActualPosition(paddingMetrics.getX(), paddingMetrics.getY());
			else
				this._labelElement._setActualPosition(this._height + labelGap + paddingMetrics.getX(), paddingMetrics.getY());
			
			this._labelElement._setActualSize(paddingMetrics.getWidth() - labelGap - this._height, paddingMetrics.getHeight());
		}
		else
		{
			for (var prop in this._skins)
			{
				this._skins[prop]._setActualSize(this._width, this._height);
				this._skins[prop]._setActualPosition(0, 0);
			}
		}
	};	




/**
 * @depends ButtonElement.js
 * @depends DropdownArrowButtonSkinElement.js
 * @depends DataGridDataRenderer.js
 * @depends DataRendererLabelElement.js
 * @depends Tween.js
 * @depends DataListElement.js
 */

//////////////////////////////////////////////////////////////
//////////////////DropdownElement/////////////////////////////

/**
 * @class DropdownElement
 * @inherits ButtonElement
 * 
 * DropdownElement is a compound button that creates a pop-up drop-down list which the user
 * can select a value which is then displayed on the by the Dropdown. The values
 * in the list are generated by a supplied ListCollection and associated styling.
 * 
 * The Dropdown button itself contains a child button which is used to render
 * the divider line and arrow. Dropdown proxies its SkinState style to the arrow
 * button so the arrow button will change states along with the Dropdown itself.
 * See the default skin for the arrow button DropdownArrowButtonSkinElement for additional styles.
 * 
 * @seealso DropdownArrowButtonSkinElement
 * 
 * 
 * @constructor DropdownElement 
 * Creates new DropdownElement instance.
 */
function DropdownElement()
{
	DropdownElement.base.prototype.constructor.call(this);

	this._listCollection = null; //Data collection
	
	this._arrowButton = null;
	
	this._selectedIndex = -1;
	this._selectedItem = null;
	
	this._dataListPopupClipContainer = new CanvasElement();
	this._dataListPopupClipContainer.setStyle("ClipContent", true);
	this._dataListPopup = null;
	
	this._openDirection = null;
	this._openHeight = null;
	this._dropdownManagerMetrics = null;
	
	this._sampledTextWidth = null;
	
	this._openCloseTween = null;
	
	var _self = this;
	
	//Private event listener, need an instance for each DropdownElement, proxy to prototype.
	this._onDropdownListCollectionChangedInstance = 
		function (collectionChangedEvent)
		{
			_self._onDropdownListCollectionChanged(collectionChangedEvent);
		};
		
	this._onDropdownDataListPopupChangedInstance = 
		function (event)
		{
			_self._onDropdownDataListPopupChanged(event);
		};
	
	this._onDropdownDataListPopupLayoutCompleteInstance = 
		function (event)
		{
			_self._onDropdownDataListPopupLayoutComplete(event);
		};
		
	this._onDropdownManagerCaptureEventInstance = 
		function (event)
		{
			_self._onDropdownManagerCaptureEvent(event);
		};
		
	this._onDropdownManagerResizeEventInstance = 
		function (event)
		{
			_self._onDropdownManagerResizeEvent(event);
		};
		
	this._onDropDownEnterFrameInstance = 
		function (event)
		{
			_self._onDropDownEnterFrame(event);
		};
}

//Inherit from ButtonElement
DropdownElement.prototype = Object.create(ButtonElement.prototype);
DropdownElement.prototype.constructor = DropdownElement;
DropdownElement.base = ButtonElement;

////////////Events///////////////////////////////

/**
 * @event changed ElementEvent
 * Dispatched when the drop down selection changes as a result of user input.
 */

/////////////Style Types/////////////////////////

DropdownElement._StyleTypes = Object.create(null);

/**
 * @style ItemLabelFunction Function
 * 
 * A function that returns a text string per a supplied collection item.
 * function (itemData) { return "" }
 */
DropdownElement._StyleTypes.ItemLabelFunction = 			{inheritable:false}; 		// function (itemData) { return "" }

/**
 * @style PopupDataListClass DataListElement
 * 
 * The DataListElement or subclass constructor to be used for the pop up list. 
 */
DropdownElement._StyleTypes.PopupDataListClass =			{inheritable:false};		// DataListElement constructor.

/**
 * @style PopupDataListStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the pop up list element.
 */
DropdownElement._StyleTypes.PopupDataListStyle = 			{inheritable:false}; 		// StyleDefinition

/**
 * @style MaxPopupHeight Number
 * Maximum height in pixels of the pop up list element.
 */
DropdownElement._StyleTypes.MaxPopupHeight = 				{inheritable:false}; 		// number

/**
 * @style ArrowButtonClass CanvasElement
 * 
 * The CanvasElement or subclass constructor to be used for the arrow icon. Defaults to Button. 
 * Note that Dropdown proxies its SkinState style to the arrow button so the arrow will change states with the Dropdown.
 */
DropdownElement._StyleTypes.ArrowButtonClass = 				{inheritable:false}; 		// CanvasElement constructor

/**
 * @style ArrowButtonStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the arrow icon class.
 */
DropdownElement._StyleTypes.ArrowButtonStyle = 				{inheritable:false}; 		// StyleDefinition

/**
 * @style OpenCloseTweenDuration Number
 * 
 * Duration in milliseconds the open and close animation should run.
 */
DropdownElement._StyleTypes.OpenCloseTweenDuration = 		{inheritable:false}; 		// number (milliseconds)

/**
 * @style OpenCloseTweenEasingFunction Function
 * 
 * Easing function used on the open and close animations. Defaults to Tween.easeInOutSine().
 */
DropdownElement._StyleTypes.OpenCloseTweenEasingFunction = 	{inheritable:false}; 		// function (fraction) { return fraction} - see Tween.easing

/**
 * @style PopupDataListClipTopOrBottom Number
 * 
 * Size in pixels to clip off the pop up list. Clips top when opening down, bottom when opening up. 
 * Defaults to 1 to collapse pop up list and dropdown default borders.
 */
DropdownElement._StyleTypes.PopupDataListClipTopOrBottom = 	{inheritable:false}; 		// number


////////////Default Styles////////////////////


/////Arrow default style///////
DropdownElement.ArrowButtonStyleDefault = new StyleDefinition();
DropdownElement.ArrowButtonStyleDefault.setStyle("BorderType", 					"none");
DropdownElement.ArrowButtonStyleDefault.setStyle("BackgroundColor", 			null);
DropdownElement.ArrowButtonStyleDefault.setStyle("SkinClass", 					DropdownArrowButtonSkinElement);

//Note that SkinState is proxied to the arrow button, so the arrow will change state along with the Dropdown (unless you turn mouse back on)
DropdownElement.ArrowButtonStyleDefault.setStyle("MouseEnabled", 				false);

//Wipe out the skin styles provided by button (we're currently just using the base state for all skins).
DropdownElement.ArrowButtonStyleDefault.setStyle("UpSkinStyle", 				null);
DropdownElement.ArrowButtonStyleDefault.setStyle("OverSkinStyle", 				null);
DropdownElement.ArrowButtonStyleDefault.setStyle("DownSkinStyle", 				null);
DropdownElement.ArrowButtonStyleDefault.setStyle("DisabledSkinStyle", 			null);
///////////////////////////////

/////Dropdown DataList Style//////

//DataList Scrollbar style
DropdownElement.DataListScrollBarStyleDefault = new StyleDefinition();
DropdownElement.DataListScrollBarStyleDefault.setStyle("Padding", -1);			//Expand by 1px to share borders

//DataList ListItem style
DropdownElement.DataListItemStyleDefault = new StyleDefinition();
DropdownElement.DataListItemStyleDefault.setStyle("UpSkinStyle", 				DataGridDataRenderer.UpSkinStyleDefault);
DropdownElement.DataListItemStyleDefault.setStyle("AltSkinStyle", 				DataGridDataRenderer.AltSkinStyleDefault);

//DataList style
DropdownElement.DataListStyleDefault = new StyleDefinition();
DropdownElement.DataListStyleDefault.setStyle("ScrollBarStyle", 				DropdownElement.DataListScrollBarStyleDefault);
DropdownElement.DataListStyleDefault.setStyle("ListItemClass", 					DataRendererLabelElement);	//Same as DataList default (not needed)
DropdownElement.DataListStyleDefault.setStyle("ListItemStyle", 					DropdownElement.DataListItemStyleDefault);										
DropdownElement.DataListStyleDefault.setStyle("BorderType", 					"solid");
DropdownElement.DataListStyleDefault.setStyle("BorderThickness", 				1);
DropdownElement.DataListStyleDefault.setStyle("PaddingTop",						1);
DropdownElement.DataListStyleDefault.setStyle("PaddingBottom",					1);
DropdownElement.DataListStyleDefault.setStyle("PaddingLeft",					1);
DropdownElement.DataListStyleDefault.setStyle("PaddingRight",					1);
///////////////////////////////////

DropdownElement.StyleDefault = new StyleDefinition();
DropdownElement.StyleDefault.setStyle("PaddingTop",								4);
DropdownElement.StyleDefault.setStyle("PaddingBottom",							4);
DropdownElement.StyleDefault.setStyle("PaddingRight",							4);
DropdownElement.StyleDefault.setStyle("PaddingLeft",							4);

DropdownElement.StyleDefault.setStyle("PopupDataListClass", 					DataListElement); 								// DataListElement constructor
DropdownElement.StyleDefault.setStyle("PopupDataListStyle", 					DropdownElement.DataListStyleDefault); 			// StyleDefinition
DropdownElement.StyleDefault.setStyle("ArrowButtonClass", 						ButtonElement); 								// Element constructor
DropdownElement.StyleDefault.setStyle("ArrowButtonStyle", 						DropdownElement.ArrowButtonStyleDefault); 		// StyleDefinition
DropdownElement.StyleDefault.setStyle("TextAlign", 								"left"); 								
DropdownElement.StyleDefault.setStyle("MaxPopupHeight", 						200); 											// number
DropdownElement.StyleDefault.setStyle("OpenCloseTweenDuration", 				300); 											// number (milliseconds)
DropdownElement.StyleDefault.setStyle("OpenCloseTweenEasingFunction", 			Tween.easeInOutSine); 							// function (fraction) { return fraction}
DropdownElement.StyleDefault.setStyle("PopupDataListClipTopOrBottom", 			1); 											// number
DropdownElement.StyleDefault.setStyle("ItemLabelFunction", 						DataListElement.DefaultItemLabelFunction); 		// function (itemData) { return "" }


/////////Style Proxy Maps/////////////////////////////

//Proxy map for styles we want to pass to the DataList popup.
DropdownElement._PopupDataListProxyMap = Object.create(null);
DropdownElement._PopupDataListProxyMap.ItemLabelFunction = 				true;
DropdownElement._PopupDataListProxyMap._Arbitrary = 					true;

//Proxy map for styles we want to pass to the arrow button.
DropdownElement._ArrowButtonProxyMap = Object.create(null);
DropdownElement._ArrowButtonProxyMap.SkinState = 						true;
DropdownElement._ArrowButtonProxyMap._Arbitrary = 						true;


/////////////Public///////////////////////////////

/**
 * @function setSelectedIndex
 * Sets the selection collection index. Also updates selected item.
 * 
 * @param index int
 * Collection index to select.
 */
DropdownElement.prototype.setSelectedIndex = 
	function (index)
	{
		if (this._selectedIndex == index)
			return false;
		
		if (this._listCollection == null || index > this._listCollection.length -1)
			return false;
		
		if (index < -1)
			index = -1;
		
		if (this._dataListPopup != null)
			this._dataListPopup.setSelectedIndex(index);
		
		this._selectedIndex = index;
		this._selectedItem = this._listCollection.getItemAt(index);
		this._updateText();

		return true;
	};

/**
 * @function getSelectedIndex
 * Gets the selected collection index.
 * 
 * @returns int
 * Selected collection index or -1 if none selected.
 */	
DropdownElement.prototype.getSelectedIndex = 
	function ()
	{
		return this._selectedIndex;
	};
	
/**
 * @function setSelectedItem
 * Sets the collection item to select, also updates selected index.
 * 
 * @param item Object
 * Collection item to select.
 */	
DropdownElement.prototype.setSelectedItem = 
	function (item)
	{
		var index = this._listCollection.getItemIndex(item);
		this._setSelectedIndex(index);
	};
	
/**
 * @function getSelectedItem
 * Gets the selected collection item.
 * 
 * @returns Object
 * Selected collection item or null if none selected.
 */	
DropdownElement.prototype.getSelectedItem = 
	function ()
	{
		return this._selectedItem;
	};
	
/**
 * @function setListCollection
 * Sets the ListCollection to be used as the data-provider.
 * 
 * @param listCollection ListCollection
 * ListCollection to be used as the data-provider.
 */	
DropdownElement.prototype.setListCollection = 
	function (listCollection)
	{
		if (this._listCollection == listCollection)
			return;
	
		if (this._manager == null)
		{
			this._listCollection = listCollection;
		}
		else
		{
			if (this._listCollection != null)
				this._listCollection.removeEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
			
			this._listCollection = listCollection;
			
			if (this._listCollection != null)
				this._listCollection.addEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
		}
		
		//Fix selected index/item
		if (this._listCollection == null)
		{
			this._selectedIndex = -1;
			this._selectedItem = null;
		}
		else
		{
			if (this._selectedItem != null)
			{
				this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
				
				if (this._selectedIndex == -1)
					this._selectedItem = null;
			}
		}
		
		this._updateText();
		this._sampledTextWidth = null;
		this._invalidateMeasure();
		
		if (this._dataListPopup != null)
			this._dataListPopup.setListCollection(listCollection);
	};	

/**
 * @function open
 * Opens the Dropdown pop up list.
 * 
 * @param animate boolean
 * When true animates the appearance of the pop-up list.
 */	
DropdownElement.prototype.open = 
	function (animate)
	{
		if (this._manager == null || this._listCollection == null || this._listCollection.getLength() == 0)
			return;
	
		if (this._dataListPopup == null)
		{
			this._dataListPopup = this._createDataListPopup();
			this._dataListPopupClipContainer._addChild(this._dataListPopup);
		}
		
		if (this._dropdownManagerMetrics == null)
			this._dropdownManagerMetrics = this.getMetrics(this._manager);
		
		//Add the pop-up list. Wait for layoutcomplete to adjust positioning and size (will set openHeight once done)
		this._addDataListPopup(); 
		
		var tweenDuration = this.getStyle("OpenCloseTweenDuration");
		
		if (animate == false || tweenDuration <= 0)
		{
			if (this._openCloseTween != null && this._openHeight != null) //Tween running 
			{
				this._endOpenCloseTween();
				this._updateTweenPosition(this._openHeight);
			}
		}
		else
		{
			if (this._openCloseTween != null) //Tween running
			{
				if (this._openCloseTween.startVal != 0) //Reverse if closing, ignore if opening.
					this._reverseTween();
			}
			else if (this._openHeight == null) //Dont open if already open
			{
				this._openCloseTween = new Tween();
				this._openCloseTween.startVal = 0; 
				this._openCloseTween.endVal = null;	//Dont know the end val yet (popup size unknown)
				this._openCloseTween.duration = tweenDuration;
				this._openCloseTween.startTime = Date.now();
				this._openCloseTween.easingFunction = this.getStyle("OpenCloseTweenEasingFunction");
				
				this.addEventListener("enterframe", this._onDropDownEnterFrameInstance);
			}
		}
	};
	
/**
 * @function close
 * Closes the Dropdown pop up list.
 * 
 * @param animate boolean
 * When true animates the disappearance of the pop-up list.
 */		
DropdownElement.prototype.close = 
	function (animate)
	{
		var tweenDuration = this.getStyle("OpenCloseTweenDuration");
	
		if (animate == false || tweenDuration <= 0)
		{
			this._endOpenCloseTween();		
			this._removeDataListPopup();
		}
		else 
		{
			if (this._openCloseTween != null) //Tween running
			{
				if (this._openCloseTween.startVal == 0) //Reverse if opening, ignore if closing.
					this._reverseTween();
			}
			else if (this._openHeight != null) //Dont close if already closed
			{
				this._openCloseTween = new Tween();
				this._openCloseTween.startVal = this._openHeight - this.getStyle("PopupDataListClipTopOrBottom");
				this._openCloseTween.endVal = 0;
				this._openCloseTween.duration = tweenDuration;
				this._openCloseTween.startTime = Date.now();
				this._openCloseTween.easingFunction = this.getStyle("OpenCloseTweenEasingFunction");
				
				this.addEventListener("enterframe", this._onDropDownEnterFrameInstance);
			}
		}
	};

	
/////////////Internal///////////////////////////////	
	
/**
 * @function _removeDataListPopup
 * Removes the pop up list and cleans up event listeners.
 */	
DropdownElement.prototype._removeDataListPopup = 
	function ()
	{
		if (this._dataListPopupClipContainer._parent == null)
			return;
	
		this._dataListPopupClipContainer._manager.removeCaptureListener("wheel", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.removeCaptureListener("mousedown", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.removeEventListener("resize", this._onDropdownManagerResizeEventInstance);
		
		this._dataListPopupClipContainer._manager.removeElement(this._dataListPopupClipContainer);
		
		this._dropdownManagerMetrics = null;
		this._openDirection = null;
		this._openHeight = null;
	};

/**
 * @function _addDataListPopup
 * Adds the pop up list and registers event listeners.
 */		
DropdownElement.prototype._addDataListPopup = 
	function ()
	{
		if (this._dataListPopupClipContainer._parent != null)
			return;
		
		var popupHeight = this.getStyle("MaxPopupHeight");
		
		this._dataListPopupClipContainer.setStyle("Width", this._dropdownManagerMetrics._width);
		this._dataListPopupClipContainer.setStyle("Height", popupHeight);
		this._dataListPopupClipContainer.setStyle("X", this._dropdownManagerMetrics._x);
		this._dataListPopupClipContainer.setStyle("Y", this._dropdownManagerMetrics._y + this._dropdownManagerMetrics._height);
		
		this._dataListPopup._setActualPosition(0, 0);
		this._dataListPopup._setActualSize(this._dropdownManagerMetrics._width, popupHeight);
		
		this._manager.addElement(this._dataListPopupClipContainer);
		
		this._dataListPopupClipContainer._manager.addCaptureListener("wheel", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.addCaptureListener("mousedown", this._onDropdownManagerCaptureEventInstance);
		this._dataListPopupClipContainer._manager.addEventListener("resize", this._onDropdownManagerResizeEventInstance);
	};
	
//@private	
DropdownElement.prototype._onDropDownEnterFrame = 
	function (event)
	{
		//Tween created, but layoutcomplete has not yet finished. 
		//When we first create the popup list, we need to wait a cycle for the list layout to finish.
		//However, enter frame fires first *before* the list cycle has finished.
		if (this._openCloseTween.endVal == null)
			return;
	
		var value = this._openCloseTween.getValue(Date.now());
		this._updateTweenPosition(value);
		
		if (value == this._openCloseTween.endVal)
		{
			if (value == 0)
				this.close(false);
			else
				this._endOpenCloseTween();
		}
	};
	
//@private
DropdownElement.prototype._endOpenCloseTween = 
	function ()
	{
		if (this._openCloseTween != null)
		{
			this.removeEventListener("enterframe", this._onDropDownEnterFrameInstance);
			this._openCloseTween = null;
		}
	};
	
//@private	
DropdownElement.prototype._updateTweenPosition = 
	function (value)
	{
		this._dataListPopupClipContainer.setStyle("Height", value);
		
		if (this._openDirection == "up")
			this._dataListPopupClipContainer.setStyle("Y", this._dropdownManagerMetrics._y - value);
		else //if (this._openDirection == "down")
			this._dataListPopup._setActualPosition(0, value - this._dataListPopup._height);
	};
	
/**
 * @function _onDropdownManagerCaptureEvent
 * Capture event handler for CanvasManager "wheel" and "mousedown". Used to close 
 * the drop down when events happen outside the Dropdown or pop up list. Only active when pop up list is open.
 * 
 * @param event ElementEvent
 * ElementEvent to process.
 */	
DropdownElement.prototype._onDropdownManagerCaptureEvent = 
	function (event)
	{
		//Check if the dropdown list is in this target's parent chain.
		var target = event.getTarget();
		while (target != null)
		{
			//Yes, leave the drop down open
			if (target == this._dataListPopup || 
				(event.getType() == "mousedown" && target == this))
				return;
			
			target = target._parent;
		}
		
		//Kill the drop down, event happened outside the popup list.
		this.close(false);
	};
	
/**
 * @function _onDropdownManagerResizeEvent
 * Capture event handler for CanvasManager "resize". Used to close the dropdown.
 * Only active when pop up list is open.
 * 
 * @param event DispatcherEvent
 * DispatcherEvent to process.
 */		
DropdownElement.prototype._onDropdownManagerResizeEvent = 
	function (event)
	{
		this.close(false);
	};

/**
 * @function _onDropdownDataListPopupLayoutComplete
 * Event handler for pop up list "layoutcomplete". 
 * Updates the pop up list height after content size is known and determines
 * if drop down opens up or down depending on available space.
 * 
 * @param event DispatcherEvent
 * DispatcherEvent to process.
 */		
DropdownElement.prototype._onDropdownDataListPopupLayoutComplete =
	function (event)
	{
		var maxHeight = this.getStyle("MaxPopupHeight");
		var height = null;
		
		if (this._dataListPopup.getStyle("ListDirection") == "horizontal")
			height = maxHeight;
		else
		{
			//Get actual Popup list height.
			var contentSize = this._dataListPopup._getContentSize();
			
			if (contentSize < maxHeight)
			{
				if (this._listCollection != null && this._dataListPopup._getNumRenderers() < this._listCollection.getLength())
					height = maxHeight;
				else
					height = contentSize;
			}
			else //contentSize >= maxHeight
				height = maxHeight;
		}
		
		//Determine open up/down and correct if not enough available space.
		var availableBottom = this._manager._height - (this._dropdownManagerMetrics._y + this._dropdownManagerMetrics._height);
		if (availableBottom >= height)
		{
			this._openDirection = "down";
			this._openHeight = height;
		}
		else //if (availableBottom < height)
		{
			var availableTop = this._dropdownManagerMetrics._y;
			if (availableTop >= height)
			{
				this._openDirection = "up";
				this._openHeight = height;
			}
			else //if (availableTop < height)
			{
				if (availableBottom >= availableTop)
				{
					this._openDirection = "down";
					this._openHeight = availableBottom;
				}
				else
				{
					this._openDirection = "up";
					this._openHeight = availableTop;
				}
			}
		}

		//Fix list height
		this._dataListPopup._setActualSize(this._dataListPopup._width, this._openHeight);
		this._dataListPopupClipContainer.setStyle("Height", this._openHeight);
		
		var clipTopOrBottom = this.getStyle("PopupDataListClipTopOrBottom");
		
		if (this._openCloseTween != null)
		{
			if (this._openCloseTween.startVal == 0) //Closing
				this._openCloseTween.endVal = this._openHeight - clipTopOrBottom;
			else //Opening
				this._openCloseTween.startVal = this._openHeight - clipTopOrBottom;
			
			this._onDropDownEnterFrame(null); //Force a tween update.
		}
		else
			this._updateTweenPosition(this._openHeight - clipTopOrBottom);
	};
	
/**
 * @function _onDropdownDataListPopupChanged
 * Event handler for pop up list "changed" event. Updates selected item/index and re-dispatches "changed" event.
 * 
 * @param elementEvent ElementEvent
 * ElementEvent to process.
 */	
DropdownElement.prototype._onDropdownDataListPopupChanged = 
	function (elementEvent)
	{
		this.setSelectedIndex(this._dataListPopup.getSelectedIndex());
		this.close(true);
		this._dispatchEvent(new ElementEvent("changed", false));
	};
	
/**
 * @function _createDataListPopup
 * Generates and sets up a pop up list element instance per styling.
 * 
 * @returns DataListElement
 * New pop up list instance.
 */	
DropdownElement.prototype._createDataListPopup = 
	function ()
	{
		//TODO: Use PopupDataListClass style.
	
		var dataListPopup = new DataListElement();
		dataListPopup._setStyleDefinitionDefault(this._getDefaultStyle("PopupDataListStyle"));
		dataListPopup._setStyleProxy(new StyleProxy(this, DropdownElement._PopupDataListProxyMap));
		dataListPopup.setStyleDefinitions(this.getStyle("PopupDataListStyle"));
		
		dataListPopup.setListCollection(this._listCollection);
		dataListPopup.setSelectedIndex(this._selectedIndex);
		
		dataListPopup.addEventListener("changed", this._onDropdownDataListPopupChangedInstance);
		dataListPopup.addEventListener("layoutcomplete", this._onDropdownDataListPopupLayoutCompleteInstance);
		
		return dataListPopup;
	};
	
//@override	
DropdownElement.prototype._updateText = 
	function ()
	{
		var text = null;
		var labelFunction = this.getStyle("ItemLabelFunction");
		
		if (this._selectedItem == null || labelFunction == null)
			text = this.getStyle("Text");
		else
			text = labelFunction(this._selectedItem);
		
		if (text == null || text == "")
		{
			if (this._labelElement != null)
			{
				this._removeChild(this._labelElement);
				this._labelElement = null;
			}
		}
		else
		{
			if (this._labelElement == null)
			{
				this._labelElement = this._createLabel();
				if (this._labelElement != null)
				{
					this._updateTextColor();
					this._addChild(this._labelElement);
				}
			}
			
			if (this._labelElement != null)
				this._labelElement.setStyle("Text", text);
		}
	};	
	
/**
 * @function _onDropdownListCollectionChanged
 * Event handler for the ListCollection data-providers "collectionchanged" event. 
 * 
 * @param collectionChangedEvent CollectionChangedEvent
 * CollectionChangedEvent to process.
 */	
DropdownElement.prototype._onDropdownListCollectionChanged = 
	function (collectionChangedEvent)
	{
		//Room to optimize here
//		var type = collectionChangedEvent.getKind();
//		var index = collectionChangedEvent.getIndex();
	
		//Fix selected index/item 
		if (this._selectedItem != null)
		{
			this._selectedIndex = this._listCollection.getItemIndex(this._selectedItem);
			
			if (this._selectedIndex == -1)
				this._selectedItem = null;
		}
		
		this._updateText();
		
		this._sampledTextWidth = null;
		this._invalidateMeasure();
	};	
	
//@Override	
DropdownElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		DropdownElement.base.prototype._onCanvasElementAdded.call(this, addedRemovedEvent);
	
		if (this._listCollection != null && this._listCollection.hasEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance) == false)
			this._listCollection.addEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
	};

//@Override	
DropdownElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		DropdownElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		if (this._listCollection != null && this._listCollection.hasEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance) == true)
			this._listCollection.removeEventListener("collectionchanged", this._onDropdownListCollectionChangedInstance);
		
		this.close(false);
	};	

//@private	
DropdownElement.prototype._reverseTween = 
	function ()
	{
		var start = this._openCloseTween.startVal;
		var end = this._openCloseTween.endVal;
		var now = Date.now();
		var elapsed = now - this._openCloseTween.startTime;
		
		this._openCloseTween.startVal = end;
		this._openCloseTween.endVal = start;
		this._openCloseTween.startTime = now + elapsed - this._openCloseTween.duration;		
	};
	
//@Override	
DropdownElement.prototype._onButtonClick = 
	function (elementMouseEvent)
	{
		//Just cancels event if we're disabled.
		DropdownElement.base.prototype._onButtonClick.call(this, elementMouseEvent);
		
		if (elementMouseEvent.getIsCanceled() == true)
			return;
		
		if (this._openCloseTween != null)
			this._reverseTween();
		else 
		{
			if (this._openHeight == null)
				this.open(true);
			else
				this.close(true);
		}
	};	
	
/**
 * @function _createArrowButton
 * Generates and sets up the arrow element instance per styling.
 * 
 * @returns DataListElement
 * New arrow element instance.
 */		
DropdownElement.prototype._createArrowButton = 
	function (arrowClass)
	{
		var newIcon = new (arrowClass)();
		newIcon._setStyleDefinitionDefault(this._getDefaultStyle("ArrowButtonStyle"));
		newIcon._setStyleProxy(new StyleProxy(this, DropdownElement._ArrowButtonProxyMap));
		newIcon.setStyleDefinitions(this.getStyle("ArrowButtonStyle"));
		
		return newIcon;
	};
	
//@private	
DropdownElement.prototype._updateArrowButton = 
	function ()
	{
		var arrowClass = this.getStyle("ArrowButtonClass");
		
		if (arrowClass == null)
		{
			if (this._arrowButton != null)
			{
				this._removeChild(this._arrowButton);
				this._arrowButton = null;
			}
		}
		else
		{
			if (this._arrowButton == null)
			{
				this._arrowButton = this._createArrowButton(arrowClass);
				this._addChild(this._arrowButton);
			}
			else if (this._arrowButton.constructor != arrowClass)
			{ //Class changed
				this._removeChild(this._arrowButton);
				this._arrowButton = this._createArrowButton(arrowClass);
				this._addChild(this._arrowButton);
			}
			else
				this._arrowButton.setStyleDefinitions(this.getStyle("ArrowButtonStyle"));
		}
	};
	
//@Override
DropdownElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DropdownElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ItemLabelFunction" in stylesMap)
		{
			this._sampledTextWidth = null;
			this._invalidateMeasure();
			this._updateText();
		}
		
		if ("PopupDataListStyle" in stylesMap && this._dataListPopup != null)
			this._dataListPopup.setStyleDefinitions(this.getStyle("PopupListStyle"));
		
		if ("ArrowButtonClass" in stylesMap || "ArrowButtonStyle" in stylesMap)
			this._updateArrowButton();
		
		if ("TextStyle" in stylesMap ||
			"TextFont" in stylesMap ||
			"TextSize" in stylesMap ||
			"TextAlign" in stylesMap ||
			"TextBaseline" in stylesMap || 
			"Text" in stylesMap)
		{
			this._sampledTextWidth = null;
			this._invalidateMeasure();
		}
	};
	
/**
 * @function _sampleTextWidths
 * Measures text width of first 10 ListCollection items for measurement.
 * 
 * @returns Number
 * Largest text width in pixels.
 */	
DropdownElement.prototype._sampleTextWidths = 
	function ()
	{
		var labelFont = this._getFontString();
		
		var text = this.getStyle("Text");
		if (text == null)
			text = "";
		
		var measuredTextWidth = CanvasElement._measureText(text, labelFont);
		
		//Sample the first 10 items.
		var labelFunction = this.getStyle("ItemLabelFunction");
		if (this._listCollection != null && labelFunction != null)
		{
			var textWidth = 0;
			for (var i = 0; i < 10; i++)
			{
				if (i == this._listCollection.getLength())
					break;
				
				textWidth = CanvasElement._measureText(labelFunction(this._listCollection.getItemAt(i)), labelFont);
				
				if (textWidth > measuredTextWidth)
					measuredTextWidth = textWidth;
			}
		}
		
		return measuredTextWidth;
	};
	
//@Override
DropdownElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		if (this._sampledTextWidth == null)
			this._sampledTextWidth = this._sampleTextWidths();
		
		var textHeight = this.getStyle("TextSize") + this.getStyle("TextLinePaddingTop") + this.getStyle("TextLinePaddingBottom");
		
		var measuredSize = {width: this._sampledTextWidth + padWidth, height: textHeight + padHeight};
		measuredSize.width += 20; //Add some extra space
		
		if (this._arrowButton != null)
		{
			var iconWidth = this._arrowButton.getStyle("Width");
			var iconHeight = this._arrowButton.getStyle("Height");
			
			if (iconHeight != null && iconHeight > measuredSize.height)
				measuredSize.height = iconHeight;
			if (iconWidth != null)
				measuredSize.width += iconWidth;
			else
				measuredSize.width += Math.round(measuredSize.height * .85);
		}

		return measuredSize;
	};	
	
//@Override	
DropdownElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DropdownElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._openDirection != null) //dropdown open
		{
			//Update the dropdown metrics
			this._dropdownManagerMetrics = this.getMetrics(this._manager);
			
			//Update the widths of the popup container and list. (Heights handled by tween / list layoutcomplete)
			//This is here so that when the Dropdown is using measured width, and the collection changes,
			//it may change the width of the dropdown button, so we need to make sure we keep the widths in sync.
			this._dataListPopupClipContainer.setStyle("Width", this._dropdownManagerMetrics._width);
			this._dataListPopup._setActualSize(this._dropdownManagerMetrics._width, this._dataListPopup._height);
		}
		
		if (this._arrowButton != null)
		{
			var x = paddingMetrics.getX();
			var y = paddingMetrics.getY();
			var w = paddingMetrics.getWidth();
			var h = paddingMetrics.getHeight();
			
			var iconWidth = this._arrowButton.getStyle("Width");
			var iconHeight = this._arrowButton.getStyle("Height");
			
			if (iconHeight == null)
				iconHeight = this._height;
			if (iconWidth == null)
				iconWidth = this._height * .85;
			
			if (this._width < iconWidth)
			{
				this._arrowButton._setActualSize(0, 0);
				this._labelElement._setActualSize(0, 0);
			}
			else
			{
				if (this._labelElement != null)
				{
					this._labelElement._setActualPosition(x, y);
					this._labelElement._setActualSize(w - iconWidth, h);
				}
					
				this._arrowButton._setActualPosition(this._width - iconWidth, y + (h / 2) - (iconHeight / 2));
				this._arrowButton._setActualSize(iconWidth, iconHeight);
			}
		}
	};


/**
 * @depends ButtonElement.js
 */

//////////////////////////////////////////////////////////////////
/////////////DataGridHeaderItemRenderer////////////////////////////

/**
 * @class DataGridHeaderItemRenderer
 * @inherits ButtonElement
 * 
 * Default DataGrid HeaderItem renderer based on Button. 
 * Adds sort icons.
 * 
 * @constructor DataGridHeaderItemRenderer 
 * Creates new DataGridHeaderItemRenderer instance.
 */
function DataGridHeaderItemRenderer()
{
	DataGridHeaderItemRenderer.base.prototype.constructor.call(this);
	
	this._sortAscIcon = null;
	this._sortDescIcon = null;
	this._currentSortDirection = null;
}

//Inherit from ButtonElement
DataGridHeaderItemRenderer.prototype = Object.create(ButtonElement.prototype);
DataGridHeaderItemRenderer.prototype.constructor = DataGridHeaderItemRenderer;
DataGridHeaderItemRenderer.base = ButtonElement;

//////Style Types//////////////////////
DataGridHeaderItemRenderer._StyleTypes = Object.create(null);

/**
 * @style SortAscIconClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the ascending sort icon. 
 * Defaults to Button. HeaderItemRenderer proxies its SkinState style to the sort icons so
 * the sort icons will change state along with the HeaderItemRenderer.
 */
DataGridHeaderItemRenderer._StyleTypes.SortAscIconClass =			{inheritable:false};		// CanvasElement constructor

/**
 * @style SortAscIconStyle StyleDefinition
 * 
 * The StyleDefinition to apply ascending sort icon element.
 */
DataGridHeaderItemRenderer._StyleTypes.SortAscIconStyle =			{inheritable:false};		// StyleDefinition

/**
 * @style SortDescIconClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the descending sort icon. 
 * Defaults to Button. HeaderItemRenderer proxies its SkinState style to the sort icons so
 * the sort icons will change state along with the HeaderItemRenderer.
 */
DataGridHeaderItemRenderer._StyleTypes.SortDescIconClass =			{inheritable:false};		// CanvasElement constructor

/**
 * @style SortDescIconStyle StyleDefinition
 * 
 * The StyleDefinition to apply descending sort icon element.
 */
DataGridHeaderItemRenderer._StyleTypes.SortDescIconStyle =			{inheritable:false};		// StyleDefinition

/**
 * @style IconGap Number
 * 
 * Distance in pixels between the sort icon and the header label.
 */
DataGridHeaderItemRenderer._StyleTypes.IconGap =					{inheritable:false};		// number

/**
 * @style IconPlacement String
 * 
 * Determines placement of the sort icon. Allowable values are "left" or "right".
 */
DataGridHeaderItemRenderer._StyleTypes.IconPlacement =				{inheritable:false};		// "left" || "right"


/////////Default Styles///////////////

DataGridHeaderItemRenderer.StyleDefault = new StyleDefinition();

//Override disabled styles, make them same as "up" state styles.
DataGridHeaderItemRenderer.StyleDefault.setStyle("DisabledSkinStyle", 		ButtonElement.UpSkinStyleDefault);
DataGridHeaderItemRenderer.StyleDefault.setStyle("DisabledTextColor", 		null);

DataGridHeaderItemRenderer.StyleDefault.setStyle("BorderType", 				"none");		
DataGridHeaderItemRenderer.StyleDefault.setStyle("TextSize", 				12);
DataGridHeaderItemRenderer.StyleDefault.setStyle("TextAlign", 				"left");
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingTop",				3);
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingBottom",			3);
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingLeft",				8);
DataGridHeaderItemRenderer.StyleDefault.setStyle("PaddingRight",			8);

/////Sort Icon default styles //////

//Ascending Sort Icon
DataGridHeaderItemRenderer.SortAscIconBgShapeDefault = new ArrowShape();
DataGridHeaderItemRenderer.SortAscIconBgShapeDefault.setStyle("Direction", "up");

DataGridHeaderItemRenderer.SortAscIconStyleDefault = new StyleDefinition();
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BorderType", 				"none");
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BackgroundColor", 			"#444444");
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("BackgroundShape", 			DataGridHeaderItemRenderer.SortAscIconBgShapeDefault);
//Note that SkinState is proxied to the sort icons, so the sort icons will change state along with the HeaderRenderer (unless you turn mouse back on)
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("MouseEnabled", 			false);

//Wipe out the skin styles provided by button (we're currently just using the base state for all skins).
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("UpSkinStyle", 				null);
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("OverSkinStyle", 			null);
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("DownSkinStyle", 			null);
DataGridHeaderItemRenderer.SortAscIconStyleDefault.setStyle("DisabledSkinStyle", 		null);

//Descending Sort Icon
DataGridHeaderItemRenderer.SortDescIconBgShapeDefault = new ArrowShape();
DataGridHeaderItemRenderer.SortDescIconBgShapeDefault.setStyle("Direction", "down");

DataGridHeaderItemRenderer.SortDescIconStyleDefault = new StyleDefinition();
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BorderType", 				"none");
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BackgroundColor", 		"#444444");
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("BackgroundShape", 		DataGridHeaderItemRenderer.SortDescIconBgShapeDefault);
//Note that SkinState is proxied to the sort icons, so the sort icons will change state along with the HeaderRenderer (unless you turn mouse back on)
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("MouseEnabled", 			false);

//Wipe out the skin styles provided by button (we're currently just using the base state for all skins).
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("UpSkinStyle", 			null);
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("OverSkinStyle", 			null);
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("DownSkinStyle", 			null);
DataGridHeaderItemRenderer.SortDescIconStyleDefault.setStyle("DisabledSkinStyle", 		null);
///////////////////////////////////

DataGridHeaderItemRenderer.StyleDefault.setStyle("SortAscIconClass",					ButtonElement);											// CanvasElement constructor
DataGridHeaderItemRenderer.StyleDefault.setStyle("SortAscIconStyle",					DataGridHeaderItemRenderer.SortAscIconStyleDefault);	// StyleDefinition
DataGridHeaderItemRenderer.StyleDefault.setStyle("SortDescIconClass",					ButtonElement);											// CanvasElement constructor
DataGridHeaderItemRenderer.StyleDefault.setStyle("SortDescIconStyle",					DataGridHeaderItemRenderer.SortDescIconStyleDefault);	// StyleDefinition

DataGridHeaderItemRenderer.StyleDefault.setStyle("IconGap",								3);			// number
DataGridHeaderItemRenderer.StyleDefault.setStyle("IconPlacement",						"right");	// "left" || "right"



//////Proxy////////////////////////////
DataGridHeaderItemRenderer._SortIconProxyMap = Object.create(null);

//Proxy the SkinState this way we can trigger icon skin changes when our skin changes without
//impacting the functionality of a custom icon. We'll also disable mouse on the default style.
DataGridHeaderItemRenderer._SortIconProxyMap.SkinState = 		true;


///////////Internal/////////////////////

/**
 * @function _createSortIcon
 * Generates a sort icon based on the IconClass styles.
 * 
 * @param isDecending boolean
 * True if the icon should be a descending icon, false otherwise.
 * 
 * @returns CanvasElement
 * The resulting sort icon element instance.
 */
DataGridHeaderItemRenderer.prototype._createSortIcon = 
	function (isDecending)
	{
		var iconClass = null;
		var iconDefaultStyle = null;
		var iconStyle = null;
		
		if (isDecending == true)
		{
			iconClass = this.getStyle("SortDescIconClass");
			iconDefaultStyle = this._getDefaultStyle("SortDescIconStyle");
			iconStyle = this.getStyle("SortDescIconStyle");
		}
		else
		{
			iconClass = this.getStyle("SortAscIconClass");
			iconDefaultStyle = this._getDefaultStyle("SortAscIconStyle");
			iconStyle = this.getStyle("SortAscIconStyle");
		}
		
		var newIcon = new (iconClass)();
		newIcon._setStyleDefinitionDefault(iconDefaultStyle);
		newIcon._setStyleProxy(new StyleProxy(this,DataGridHeaderItemRenderer._SortIconProxyMap));
		newIcon.setStyleDefinitions(iconStyle);
		
		return newIcon;
	};

/**
 * @function _updateSortIcons
 * Updates sort icons in response to style and list data changes.
 */
DataGridHeaderItemRenderer.prototype._updateSortIcons = 
	function ()
	{
		if (this._listData == null)
			return;
	
		var listData = this._listData;
		var dataCollection = listData._parentGrid._listCollection;
		
		var sortDirection = null;
		
		if (dataCollection != null && 
			dataCollection._collectionSort != null && 
			dataCollection._collectionSort == listData._parentGrid._gridColumns[listData._columnIndex].getStyle("CollectionSort"))
		{
			if (dataCollection._collectionSort._isDecending == true)
				sortDirection = "down";
			else
				sortDirection = "up";
		}

		if (this._currentSortDirection != sortDirection)
		{
			this._currentSortDirection = sortDirection;
			this._invalidateLayout();
		}
		
		if (sortDirection == null)
		{
			if (this._sortAscIcon != null)
				this._sortAscIcon.setStyle("Visible", false);
			if (this._sortDescIcon != null)
				this._sortDescIcon.setStyle("Visible", false);
		}
		else if (sortDirection == "up")
		{
			var upIconClass = this.getStyle("SortAscIconClass");
			
			if (upIconClass == null)
			{
				if (this._sortAscIcon != null)
				{
					this._removeChild(this._sortAscIcon);
					this._sortAscIcon = null;
				}
			}
			else
			{
				if (this._sortAscIcon == null)
				{
					this._sortAscIcon = this._createSortIcon(false);
					this._addChild(this._sortAscIcon);
				}
				else if (this._sortAscIcon.constructor != upIconClass)
				{ //Icon Class changed
					this._removeChild(this._sortAscIcon);
					this._sortAscIcon = this._createSortIcon(false);
					this._addChild(this._sortAscIcon);
				}
				else
					this._sortAscIcon.setStyleDefinitions(this.getStyle("SortAscIconStyle"));
				
				if (this._sortDescIcon != null)
					this._sortDescIcon.setStyle("Visible", false);
				
				this._sortAscIcon.setStyle("Visible", true);
			}
		}
		else if (sortDirection == "down")
		{
			var downIconClass = this.getStyle("SortDescIconClass");
			
			if (downIconClass == null)
			{
				if (this._sortDescIcon != null)
				{
					this._removeChild(this._sortDescIcon);
					this._sortDescIcon = null;
				}
			}
			else
			{
				if (this._sortDescIcon == null)
				{
					this._sortDescIcon = this._createSortIcon(true);
					this._addChild(this._sortDescIcon);
				}
				else if (this._sortDescIcon.constructor != downIconClass)
				{ //Icon Class changed
					this._removeChild(this._sortDescIcon);
					this._sortDescIcon = this._createSortIcon(true);
					this._addChild(this._sortDescIcon);
				}
				else
					this._sortDescIcon.setStyleDefinitions(this.getStyle("SortDescIconStyle"));
				
				if (this._sortAscIcon != null)
					this._sortAscIcon.setStyle("Visible", false);
				
				this._sortDescIcon.setStyle("Visible", true);
			}
		}
	};

//@Override
DataGridHeaderItemRenderer.prototype._setListData = 
	function (listData, itemData)
	{
		DataGridHeaderItemRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		if (listData == null)
			return;
		
		this.setStyle("Text", listData._parentGrid._gridColumns[listData._columnIndex].getStyle("HeaderLabel"));
		this._updateSortIcons();
	};

//@Override
DataGridHeaderItemRenderer.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridHeaderItemRenderer.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("SortAscIconClass" in stylesMap ||
			"SortAscIconStyle" in stylesMap ||
			"SortDescIconClass" in stylesMap ||
			"SortDescIconStyle" in stylesMap)
		{
			this._updateSortIcons();
		}
		
		if ("IconGap" in stylesMap || "IconPlacement" in stylesMap)
			this._invalidateLayout();
	};	
	
//@Override	
DataGridHeaderItemRenderer.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataGridHeaderItemRenderer.base.prototype._doLayout.call(this, paddingMetrics);
	
		//Fix label position to leave room for sort indicator.
		if (this._labelElement != null && this._currentSortDirection != null)
		{
			var sortIcon = null;
			if (this._currentSortDirection == "up")
				sortIcon = this._sortAscIcon;
			else
				sortIcon = this._sortDescIcon;
			
			if (sortIcon != null)
			{
				var x = paddingMetrics.getX();
				var y = paddingMetrics.getY();
				var w = paddingMetrics.getWidth();
				var h = paddingMetrics.getHeight();
				
				var iconWidth = sortIcon.getStyle("Width");
				var iconHeight = sortIcon.getStyle("Height");
				
				if (iconHeight == null)
					iconHeight = paddingMetrics.getHeight() * .35;
				if (iconWidth == null)
					iconWidth = iconHeight * 1.5;
				
				if (w < iconWidth)
				{
					sortIcon._setActualSize(0, 0);
					this._labelElement._setActualSize(0, 0);
				}
				else
				{
					var gap = this.getStyle("IconGap");
					var iconPlacement = this.getStyle("IconPlacement");
					
					if (iconPlacement == "left")
					{
						this._labelElement._setActualPosition(x + iconWidth + gap, y);
						this._labelElement._setActualSize(w - iconWidth - gap, h);
						
						sortIcon._setActualPosition(x, y + (h / 2) - (iconHeight / 2));
						sortIcon._setActualSize(iconWidth, iconHeight);
					}
					else // "right"
					{
						this._labelElement._setActualPosition(x, y);
						this._labelElement._setActualSize(w - iconWidth - gap, h);
						
						sortIcon._setActualPosition(x + w - iconWidth, y + (h / 2) - (iconHeight / 2));
						sortIcon._setActualSize(iconWidth, iconHeight);
					}
				}
			}
		}
	};	


/**
 * @depends DataGridDataRenderer.js
 * @depends DataGridHeaderColumnDividerSkinElement.js
 * @depends ButtonElement.js
 */

//////////////////////////////////////////////////////////////////
/////////////DataGridHeaderElement////////////////////////////////

/**
 * @class DataGridHeaderElement
 * @inherits DataGridDataRenderer
 * 
 * Default DataGrid header element. 
 * Renders header items per parent grid's columns. 
 * Adds drag-able column dividers and updates parent grid's column widths.
 * 
 * 
 * @constructor DataGridHeaderElement 
 * Creates new DataGridHeaderElement instance.
 */
function DataGridHeaderElement()
{
	DataGridHeaderElement.base.prototype.constructor.call(this);
	
	var _self = this;
	
	this._onColumnDividerDragInstance = 
		function (elementEvent)
		{
			_self._onColumnDividerDrag(elementEvent);
		};
}
	
//Inherit from DataGridDataRenderer
DataGridHeaderElement.prototype = Object.create(DataGridDataRenderer.prototype);
DataGridHeaderElement.prototype.constructor = DataGridHeaderElement;
DataGridHeaderElement.base = DataGridDataRenderer;	

/////////////Style Types/////////////////////////

DataGridHeaderElement._StyleTypes = Object.create(null);

/**
 * @style ColumnDividerClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the draggable column divider (defaults to Button). 
 */
DataGridHeaderElement._StyleTypes.ColumnDividerClass = 		{inheritable:false}; 	// Element constructor()

/**
 * @style ColumnDividerStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the column divider element.
 * See default skin class is DataGridHeaderColumnDividerSkinElement for additional styles.
 * 
 * @seealso DataGridHeaderColumnDividerSkinElement
 */
DataGridHeaderElement._StyleTypes.ColumnDividerStyle = 		{inheritable:false}; 	// StyleDefinition

/**
 * @style DraggableColumns boolean
 * 
 * When true, column dividers are draggable.
 */
DataGridHeaderElement._StyleTypes.DraggableColumns = 		{inheritable:false}; 	// StyleDefinition


////////////Default Styles////////////////////

DataGridHeaderElement.StyleDefault = new StyleDefinition();

DataGridHeaderElement.StyleDefault.setStyle("BorderType", 				"solid");
DataGridHeaderElement.StyleDefault.setStyle("BorderThickness", 			1);
DataGridHeaderElement.StyleDefault.setStyle("PaddingBottom", 			1);

//Column Divider button style
DataGridHeaderElement.ColumnDividerStyleDefault = new StyleDefinition();

DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("SkinClass", 				DataGridHeaderColumnDividerSkinElement); //
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("DividerLineColor", 		"#777777");
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("DividerArrowColor", 		"#444444");
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("BorderType", 				"none");
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("BackgroundColor", 		null);
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("Width", 					11);
DataGridHeaderElement.ColumnDividerStyleDefault.setStyle("TabStop", 				-1);


DataGridHeaderElement.StyleDefault.setStyle("ColumnDividerClass", 			ButtonElement);
DataGridHeaderElement.StyleDefault.setStyle("ColumnDividerStyle", 			DataGridHeaderElement.ColumnDividerStyleDefault); 
DataGridHeaderElement.StyleDefault.setStyle("DraggableColumns", 			true);



////////Internal////////////////////////////////

/**
 * @function _onColumnDividerDrag
 * Event handler for column divider "dragging" event. Updates the header item renderers and 
 * parent grid column widths.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */	
DataGridHeaderElement.prototype._onColumnDividerDrag = 
	function (elementEvent)
	{
		if (this._listData == null)
			return;
		
		var parentGrid = this._listData._parentList;
		var dividerRenderer = null;
		var expectedPosition = 0;
		var totalSize = 0;
		var totalPercent = 0;
		var i;
		
		//Record column data
		var columnData = []; 
		for (i = 0; i < parentGrid._gridColumns.length; i++)
		{
			columnData.push(
				{actualSize:parentGrid._columnSizes[i], 
				percentSize:parentGrid._columnPercents[i],
				oldPercentSize:parentGrid._columnPercents[i],
				minSize:parentGrid._gridColumns[i].getStyle("MinSize"),
				minPercent:0});
			
			totalSize += columnData[i].actualSize;
			totalPercent += columnData[i].percentSize;
		}
		
		//Min percent per column based on its min pixel size.
		for (i = 0; i < columnData.length; i++)
			columnData[i].minPercent = columnData[i].minSize / totalSize * totalPercent;
		
		//Calculate new column widths
		var currentColumn = 0;
		for (i = columnData.length; i < this._itemRenderersContainer._children.length; i++)
		{
			dividerRenderer = this._itemRenderersContainer._children[i];
			currentColumn = i - columnData.length;
			
			expectedPosition += columnData[currentColumn].actualSize;
			
			if (dividerRenderer == elementEvent.getCurrentTarget())
			{
				//Columns left of the divider we adjust by pixel and re-calculate their approximate percents.
				//Columns right of the divider we re-calculate their percents, and then determine the pixel size.
				
				expectedPosition = Math.round(expectedPosition - (dividerRenderer._width / 2)); //Round here
				
				var minPosition = expectedPosition;
				var maxPosition = expectedPosition;
				
				//Record "right" side column data, determine maximum slide position.
				var remainingPercent = 0;
				var remainingSize = 0;
				var remainingColumns = [];
				for (var i2 = currentColumn + 1; i2 < columnData.length; i2++)
				{
					remainingColumns.push(columnData[i2]);
					remainingPercent += columnData[i2].percentSize;
					remainingSize += columnData[i2].actualSize;
					maxPosition += columnData[i2].actualSize - columnData[currentColumn].minSize;
				}
				
				//Minimum slide position.
				for (var i2 = currentColumn; i2 >= 0; i2--)
					minPosition -= (columnData[i2].actualSize - columnData[i2].minSize);

				//Correct if we're outside of min/max
				var actualPosition = dividerRenderer._x;
				if (actualPosition < minPosition)
					actualPosition = minPosition;
				if (actualPosition > maxPosition)
					actualPosition = maxPosition;
				
				//Adjust left side columns
				var percentDelta = 0;
				var availableDelta = actualPosition - expectedPosition;
				remainingSize -= availableDelta;
				
				for (var i2 = currentColumn; i2 >= 0; i2--)
				{
					//Adjust size
					if (columnData[i2].actualSize + availableDelta < columnData[i2].minSize)
					{
						availableDelta -= columnData[i2].actualSize - columnData[i2].minSize;
						columnData[i2].actualSize = columnData[i2].minSize;
					}
					else
					{
						columnData[i2].actualSize += availableDelta;
						availableDelta = 0;
					}
					
					//Calculate column's new percent
					columnData[i2].percentSize = columnData[i2].actualSize / totalSize * totalPercent;
					
					//Add up the percent delta to distribute to "right" side columns.
					percentDelta += columnData[i2].percentSize - columnData[i2].oldPercentSize;
					
					if (availableDelta == 0)
						break;
				}
				
				//Calculate new percentages for remaining columns.
				var percentColumns = remainingColumns.slice();		
				var done = false;
				while (done == false)
				{
					done = true;
					for (var i2 = 0; i2 < percentColumns.length; i2++)
					{
						//Break the percent delta up by ratio.
						var delta = percentDelta * (percentColumns[i2].oldPercentSize / remainingPercent);
						
						//We hit minimum percent, use the minimum, remove it from the calculation and restart.
						if (percentColumns[i2].oldPercentSize - delta < percentColumns[i2].minPercent)
						{
							percentColumns[i2].percentSize = percentColumns[i2].minPercent;
							remainingPercent -= percentColumns[i2].minPercent;
							percentDelta -= (percentColumns[i2].oldPercentSize - percentColumns[i2].percentSize);
							
							percentColumns.splice(i2, 1);
							
							done = false;
							break;
						}
						else
							percentColumns[i2].percentSize = percentColumns[i2].oldPercentSize - delta;
					}
				}
	
				//Translate remaining column percents to actual widths.
				CanvasElement._calculateMinMaxPercentSizes(remainingColumns, remainingSize);
				
				break;
			}
		}
		
		//Update Grids column data.
		for (i = 0; i < columnData.length; i++)
		{
			parentGrid._columnSizes[i] = columnData[i].actualSize;
			parentGrid._columnPercents[i] = columnData[i].percentSize;
		}
		
		this._invalidateLayout();
		parentGrid._invalidateLayout(); //For gridlines
		parentGrid._invalidateListRenderersLayout(); //Adjust columns
	};

//@Override
DataGridHeaderElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridHeaderElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("ColumnDividerClass" in stylesMap || "ColumnDividerStyle" in stylesMap)
			this._setListData(this._listData, this._itemData);
		
		if ("DraggableColumns" in stylesMap && this._listData != null)
		{
			var parentGrid = this._listData._parentList;
			var draggableColumns = this.getStyle("DraggableColumns");
			var dividerRenderer = null;
			var hasListener = null;
			
			for (var i = parentGrid._gridColumns.length; i < this._itemRenderersContainer._children.length; i++)
			{
				dividerRenderer = this._itemRenderersContainer._children[i];
				dividerRenderer.setStyle("Draggable", draggableColumns);
				
				hasListener = dividerRenderer.hasEventListener("dragging", this._onColumnDividerDragInstance);
				
				if (draggableColumns == true && hasListener == false)
					dividerRenderer.addEventListener("dragging", this._onColumnDividerDragInstance);
				else if (draggableColumns == false && hasListener == true)
					dividerRenderer.removeEventListener("dragging", this._onColumnDividerDragInstance);
				
				if (draggableColumns == true)
					dividerRenderer.setStyle("Enabled", true);
				else
					dividerRenderer.setStyle("Enabled", false);
			}
		}
	};
	
//@Override
DataGridHeaderElement.prototype._setListData = 
	function (listData, itemData)
	{
		// Call base.base
		DataGridDataRenderer.base.prototype._setListData.call(this, listData, itemData);
		
		if (listData == null)
			return;
		
		var i = 0;
		var renderer = null;
		for (i = 0; i < listData._parentList._gridColumns.length; i++)
		{
			renderer = this._itemRenderersContainer._getChildAt(i);
			
			if (renderer == null)
			{
				renderer = listData._parentList._createHeaderItemRenderer(i);
				this._itemRenderersContainer._addChildAt(renderer, i);
			}
			else
			{
				columnDef = listData._parentList._gridColumns[i];
				
				if (renderer.constructor != columnDef.getStyle("HeaderItemClass"))
				{ //Renderer Class changed
					
					this._itemRenderersContainer._removeChildAt(i);
					renderer = listData._parentList._createHeaderItemRenderer(i);
					this._itemRenderersContainer._addChildAt(renderer, i);
				}
				else
				{ //Update DataGridData
					
					listData._parentList._updateHeaderItemRendererData(renderer, i);
				}
			}
		}
		
		var dividerClass = this.getStyle("ColumnDividerClass");
		var draggableColumns = this.getStyle("DraggableColumns");
		
		var totalElements = listData._parentList._gridColumns.length;
		
		if (dividerClass != null)
			totalElements = (totalElements * 2) - 1;
		
		for (var i2 = i; i2 < totalElements; i2++)
		{
			renderer = this._itemRenderersContainer._getChildAt(i2);
			
			if (renderer != null && renderer.constructor != dividerClass)
			{
				this._itemRenderersContainer._removeChildAt(i2);
				renderer = null;
			}
			
			if (renderer == null)
			{
				renderer = new (dividerClass)();
				renderer._setStyleDefinitionDefault(this._getDefaultStyle("ColumnDividerStyle"));
				renderer.setStyleDefinitions(this.getStyle("ColumnDividerStyle"));
				renderer.setStyle("Draggable", draggableColumns);
				
				if (draggableColumns == true)
					renderer.addEventListener("dragging", this._onColumnDividerDragInstance);
				
				this._itemRenderersContainer._addChildAt(renderer, i2);
			}
			else
				renderer.setStyleDefinitions(this.getStyle("ColumnDividerStyle"));
		}
		
		//Purge excess renderers.
		while (this._itemRenderersContainer._children.length > totalElements)
			this._itemRenderersContainer._removeChildAt(this._itemRenderersContainer._children.length - 1);
		
		//Invalidate, the item renderer container doesnt measure so wont do it for us.
		this._invalidateMeasure();
		this._invalidateLayout();
	};

//@Override	
DataGridHeaderElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		DataGridHeaderElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		if (this._listData == null)
			return;
		
		var parentGrid = this._listData._parentList;
		var dividerRenderer = null;
		var currentPosition = 0;
		var columnSize = 0;
		
		//Size / Position divider lines
		for (var i = parentGrid._columnSizes.length; i < this._itemRenderersContainer._children.length; i++)
		{
			dividerRenderer = this._itemRenderersContainer._children[i];
			columnSize = parentGrid._columnSizes[i - parentGrid._columnSizes.length];
			currentPosition += columnSize;
			
			var dividerHeight = dividerRenderer.getStyle("Height");
			if (dividerHeight == null)
				dividerHeight = Math.round(this._itemRenderersContainer._height * .7);
			
			dividerRenderer._setActualSize(dividerRenderer._getStyledOrMeasuredWidth(), dividerHeight);
			dividerRenderer._setActualPosition(currentPosition - (dividerRenderer._getStyledOrMeasuredWidth() / 2), (this._itemRenderersContainer._height / 2) - (dividerRenderer._height / 2));
		}
	};
	
	
	


/**
 * @depends DataListElement.js
 * @depends DataGridDataRenderer.js
 * @depends DataGridHeaderElement.js
 * @depends CanvasElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////DataGridElement/////////////////////////////////		
	
/**
 * @class DataGridElement
 * @inherits DataListElement
 * 
 * DataGridElement is a data-driven container that renders a header and rows
 * via a supplied ListCollection, DataGridColumnDefinition(s), and Data/Item Renderers.
 * A scroll bar will be added if the collection size exceeds the available area. 
 * DataGridElement only renders visible DataRenderers so collection size does not impact performance
 * and allows the header, rows, header item, and row item classes to be specified and styled if desired.
 * 
 * The default header class is DataGridHeaderElement.
 * The default ListItem DataRenderer (renders a row) is DataGridDataRenderer.
 * 
 * Default header/row ItemRenderers are supplied by the DataGridColumnDefinition and are as follows.
 * The default HeaderItem DataRenderer is DataGridHeaderItemRenderer.
 * The default RowItem DataRenderer DataGridLabelItemRenderer.
 * 
 * 
 * @seealso DataGridHeaderElement
 * @seealso DataGridDataRenderer
 * @seealso DataGridColumnDefinition
 * @seealso DataGridHeaderItemRenderer
 * @seealso DataGridLabelItemRenderer
 * 
 * 
 * @constructor DataGridElement 
 * Creates new DataGridElement instance.
 */
function DataGridElement()
{
	DataGridElement.base.prototype.constructor.call(this);
	
	/**
	 * @member _gridColumns Array
	 * Read Only - Array of DataGridColumnDefinition.
	 */
	this._gridColumns = [];
	
	this._columnSizes = [];
	this._columnPercents = [];	
	
	this._gridHeader = null;
	
	this._gridLineContainer = new CanvasElement();
	this._gridLineContainer.setStyle("MouseEnabled", false);
	this._gridLineContainer.setStyle("ClipContent", true);
	this._addChild(this._gridLineContainer);
	
	var _self = this;
	
	//Private event handler, proxy to prototype.
	this._onDataGridColumnDefinitionChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onDataGridColumnDefinitionChanged(styleChangedEvent);
		};
		
	this._onDataGridRowItemClickInstance = 
		function (elementMouseEvent)
		{
			_self._onDataGridRowItemClick(elementMouseEvent);
		};
		
	this._onDataGridHeaderItemClickInstance = 
		function (elementMouseEvent)
		{
			_self._onDataGridHeaderItemClick(elementMouseEvent);
		};
}

//Inherit from DataListElement
DataGridElement.prototype = Object.create(DataListElement.prototype);
DataGridElement.prototype.constructor = DataGridElement;
DataGridElement.base = DataListElement;

////////////Events////////////////////////////////////////

/**
 * @event listitemclick ElementGridItemClickEvent
 * Dispatched when an ItemRenderer or header is clicked. Includes associated collection item/index.
 */


/////////////Style Types////////////////////////////////////////////

DataGridElement._StyleTypes = Object.create(null);

/**
 * @style HeaderClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataGrid header. Default is DataGridHeaderElement.
 * 
 * @seealso DataGridHeaderElement
 */
DataGridElement._StyleTypes.HeaderClass = 						{inheritable:false};		// Element constructor()

/**
 * @style HeaderStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the header element.
 */
DataGridElement._StyleTypes.HeaderStyle = 						{inheritable:false};		// StyleDefinition

/**
 * @style GridLinesPriority String
 * 
 * Determines which set of grid lines will be rendered first. Allowable values are "vertical" or "horizontal".
 */
DataGridElement._StyleTypes.GridLinesPriority = 				{inheritable:false};		// "vertical" || "horizontal" (Which lines are drawn first / below)

/**
 * @style VerticalGridLinesClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataGrid vertical grid lines. Default is CanvasElement.
 */
DataGridElement._StyleTypes.VerticalGridLinesClass = 			{inheritable:false};		// Element constructor()

/**
 * @style VerticalGridLinesStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the vertical grid line elements.
 */
DataGridElement._StyleTypes.VerticalGridLinesStyle = 			{inheritable:false};		// StyleDefinition

/**
 * @style HorizontalGridLinesClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the DataGrid horizontal grid lines. Default is null.
 */
DataGridElement._StyleTypes.HorizontalGridLinesClass = 			{inheritable:false};		// Element constructor()

/**
 * @style HorizontalGridLinesStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the horizontal grid line elements.
 */
DataGridElement._StyleTypes.HorizontalGridLinesStyle = 			{inheritable:false};		// StyleDefinition


////////////Default Styles/////////////////////////////////////////

DataGridElement.StyleDefault = new StyleDefinition();

/////GridLines default style //////
DataGridElement.GridLineStyleDefault = new StyleDefinition();
DataGridElement.GridLineStyleDefault.setStyle("Width", 					1);				// number
DataGridElement.GridLineStyleDefault.setStyle("Height", 				1); 			// number
DataGridElement.GridLineStyleDefault.setStyle("BackgroundColor", 		"#BBBBBB");		// "#000000"
///////////////////////////////////

/////ScrollBar default style //////
DataGridElement.ScrollBarStyleDefault = new StyleDefinition();
DataGridElement.ScrollBarStyleDefault.setStyle("Padding", 				-1);			// number
///////////////////////////////////

//Override base class styles
DataGridElement.StyleDefault.setStyle("ListItemClass", 					DataGridDataRenderer); 					// Element constructor()	
DataGridElement.StyleDefault.setStyle("ListItemStyle", 					null); 									// StyleDefinition

DataGridElement.StyleDefault.setStyle("BorderType",		 				"solid"); 	
DataGridElement.StyleDefault.setStyle("BorderThickness",	 			1);
DataGridElement.StyleDefault.setStyle("PaddingTop",	 					1);
DataGridElement.StyleDefault.setStyle("PaddingBottom", 					1);
DataGridElement.StyleDefault.setStyle("PaddingLeft",					1);
DataGridElement.StyleDefault.setStyle("PaddingRight", 					1);
DataGridElement.StyleDefault.setStyle("ScrollBarStyle", 				DataGridElement.ScrollBarStyleDefault);	// StyleDefinition

//DataGrid specific
DataGridElement.StyleDefault.setStyle("HeaderClass", 					DataGridHeaderElement); 				// Element constructor()
DataGridElement.StyleDefault.setStyle("HeaderStyle", 					null); 									// StyleDefinition

DataGridElement.StyleDefault.setStyle("GridLinesPriority", 				"vertical"); 							// "vertical" || "horizontal"

DataGridElement.StyleDefault.setStyle("VerticalGridLinesClass", 		CanvasElement); 						// Element constructor()
DataGridElement.StyleDefault.setStyle("VerticalGridLinesStyle", 		DataGridElement.GridLineStyleDefault); 	// StyleDefinition

DataGridElement.StyleDefault.setStyle("HorizontalGridLinesClass", 		null); 									// Element constructor()
DataGridElement.StyleDefault.setStyle("HorizontalGridLinesStyle", 		DataGridElement.GridLineStyleDefault); 	// StyleDefinition
DataGridElement.StyleDefault.setStyle("TabStop", 						0);


///////////Public//////////////////////////////////

/**
 * @function addColumnDefinition
 * Adds a column definition to be rendered by the DataGrid.
 * 
 * @param columnDefinition DataGridColumnDefinition
 * Column definition to be rendered by the DataGrid.
 */
DataGridElement.prototype.addColumnDefinition = 
	function (columnDefinition)
	{
		return this.addColumnDefinitionAt(columnDefinition, this._gridColumns.length);
	};
	
/**
 * @function addColumnDefinitionAt
 * Adds a column definition to be rendered by the DataGrid at a supplied column index.
 * 
 * @param columnDefinition DataGridColumnDefinition
 * Column definition to be rendered by the DataGrid.
 * 
 * @param index int
 * The index to insert the column definition.
 */	
DataGridElement.prototype.addColumnDefinitionAt = 
	function (columnDefinition, index)
	{
		if (!(columnDefinition instanceof DataGridColumnDefinition))
			throw "Invalid DataGridColumnDefinition";
		
		this._gridColumns.splice(index, 0, columnDefinition);
		this._columnPercents.splice(index, 0, columnDefinition.getStyle("PercentSize"));
		
		if (this._manager != null)
			columnDefinition.addEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
		
		this._columnSizes = []; //Force grid to re-calculate column sizes
		this._columnsChanged();
		
		return columnDefinition;
	};
	
/**
 * @function getColumnDefinitionAt
 * Gets the DataGridColumnDefinition at a supplied column index.
 * 
 * @param index int
 * The index to return the DataGridColumnDefinition.
 * 
 * @returns DataGridColumnDefinition
 * The DataGridColumnDefinition at the supplied index.
 */	
DataGridElement.prototype.getColumnDefinitionAt = 
	function (index)
	{
		if (index < 0 || index >= this._gridColumns.length)
			return null;
	
		return this._gridColumns[index];
	};	
	
/**
 * @function removeColumnDefinition
 * Removes a column definition from the DataGrid.
 * 
 * @param columnDefinition DataGridColumnDefinition
 * Column definition to be removed.
 * 
 * @returns DataGridColumnDefinition
 * The removed column definition.
 */	
DataGridElement.prototype.removeColumnDefinition = 
	function (columnDefinition)
	{
		return this.removeColumnDefinitionAt(this._gridColumns.indexOf(columnDefinition));
	};

/**
 * @function removeColumnDefinitionAt
 * Removes a column definition from the DataGrid.
 * 
 * @param index int
 * Column index of definition to be removed.
 * 
 * @returns DataGridColumnDefinition
 * The removed column definition or null if the index was out of range.
 */		
DataGridElement.prototype.removeColumnDefinitionAt = 
	function (index)
	{
		if (index < 0 || index >= this._gridColumns.length)
			return null;
		
		var removed = this._gridColumns.splice(index, 1)[0]; //Returns array of removed items.
		this._columnPercents.splice(index, 1);
		
		if (this._manager != null)
			removed.removeEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
		
		this._columnSizes = []; //Force grid to re-calculate column sizes
		this._columnsChanged();
		
		return removed;
	};

/**
 * @function getNumColumns
 * Gets the number of column definitions.
 * 
 * @returns int
 * Number of column definitions.
 */		
DataGridElement.prototype.getNumColumns = 
	function ()
	{
		return this._gridColumns.length;
	};
	
	
///////////Internal////////////////////////////////
	
/**
 * @function _onDataGridColumnDefinitionChanged
 * Event handler for DataGridColumnDefinition "stylechanged" event. Updates the DataGrid column.
 * 
 * @param styleChangedEvent StyleChangedEvent
 * The StyleChangedEvent to process.
 */	
DataGridElement.prototype._onDataGridColumnDefinitionChanged = 
	function (styleChangedEvent)
	{
		var styleName = styleChangedEvent.getStyleName();
		
		if (styleName == "PercentSize")
		{
			var columnIndex = this._gridColumns.indexOf(styleChangedEvent.getTarget());
			this._columnPercents[columnIndex] = styleChangedEvent.getNewValue();
			this._columnSizes = []; //Force grid to re-calculate column sizes
			this._invalidateLayout();
		}
		else if (styleName == "MinSize")
		{
			this._columnSizes = []; //Force grid to re-calculate column sizes
			this._invalidateLayout();
		}
		else
			this._columnsChanged();
	};

/**
 * @function _columnsChanged
 * Called in response to columns being added/removed or their styles changed.
 * Updates the DataGrid columns.
 */	
DataGridElement.prototype._columnsChanged = 
	function ()
	{
		//Refresh all the ListData, data hasnt changed, but this
		//also tells the renderer to inspect and adjust the columns.
		if (this._gridHeader != null)
		{
			this._gridHeader._setListData(
				this._gridHeader._listData,
				null);
		}
		
		var renderer = null;
		for (var i = 0; i < this._contentPane._children.length; i++)
		{
			renderer = this._contentPane._children[i];
			
			renderer._setListData(
				renderer._listData,
				renderer._itemData);
		}
		
		this._invalidateLayout();
	};

//Override	
DataGridElement.prototype._onDataListCollectionChanged = 
	function (collectionChangedEvent)
	{
		DataGridElement.base.prototype._onDataListCollectionChanged.call(this, collectionChangedEvent);
		
		//Sort may have happened, update the header's data so it can adjust sort icon.
		if (collectionChangedEvent.getKind() == "reset" && this._gridHeader != null)
		{
			//Data hasnt actually changed.
			this._gridHeader._setListData(
				this._gridHeader._listData,
				null);
		}
	};
	
//@Override	
DataGridElement.prototype._onCanvasElementAdded = 
	function (addedRemovedEvent)
	{
		DataGridElement.base.prototype._onCanvasElementAdded.call(this, addedRemovedEvent);
	
		for (var i = 0; i < this._gridColumns.length; i++)
			this._gridColumns[i].addEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
	};

//@Override	
DataGridElement.prototype._onCanvasElementRemoved = 
	function (addedRemovedEvent)
	{
		DataGridElement.base.prototype._onCanvasElementRemoved.call(this, addedRemovedEvent);
		
		for (var i = 0; i < this._gridColumns.length; i++)
			this._gridColumns[i].removeEventListener("stylechanged", this._onDataGridColumnDefinitionChangedInstance);
	};		
	
//@Override
DataGridElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		DataGridElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("HeaderClass" in stylesMap)
		{
			var headerClass = this.getStyle("HeaderClass");
			
			//Destroy if class is null or does not match existing
			if ((headerClass == null && this._gridHeader != null) ||
				this._gridHeader != null && this._gridHeader.constructor != headerClass)
			{
				this._removeChild(this._gridHeader);
				this._gridHeader = null;
			}
			
			//Create
			if (headerClass != null && this._gridHeader == null)
			{
				this._gridHeader = new (headerClass)();
				this._gridHeader._setStyleDefinitionDefault(this._getDefaultStyle("HeaderStyle"));
				
				this._gridHeader._setListData(
					new DataListData(this, -1),
					null);
				
				this._addChild(this._gridHeader);
			}
			
			this._invalidateLayout();
		}
		
		if ("HeaderStyle" in stylesMap && this._gridHeader != null)
			this._gridHeader.setStyleDefinitions(this.getStyle("HeaderStyle"));
		
		if ("GridLinesPriority" in stylesMap ||
			"VerticalGridLinesClass" in stylesMap ||
			"VerticalGridLinesStyle" in stylesMap ||
			"HorizontalGridLinesClass" in stylesMap ||
			"HorizontalGridLinesStyle" in stylesMap)
		{
			this._invalidateLayout();
		}
	};	
	
//@Override		
DataGridElement.prototype._createRenderer = 
	function (itemIndex)
	{
		var newRenderer = new (this.getStyle("ListItemClass"))();
		newRenderer._setStyleDefinitionDefault(this._getDefaultStyle("ListItemStyle"));
		//newRenderer._setStyleProxy(new StyleProxy(this, DataListElement._DataRendererProxyMap));
		newRenderer.setStyleDefinitions(this.getStyle("ListItemStyle"));
		
		this._updateRendererData(newRenderer, itemIndex);
		
		return newRenderer;
	};	

/**
 * @function _createHeaderItemRenderer
 * Generates a header ItemRenderer base on the column definition HeaderItemClass style.
 * 
 * @param columnIndex int
 * Column index associated with the header ItemRenderer.
 * 
 * @returns CanvasElement
 * The new header ItemRenderer instance.
 */		
DataGridElement.prototype._createHeaderItemRenderer = 
	function (columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
		
		var headerItemClass = columnDefinition.getStyle("HeaderItemClass");
		var newRenderer = new (headerItemClass)();
		newRenderer._setStyleDefinitionDefault(columnDefinition._getDefaultStyle("HeaderItemStyle"));
		
		this._updateHeaderItemRendererData(newRenderer, columnIndex);		
		
		newRenderer.addEventListener("click", this._onDataGridHeaderItemClickInstance);
		
		return newRenderer;
	};
	
/**
 * @function _updateHeaderItemRendererData
 * Updates the header ItemRenderer list data.
 * 
 * @param renderer CanvasElement
 * Header ItemRenderer to update.
 * 
 * @param columnIndex int
 * Column index to associate with the header ItemRenderer.
 */		
DataGridElement.prototype._updateHeaderItemRendererData = 
	function (renderer, columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
		
		//Optimize, only create new data if its actually changed.
		var listData = null;
		if (renderer._listData != null && renderer._listData._columnIndex == columnIndex)
			listData = renderer._listData;
		else
			listData = new DataGridItemData(this, -1, columnIndex);
		
		renderer.setStyleDefinitions(columnDefinition.getStyle("HeaderItemStyle"));
		
		renderer._setListData(
			listData,
			null);
	};
	
/**
 * @function _onDataGridHeaderItemClick
 * Event handler for header ItemRenderer "click" event. Sorts the collection if a 
 * CollectionSort is assigned to the DataGridColumDefinition and dispatched "listitemclick" event.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */			
DataGridElement.prototype._onDataGridHeaderItemClick = 
	function (elementMouseEvent)
	{
		var columnIndex = elementMouseEvent.getCurrentTarget()._listData._columnIndex;
		
		var collectionSort = this._gridColumns[columnIndex].getStyle("CollectionSort");
		if (collectionSort != null && collectionSort instanceof CollectionSort)
		{
			if (this._listCollection._collectionSort != collectionSort)
			{
				collectionSort._isDecending = false;
				this._listCollection.setCollectionSort(collectionSort);
				this._listCollection.sort();
			}
			else
			{
				collectionSort._isDecending = !(collectionSort._isDecending);
				this._listCollection.sort();
			}
		}
		
		this._dispatchEvent(new ElementGridItemClickEvent(-1, columnIndex, null));
	};
	
/**
 * @function _createRowItemRenderer
 * Generates a row ItemRenderer base on the column definition RowItemClass style.
 * 
 * @param itemIndex int
 * Collection item index to associate with the row ItemRenderer.
 * 
 * @param columnIndex int
 * Column index to associate with the row ItemRenderer.
 * 
 * @returns CanvasElement
 * The new row ItemRenderer instance.
 */		
DataGridElement.prototype._createRowItemRenderer = 
	function (itemIndex, columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
	
		var rowItemClass = columnDefinition.getStyle("RowItemClass");
		var newRenderer = new (rowItemClass)();
		newRenderer._setStyleDefinitionDefault(columnDefinition._getDefaultStyle("RowItemStyle"));
		
		this._updateRowItemRendererData(newRenderer, itemIndex, columnIndex);		
		
		newRenderer.addEventListener("click", this._onDataGridRowItemClickInstance);
		
		return newRenderer;
	};

/**
 * @function _updateRowItemRendererData
 * Updates the row ItemRenderer list data.
 * 
 * @param renderer CanvasElement
 * Row ItemRenderer to update.
 * 
 * @param itemIndex int
 * Collection item index to associate with the row ItemRenderer.
 * 
 * @param columnIndex int
 * Column index to associate with the row ItemRenderer.
 */		
DataGridElement.prototype._updateRowItemRendererData = 
	function (renderer, itemIndex, columnIndex)
	{
		var columnDefinition = this._gridColumns[columnIndex];
		
		//Optimize, only create new data if its actually changed.
		var listData = null;
		if (renderer._listData != null && renderer._listData._columnIndex == columnIndex && renderer._listData._itemIndex == itemIndex)
			listData = renderer._listData;
		else
			listData = new DataGridItemData(this, itemIndex, columnIndex);
		
		renderer.setStyleDefinitions(columnDefinition.getStyle("RowItemStyle"));
	
		renderer._setListData(
			listData,
			this._listCollection.getItemAt(itemIndex));
	};
	
/**
 * @function _onDataGridRowItemClick
 * Event handler for the row ItemRenderer "click" event. Updates selected index/item and dispatches "listitemclick" and "changed" events.
 * 
 * @param elementMouseEvent ElementMouseEvent
 * The ElementMouseEvent to process.
 */
DataGridElement.prototype._onDataGridRowItemClick = 
	function (elementMouseEvent)
	{
		var itemIndex = elementMouseEvent.getCurrentTarget()._listData._itemIndex;
		var columnIndex = elementMouseEvent.getCurrentTarget()._listData._columnIndex;
		var itemData = elementMouseEvent.getCurrentTarget()._itemData;
		
		var dispatchChanged = false;
		
		if (this.getStyle("Selectable") == true && this.setSelectedIndex(itemIndex) == true)
			dispatchChanged = true;
		
		this._dispatchEvent(new ElementGridItemClickEvent(itemIndex, columnIndex, itemData));
		
		if (dispatchChanged == true)
			this._dispatchEvent(new ElementEvent("changed", false));
	};
	
//@Override
DataGridElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:16, height:16};
	};
	
/**
 * @function _createGridLine
 * Generates a grid line element based on vertical/horizontal GridLinesClass style.
 * 
 * @param direction String
 * The grid line direction "vertical" or "horizontal"
 * 
 * @returns CanvasElement
 * The new grid line element.
 */		
DataGridElement.prototype._createGridLine = 
	function (direction)
	{
		var line = null;
		if (direction == "vertical")
		{
			line = new (this.getStyle("VerticalGridLinesClass"))();
			line._setStyleDefinitionDefault(this._getDefaultStyle("VerticalGridLinesStyle"));
			line.setStyleDefinitions(this.getStyle("VerticalGridLinesStyle"));
		}
		else
		{
			line = new (this.getStyle("HorizontalGridLinesClass"))();
			line._setStyleDefinitionDefault(this._getDefaultStyle("HorizontalGridLinesStyle"));
			line.setStyleDefinitions(this.getStyle("HorizontalGridLinesStyle"));
		}
		
		return line;
	};
	
//@Override	
DataGridElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		if (this._gridHeader != null)
		{
			var headerHeight = this._gridHeader._getStyledOrMeasuredHeight();
			
			var adjustedPadding = new DrawMetrics();
			adjustedPadding._x = paddingMetrics._x;
			adjustedPadding._y = paddingMetrics._y + headerHeight;
			adjustedPadding._width = paddingMetrics._width;
			adjustedPadding._height = paddingMetrics._height - headerHeight;
			
			//Adjust the padding so base() leaves us room for the header
			DataGridElement.base.prototype._doLayout.call(this, adjustedPadding);
		}
		else
			DataGridElement.base.prototype._doLayout.call(this, paddingMetrics);
		
		//Base makes multiple passes, no reason to run below if we're waiting for the DataList to finish anyway.
		if (this._layoutInvalid == true)
			return;
		
		//Size / Position the grid header
		if (this._gridHeader != null)
		{
			this._gridHeader._setActualPosition(this._contentPane._x, paddingMetrics.getY());
			this._gridHeader._setActualSize(paddingMetrics.getWidth(), this._gridHeader._getStyledOrMeasuredHeight());
		}
		
		var i;
		var calculateColumnSizes = false;
		
		//Determine if we need to recalculate column widths (new columns or size change)
		if (this._columnSizes.length != this._gridColumns.length)
			calculateColumnSizes = true;
		else
		{
			var totalSize = 0;
			for (i = 0; i < this._columnSizes.length; i++)
				totalSize += this._columnSizes[i];
			
			if (totalSize != this._contentPane._width)
				calculateColumnSizes = true;
		}
		
		if (calculateColumnSizes == true)
		{
			var columnData = [];
			
			//Record column size info.
			for (i = 0; i < this._gridColumns.length; i++)
			{
				columnData.push(
					{percentSize: this._columnPercents[i], //We dont use column style, its maintained separately. Header can change the percents.
					minSize: this._gridColumns[i].getStyle("MinSize")});
			}
			
			//Calculate actual widths.
			CanvasElement._calculateMinMaxPercentSizes(columnData, this._contentPane._width);
			
			//Update recorded sizes.
			var newColumnSizes = [];
			for (i = 0; i < columnData.length; i++)
				newColumnSizes.push(columnData[i].actualSize);
			
			this._columnSizes = newColumnSizes;
			
			//Invalidate children.
			if (this._gridHeader != null)
				this._gridHeader._invalidateLayout();
			
			this._invalidateListRenderersLayout();
		}
		
		////////Grid Lines//////////////////////////////////////////////////////////////////////////
		this._gridLineContainer._setActualPosition(this._contentPane._x, this._contentPane._y);
		this._gridLineContainer._setActualSize(this._contentPane._width, this._contentPane._height);
		
		var itemIndex = null;
		var lineIndex = 0;
		var gridLine = null;
		var rowRenderer = null;
		var verticalComplete = false;
		var horizontalComplete = false;
		var linePriority = this.getStyle("GridLinesPriority");
		var verticalClass = this.getStyle("VerticalGridLinesClass");
		var verticalStyle = this.getStyle("VerticalGridLinesStyle");
		var horizontalClass = this.getStyle("HorizontalGridLinesClass");
		var horizontalStyle = this.getStyle("HorizontalGridLinesStyle");
		
		while (verticalComplete == false || horizontalComplete == false)
		{
			if ((linePriority == "horizontal" && horizontalComplete == false) || (verticalComplete == true && horizontalComplete == false))
			{
				if (horizontalClass != null)
				{
					for (i = 0; i < this._contentPane._children.length; i++)
					{
						rowRenderer = this._contentPane._children[i];
						itemIndex = rowRenderer._listData._itemIndex;
						if (itemIndex == 0)
							continue;
						
						gridLine = this._gridLineContainer._getChildAt(lineIndex);
						if (gridLine == null)
						{
							gridLine = this._createGridLine("horizontal");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else if (gridLine.constructor != horizontalClass)
						{
							this._gridLineContainer._removeChildAt(lineIndex);
							gridLine = this._createGridLine("horizontal");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else
							gridLine.setStyleDefinitions(horizontalStyle);
						
						gridLine._setActualSize(this._gridLineContainer._width, gridLine.getStyle("Height"));
						gridLine._setActualPosition(0, rowRenderer._y - (gridLine._height / 2));
						
						lineIndex++;
					}
				}
				
				horizontalComplete = true;
			}
			
			if ((linePriority == "vertical" && verticalComplete == false) || (horizontalComplete == true && verticalComplete == false))
			{
				if (verticalClass != null)
				{
					var linePosition = 0;
					for (i = 0; i < this._columnSizes.length - 1; i++)
					{
						linePosition += this._columnSizes[i];
						gridLine = this._gridLineContainer._getChildAt(lineIndex);
						
						if (gridLine == null)
						{
							gridLine = this._createGridLine("vertical");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else if (gridLine.constructor != verticalClass)
						{
							this._gridLineContainer._removeChildAt(lineIndex);
							gridLine = this._createGridLine("vertical");
							this._gridLineContainer._addChildAt(gridLine, lineIndex);
						}
						else
							gridLine.setStyleDefinitions(verticalStyle);
						
						gridLine._setActualSize(gridLine.getStyle("Width"), this._gridLineContainer._height);
						gridLine._setActualPosition(linePosition - (gridLine._width / 2), 0);
						
						lineIndex++;
					}
				}
				
				verticalComplete = true;
			}
		}
		
		//Purge excess line renderers.
		while (lineIndex < this._gridLineContainer._children.length)
			this._gridLineContainer._removeChildAt(this._gridLineContainer._children.length - 1);
	};
	
	




/**
 * @depends StyleableBase.js
 * @depends DataGridHeaderItemRenderer.js
 * @depends DataGridLabelItemRenderer.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////DataGridColumnDefinition////////////////////////////		
	
/**
 * @class DataGridColumnDefinition
 * @inherits StyleableBase
 * 
 * DataGridColumnDefinition defines and stores styles necessary for the DataGrid to render columns.
 * 
 * The default HeaderItemClass is DataGridHeaderItemRenderer.
 * The default RowItemClass is DataGridLabelItemRenderer.
 * 
 * 
 * @seealso DataGridElement
 * @seealso DataGridHeaderItemRenderer
 * @seealso DataGridLabelItemRenderer
 * 
 * @constructor DataGridColumnDefinition 
 * Creates new DataGridColumnDefinition instance.
 */
function DataGridColumnDefinition()
{
	DataGridColumnDefinition.base.prototype.constructor.call(this);
}
	
//Inherit from StyleableBase
DataGridColumnDefinition.prototype = Object.create(StyleableBase.prototype);
DataGridColumnDefinition.prototype.constructor = DataGridColumnDefinition;
DataGridColumnDefinition.base = StyleableBase;

/////////////Style Types///////////////////////////////

DataGridColumnDefinition._StyleTypes = Object.create(null);

/**
 * @style PercentSize Number
 * 
 * The percentage of available space the column should consume. Percentages
 * are allowed to add to more than 100 and will consume all of the available space. 
 */
DataGridColumnDefinition._StyleTypes.PercentSize = 					{inheritable:false};		// number || null

/**
 * @style MinSize Number
 * 
 * Minimum number of pixels the column should consume.
 */
DataGridColumnDefinition._StyleTypes.MinSize = 						{inheritable:false};		// number || null

/**
 * @style HeaderLabel String
 * Text label to be used for the column header.
 */
DataGridColumnDefinition._StyleTypes.HeaderLabel = 					{inheritable:false};		// "string"

/**
 * @style HeaderItemClass CanvasElement
 * 
 * The DataRenderer CanvasElement constructor to be used for the column header. 
 */
DataGridColumnDefinition._StyleTypes.HeaderItemClass = 				{inheritable:false};		// Element constructor()

/**
 * @style HeaderItemStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the HeaderItem DataRenderer.
 */
DataGridColumnDefinition._StyleTypes.HeaderItemStyle = 				{inheritable:false};		// StyleDefinition

/**
 * @style CollectionSort CollectionSort
 * 
 * CollectionSort to be used to sort the column.
 */
DataGridColumnDefinition._StyleTypes.CollectionSort = 				{inheritable:false};		// CollectionSort() 

/**
 * @style RowItemClass CanvasElement
 * 
 * The DataRenderer CanvasElement constructor to be used for this columns rows. 
 */
DataGridColumnDefinition._StyleTypes.RowItemClass = 				{inheritable:false};		// Element constructor()

/**
 * @style RowItemStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the RowItem DataRenderer.
 */
DataGridColumnDefinition._StyleTypes.RowItemStyle = 				{inheritable:false};		// StyleDefinition

/**
 * @style RowItemLabelFunction Function
 * 
 * A function that returns a text string per a supplied collection item and columnIndex. 
 * function (itemData, columnIndex) { return "" }
 */
DataGridColumnDefinition._StyleTypes.RowItemLabelFunction = 		{inheritable:false};		// function (data, columnIndex) { return "" }


/////////Default Styles///////////////////////////////

DataGridColumnDefinition.StyleDefault = new StyleDefinition();

DataGridColumnDefinition.StyleDefault.setStyle("PercentSize", 				100);							// number || null
DataGridColumnDefinition.StyleDefault.setStyle("MinSize", 					12);							// number || null

DataGridColumnDefinition.StyleDefault.setStyle("HeaderLabel", 				"");							// "string"
DataGridColumnDefinition.StyleDefault.setStyle("HeaderItemClass", 			DataGridHeaderItemRenderer);	// Element constructor()
DataGridColumnDefinition.StyleDefault.setStyle("HeaderItemStyle", 			null);							// StyleDefinition
DataGridColumnDefinition.StyleDefault.setStyle("CollectionSort", 			null);							// CollectionSort()

DataGridColumnDefinition.StyleDefault.setStyle("RowItemClass", 				DataGridLabelItemRenderer);		// Element constructor()
DataGridColumnDefinition.StyleDefault.setStyle("RowItemStyle", 				null);							// StyleDefinition
DataGridColumnDefinition.StyleDefault.setStyle("RowItemLabelFunction", 		null);							// function (data, columnIndex) { return "" }




/**
 * @depends RadioButtonElement.js
 * @depends CheckboxSkinElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////CheckboxElement/////////////////////////////////

/**
 * @class CheckboxElement
 * @inherits RadioButtonElement
 * 
 * Checkbox adds "halfSelected" versions of the 4 button states and assigns a default skin. 
 * The HalfSelected state may only be set programmatically. 
 * 
 * Checkbox half selected states:
 * "halfSelectedUp", "halfSelectedOver", "halfSelectedDown", "halfSelectedDisabled".
 * 
 * Being a SkinnableElement, Checkbox proxies its styles to its skins. 
 * You may assign custom skins and assign any styles you wish to apply to all skins to the Checkbox itself. 
 * 
 * See the default skin CheckBoxSkin for additional skin styles.
 * 
 * @seealso CheckboxSkinElement
 * 
 * 
 * @constructor CheckboxElement 
 * Creates new CheckboxElement instance.
 */
function CheckboxElement()
{
	CheckboxElement.base.prototype.constructor.call(this);
}

//Inherit from ToggleButtonElement
CheckboxElement.prototype = Object.create(RadioButtonElement.prototype);
CheckboxElement.prototype.constructor = CheckboxElement;
CheckboxElement.base = RadioButtonElement;	
	
/////////////Style Types///////////////////////////////

CheckboxElement._StyleTypes = Object.create(null);

//New checkbox specific styles, add half selected state.

/**
 * @style HalfSelectedUpSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedUp" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedUpSkinClass = 			{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedUpSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedUp" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedUpSkinStyle = 			{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedUpTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedUp" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedUpTextColor = 			{inheritable:false};		//"#000000"

/**
 * @style HalfSelectedOverSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedOver" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedOverSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedOverSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedOver" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedOverSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedOverTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedOver" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedOverTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style HalfSelectedDownSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedDown" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedDownSkinClass = 		{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedDownSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedDown" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedDownSkinStyle = 		{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedDownTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedDown" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedDownTextColor = 		{inheritable:false};		//"#000000"

/**
 * @style HalfSelectedDisabledSkinClass CanvasElement
 * 
 * The CanvasElement constructor to be used for the checkbox skin when the checkbox is in the "halfSelectedDisabled" state. 
 * This will override SkinClass when equal or higher priority than SkinClass.
 */
CheckboxElement._StyleTypes.HalfSelectedDisabledSkinClass = 	{inheritable:false};		//Element constructor()

/**
 * @style HalfSelectedDisabledSkinStyle StyleDefinition
 * 
 * The StyleDefinition to apply to the "halfSelectedDisabled" state skin element.
 */
CheckboxElement._StyleTypes.HalfSelectedDisabledSkinStyle = 	{inheritable:false};		//StyleDefinition

/**
 * @style HalfSelectedDisabledTextColor String
 * 
 * Hex color value to be used for the checkbox label when the checkbox is in the "halfSelectedDisabled" state. Format like "#FF0000" (red).
 * This will override TextColor when equal or higher priority than TextColor.
 */
CheckboxElement._StyleTypes.HalfSelectedDisabledTextColor = 	{inheritable:false};		//"#000000"	


////////////Default Styles//////////////////////

CheckboxElement.StyleDefault = new StyleDefinition();

CheckboxElement.StyleDefault.setStyle("AllowDeselect", 							true);

CheckboxElement.StyleDefault.setStyle("SkinClass", 								CheckboxSkinElement); //Not necessary, just for completeness

CheckboxElement.StyleDefault.setStyle("UpSkinClass", 							CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("OverSkinClass", 							CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("DownSkinClass", 							CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("DisabledSkinClass", 						CheckboxSkinElement);

CheckboxElement.StyleDefault.setStyle("SelectedUpSkinClass", 					CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("SelectedOverSkinClass", 					CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("SelectedDownSkinClass", 					CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("SelectedDisabledSkinClass", 				CheckboxSkinElement);

CheckboxElement.StyleDefault.setStyle("HalfSelectedUpSkinClass", 				CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("HalfSelectedOverSkinClass", 				CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDownSkinClass", 				CheckboxSkinElement);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledSkinClass", 			CheckboxSkinElement);

CheckboxElement.StyleDefault.setStyle("HalfSelectedUpTextColor", 				"#000000");
CheckboxElement.StyleDefault.setStyle("HalfSelectedOverTextColor", 				"#000000");
CheckboxElement.StyleDefault.setStyle("HalfSelectedDownTextColor", 				"#000000");
CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledTextColor", 			"#888888");


//Skin Defaults
CheckboxElement.UpSkinStyleDefault = new StyleDefinition();

CheckboxElement.UpSkinStyleDefault.setStyle("BorderType", 						"solid");
CheckboxElement.UpSkinStyleDefault.setStyle("BorderThickness", 					1);
CheckboxElement.UpSkinStyleDefault.setStyle("BorderColor", 						"#333333");
CheckboxElement.UpSkinStyleDefault.setStyle("BackgroundColor", 					"#EBEBEB");
CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientStart", 				(+.05));
CheckboxElement.UpSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));
CheckboxElement.UpSkinStyleDefault.setStyle("CheckColor", 						"#000000");

CheckboxElement.OverSkinStyleDefault = new StyleDefinition();

CheckboxElement.OverSkinStyleDefault.setStyle("BorderType", 					"solid");
CheckboxElement.OverSkinStyleDefault.setStyle("BorderThickness", 				1);
CheckboxElement.OverSkinStyleDefault.setStyle("BorderColor", 					"#333333");
CheckboxElement.OverSkinStyleDefault.setStyle("BackgroundColor", 				"#DDDDDD");
CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientStart", 				(+.05));
CheckboxElement.OverSkinStyleDefault.setStyle("AutoGradientStop", 				(-.05));
CheckboxElement.OverSkinStyleDefault.setStyle("CheckColor", 					"#000000");

CheckboxElement.DownSkinStyleDefault = new StyleDefinition();

CheckboxElement.DownSkinStyleDefault.setStyle("BorderType", 					"solid");
CheckboxElement.DownSkinStyleDefault.setStyle("BorderThickness", 				1);
CheckboxElement.DownSkinStyleDefault.setStyle("BorderColor", 					"#333333");
CheckboxElement.DownSkinStyleDefault.setStyle("BackgroundColor", 				"#CCCCCC");
CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientType", 				"linear");
CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientStart", 				(-.06));
CheckboxElement.DownSkinStyleDefault.setStyle("AutoGradientStop", 				(+.02));
CheckboxElement.DownSkinStyleDefault.setStyle("CheckColor", 					"#000000");

CheckboxElement.DisabledSkinStyleDefault = new StyleDefinition();

CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderType", 				"solid");
CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderThickness", 			1);
CheckboxElement.DisabledSkinStyleDefault.setStyle("BorderColor", 				"#999999");
CheckboxElement.DisabledSkinStyleDefault.setStyle("BackgroundColor", 			"#ECECEC");
CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientType", 			"linear");
CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientStart", 			(+.05));
CheckboxElement.DisabledSkinStyleDefault.setStyle("AutoGradientStop", 			(-.05));
CheckboxElement.DisabledSkinStyleDefault.setStyle("CheckColor", 				"#777777");


//Apply Skin Defaults
CheckboxElement.StyleDefault.setStyle("UpSkinStyle", 							CheckboxElement.UpSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("OverSkinStyle", 							CheckboxElement.OverSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("DownSkinStyle", 							CheckboxElement.DownSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("DisabledSkinStyle", 						CheckboxElement.DisabledSkinStyleDefault);

CheckboxElement.StyleDefault.setStyle("SelectedUpSkinStyle", 					CheckboxElement.UpSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("SelectedOverSkinStyle", 					CheckboxElement.OverSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("SelectedDownSkinStyle", 					CheckboxElement.DownSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("SelectedDisabledSkinStyle", 				CheckboxElement.DisabledSkinStyleDefault);

CheckboxElement.StyleDefault.setStyle("HalfSelectedUpSkinStyle", 				CheckboxElement.UpSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("HalfSelectedOverSkinStyle", 				CheckboxElement.OverSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDownSkinStyle", 				CheckboxElement.DownSkinStyleDefault);
CheckboxElement.StyleDefault.setStyle("HalfSelectedDisabledSkinStyle", 			CheckboxElement.DisabledSkinStyleDefault);

/////////////Public Functions////////////////////////////////////////

/**
 * @function setSelected
 * @override
 * Sets the selected state of the Checkbox.
 * 
 * @param isSelected boolean
 * Checkbox adds a half selected state by setting isSelected = 2.
 * 0 (or false) is unchecked, 1 (or true) is checked, and 2 is half checked.
 */	
CheckboxElement.prototype.setSelected = 
	function (isSelected)
	{
		CheckboxElement.base.prototype.setSelected.call(this, isSelected);
	};


/////////////Internal Functions/////////////////////	

//@override
CheckboxElement.prototype._updateState = 
	function ()
	{
		if (this.getStyle("Selected") == 2)
		{
			var newState = "halfSelectedUp";
			
			if (this.getStyle("Enabled") == false)
				newState = "halfSelectedDisabled";
			else
			{
				if (this._mouseIsDown == true)
					newState = "halfSelectedDown";
				else if (this._mouseIsOver == true)
					newState = "halfSelectedOver";
			}
			
			this.setStyle("SkinState", newState);
		}
		else
		{
			//Call base if we're not selected, handles non-selected states.
			CheckboxElement.base.prototype._updateState.call(this);
		}
	};

//@override
CheckboxElement.prototype._getSkinClass = 
	function (state)
	{
		var stateSkinClass = null;
		
		if (state == "halfSelectedUp")
			stateSkinClass = this.getStyleData("HalfSelectedUpSkinClass");
		else if (state == "halfSelectedOver")
			stateSkinClass = this.getStyleData("HalfSelectedOverSkinClass");
		else if (state == "halfSelectedDown")
			stateSkinClass = this.getStyleData("HalfSelectedDownSkinClass");
		else if (state == "halfSelectedDisabled")
			stateSkinClass = this.getStyleData("HalfSelectedDisabledSkinClass");
		else //base class state
			return CheckboxElement.base.prototype._getSkinClass.call(this, state);
		
		var skinClass = this.getStyleData("SkinClass");
		
		if (skinClass.comparePriority(stateSkinClass) > 0) //Use skinClass if higher priority
			return skinClass.value;
		
		return stateSkinClass.value;
	};
	
//@override	
CheckboxElement.prototype._getSkinStyleDefinitions = 
	function (state)
	{
		if (state == "halfSelectedUp")
			return this.getStyle("HalfSelectedUpSkinStyle");
		else if (state == "halfSelectedOver")
			return this.getStyle("HalfSelectedOverSkinStyle");
		else if (state == "halfSelectedDown")
			return this.getStyle("HalfSelectedDownSkinStyle");
		else if (state == "halfSelectedDisabled")
			return this.getStyle("HalfSelectedDisabledSkinStyle");
		
		return CheckboxElement.base.prototype._getSkinStyleDefinitions.call(this, state);
	};

//@override
CheckboxElement.prototype._getSkinStyleDefinitionDefault =
	function (state)
	{
		if (state == "halfSelectedUp")
			return this._getDefaultStyle("HalfSelectedUpSkinStyle");
		else if (state == "halfSelectedOver")
			return this._getDefaultStyle("HalfSelectedOverSkinStyle");
		else if (state == "halfSelectedDown")
			return this._getDefaultStyle("HalfSelectedDownSkinStyle");
		else if (state == "halfSelectedDisabled")
			return this._getDefaultStyle("HalfSelectedDisabledSkinStyle");
		
		return CheckboxElement.base.prototype._getSkinStyleDefinitionDefault.call(this, state);
	};	
	
//@override
CheckboxElement.prototype._getTextColor = 
	function (state)
	{
		var stateTextColor = null;
		
		if (state == "halfSelectedUp")
			stateTextColor = this.getStyleData("HalfSelectedUpTextColor");
		else if (state == "halfSelectedOver")
			stateTextColor = this.getStyleData("HalfSelectedOverTextColor");
		else if (state == "halfSelectedDown")
			stateTextColor = this.getStyleData("HalfSelectedDownTextColor");
		else if (state == "halfSelectedDisabled")
			stateTextColor = this.getStyleData("HalfSelectedDisabledTextColor");
		else //base class state
			return CheckboxElement.base.prototype._getTextColor.call(this, state);
	
		var textColor = this.getStyleData("TextColor");
		
		if (textColor.comparePriority(stateTextColor) > 0) //Use textColor if higher priority
			return textColor.value;
		
		return stateTextColor.value;
	};

//@override
CheckboxElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		CheckboxElement.base.prototype._doStylesUpdated.call(this, stylesMap);
	
		//Always update these, they don't do anything if no changes, and
		//this already maps our current state to our skin class.
		this._updateSkinClass("halfSelectedUp");
		this._updateSkinStyleDefinitions("halfSelectedUp");
		
		this._updateSkinClass("halfSelectedOver");
		this._updateSkinStyleDefinitions("halfSelectedOver");
		
		this._updateSkinClass("halfSelectedDown");
		this._updateSkinStyleDefinitions("halfSelectedDown");
		
		this._updateSkinClass("HalfSelectedDisabled");
		this._updateSkinStyleDefinitions("halfSelectedDisabled");
	};	
	
	


/**
 * @depends ContainerBaseElement.js
 */

///////////////////////////////////////////////////////////////////////////	
///////////////////////AnchorContainerElement//////////////////////////////

/**
 * @class AnchorContainerElement
 * @inherits ContainerBaseElement
 * 
 * The AnchorContainer can be used to lay out children via absolute or constraint positioning.
 * This container uses children's styles X, Y, Width, Height, PercentWidth, PercentHeight,
 * Top, Bottom, Left, Right, Horizontal Center, and Vertical Center. Nesting containers
 * is the best way to quickly and simply build complex layouts.
 * 
 * X, Y, Width, and Height are treated as highest priority and will override other styles.
 * Elements Z index is determined by the order they are added (child index).
 * You may use styles such as Top and Bottom in conjunction to relatively size elements.
 * You may also combine styles such as Left or X and PercentWidth. Most styles are combine-able unless
 * they are in direct conflict with each other such as having a Left, Right, and Width which under
 * this scenario the Right style will be ignored. Exact behavior of conflicting styles is not defined 
 * and subject to change. 
 * 
 * See the associated style documentation for additional details.
 * 
 * @constructor AnchorContainerElement 
 * Creates new AnchorContainerElement instance.
 */
function AnchorContainerElement()
{
	AnchorContainerElement.base.prototype.constructor.call(this);
}

//Inherit from ContainerBaseElement
AnchorContainerElement.prototype = Object.create(ContainerBaseElement.prototype);
AnchorContainerElement.prototype.constructor = AnchorContainerElement;
AnchorContainerElement.base = ContainerBaseElement;	
	
//@Override
AnchorContainerElement.prototype._doMeasure = 
	function (padWidth, padHeight)
	{
		var contentSize = {width:0, height:0}; 
		
		var child = null; //for convienence
		
		var x;
		var y;
		var width;
		var height;
		var pWidth;
		var pHeight;
		var minWidth;
		var minHeight;
		var maxWidth;
		var maxHeight;
		var top;
		var left;
		var bottom;
		var right;
		var hCenter;
		var vCenter;
		var rotateDegrees;
		var rotateCenterX;
		var rotateCenterY;
		var rotatedMetrics;
		
		var tempX;
		var tempY;
		var tempWidth;
		var tempHeight;
		var tempRotateDegrees;
		var tempRotateCenterX;
		var tempRotateCenterY;
		
		for (var i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			var childSize = {width: 0, height:0};
			
			x = child.getStyle("X");
			y = child.getStyle("Y");
			top = child.getStyle("Top");
			left = child.getStyle("Left");
			bottom = child.getStyle("Bottom");
			right = child.getStyle("Right");
			width = child.getStyle("Width");
			height = child.getStyle("Height");
			minWidth = child.getStyle("MinWidth");
			minHeight = child.getStyle("MinHeight");
			maxWidth = child.getStyle("MaxWidth");
			maxHeight = child.getStyle("MaxHeight");
			hCenter = child.getStyle("HorizontalCenter");
			vCenter = child.getStyle("VerticalCenter");
			rotateDegrees = child.getStyle("RotateDegrees");
			rotateCenterX = child.getStyle("RotateCenterX");
			rotateCenterY = child.getStyle("RotateCenterY");
			
			if (minWidth == null)
				minWidth = 0;
			if (minHeight == null)
				minHeight = 0;
			if (maxWidth == null)
				maxWidth = Number.MAX_VALUE;
			if (maxHeight == null)
				maxHeight = Number.MAX_VALUE;
			
			if (rotateDegrees != 0)
			{
				if (width == null)
				{
					width = child._measuredWidth;
					width = Math.min(width, maxWidth);
					width = Math.max(width, minWidth);
				}
				
				if (height == null)
				{
					height = child._measuredHeight;
					height = Math.min(height, maxHeight);
					height = Math.max(height, minHeight);
				}
				
				//Record child's current x/y & w/h & rotation
				tempX = child._x;
				tempY = child._y;
				tempWidth = child._width;
				tempHeight = child._height;
				tempRotateDegrees = child._rotateDegrees;
				tempRotateCenterX = child._rotateCenterX;
				tempRotateCenterY = child._rotateCenterY;
				
				//TODO: Update getMetrics() so we can pass child values.
				//Spoof the rotation position/size so we can get parent metrics.
				child._x = x == null ? 0 : x;
				child._y = y == null ? 0 : y;
				child._width = width;
				child._height = height;
				child._rotateDegrees = rotateDegrees;
				child._rotateCenterX = rotateCenterX == null ? 0 : rotateCenterX;
				child._rotateCenterY = rotateCenterY == null ? 0 : rotateCenterY;
				
				//Get parent metrics for spoof position
				rotatedMetrics = child.getMetrics(this);
				
				//Put back current values
				child._x = tempX;
				child._y = tempY;
				child._width = tempWidth;
				child._height = tempHeight;
				child._rotateDegrees = tempRotateDegrees;
				child._rotateCenterX = tempRotateCenterX;
				child._rotateCenterY = tempRotateCenterY;
				
				if (rotateCenterX != null && rotateCenterY != null)
				{
					x = Math.max(rotatedMetrics.getX(), 0);
					y = Math.max(rotatedMetrics.getY(), 0);
				}
				else
				{
					//prioritize x/y over left/top (but they're the same)
					if (x == null)
						x = left;
					if (y == null)
						y = top;
					
					if (x == null && right != null)
						childSize.width += right;
					if (y == null && bottom != null)
						childSize.height += bottom;
				}
				
				childSize.width += Math.ceil(rotatedMetrics.getWidth());
				childSize.height += Math.ceil(rotatedMetrics.getHeight());
			}
			else //Non-Rotated Element
			{
				//prioritize x/y over left/top (but they're the same)
				if (x == null)
					x = left;
				if (y == null)
					y = top;
				
				pWidth = child.getStyle("PercentWidth");
				pHeight = child.getStyle("PercentHeight");
								
				//right/bottom cannot be used when both x/y and width/height are in use.
				if ((width == null || x == null) && right != null)
					childSize.width += right;
				if ((height == null || y == null) && bottom != null)
					childSize.height += bottom;
				
				//No explicit sizing
				if (width == null)
				{
					//Add size for measured or min
					if (pWidth == null && (left == null || right == null))
					{
						width = child._measuredWidth;
						width = Math.min(width, maxWidth);
						width = Math.max(width, minWidth);
					}
					else
						width = minWidth;
				}
				if (height == null)
				{
					if (pHeight == null && (top == null || bottom == null))
					{
						height = child._measuredHeight;
						height = Math.min(height, maxHeight);
						height = Math.max(height, minHeight);
					}
					else
						height = minHeight;
				}
				
				childSize.width += width;
				childSize.height += height;
			}
			
			if (x == null && right == null && hCenter != null)
				childSize.width += Math.abs(hCenter * 2);
			if (y == null && bottom == null && vCenter != null)
				childSize.height += Math.abs(vCenter * 2);
			
			if (x == null || x < 0)
				x = 0;
			if (y == null || y < 0)
				y = 0;
			
			childSize.width += x;
			childSize.height += y;
			
			contentSize.width = Math.max(contentSize.width, Math.ceil(childSize.width));
			contentSize.height = Math.max(contentSize.height, Math.ceil(childSize.height));
		}
		
		return contentSize;
	};
	
//@Override
AnchorContainerElement.prototype._doLayout =
	function(paddingMetrics)
	{
		AnchorContainerElement.base.prototype._doLayout.call(this, paddingMetrics);
	
		var child = null;
		
		var x = null;
		var y = null;
		var width = null;
		var height = null;
		var pWidth = null;
		var pHeight = null;
		var minWidth = null;
		var maxWidth = null;
		var minHeight = null;
		var maxHeight = null;		
		var top = null;
		var left = null;
		var bottom = null;
		var right = null;
		var hCenter = null;
		var vCenter = null;
		var rotateDegrees = null;
		var rotateCenterX = null;
		var rotateCenterY = null;
		var rotatedMetrics = null;
		
		for (var i = 0; i < this._elements.length; i++)
		{
			child = this._elements[i];
			if (child.getStyle("IncludeInLayout") == false)
				continue;
			
			x = child.getStyle("X");
			y = child.getStyle("Y");
			top = child.getStyle("Top");
			left = child.getStyle("Left");
			bottom = child.getStyle("Bottom");
			right = child.getStyle("Right");
			width = child.getStyle("Width");
			height = child.getStyle("Height");
			minWidth = child.getStyle("MinWidth");
			minHeight = child.getStyle("MinHeight");
			maxWidth = child.getStyle("MaxWidth");
			maxHeight = child.getStyle("MaxHeight");
			hCenter = child.getStyle("HorizontalCenter");
			vCenter = child.getStyle("VerticalCenter");
			rotateDegrees = child.getStyle("RotateDegrees");
			rotateCenterX = child.getStyle("RotateCenterX");
			rotateCenterY = child.getStyle("RotateCenterY");
			
			if (minWidth == null)
				minWidth = 0;
			if (minHeight == null)
				minHeight = 0;
			if (maxWidth == null)
				maxWidth = Number.MAX_VALUE;
			if (maxHeight == null)
				maxHeight = Number.MAX_VALUE;
			
			child._setActualRotation(rotateDegrees, rotateCenterX, rotateCenterY);
			
			if (rotateDegrees != 0)
			{
				if (width == null)
				{
					width = child._measuredWidth;
					width = Math.min(width, maxWidth);
					width = Math.max(width, minWidth);
				}
				
				if (height == null)
				{
					height = child._measuredHeight;
					height = Math.min(height, maxHeight);
					height = Math.max(height, minHeight);
				}
				
				child._setActualSize(width, height);
				
				if (rotateCenterX == null || rotateCenterY == null)
				{
					//prioritize x/y over left/top (but they're the same)
					if (x == null)
						x = left;
					if (y == null)
						y = top;
					
					if (x == null || y == null)
					{
						rotatedMetrics = child.getMetrics(this);
						
						width = Math.ceil(rotatedMetrics.getWidth());
						height = Math.ceil(rotatedMetrics.getHeight());
						
						if (x == null && right != null)
							x = this._width - width - right;
						
						if (y == null && bottom != null)
							y = this._height - height - bottom;
						
						if (x == null && hCenter != null)
							x = Math.round((this._width / 2) - (width / 2) + hCenter);
						
						if (y == null && vCenter != null)
							y = Math.round((this._height / 2) - (height / 2) + vCenter);
					}
					
					if (x == null)
						x = 0;
					if (y == null)
						y = 0;
					
					child._setRelativePosition(x, y, this);
				}
				else
				{
					if (x == null)
						x = 0;
					if (y == null)
						y = 0;
					
					child._setActualPosition(x, y);
				}
			}
			else //Non-Rotated Element
			{
				pWidth = child.getStyle("PercentWidth");
				pHeight = child.getStyle("PercentHeight");
			
				//prioritize x/y over left/top (but they're the same)
				if (x == null)
					x = left;
				if (y == null)
					y = top;
				
				if (width == null)
				{
					if (x != null && right != null)
						width = this._width - x - right;
					else
					{
						if (pWidth != null)
							width = Math.round(this._width * (pWidth / 100));
						else
							width = child._measuredWidth;
					}
					
					width = Math.min(width, maxWidth);
					width = Math.max(width, minWidth);
				}
				
				if (height == null)
				{
					if (y != null && bottom != null)
						height = this._height - y - bottom;
					else
					{
						if (pHeight != null)
							height = Math.round(this._height * (pHeight / 100));
						else
							height = child._measuredHeight;
					}
					
					height = Math.min(height, maxHeight);
					height = Math.max(height, minHeight);
				}
				
				if (x == null && right != null)
					x = this._width - width - right;
				
				if (y == null && bottom != null)
					y = this._height - height - bottom;
				
				if (x == null && hCenter != null)
					x = Math.round((this._width / 2) - (width / 2) + hCenter);
				
				if (y == null && vCenter != null)
					y = Math.round((this._height / 2) - (height / 2) + vCenter);
				
				if (x == null)
					x = 0;
				if (y == null)
					y = 0;
				
				child._setActualPosition(x, y);
				child._setActualSize(width, height);
			}
		}
	};	
	
	


/**
 * @depends CanvasElement.js
 * @depends AnchorContainerElement.js
 */

///////////////////////////////////////////////////////////////////////
///////////////////////ViewportElement/////////////////////////////////	
	
/**
 * @class ViewportElement
 * @inherits CanvasElement
 * 
 * Viewport is an AnchorContainer that only supports one child element (usually another container).
 * When the child is too large for the view area, the Viewport will optionally pop up scroll bars.
 * 
 * This class needs more work. More styles are needed for controlling tween behavior and allowing
 * scrolling even if scroll bars are disabled.
 *  
 * 
 * @constructor ViewportElement 
 * Creates new ViewportElement instance.
 */
function ViewportElement()
{
	ViewportElement.base.prototype.constructor.call(this);
	
	this._viewElement = null;
	
	this._horizontalScrollBar = null;
	this._verticalScrollBar = null;
	
	this._viewPortContainer = new ViewportAnchorContainerElement();
	this._addChild(this._viewPortContainer);
	
	var _self = this;
	
	//Private event handler, need different instance for each Viewport, proxy to prototype.
	this._onViewportScrollBarChangeInstance =
		function (elementEvent)
		{
			_self._onViewportScrollBarChange(elementEvent);
		};
		
	this._onViewportMouseWheelEventInstance = 
		function (elementMouseWheelEvent)
		{
			_self._onViewportMouseWheelEvent(elementMouseWheelEvent);
		};
		
	this.addEventListener("wheel", this._onViewportMouseWheelEventInstance);
}

//Inherit from CanvasElement
ViewportElement.prototype = Object.create(CanvasElement.prototype);
ViewportElement.prototype.constructor = ViewportElement;
ViewportElement.base = CanvasElement;

/////////////Style Types////////////////////////////////////////////

ViewportElement._StyleTypes = Object.create(null);

/**
 * @style HorizontalScrollBarDisplay String
 * Determines the behavior of the horizontal scroll bar. Allowable values are "on", "off", or "auto".
 */
ViewportElement._StyleTypes.HorizontalScrollBarDisplay = 		{inheritable:false};		// "on" || "off" || "auto"

/**
 * @style HorizontalScrollBarPlacement String
 * Determines the position of the horizontal scroll bar. Allowable values are "top" or "bottom".
 */
ViewportElement._StyleTypes.HorizontalScrollBarPlacement = 		{inheritable:false};		// "top" || "bottom"

/**
 * @style VerticalScrollBarDisplay String
 * Determines the behavior of the vertical scroll bar. Allowable values are "on", "off", or "auto".
 */
ViewportElement._StyleTypes.VerticalScrollBarDisplay = 			{inheritable:false};		// "on" || "off" || "auto"

/**
 * @style VerticalScrollBarPlacement String
 * Determines the position of the vertical scroll bar. Allowable values are "left" or "right".
 */
ViewportElement._StyleTypes.VerticalScrollBarPlacement = 		{inheritable:false};		// "left" || "right"

//ScrollBar styles.
/**
 * @style HorizontalScrollBarStyle StyleDefinition
 * The StyleDefinition to be applied to the horizontal scroll bar.
 */
ViewportElement._StyleTypes.HorizontalScrollBarStyle = 			{inheritable:false};		// StyleDefinition

/**
 * @style VerticalScrollBarStyle StyleDefinition
 * The StyleDefinition to be applied to the vertical scroll bar.
 */
ViewportElement._StyleTypes.VerticalScrollBarStyle = 			{inheritable:false};		// StyleDefinition


////////////Default Styles///////////////////////////////////////

ViewportElement.StyleDefault = new StyleDefinition();

ViewportElement.StyleDefault.setStyle("HorizontalScrollBarDisplay", 					"auto");
ViewportElement.StyleDefault.setStyle("HorizontalScrollBarPlacement", 					"bottom");

ViewportElement.StyleDefault.setStyle("VerticalScrollBarDisplay", 						"auto");
ViewportElement.StyleDefault.setStyle("VerticalScrollBarPlacement", 					"right");

ViewportElement.StyleDefault.setStyle("HorizontalScrollBarStyle", 						null);
ViewportElement.StyleDefault.setStyle("VerticalScrollBarStyle", 						null);



/////////////Public///////////////////////////////

/**
 * @function setElement
 * Sets the child element of the Viewport.
 * 
 * @param element CanvasElement
 * The child element of the Viewport (or null).
 */
ViewportElement.prototype.setElement = 
	function (element)
	{
		if (this._viewElement != null)
			this._viewPortContainer.removeElement(this._viewElement);
		
		this._viewElement = element;
		
		if (this._viewElement != null)
			this._viewPortContainer.addElement(this._viewElement);
		
		this._invalidateLayout();
	};


////////////Internal//////////////////////////////
	
/**
 * @function _onViewportScrollBarChange
 * Event handler for the scroll bar "changed" event. Updates the child elements position within the Viewport.
 * 
 * @param elementEvent ElementEvent
 * The ElementEvent to process.
 */		
ViewportElement.prototype._onViewportScrollBarChange = 
	function (elementEvent)
	{
		this._invalidateLayout();
	};
	
/**
 * @function _onViewportMouseWheelEvent
 * Event handler for the Viewport's "wheel" event. Starts the scroll bar tween.
 * 
 * @param elementMouseWheelEvent ElementMouseWheelEvent
 * The ElementMouseWheelEvent to process.
 */		
ViewportElement.prototype._onViewportMouseWheelEvent = 
	function (elementMouseWheelEvent)
	{
		if (elementMouseWheelEvent.getDefaultPrevented() == true)
			return;
	
		var consumeEvent = false;
		
		var scrollPageSize = null;
		var scrollViewSize = null;
		var scrollLineSize = null;
		var scrollValue = null;
		var maxScrollValue = null;
		
		var deltaX = elementMouseWheelEvent.getDeltaX();
		var deltaY = elementMouseWheelEvent.getDeltaY();
		
		if (deltaX != 0 && this._horizontalScrollBar != null)
		{
			scrollPageSize = this._horizontalScrollBar.getScrollPageSize();
			scrollViewSize = this._horizontalScrollBar.getScrollViewSize();
			scrollLineSize = this._horizontalScrollBar.getScrollLineSize();
			
			maxScrollValue = scrollPageSize - scrollViewSize;
			if (maxScrollValue > 0)
			{
				scrollValue = this._horizontalScrollBar.getTweenToValue();
				if (scrollValue == null)
					scrollValue = this._horizontalScrollBar.getScrollValue();
				
				if (deltaX < 0 && scrollValue > 0)
				{
					this._horizontalScrollBar.startScrollTween(Math.max(scrollValue + (deltaX * (scrollLineSize * 3)), 0));
					consumeEvent = true;
				}
				else if (deltaX > 0 && scrollValue < maxScrollValue)
				{
					this._horizontalScrollBar.startScrollTween(Math.min(scrollValue + (deltaX * (scrollLineSize * 3)), maxScrollValue));
					consumeEvent = true;
				}
			}
		}
		
		if (deltaY != 0 && this._verticalScrollBar != null)
		{
			scrollPageSize = this._verticalScrollBar.getScrollPageSize();
			scrollViewSize = this._verticalScrollBar.getScrollViewSize();
			scrollLineSize = this._verticalScrollBar.getScrollLineSize();
			
			maxScrollValue = scrollPageSize - scrollViewSize;
			if (maxScrollValue > 0)
			{
				scrollValue = this._verticalScrollBar.getTweenToValue();
				if (scrollValue == null)
					scrollValue = this._verticalScrollBar.getScrollValue();
				
				if (deltaY < 0 && scrollValue > 0)
				{
					this._verticalScrollBar.startScrollTween(Math.max(scrollValue + (deltaY * (scrollLineSize * 3)), 0));
					consumeEvent = true;
				}
				else if (deltaY > 0 && scrollValue < maxScrollValue)
				{
					this._verticalScrollBar.startScrollTween(Math.min(scrollValue + (deltaY * (scrollLineSize * 3)), maxScrollValue));
					consumeEvent = true;
				}
			}
		}
		
		//We've consumed the wheel event, don't want parents double scrolling.
		if (consumeEvent == true)
		{
			elementMouseWheelEvent.preventDefault();
			this._invalidateLayout();
		}
	};
	
//@Override
ViewportElement.prototype._doStylesUpdated =
	function (stylesMap)
	{
		ViewportElement.base.prototype._doStylesUpdated.call(this, stylesMap);
		
		if ("HorizontalScrollBarDisplay" in stylesMap ||
			"VerticalScrollBarDisplay" in stylesMap)
		{
			this._invalidateLayout();
			this._invalidateMeasure();
		}
		else if ("HorizontalScrollBarPlacement" in stylesMap ||
				"VerticalScrollBarPlacement" in stylesMap)
		{
			this._invalidateLayout();
		}
		
		if ("HorizontalScrollBarStyle" && this._horizontalScrollBar != null)
			this._horizontalScrollBar.setStyleDefinitions(this.getStyle("HorizontalScrollBarStyle"));
		if ("VerticalScrollBarStyle" && this._verticalScrollBar != null)
			this._verticalScrollBar.setStyleDefinitions(this.getStyle("VerticalScrollBarStyle"));
	};

//@Override
ViewportElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		var vBarWidth = 0;
		var vBarHeight = 0;
		
		var hBarWidth = 0;
		var hBarHeight = 0;
		
		if (this._verticalScrollBar != null)
		{
			vBarWidth = this._verticalScrollBar._getStyledOrMeasuredWidth();
			vBarHeight = this._verticalScrollBar._getStyledOrMeasuredHeight();
		}
		if (this._horizontalScrollBar != null)
		{
			hBarWidth = this._horizontalScrollBar._getStyledOrMeasuredWidth();
			hBarHeight = this._horizontalScrollBar._getStyledOrMeasuredHeight();
		}
	
		return {width: Math.max(vBarWidth, hBarWidth) + padWidth, height: Math.max(vBarHeight, hBarHeight) + padHeight};
	};
	
//@Override	
ViewportElement.prototype._doLayout = 
	function (paddingMetrics)
	{
		var hDisplay = this.getStyle("HorizontalScrollBarDisplay");
		var vDisplay = this.getStyle("VerticalScrollBarDisplay");
		
		var paneWidth = paddingMetrics.getWidth();
		var paneHeight = paddingMetrics.getHeight();
		
		var contentWidth = 0;
		var contentHeight = 0;
		if (this._viewElement != null)
		{
			contentWidth = this._viewElement._getStyledOrMeasuredWidth();
			contentHeight = this._viewElement._getStyledOrMeasuredHeight();
		}
		
		var scrollBarsChanged = false;
		var needsHScroll = false;
		var needsVScroll = false;
		
		//We need the scroll bar.
		if (hDisplay == "on" || (hDisplay == "auto" && contentWidth > paneWidth))
			needsHScroll = true;
			
		if (vDisplay == "on" || (vDisplay == "auto" && contentHeight > paneHeight))
			needsVScroll = true;
		
		//2nd pass, we need the *other* scroll bar because the first took some of our content area.
		if (needsHScroll == true && needsVScroll == false && vDisplay == "auto" && this._horizontalScrollBar != null)
		{
			if (contentHeight > paneHeight - this._horizontalScrollBar._getStyledOrMeasuredHeight())
				needsVScroll = true;
		}

		if (needsVScroll == true && needsHScroll == false && hDisplay == "auto" && this._verticalScrollBar != null)
		{
			if (contentWidth > paneWidth - this._verticalScrollBar._getStyledOrMeasuredWidth())
				needsHScroll = true;
		}
		
		//Destroy
		if (needsHScroll == false)
		{
			if (this._horizontalScrollBar != null)
			{
				this._removeChild(this._horizontalScrollBar);
				this._horizontalScrollBar = null;
				scrollBarsChanged = true;
			}
		}
		else //Create
		{
			if (this._horizontalScrollBar == null)
			{
				this._horizontalScrollBar = new ScrollBarElement();
				this._horizontalScrollBar._setStyleDefinitionDefault(this._getDefaultStyle("HorizontalScrollBarStyle"));
				this._horizontalScrollBar.setStyleDefinitions(this.getStyle("HorizontalScrollBarStyle"));
				this._horizontalScrollBar.setStyle("ScrollBarDirection", "horizontal");
				this._horizontalScrollBar.setScrollLineSize(25);
				
				this._horizontalScrollBar.addEventListener("changed", this._onViewportScrollBarChangeInstance);
				this._addChild(this._horizontalScrollBar);
				scrollBarsChanged = true;
			}
		}
		
		//Destroy
		if (needsVScroll == false)
		{
			if (this._verticalScrollBar != null)
			{
				this._removeChild(this._verticalScrollBar);
				this._verticalScrollBar = null;
				scrollBarsChanged = true;
			}
		}
		else //Create
		{
			if (this._verticalScrollBar == null)
			{
				this._verticalScrollBar = new ScrollBarElement();
				this._verticalScrollBar._setStyleDefinitionDefault(this._getDefaultStyle("VerticalScrollBarStyle"));
				this._verticalScrollBar.setStyleDefinitions(this.getStyle("VerticalScrollBarStyle"));
				this._verticalScrollBar.setStyle("ScrollBarDirection", "vertical");
				this._verticalScrollBar.setScrollLineSize(25);
				
				this._verticalScrollBar.addEventListener("changed", this._onViewportScrollBarChangeInstance);
				this._addChild(this._verticalScrollBar);
				scrollBarsChanged = true;
			}
		}
		
		//Wait for next pass, adding / removing bars changes content size, need bars to measure.
		if (scrollBarsChanged == true)
			return;
		
		var horizontalBarHeight = 0;
		var verticalBarWidth = 0;
		
		var horizontalScrollValue = 0;
		var verticalScrollValue = 0;
		
		if (this._horizontalScrollBar != null)
		{
			horizontalScrollValue = this._horizontalScrollBar.getScrollValue();
			horizontalBarHeight = this._horizontalScrollBar._getStyledOrMeasuredHeight();
			paneHeight -= horizontalBarHeight;
		}
		
		if (this._verticalScrollBar != null)
		{
			verticalScrollValue = this._verticalScrollBar.getScrollValue();
			verticalBarWidth = this._verticalScrollBar._getStyledOrMeasuredWidth();
			paneWidth -= verticalBarWidth;
		}
		
		//Fix scroll values (size reduction forces us to scroll up)
		horizontalScrollValue = Math.min(horizontalScrollValue, contentWidth - paneWidth);
		horizontalScrollValue = Math.max(horizontalScrollValue, 0);
		
		verticalScrollValue = Math.min(verticalScrollValue, contentHeight - paneHeight);
		verticalScrollValue = Math.max(verticalScrollValue, 0);
		
		//Only enable clipping if we need it (its expensive)
		if (paneWidth < contentWidth || paneHeight < contentHeight)
			this._viewPortContainer.setStyle("ClipContent", true);
		else
			this._viewPortContainer.setStyle("ClipContent", false);		
		
		var horizontalBarPlacement = this.getStyle("HorizontalScrollBarPlacement");
		var verticalBarPlacement = this.getStyle("VerticalScrollBarPlacement");
		
		var x = paddingMetrics.getX();
		var y = paddingMetrics.getY();
		
		if (this._horizontalScrollBar != null)
		{
			this._horizontalScrollBar.setScrollPageSize(contentWidth);
			this._horizontalScrollBar.setScrollViewSize(paneWidth);
			this._horizontalScrollBar.setScrollValue(horizontalScrollValue);
			
			this._horizontalScrollBar._setActualSize(paneWidth, horizontalBarHeight);
			
			if (horizontalBarPlacement == "top")
			{
				if (verticalBarPlacement == "left")
					this._horizontalScrollBar._setActualPosition(x + verticalBarWidth, y);
				else
					this._horizontalScrollBar._setActualPosition(x, y);
			}
			else
			{
				if (verticalBarPlacement == "left")
					this._horizontalScrollBar._setActualPosition(x + verticalBarWidth, y + paneHeight);
				else
					this._horizontalScrollBar._setActualPosition(x, y + paneHeight);
			}
		}
		
		if (this._verticalScrollBar != null)
		{
			this._verticalScrollBar.setScrollPageSize(contentHeight);
			this._verticalScrollBar.setScrollViewSize(paneHeight);
			this._verticalScrollBar.setScrollValue(verticalScrollValue);
			
			this._verticalScrollBar._setActualSize(verticalBarWidth, paneHeight);
			
			if (verticalBarPlacement == "left")
			{
				if (horizontalBarPlacement == "top")
					this._verticalScrollBar._setActualPosition(x, y + horizontalBarHeight);
				else
					this._verticalScrollBar._setActualPosition(x, y);
			}
			else
			{
				if (horizontalBarPlacement == "top")
					this._verticalScrollBar._setActualPosition(x + paneWidth, y + horizontalBarHeight);
				else
					this._verticalScrollBar._setActualPosition(x + paneWidth, y);
			}
		}
		
		var containerX = x;
		var containerY = y;
		
		if (horizontalBarPlacement == "top")
			containerY += horizontalBarHeight;
		if (verticalBarPlacement == "left")
			containerX += verticalBarWidth;		
		
		this._viewPortContainer._setActualSize(paneWidth, paneHeight);
		this._viewPortContainer._setActualPosition(containerX, containerY);
		
		if (this._viewElement != null)
		{
			this._viewElement.setStyle("X", horizontalScrollValue * -1);
			this._viewElement.setStyle("Y", verticalScrollValue * -1);
		}
	};
	
	
///////////////////////////////////////////////////////////////////////
///////////////////////ViewportAnchorContainerElement//////////////////


//This is an internal class used by the Viewport. Its identical to an 
//AnchorContainer except it blocks the _doMeasure() function. Viewport
//uses this as a layout mechanism and doesn't want changes to this
//elements children to cause redundant measurement and layout.

function ViewportAnchorContainerElement()
{
	ViewportAnchorContainerElement.base.prototype.constructor.call(this);
}

//Inherit from AnchorContainerElement
ViewportAnchorContainerElement.prototype = Object.create(AnchorContainerElement.prototype);
ViewportAnchorContainerElement.prototype.constructor = ViewportAnchorContainerElement;
ViewportAnchorContainerElement.base = AnchorContainerElement;

//@Override
ViewportAnchorContainerElement.prototype._doMeasure = 
	function(padWidth, padHeight)
	{
		return {width:0, height:0};
	};	
	
	
	


/**
 * @depends AnchorContainerElement.js
 */

//////////////////////////////////////////////////////////////
////////////////////CanvasManager/////////////////////////////

/**
 * @class CanvasManager
 * @inherits AnchorContainerElement
 * 
 * CanvasManager is the root of the display hierarchy, manages a single canvas, and is essentially
 * the brain of the system, its responsible things such as driving the component life cycle, 
 * managing CanvasElements, requesting render frames from the browser, etc.  
 * For elements to be rendered to the canvas, they must be added to CanvasManager, or be a descendant of
 * an element that has been added to CanvasManager. 
 * 
 * CanvasManager itself is a subclass of an AnchorContainer and can be used as such, although typically
 * for more complex layouts you will nest containers inside of CanvasManager.
 * 
 * @constructor CanvasManager 
 * Creates new CanvasManager instance.
 */

function CanvasManager()
{
	//Life cycle phases
	this._updateStylesQueue = new CmDepthQueue();
	this._updateMeasureQueue = new CmDepthQueue();
	this._updateLayoutQueue = new CmDepthQueue();
	this._updateRenderQueue = new CmDepthQueue();

	this._compositeRenderQueue = new CmDepthQueue();
	
	//Used to store the add/remove events we need to dispatch after elements are added/removed from the display chain.
	//Adding and removing elements is a recursive process which must finish prior to dispatching any events.
	this._addRemoveDisplayChainQueue = new CmLinkedList();
	this._addRemoveDisplayChainQueueProcessing = false; //Recursion guard
	
	this._broadcastDispatcher = new EventDispatcher(); //Dispatches broadcast events.
	
	this._browserCursor = null;
	this._cursorChain = new CmLinkedList();	//Priority Chain (cursor)
	
	this._tabStopReverse = false;
	this._focusElement = null;				//Target with focus
	
	this._canvas = null;
	this._canvasContext = null;
	this._canvasRenderFramePending = false;
	
	this._mouseX = -1;
	this._mouseY = -1;
	
	this._rollOverInvalid = true;
	this._rollOverElement = null;	//Last roll over target.
	this._rollOverX = -1;			//Position within target (used for mousemove)
	this._rollOverY = -1;
	
	this._mouseDownElement = null; 	//Target to dispatch mouseup
	
	this._draggingElement = null;	//Target currently being dragged.
	this._draggingOffsetX = null;
	this._draggingOffsetY = null;	
	
	this._currentLocale = "en-us";
	
	this._redrawRegionInvalid = true;
	this._redrawRegionPrevMetrics = null;
	
	//Now call base
	CanvasManager.base.prototype.constructor.call(this);

	this._cursorContainer = new CanvasElement();
	this._cursorContainer.setStyle("MouseEnabled", false);
	this._addOverlayChild(this._cursorContainer);	
	
	var _self = this;
	
	//Private handlers, need instance for every CanvasManager
	this._onCursorDefinitionStyleChangedInstance = 
		function (styleChangedEvent)
		{
			_self._onCursorDefinitionStyleChanged(styleChangedEvent);
		};
		
	this._onCanvasFrame = 
		function ()
		{
			//Prevent double render frames if someone changes our associated canvas.
			if (_self._canvasContext == null)
			{
				_self._canvasRenderFramePending = false;
				return;
			}
			
			window.requestAnimationFrame(_self._onCanvasFrame);	
			
			_self.updateNow();
		};
	
	this._canvasResizeEventHandler = 
		function ()
		{
			//Fix canvas manager size.
			_self.setStyle("Width", _self._canvas.clientWidth);
			_self.setStyle("Height", _self._canvas.clientHeight);
			_self._setActualSize(_self._canvas.clientWidth, _self._canvas.clientHeight);
			
			_self._redrawRegionPrevMetrics = null;
			_self._updateRedrawRegion(_self.getMetrics(null));
			
			_self.updateNow();
		};
	
	this._canvasFocusEventHandler = 
		function (browserEvent)
		{
			//Tab focus only (if focused via mouse we'll get the mouse event first)
			if (_self._focusElement == null && browserEvent.type == "focus")
			{
				if (_self._tabStopReverse == true)
					_self._updateFocusElement(_self._findChildTabStopReverse(_self, null, null), true);
				else
					_self._updateFocusElement(_self._findChildTabStopForward(_self, null), true);
			}
			else if (_self._focusElement != null && browserEvent.type == "blur")
				_self._updateFocusElement(null, true);
		};		
		
	this._canvasKeyboardEventHandler = 
		function (browserEvent)
		{
			if (browserEvent.type == "keydown")
			{
				if (browserEvent.key == "Tab" && browserEvent.shiftKey == true)
					_self._tabStopReverse = true;
				else if (browserEvent.key == "Tab" && browserEvent.shiftKey == false)
					_self._tabStopReverse = false;
			}
		
			if (_self._focusElement != null)
			{
				var keyboardEvent = new ElementKeyboardEvent(browserEvent.type, 
											browserEvent.key, browserEvent.which, 
											browserEvent.ctrlKey, browserEvent.altKey, 
											browserEvent.shiftKey, browserEvent.metaKey);
				
				_self._focusElement._dispatchEvent(keyboardEvent);
				
				if (keyboardEvent._canceled == true || keyboardEvent._defaultPrevented == true)
					browserEvent.preventDefault();
				else if (browserEvent.type == "keydown" && keyboardEvent.getKey() == "Tab")
				{
					var tabStopElement = null;
					var currentParent = _self._focusElement;
					var lastParent = null;
					
					if (_self._tabStopReverse == false)
					{
						while (currentParent != null)
						{
							tabStopElement = _self._findChildTabStopForward(currentParent, lastParent);
							
							if (tabStopElement != null)
								break;
							
							lastParent = currentParent;
							currentParent = currentParent._parent;
						}
					}
					else //Tab backwards
					{
						while (currentParent != null)
						{
							tabStopElement = _self._findChildTabStopReverse(currentParent, lastParent, null);
							
							if (tabStopElement != null)
								break;
							
							lastParent = currentParent;
							currentParent = currentParent._parent;
						}
					}
					
					_self._updateFocusElement(tabStopElement, true);
					if (tabStopElement != null)
						browserEvent.preventDefault();
				}
			}
		};
	
	this._canvasMouseEventHandler = 
		function(browserEvent)
		{
			//Translate mouse to local position
			var mousePoint = CanvasManager.getLocalMousePos(browserEvent, _self._canvas);
			
			var i = 0;

			if (browserEvent.type == "mouseup")
			{
				window.removeEventListener('mouseup', _self._canvasMouseEventHandler);

				_self._clearDraggingElement();
				_self._mouseDownElement._mouseIsDown = false;

				//Start at mousedown target, record parents up to canvas manager, fix state.
				var parentChain = [];
				parentChain.push(_self._mouseDownElement);
				
				while (parentChain[parentChain.length - 1]._parent != null)
				{
					parentChain[parentChain.length - 1]._parent._mouseIsDown = false;
					parentChain.push(parentChain[parentChain.length - 1]._parent);
				}

				var clickElement = null;
				var clickPoint = {x:0, y:0};
				
				//Adjust mouse point for target element to dispatch mouseup
				for (i = parentChain.length - 1; i >= 0; i--) //Start at CanvasManager child, work down to target.
				{
					//Rotate the point backwards so we can translate the point to the element's rotated plane.
					parentChain[i].rotatePoint(mousePoint, true);
					
					//Adjust the mouse point to within this element rather than its position in parent.
					mousePoint.x = mousePoint.x - parentChain[i]._x;
					mousePoint.y = mousePoint.y - parentChain[i]._y;
					
					//Dispatch click if we're still over the target element.
					if (mousePoint.x >= 0 && 
						mousePoint.x <= parentChain[i]._width &&
						mousePoint.y >= 0 &&
						mousePoint.y <= parentChain[i]._height)
					{
						clickElement = parentChain[i];
						
						clickPoint.x = mousePoint.x;
						clickPoint.y = mousePoint.y;
					}
				}
				
				_self._mouseDownElement = null;

				//Dispatch mouseup
				parentChain[0]._dispatchEvent(new ElementMouseEvent("mouseup", mousePoint.x, mousePoint.y));
				
				//Dispatch click if we're still over the target element.
				if (clickElement != null)
					clickElement._dispatchEvent(new ElementMouseEvent("click", clickPoint.x, clickPoint.y));
			}
			else if (browserEvent.type == "wheel")
			{
				//Mouse is disabled on CanvasManager
				if (_self.getStyle("MouseEnabled") == false || _self.getStyle("Visible") == false)
					return;
				
				var currentElement = null;
				
				if (mousePoint.x >= 0 && mousePoint.x <= _self._width &&
					mousePoint.y >= 0 && mousePoint.y <= _self._height)
				{
					currentElement = _self;
					
					var foundChild = false;
					while (true)
					{
						foundChild = false;
						for (i = currentElement._children.length -1; i >= 0; i--)
						{
							//Skip element if mouse is disabled or visibility is off.
							if (currentElement._children[i].getStyle("MouseEnabled") == false || 
								currentElement._children[i].getStyle("Visible") == false)
								continue;
							
							//Rotate the point backwards so we can translate the point to the element's rotated plane.
							currentElement._children[i].rotatePoint(mousePoint, true);
							
							if (mousePoint.x >= currentElement._children[i]._x && 
								mousePoint.x <= currentElement._children[i]._x + currentElement._children[i]._width &&
								mousePoint.y >= currentElement._children[i]._y &&
								mousePoint.y <= currentElement._children[i]._y + currentElement._children[i]._height)
							{
								currentElement = currentElement._children[i];
								
								//Adjust the mouse point to within this element rather than its position in parent.
								mousePoint.x = mousePoint.x - currentElement._x;
								mousePoint.y = mousePoint.y - currentElement._y;
								
								foundChild = true;
								break;
							}
							
							//Rotate forwards, we're not over this child, undo the rotation.
							currentElement._children[i].rotatePoint(mousePoint, false);
						}
						
						if (foundChild == false)
							break;
					}
				}
				
				if (currentElement != null)
				{
					var deltaX = 0;
					if (browserEvent.deltaX > 0)
						deltaX = 1;
					else if (browserEvent.deltaX < 0)
						deltaX = -1;
					
					var deltaY = 0;
					if (browserEvent.deltaY > 0)
						deltaY = 1;
					else if (browserEvent.deltaY < 0)
						deltaY = -1;
					
					var mouseWheelEvent = new ElementMouseWheelEvent(mousePoint.x, mousePoint.y, deltaX, deltaY);
					currentElement._dispatchEvent(mouseWheelEvent);
					
					if (mouseWheelEvent._canceled == true || mouseWheelEvent._defaultPrevented == true)
						browserEvent.preventDefault();
				}
			}
			else if (browserEvent.type == "mousedown")
			{
				//Kill focus if we're not over the canvas				
				if (mousePoint.x < 0 || mousePoint.x > this._width || 
					mousePoint.y < 0 || mousePoint.y > this._height)
				{
					_self._updateFocusElement(null, false);
					return;
				}
					
				//Mouse is disabled on CanvasManager
				if (_self.getStyle("MouseEnabled") == false || _self.getStyle("Visible") == false || _self._mouseDownElement != null)
					return;
				
				var draggingElement = null;
				var draggingOffset = {x:0, y:0};
				
				var focusElement = null;
				var focusElementTabStop = -1;
				var currentElementTabStop = -1;
				
				var currentElement = _self; 
				var foundChild = false;
				while (true)
				{
					currentElement._mouseIsDown = true;
					
					//Only allow dragging if we're not in a container, or an AnchorContainer
					if (currentElement.getStyle("Draggable") == true && 
						(currentElement._parent instanceof AnchorContainerElement || !(currentElement._parent instanceof ContainerBaseElement)))
					{
						draggingElement = currentElement;
						draggingOffset = {x:mousePoint.x, y:mousePoint.y};
					}
				
					currentElementTabStop = currentElement.getStyle("TabStop");
					if (currentElementTabStop >= 0 || focusElementTabStop < 0)
					{
						focusElement = currentElement;
						focusElementTabStop = currentElementTabStop;
					}
					
					foundChild = false;
					for (i = currentElement._children.length -1; i >= 0; i--)
					{
						//Skip element if mouse is disabled or visibility is off.
						if (currentElement._children[i].getStyle("MouseEnabled") == false || 
							currentElement._children[i].getStyle("Visible") == false)
							continue;
						
						//Rotate the point backwards so we can translate the point to the element's rotated plane.
						currentElement._children[i].rotatePoint(mousePoint, true);
						
						if (mousePoint.x >= currentElement._children[i]._x && 
							mousePoint.x <= currentElement._children[i]._x + currentElement._children[i]._width &&
							mousePoint.y >= currentElement._children[i]._y &&
							mousePoint.y <= currentElement._children[i]._y + currentElement._children[i]._height)
						{
							currentElement = currentElement._children[i];
							
							//Adjust the mouse point to within this element rather than its position in parent.
							mousePoint.x = mousePoint.x - currentElement._x;
							mousePoint.y = mousePoint.y - currentElement._y;
							
							foundChild = true;
							break;
						}
						
						//Rotate forwards, we're not over this child, undo the rotation.
						currentElement._children[i].rotatePoint(mousePoint, false);
					}
					
					if (foundChild == false)
						break;
				}

				_self._mouseDownElement = currentElement;
				window.addEventListener('mouseup', _self._canvasMouseEventHandler, false);
					
				if (draggingElement != null)
					_self._setDraggingElement(draggingElement, draggingOffset.x, draggingOffset.y);
				
				currentElement._dispatchEvent(new ElementMouseEvent(browserEvent.type, mousePoint.x, mousePoint.y));
				
				_self._updateFocusElement(focusElement, false);
				
				//Always shut off focus ring (even if focus doesnt change)
				if (_self._focusElement != null)
					_self._focusElement._setRenderFocusRing(false);
			}
			else if (browserEvent.type == "mousemove")
			{
				//Mouse is disabled on CanvasManager
				if (_self.getStyle("MouseEnabled") == false)
					return;
				
				_self._mouseX = mousePoint.x;
				_self._mouseY = mousePoint.y;
				_self._rollOverInvalid = true;
				
				_self._updateCursor();
				
				//Adjust dragging element.
				if (_self._draggingElement != null)
				{
					//We use metrics relative to the parent of the element being dragged. We
					//want to keep the element within parent bounds even if its transformed (rotated).
					
					//Get drag element's metrics relative to its parent.
					var metrics = _self._draggingElement.getMetrics(_self._draggingElement._parent);
					
					//Get the drag offset relative to parent.
					var offset = {x: _self._draggingOffsetX, y: _self._draggingOffsetY};
					_self._draggingElement.translatePointTo(offset, _self._draggingElement._parent);
					
					//Get the mouse position relative to parent.
					var newPosition = {	x: mousePoint.x, y: mousePoint.y };
					_self.translatePointTo(newPosition, _self._draggingElement._parent);
					
					//Adjust mouse position for drag start offset.
					newPosition.x += metrics.getX() - offset.x;
					newPosition.y += metrics.getY() - offset.y;
					
					//Correct if we're out of bounds.
					if (newPosition.x < 0)
						newPosition.x = 0;
					if (newPosition.x > _self._draggingElement._parent._width - metrics.getWidth())
						newPosition.x = _self._draggingElement._parent._width - metrics.getWidth();
					if (newPosition.y < 0)
						newPosition.y = 0;
					if (newPosition.y > _self._draggingElement._parent._height - metrics.getHeight())
						newPosition.y = _self._draggingElement._parent._height - metrics.getHeight();
					
					//Set position relative to parent.
					_self._draggingElement._setRelativePosition(
							newPosition.x, 
							newPosition.y, 
							 _self._draggingElement._parent);
					
					//TODO: Can probably be smarter about this... Check style states
					if (_self._draggingElement._parent instanceof AnchorContainerElement)
					{
						if (_self._draggingElement.getStyle("RotateCenterX") == null || _self._draggingElement.getStyle("RotateCenterY") == null)
						{
							if (_self._draggingElement.getStyle("X") != null)
								_self._draggingElement.setStyle("X", newPosition.x);
							if (_self._draggingElement.getStyle("Y") != null)
								_self._draggingElement.setStyle("Y", newPosition.y);
						}
						else
						{
							if (_self._draggingElement.getStyle("X") != null)
								_self._draggingElement.setStyle("X", _self._draggingElement._x);
							if (_self._draggingElement.getStyle("Y") != null)
								_self._draggingElement.setStyle("Y", _self._draggingElement._y);
							
							_self._draggingElement.setStyle("RotateCenterX", _self._draggingElement._rotateCenterX);
							_self._draggingElement.setStyle("RotateCenterY", _self._draggingElement._rotateCenterY);
						}
					}
					
					//Dispatch dragging.
					_self._draggingElement._dispatchEvent(new ElementEvent("dragging", false));
				}
			}
		};
}

//Inherit from AnchorContainerElement
CanvasManager.prototype = Object.create(AnchorContainerElement.prototype);
CanvasManager.prototype.constructor = CanvasManager;
CanvasManager.base = AnchorContainerElement;	


/////////////Style Types///////////////////////////////

CanvasManager._StyleTypes = Object.create(null);

/**
 * @style ShowRedrawRegion boolean
 * 
 * When true the canvas redraw region will be displayed.
 */
CanvasManager._StyleTypes.ShowRedrawRegion = 								{inheritable:false};		


/////////////Default Styles///////////////////////////////

CanvasManager.StyleDefault = new StyleDefinition();

CanvasManager.StyleDefault.setStyle("ShowRedrawRegion", 					false);		// true || false



///////////////////CanvasManager Public Functions//////////////////////

/**
 * @function setCanvas
 * Sets the canvas that CanvasManager should manage.
 * 
 * @param canvas Canvas
 * Reference to the DOM canvas that CanvasManager should manage.
 */
CanvasManager.prototype.setCanvas = 
	function (canvas)
	{
		if (this._canvas == canvas)
			return;
	
		var addedOrRemoved = (this._canvas == null || canvas == null);
		
		//Clean up old canvas
		if (this._canvas != null)
		{
			window.removeEventListener('mousedown', this._canvasMouseEventHandler, false);
			window.removeEventListener('mousemove', this._canvasMouseEventHandler, false);
			window.removeEventListener("wheel", this._canvasMouseEventHandler, false);
			window.removeEventListener("keydown", this._canvasKeyboardEventHandler, false);
			window.removeEventListener("keyup", this._canvasKeyboardEventHandler, false);
			window.removeEventListener("resize", this._canvasResizeEventHandler, false);
			
			this._canvas.removeEventListener("focus", this._canvasFocusEventHandler, true);
			this._canvas.removeEventListener("blur", this._canvasFocusEventHandler, true);
			
			this._canvas = null;
			this._canvasContext = null;
		}

		if (canvas != null)
		{
			this._canvas = canvas;
			this._canvasContext = canvas.getContext("2d");
			
			window.addEventListener("mousedown", this._canvasMouseEventHandler, false);
			window.addEventListener("mousemove", this._canvasMouseEventHandler, false);
			window.addEventListener("wheel", this._canvasMouseEventHandler, false);
			window.addEventListener("keydown", this._canvasKeyboardEventHandler, false);
			window.addEventListener("keyup", this._canvasKeyboardEventHandler, false);
			window.addEventListener("resize", this._canvasResizeEventHandler, false);
			
			this._canvas.addEventListener("focus", this._canvasFocusEventHandler, true);
			this._canvas.addEventListener("blur", this._canvasFocusEventHandler, true);
					
			this._canvas.tabIndex = 1;
			this._canvas.style.outline = "none";
			this._canvas.style.cursor = "default";
			
			//Disable text selection cursor.
//			canvas.onselectstart = function () { return false; }; 
//			canvas.style.userSelect = "none";
//			canvas.style.webkitUserSelect = "none";
//			canvas.style.MozUserSelect = "none";
//			canvas.style.mozUserSelect = "none";
//			canvas.setAttribute("unselectable", "on"); // For IE and Opera

			//Prevent double render frames if someone changes our associated canvas.
			if (this._canvasRenderFramePending == false)
			{
				this._canvasRenderFramePending = true;
				window.requestAnimationFrame(this._onCanvasFrame);	
			}
			
			if (navigator.userAgent.indexOf("Firefox") > 0)
				CanvasElement._browserType = "Firefox";
		}
		
		if (addedOrRemoved == true)
		{
			this._propagateChildData();
			this._processAddRemoveDisplayChainQueue();
		}
		
		if (this._canvas != null)
		{
			this._rollOverInvalid = true;
			this._canvasResizeEventHandler();
		}
	};

/**
 * @function getCanvas
 * Gets the DOM canvas reference CanvasManager is currently managing.
 * 
 * @returns Canvas
 * The DOM canvas reference CanvasManager is currently managing.
 */	
CanvasManager.prototype.getCanvas = 
	function ()
	{
		return this._canvas;
	};

/**
 * @function setLocale
 * Sets the locale to be used when using localized strings. The actual
 * locale value is arbitrary, this simply dispatches an event to notify elements
 * that the locale has changed. Its up to implementors to store their locale strings
 * and update/lookup accordingly. CanvasManager defaults locale to "en-us". 
 * 
 * @param locale String
 * The locale to change too.
 */	
CanvasManager.prototype.setLocale = 
	function (locale)
	{
		if (this._currentLocale == locale)
			return;
		
		this._currentLocale = locale;
		
		if (this._broadcastDispatcher.hasEventListener("localechanged", null) == true)
			this._broadcastDispatcher._dispatchEvent(new DispatcherEvent("localechanged"));
	};
	
/**
 * @function getLocale
 * Gets CanvasManager's current locale.
 * 
 * @returns String
 * String representing CanvasManager's current locale.
 */	
CanvasManager.prototype.getLocale = 
	function ()
	{
		return this._currentLocale;
	};
	
/**
 * @function addCursor
 * Adds a cursor to be used when the mouse is over the canvas. Cursors are managed
 * as a priority chain. Element roll-over cursors use priority 0 so setting any explicit
 * cursor such as a busy cursor should use a priority higher than 0, unless you want Elements
 * to override the canvas cursor on roll-over.
 * 
 * @param cursorDefinition CursorDefinition
 * The cursor to add. This may be a custom CursorDefinition and CanvasManager will hide
 * the native browser cursor and render the custom cursor. It also may be a standard
 * browser CSS cursor String such as "text".
 * 
 * @param priority int
 * The priority to assign to the cursor. Higher priorities override lower priorities.
 * 
 * @returns Object
 * A "cursor instance" object that is to be used to remove the cursor.
 */	
CanvasManager.prototype.addCursor = 
	function (cursorDefinition, priority)
	{
		if (priority == null)
			priority = 0;
	
		if (cursorDefinition instanceof CursorDefinition)
		{
			if (cursorDefinition._addedCount == 0)
				cursorDefinition.addEventListener("stylechanged", this._onCursorDefinitionStyleChangedInstance);
				
			cursorDefinition._addedCount++;
		}
		
		var cursorInstance = new CmLinkedNode();
		cursorInstance.data = cursorDefinition;
		cursorInstance.priority = priority;
		
		var lastCursor = this._cursorChain.back;
		if (lastCursor == null)
			this._cursorChain.pushBack(cursorInstance);
		else
		{
			while (lastCursor != null && lastCursor.priority > cursorInstance.priority)
				lastCursor = lastCursor.prev;
			
			if (lastCursor == null)
				this._cursorChain.pushFront(cursorInstance);
			else
				this._cursorChain.insertAfter(cursorInstance, lastCursor);
		}
		
		this._updateCursor();
		
		return cursorInstance;
	};

/**
 * @function removeCursor
 * Removes a cursor via the cursor instance object returned by addCursor().
 * 
 * @param cursorInstance Object
 * The cursor instance Object returned by addCursor().
 */	
CanvasManager.prototype.removeCursor = 
	function (cursorInstance)
	{
		if (cursorDefinition instanceof CursorDefinition)
		{
			var cursorDefinition = cursorInstance.data;
			cursorDefinition._addedCount--;
				
			if (cursorDefinition._addedCount == 0)
				cursorDefinition.removeEventListener("stylechanged", this._onCursorDefinitionStyleChangedInstance);
		}

		this._cursorChain.removeNode(cursorInstance);
		this._updateCursor();
		
		return true;
	};	
	
/**
 * @function updateNow
 * This is an internal function and should conceivably *never* be called.
 * This forces a full pass of the component life cycle and is incredibly expensive.
 * The system calls this once per render frame with the only known exception being immediately after a canvas resize.
 * If you think you need to call this, you probably have a design problem.
 * Documentation added for unforeseen circumstances. 
 */	
CanvasManager.prototype.updateNow = 
	function ()
	{
		if (this._broadcastDispatcher.hasEventListener("enterframe", null) == true)
			this._broadcastDispatcher._dispatchEvent(new DispatcherEvent("enterframe"));
	
		//Process state updates.
		while (this._updateStylesQueue.length > 0 || 
				this._updateMeasureQueue.length > 0 || 
				this._updateLayoutQueue.length > 0 || 
				this._rollOverInvalid == true ||
				this._updateRenderQueue.length > 0)
		{
			//Process styles queue.
			while (this._updateStylesQueue.length > 0)
				this._updateStylesQueue.removeSmallest().data._validateStyles();
			
			//Process measure queue.
			while (this._updateMeasureQueue.length > 0 && 
					this._updateStylesQueue.length == 0)
			{
				this._updateMeasureQueue.removeLargest().data._validateMeasure();
			}
			
			//Process layout queue.
			while (this._updateLayoutQueue.length > 0 && 
					this._updateMeasureQueue.length == 0 && 
					this._updateStylesQueue.length == 0)
			{
				this._updateLayoutQueue.removeSmallest().data._validateLayout();
			}
			
			//Do rollover/rollout/mousemove
			if (this._rollOverInvalid == true && 
				this._updateLayoutQueue.length == 0 && 
				this._updateMeasureQueue.length == 0 && 
				this._updateStylesQueue.length == 0)
			{
				this._rollOverInvalid = false;
				
				var i;
				var currentElement = null;
				var mousePoint = {x: this._mouseX, y:this._mouseY};
				
				var lastRollOverTarget = this._rollOverElement;
				var lastRollOverX = this._rollOverX;
				var lastRollOverY = this._rollOverY;
				
				this._rollOverElement = null;
				
				var rollOverCommonParent = null;
				var rollOverElements = [];
				
				//Make sure we're over the canvas.				
				if (mousePoint.x >= 0 && mousePoint.x <= this._width &&
					mousePoint.y >= 0 && mousePoint.y <= this._height)
				{
					currentElement = this;
					if (currentElement._mouseIsOver == false)
					{
						rollOverElements.push(currentElement);
						currentElement._mouseIsOver = true;
					}
					else
						rollOverCommonParent = currentElement;
					
					this._rollOverElement = currentElement; 
					this._rollOverX = mousePoint.x;
					this._rollOverY = mousePoint.y;
					
					var foundChild = false;
					while (true)
					{
						foundChild = false;
						for (i = currentElement._children.length -1; i >= 0; i--)
						{
							//Skip element if mouse is disabled or not visible.
							if (currentElement._children[i].getStyle("MouseEnabled") == false ||
								currentElement._children[i].getStyle("Visible") == false)
								continue;
							
							//Rotate the point backwards so we can translate the point to the element's rotated plane.
							currentElement._children[i].rotatePoint(mousePoint, true);
							
							if (mousePoint.x >= currentElement._children[i]._x && 
								mousePoint.x <= currentElement._children[i]._x + currentElement._children[i]._width &&
								mousePoint.y >= currentElement._children[i]._y &&
								mousePoint.y <= currentElement._children[i]._y + currentElement._children[i]._height)
							{
								currentElement = currentElement._children[i];
								if (currentElement._mouseIsOver == false)
								{
									rollOverElements.push(currentElement);
									currentElement._mouseIsOver = true;
								}								
								else
									rollOverCommonParent = currentElement;
								
								//Adjust the mouse point to within this element rather than its position in parent.
								mousePoint.x = mousePoint.x - currentElement._x;
								mousePoint.y = mousePoint.y - currentElement._y;
								
								this._rollOverElement = currentElement;
								this._rollOverX = mousePoint.x;
								this._rollOverY = mousePoint.y;
								
								foundChild = true;
								break;
							}
							
							//Rotate forwards, we're not over this child, undo the rotation.
							currentElement._children[i].rotatePoint(mousePoint, false);
						}
						
						if (foundChild == false)
							break;
					}
				}

				if (currentElement != null && 
					(this._rollOverElement != lastRollOverTarget || 
					this._rollOverX != lastRollOverX || 
					this._rollOverY != lastRollOverY))
				{
					currentElement._dispatchEvent(new ElementMouseEvent("mousemove", mousePoint.x, mousePoint.y));
				}
				
				this._broadcastDispatcher._dispatchEvent(new ElementMouseEvent("mousemoveex", this._mouseX, this._mouseY));
				
				if (lastRollOverTarget != null && this._rollOverElement != lastRollOverTarget)
				{
					var rollOutElements = [];
					currentElement = lastRollOverTarget;
					while (currentElement != rollOverCommonParent)
					{
						currentElement._mouseIsOver = false;
						rollOutElements.push(currentElement);
						currentElement = currentElement._parent;
					}
					
					for (i = 0; i < rollOutElements.length; i++)
						rollOutElements[i]._dispatchEvent(new ElementEvent("rollout", false));
				}
				
				for (i = 0; i < rollOverElements.length; i++)
					rollOverElements[i]._dispatchEvent(new ElementEvent("rollover", false));
			}
			
			//Process render queue.
			while (this._updateRenderQueue.length > 0 && 
					this._rollOverInvalid == false &&
					this._updateLayoutQueue.length == 0 && 
					this._updateMeasureQueue.length == 0 && 
					this._updateStylesQueue.length == 0)
			{
				this._updateRenderQueue.removeSmallest().data._validateRender();
			}
		}
		
		if (this._redrawRegionInvalid == true)
		{
			this._validateRedrawRegion(this, false);
			this._redrawRegionInvalid = false;
		}
		
		//Render composite layers.
		while (this._compositeRenderQueue.length > 0)
			this._compositeRenderQueue.removeLargest().data._validateCompositeRender();
		
		//Render redraw region
		if (this._redrawRegionPrevMetrics != null)
			this._invalidateCompositeRender();
	};

/////////////CanvasManager Static Public Functions///////////////	

/**
 * @function getLocalMousePos
 * @static
 * Translates browser mouse event coordinates to canvas relative coordinates.
 * The system automatically calls this and translates raw browser events to 
 * system events to be consumed by CanvasElements. You probably never need to call this.
 * 
 * @param event BrowserEvent
 * The browser mouse event.
 * 
 * @param canvas Canvas
 * The DOM Canvas reference to translate the mouse coordinates too.
 * 
 * @returns Object
 * A point object containing {x, y}.
 */	
CanvasManager.getLocalMousePos = 
	function (event, canvas)
	{
		//Reliable way to get position with canvas scaling.
		var rect = canvas.getBoundingClientRect();
		return {
			x: Math.round((event.clientX - rect.left) / (rect.right - rect.left) * canvas.width),
			y: Math.round((event.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height)
		};
	};	

//////////////Internal Functions////////////////

//@override	
CanvasManager.prototype._updateCompositeCanvas = 
	function ()
	{
		if (this._compositeCanvas == null)
		{
			this._compositeCanvas = this._canvas;
			this._compositeCtx = this._canvasContext;
		}
		
		if (this._compositeCanvas.width != this._width || 
			this._compositeCanvas.height != this._height)
		{
			this._compositeCanvas.width = this._width;
			this._compositeCanvas.height = this._height;
			
			if (this._compositeCanvasMetrics == null)
				this._compositeCanvasMetrics = new DrawMetrics();
			
			this._compositeCanvasMetrics._x = 0;
			this._compositeCanvasMetrics._y = 0;
			this._compositeCanvasMetrics._width = this._width;
			this._compositeCanvasMetrics._height = this._height;
			
			//Expand the redraw region to this whole canvas.
			if (this._redrawRegionMetrics == null)
				this._redrawRegionMetrics = this._compositeCanvasMetrics.clone();
			else
				this._redrawRegionMetrics.mergeExpand(this._compositeCanvasMetrics);
		}
	};	

//@private (recursive function)	
CanvasManager.prototype._validateRedrawRegion = 
	function (element, forceRegionUpdate)
	{
		var newCompositeMetrics = [];
		var oldVisible = element._renderVisible;
		
		//Get new visibility
		var newVisible = true;
		if ((element._parent != null && element._parent._renderVisible == false) || 
			element.getStyle("Visible") == false || 
			element.getStyle("Alpha") <= 0)
		{
			newVisible = false;
		}
		
		//Composite effect on this element changed, we *must* update the region on ourself and all of our children.
		if (element._compositeEffectChanged == true)
			forceRegionUpdate = true;
		
		//Wipe out the composite metrics (rebuild as we recurse children if we're a composite layer)
		element._compositeVisibleMetrics = null;
		element._transformVisibleMetrics = null;
		element._transformDrawableMetrics = null;
		
		if ((element._renderChanged == true || element._graphicsClear == false) &&
			(oldVisible == true || newVisible == true))
		{
			var parent = element;
			var rawMetrics = element.getMetrics();		//Transformed via points up parent chain
			
			var drawableMetrics = rawMetrics.clone();	//Transformed via metrics up parent chain (recalculated each layer, expands, and clips)
			
			//Used for transforming the raw metrics up the parent chain.
			var pointRawTl = {x:rawMetrics._x, y:rawMetrics._y};
			var pointRawTr = {x:rawMetrics._x + rawMetrics._width, y:rawMetrics._y};
			var pointRawBr = {x:rawMetrics._x + rawMetrics._width, y:rawMetrics._y + rawMetrics._height};
			var pointRawBl = {x:rawMetrics._x, y:rawMetrics._y + rawMetrics._height};
			
			var pointDrawableTl = {x:0, y:0};
			var pointDrawableTr = {x:0, y:0};
			var pointDrawableBr = {x:0, y:0};
			var pointDrawableBl = {x:0, y:0};
			
			var minX = null;
			var maxX = null;
			var minY = null;
			var maxY = null;
			
			//Cached storage of previous metrics per composite parent.
			var oldMetrics = null;	//{element:element, metrics:DrawMetrics, drawableMetrics:DrawMetrics}
			
			var clipMetrics = new DrawMetrics();
			var shadowMetrics = new DrawMetrics();
			var shadowSize = 0;
			
			var drawableMetricsChanged = false;
			var rawMetricsChanged = false;
			
			//Walk up the parent chain invalidating the redraw region and updating _compositeVisibleMetrics
			while (parent != null)
			{
				//Apply clipping to drawable metrics (Always clip root manager)
				if (drawableMetrics != null && (parent == this || parent.getStyle("ClipContent") == true))
				{
					//Clip metrics relative to current element
					clipMetrics._x = 0;
					clipMetrics._y = 0;
					clipMetrics._width = parent._width;
					clipMetrics._height = parent._height;
					
					//Reduce drawable metrics via clipping metrics.
					drawableMetrics.mergeReduce(clipMetrics);
					
					//Kill metrics if completely clipped
					if (drawableMetrics._width <= 0 || drawableMetrics._height <= 0)
						drawableMetrics = null;
				}
				
				//Update redraw region, _compositeVisibleMetrics, and record new stored composite metrics.
				if (parent._isCompositeElement() == true)
				{
					oldMetrics = element._getCompositeMetrics(parent);
					
					if (drawableMetrics != null && newVisible == true && element._graphicsClear == false)
					{
						newCompositeMetrics.push({element:parent, metrics:rawMetrics.clone(), drawableMetrics:drawableMetrics.clone()});
						
						//Update composite parents visible metrics
						if (parent._compositeVisibleMetrics == null)
							parent._compositeVisibleMetrics = drawableMetrics.clone();
						else
							parent._compositeVisibleMetrics.mergeExpand(drawableMetrics);
					}
					else
						newMetrics = null;
					
					drawableMetricsChanged = true;
					if ((oldMetrics == null && drawableMetrics == null) ||
						(oldMetrics != null && drawableMetrics != null && oldMetrics.drawableMetrics.equals(drawableMetrics) == true))
					{
						drawableMetricsChanged = false;
					}
					
					rawMetricsChanged = true;
					if (oldMetrics != null && oldMetrics.metrics.equals(rawMetrics) == true)
					{
						rawMetricsChanged = false;
					}
					
					//Update the composite element's redraw region
					if (forceRegionUpdate == true || 			//Composite effect changed	
						element._renderChanged == true ||		//Render changed
						oldVisible != newVisible ||				//Visible changed
						drawableMetricsChanged == true ||		//Drawable region changed (clipping)
						rawMetricsChanged)						//Position changed
					{
						//If was visible, redraw old metrics
						if (oldVisible == true && oldMetrics != null)
							parent._updateRedrawRegion(oldMetrics.drawableMetrics);
						
						//Redraw new metrics
						if (newVisible == true)
							parent._updateRedrawRegion(drawableMetrics);
					}
				}				
				
				//Drawable metrics will be null if we've been completely clipped. No reason to do any more translation.
				if (drawableMetrics != null)
				{	//Fix current metrics so that we're now relative to our parent.
					
					//Update position
					
					//Drawable metrics////
					drawableMetrics._x += parent._x;
					drawableMetrics._y += parent._y;
					
					shadowSize = parent.getStyle("ShadowSize");
					
					//Expand metrics for shadow
					if (shadowSize > 0 && parent.getStyle("ShadowColor") != null)
					{
						//Copy drawable metrics
						shadowMetrics.copyFrom(drawableMetrics);
						
						//Create shadow position metrics
						shadowMetrics._width += (shadowSize * 2);
						shadowMetrics._height += (shadowSize * 2);
						shadowMetrics._x -= shadowSize;
						shadowMetrics._y -= shadowSize;
						shadowMetrics._x += parent.getStyle("ShadowOffsetX");
						shadowMetrics._y += parent.getStyle("ShadowOffsetY");
						
						//Merge the shadow metrics with the drawable metrics
						drawableMetrics.mergeExpand(shadowMetrics);
						
						//Handle transform
						if (CanvasElement.normalizeDegrees(parent._rotateDegrees) != 0)
						{
							//Transform drawable metrics/////////////
							pointDrawableTl.x = drawableMetrics._x;
							pointDrawableTl.y = drawableMetrics._y;
							
							pointDrawableTr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableTr.y = drawableMetrics._y;
							
							pointDrawableBr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableBr.y = drawableMetrics._y + drawableMetrics._height;
							
							pointDrawableBl.x = drawableMetrics._x;
							pointDrawableBl.y = drawableMetrics._y + drawableMetrics._height;
							
							parent.rotatePoint(pointDrawableTl, false);
							parent.rotatePoint(pointDrawableTr, false);
							parent.rotatePoint(pointDrawableBl, false);
							parent.rotatePoint(pointDrawableBr, false);
							
							minX = Math.min(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							maxX = Math.max(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							minY = Math.min(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							maxY = Math.max(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							
							drawableMetrics._x = minX;
							drawableMetrics._y = minY;
							drawableMetrics._width = maxX - minX;
							drawableMetrics._height = maxY - minY;
						}
						
						//Use drawable metrics as the new raw metrics (shadow uses context of parent applying shadow)
						rawMetrics.copyFrom(drawableMetrics);
						
						pointRawTl.x += rawMetrics._x;
						pointRawTl.y += rawMetrics._y;
						
						pointRawTr.x += rawMetrics._x + rawMetrics._width;
						pointRawTr.y += rawMetrics._y;
						
						pointRawBr.x += rawMetrics._x + rawMetrics._width;
						pointRawBr.y += rawMetrics._y + rawMetrics._height;
						
						pointRawBl.x += rawMetrics._x;
						pointRawBl.y += rawMetrics._y + rawMetrics._height;
					}
					else
					{
						//Raw metrics
						pointRawTl.x += parent._x;
						pointRawTl.y += parent._y;
						
						pointRawTr.x += parent._x;
						pointRawTr.y += parent._y;
						
						pointRawBr.x += parent._x;
						pointRawBr.y += parent._y;
						
						pointRawBl.x += parent._x;
						pointRawBl.y += parent._y;
						
						//Handle transform
						if (CanvasElement.normalizeDegrees(parent._rotateDegrees) != 0)
						{
							//Rotate raw metrics points
							parent.rotatePoint(pointRawTl, false);
							parent.rotatePoint(pointRawTr, false);
							parent.rotatePoint(pointRawBl, false);
							parent.rotatePoint(pointRawBr, false);
							
							//Transform drawable metrics/////////////
							pointDrawableTl.x = drawableMetrics._x;
							pointDrawableTl.y = drawableMetrics._y;
							
							pointDrawableTr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableTr.y = drawableMetrics._y;
							
							pointDrawableBr.x = drawableMetrics._x + drawableMetrics._width;
							pointDrawableBr.y = drawableMetrics._y + drawableMetrics._height;
							
							pointDrawableBl.x = drawableMetrics._x;
							pointDrawableBl.y = drawableMetrics._y + drawableMetrics._height;
							
							parent.rotatePoint(pointDrawableTl, false);
							parent.rotatePoint(pointDrawableTr, false);
							parent.rotatePoint(pointDrawableBl, false);
							parent.rotatePoint(pointDrawableBr, false);
							
							minX = Math.min(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							maxX = Math.max(pointDrawableTl.x, pointDrawableTr.x, pointDrawableBr.x, pointDrawableBl.x);
							minY = Math.min(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							maxY = Math.max(pointDrawableTl.y, pointDrawableTr.y, pointDrawableBr.y, pointDrawableBl.y);
							
							drawableMetrics._x = minX;
							drawableMetrics._y = minY;
							drawableMetrics._width = maxX - minX;
							drawableMetrics._height = maxY - minY;
							/////////////////////////////////////
						}
						
						//Update transformed raw metrics
						minX = Math.min(pointRawTl.x, pointRawTr.x, pointRawBr.x, pointRawBl.x);
						maxX = Math.max(pointRawTl.x, pointRawTr.x, pointRawBr.x, pointRawBl.x);
						minY = Math.min(pointRawTl.y, pointRawTr.y, pointRawBr.y, pointRawBl.y);
						maxY = Math.max(pointRawTl.y, pointRawTr.y, pointRawBr.y, pointRawBl.y);
						
						rawMetrics._x = minX;
						rawMetrics._y = minY;
						rawMetrics._width = maxX - minX;
						rawMetrics._height = maxY - minY;
					}
					
					//Reduce the precision (random rounding errors at *very* high decimal points)
					rawMetrics.roundToPrecision(3);
					
					//Reduce drawable metrics via raw metrics.
					drawableMetrics.mergeReduce(rawMetrics);
					
					//Reduce the precision (random rounding errors at *very* high decimal points)
					drawableMetrics.roundToPrecision(3);
				}
				
				parent = parent._parent;
			}
		}
		
		element._compositeMetrics = newCompositeMetrics;
		element._renderVisible = newVisible;
		element._renderChanged = false;
		
		//Recurse children if we were or are visible.
		if (oldVisible == true || newVisible == true)
		{
			for (var i = 0; i < element._children.length; i++)
				this._validateRedrawRegion(element._children[i], forceRegionUpdate);
			
			if (element._isCompositeElement() == true)
				this._updateTransformMetrics(element);
		}
	};
	
CanvasManager.prototype._updateTransformMetrics = 
	function(compositeElement)
	{
		//No transform of root manager, or invisible layers.
		if (compositeElement == this || compositeElement._compositeVisibleMetrics == null)
			return;
		
		var pointTl = {x:0, y:0};
		var pointTr = {x:0, y:0};
		var pointBr = {x:0, y:0};
		var pointBl = {x:0, y:0};
		
		var minX = null;
		var maxX = null;
		var minY = null;
		var maxY = null;
		
		var shadowSize = 0;
		
		var parent = compositeElement;
		compositeElement._transformVisibleMetrics = compositeElement._compositeVisibleMetrics.clone();
		compositeElement._transformDrawableMetrics = compositeElement._compositeVisibleMetrics.clone();
		
		var clipMetrics = new DrawMetrics();
		var done = false;
		
		while (true)
		{
			if (compositeElement._transformDrawableMetrics != null && parent.getStyle("ClipContent") == true)
			{
				//Clip metrics relative to current element
				clipMetrics._x = 0;
				clipMetrics._y = 0;
				clipMetrics._width = parent._width;
				clipMetrics._height = parent._height;
				
				//Reduce drawable metrics via clipping metrics.
				compositeElement._transformDrawableMetrics.mergeReduce(clipMetrics);
				
				//Kill metrics if completely clipped
				if (compositeElement._transformDrawableMetrics._width <= 0 || compositeElement._transformDrawableMetrics._height <= 0)
				{
					compositeElement._transformDrawableMetrics = null;
					compositeElement._transformVisibleMetrics = null;
					
					return;
				}
			}
			
			if (done == true)
				break;
			
			compositeElement._transformVisibleMetrics._x += parent._x;
			compositeElement._transformVisibleMetrics._y += parent._y;
			
			compositeElement._transformDrawableMetrics._x += parent._x;
			compositeElement._transformDrawableMetrics._y += parent._y;

			shadowSize = parent.getStyle("ShadowSize");
			
			//Expand metrics for shadow
			if (shadowSize > 0 && parent.getStyle("ShadowColor") != null)
			{
				//Copy drawable metrics
				var shadowMetrics = compositeElement._transformDrawableMetrics.clone();
				
				//Create shadow position metrics
				shadowMetrics._width += (shadowSize * 2);
				shadowMetrics._height += (shadowSize * 2);
				shadowMetrics._x -= shadowSize;
				shadowMetrics._y -= shadowSize;
				shadowMetrics._x += parent.getStyle("ShadowOffsetX");
				shadowMetrics._y += parent.getStyle("ShadowOffsetY");
				
				//Merge the shadow metrics with the drawable metrics
				compositeElement._transformDrawableMetrics.mergeExpand(shadowMetrics);
			}
			
			if (CanvasElement.normalizeDegrees(parent._rotateDegrees) != 0)
			{
				//Transform visible
				pointTl.x = compositeElement._transformVisibleMetrics._x;
				pointTl.y = compositeElement._transformVisibleMetrics._y;
				
				pointTr.x = compositeElement._transformVisibleMetrics._x + compositeElement._transformVisibleMetrics._width;
				pointTr.y = compositeElement._transformVisibleMetrics._y;

				pointBr.x = compositeElement._transformVisibleMetrics._x + compositeElement._transformVisibleMetrics._width;
				pointBr.y = compositeElement._transformVisibleMetrics._y + compositeElement._transformVisibleMetrics._height;
				
				pointBl.x = compositeElement._transformVisibleMetrics._x;
				pointBl.y = compositeElement._transformVisibleMetrics._y + compositeElement._transformVisibleMetrics._height;
				
				parent.rotatePoint(pointTl, false);
				parent.rotatePoint(pointTr, false);
				parent.rotatePoint(pointBl, false);
				parent.rotatePoint(pointBr, false);
				
				minX = Math.min(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				maxX = Math.max(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				minY = Math.min(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				maxY = Math.max(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				
				compositeElement._transformVisibleMetrics._x = minX;
				compositeElement._transformVisibleMetrics._y = minY;
				compositeElement._transformVisibleMetrics._width = maxX - minX;
				compositeElement._transformVisibleMetrics._height = maxY - minY;
				
				compositeElement._transformVisibleMetrics.roundToPrecision(3);
				
				//Transform Drawable
				pointTl.x = compositeElement._transformDrawableMetrics._x;
				pointTl.y = compositeElement._transformDrawableMetrics._y;
				
				pointTr.x = compositeElement._transformDrawableMetrics._x + compositeElement._transformDrawableMetrics._width;
				pointTr.y = compositeElement._transformDrawableMetrics._y;
				
				pointBr.x = compositeElement._transformDrawableMetrics._x + compositeElement._transformDrawableMetrics._width;
				pointBr.y = compositeElement._transformDrawableMetrics._y + compositeElement._transformDrawableMetrics._height;
				
				pointBl.x = compositeElement._transformDrawableMetrics._x;
				pointBl.y = compositeElement._transformDrawableMetrics._y + compositeElement._transformDrawableMetrics._height;
				
				parent.rotatePoint(pointTl, false);
				parent.rotatePoint(pointTr, false);
				parent.rotatePoint(pointBl, false);
				parent.rotatePoint(pointBr, false);
				
				minX = Math.min(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				maxX = Math.max(pointTl.x, pointTr.x, pointBr.x, pointBl.x);
				minY = Math.min(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				maxY = Math.max(pointTl.y, pointTr.y, pointBr.y, pointBl.y);
				
				compositeElement._transformDrawableMetrics._x = minX;
				compositeElement._transformDrawableMetrics._y = minY;
				compositeElement._transformDrawableMetrics._width = maxX - minX;
				compositeElement._transformDrawableMetrics._height = maxY - minY;
				
				compositeElement._transformDrawableMetrics.roundToPrecision(3);
			}
			
			parent = parent._parent;
			
			if (parent._isCompositeElement() == true)
				done = true;
		}
	};
	
//@override (add redraw region visibility)	
CanvasManager.prototype._validateCompositeRender =
	function ()
	{
		if (this.getStyle("ShowRedrawRegion") == true)
		{
			var currentRegion = null;
			if (this._redrawRegionMetrics != null)
			{
				currentRegion = this._redrawRegionMetrics.clone();
				currentRegion._x -= 1;
				currentRegion._y -= 1;
				currentRegion._width += 2;
				currentRegion._height += 2;
				currentRegion.roundUp();
				
				//Expand the redraw region to this whole canvas.
				if (this._redrawRegionPrevMetrics != null)
					this._redrawRegionMetrics.mergeExpand(this._redrawRegionPrevMetrics);
			}
			else if (this._redrawRegionPrevMetrics != null)
				this._redrawRegionMetrics = this._redrawRegionPrevMetrics.clone();
			
			CanvasManager.base.prototype._validateCompositeRender.call(this);
			
			if (currentRegion != null)
			{
				this._canvasContext.lineWidth = 1;
				this._canvasContext.strokeStyle = "#FF0000";
				
				this._canvasContext.beginPath();
				this._canvasContext.moveTo(currentRegion._x + .5, currentRegion._y + .5);
				this._canvasContext.lineTo(currentRegion._x + currentRegion._width - .5, currentRegion._y + .5);
				this._canvasContext.lineTo(currentRegion._x + currentRegion._width - .5, currentRegion._y + currentRegion._height - .5);
				this._canvasContext.lineTo(currentRegion._x + .5, currentRegion._y + currentRegion._height - .5);
				this._canvasContext.closePath();
				this._canvasContext.stroke();	
			}
			
			this._redrawRegionPrevMetrics = currentRegion;
		}
		else
		{
			CanvasManager.base.prototype._validateCompositeRender.call(this);
			this._redrawRegionPrevMetrics = null;
		}
	};	
	
//@private	
CanvasManager.prototype._updateFocusElement = 
	function (newFocusElement, renderFocusRing)
	{
		if (newFocusElement != this._focusElement)
		{
			if (this._focusElement != null)
			{
				this._focusElement._isFocused = false;
				this._focusElement._setRenderFocusRing(false);
				
				if (this._focusElement.hasEventListener("focusout", null) == true)
					this._focusElement._dispatchEvent(new ElementEvent("focusout", false));
			}
			
			this._focusElement = newFocusElement;
			
			if (this._focusElement != null)
			{
				this._focusElement._isFocused = true;
				this._focusElement._setRenderFocusRing(renderFocusRing);
				
				if (this._focusElement.hasEventListener("focusin", null) == true)
					this._focusElement._dispatchEvent(new ElementEvent("focusin", false));
			}
		}
	};
	
//@private	
CanvasManager.prototype._findChildTabStopForward = 
	function (parent, afterChild)
	{
		var index = 0;
		if (afterChild != null)
			index = parent._children.indexOf(afterChild) + 1;
		
		var tabToElement = null;
		
		for (var i = index; i < parent._children.length; i++)
		{
			if (parent._children[i].getStyle("MouseEnabled") == false ||
				parent._children[i].getStyle("Visible") == false || 
				parent._children[i].getStyle("Enabled") == false)
				continue;
			
			if (parent._children[i].getStyle("TabStop") >= 0)
				return parent._children[i];
			
			tabToElement = this._findChildTabStopForward(parent._children[i], null);
			if (tabToElement != null)
				return tabToElement;
		}
		
		return tabToElement;
	};

//@private	
CanvasManager.prototype._findChildTabStopReverse = 
	function (parent, beforeChild, lastTabStopElement)
	{
		var index = parent._children.length - 1;
		if (beforeChild != null)
			index = parent._children.indexOf(beforeChild) - 1;
		
		for (var i = index; i >= 0; i--)
		{
			if (parent._children[i].getStyle("MouseEnabled") == false ||
				parent._children[i].getStyle("Visible") == false || 
				parent._children[i].getStyle("Enabled") == false)
				continue;
			
			if (parent._children[i].getStyle("TabStop") >= 0)
				lastTabStopElement = parent._children[i];
			
			this._findChildTabStopReverse(parent._children[i], null, lastTabStopElement);
			
			if (lastTabStopElement != null)
				return lastTabStopElement;
		}
		
		return lastTabStopElement;
	};	
	
//@private	
CanvasManager.prototype._updateCursor = 
	function ()
	{
		var cursorDefinition = null;
		if (this._cursorChain.back != null)
			cursorDefinition = this._cursorChain.back.data;
		
		var displayedCursorElement = null;
		if (this._cursorContainer._getNumChildren() > 0)
			displayedCursorElement = this._cursorContainer._getChildAt(0);
		
		if (cursorDefinition != null)
		{
			var cursorElement = null;
			if (!(typeof cursorDefinition === "string" || cursorDefinition instanceof String))
			{
				var cursorClass = cursorDefinition.getStyle("CursorClass");
				
				if (cursorClass == null)
					cursorDefinition._cursorElement = null;
				else
				{
					if (cursorDefinition._cursorElement == null || 
						cursorDefinition._cursorElement.constructor != cursorClass)
					{
						cursorDefinition._cursorElement = new (cursorClass)();
						cursorDefinition._cursorElement.setStyleDefinitions(cursorDefinition.getStyle("CursorStyle"));
					}
					else
						cursorDefinition._cursorElement.setStyleDefinitions(cursorDefinition.getStyle("CursorStyle"));
					
					cursorElement = cursorDefinition._cursorElement;
				}
			}
			
			if (displayedCursorElement != cursorElement)
			{
				if (displayedCursorElement != null)
					this._cursorContainer._removeChild(displayedCursorElement);
				if (cursorElement != null)
					this._cursorContainer._addChild(cursorElement);
			}
			
			if (cursorElement != null)
			{
				if (this._browserCursor != "none")
				{
					this._browserCursor = "none";
					this._canvas.style.cursor = "none";
				}
					
				//Make visible if we're over canvas			
				if (this._mouseX >= 0 && this._mouseX <= this._width &&
					this._mouseY >= 0 && this._mouseY <= this._height)
				{
					var cursorWidth = cursorDefinition._cursorElement._getStyledOrMeasuredWidth();
					var cursorHeight = cursorDefinition._cursorElement._getStyledOrMeasuredHeight();
					var offsetX = cursorDefinition.getStyle("CursorOffsetX");
					var offsetY = cursorDefinition.getStyle("CursorOffsetY");
					
					cursorElement._setActualPosition(this._mouseX + offsetX, this._mouseY + offsetY);
					cursorElement._setActualSize(cursorWidth, cursorHeight);
					cursorElement.setStyle("Visible", true);
				}
				else //Hide' mouse is no longer over canvas
					cursorElement.setStyle("Visible", false);
			}
			else if (this._browserCursor != cursorDefinition)
			{
				this._browserCursor = cursorDefinition;
				this._canvas.style.cursor = cursorDefinition;
			}
		}
		else
		{
			if (displayedCursorElement != null)
				this._cursorContainer._removeChildAt(0);
			
			if (this._browserCursor != "default")
			{
				this._browserCursor = "default";
				this._canvas.style.cursor = "default";
			}
		}
	};
	
//@private	
CanvasManager.prototype._onCursorDefinitionStyleChanged = 
	function (styleChangedEvent)
	{
		var cursorDefinition = styleChangedEvent.getTarget();
		
		var styleName = styleChangedEvent.getStyleName();
		if (styleName == "CursorClass" && cursorDefinition._cursorElement != null)
		{
			var cursorClass = cursorDefinition.getStyle("CursorClass");
			if (cursorDefinition._cursorElement.constructor != cursorClass)
				cursorDefinition._cursorElement = null;
		}
		if (styleName == "CursorStyle" && cursorDefinition._cursorElement != null)
			cursorDefinition._cursorElement.setStyleDefinitions(this.getStyle("CursorStyle"));
		
		this._updateCursor();
	};
	
//@private	
CanvasManager.prototype._pushAddRemoveDisplayChainQueue = 
	function (element, type)
	{
		var node = new CmLinkedNode();
		node.data = {element:element, type:type};
		
		this._addRemoveDisplayChainQueue.pushBack(node);
	};

//@private	
CanvasManager.prototype._popAddRemoveDisplayChainQueue = 
	function ()
	{
		if (this._addRemoveDisplayChainQueue.length == 0)
			return null;
		
		var data = this._addRemoveDisplayChainQueue.front.data;
		this._addRemoveDisplayChainQueue.removeNode(this._addRemoveDisplayChainQueue.front);
		
		return data;
	};

//@private	
CanvasManager.prototype._processAddRemoveDisplayChainQueue = 
	function ()
	{
		//Recursion guard. An event may add or remove other elements, we dont want this function to recurse.
		if (this._addRemoveDisplayChainQueueProcessing == true)
			return;
		
		//Block recursion
		this._addRemoveDisplayChainQueueProcessing = true;
		
		var addRemoveData = this._popAddRemoveDisplayChainQueue();
		while (addRemoveData != null)
		{
			addRemoveData.element._dispatchEvent(new AddedRemovedEvent(addRemoveData.type, this));
			addRemoveData = this._popAddRemoveDisplayChainQueue();
		}
		
		//Queue emtpy, allow processing again.
		this._addRemoveDisplayChainQueueProcessing = false;
	};

//@private	
CanvasManager.prototype._clearDraggingElement = 
	function ()
	{
		if (this._draggingElement == null)
			return;

		this._draggingElement = null;
		this._draggingOffsetX = null;
		this._draggingOffsetY = null;
	};

//@private	
CanvasManager.prototype._setDraggingElement = 
	function (element, offsetX, offsetY)
	{
		if (this._draggingElement != null)
			return;

		this._draggingElement = element;
		this._draggingOffsetX = offsetX;
		this._draggingOffsetY = offsetY;
	};
	
//@Override	
CanvasManager.prototype._doLayout = 
function (paddingMetrics)
{
	CanvasManager.base.prototype._doLayout.call(this, paddingMetrics);
	
	this._cursorContainer._setActualSize(this._width, this._height);
};	



//////////Private Helper Classes////////////////////

//Used exclusively by CanvasManager//

//Queue used for processing component cycles (styles, measure, layout) based on display chain depth.
function CmDepthQueue()
{
	this.depthArrayOfLists = []; //Array of CmLinkedList, index based on depth.
	this.length = 0;
	
	//Stores current start/end populated indexes of depthArrayOfLists for performance.
	this.minDepth = -1;
	this.maxDepth = -1;
}

CmDepthQueue.prototype.addNode = 
	function (node, depth)
	{
		var depthToIndex = depth - 1;
	
		if (this.depthArrayOfLists[depthToIndex] == null)
			this.depthArrayOfLists[depthToIndex] = new CmLinkedList();
		
		this.depthArrayOfLists[depthToIndex].pushBack(node);
		
		this.length = this.length + 1;
		
		if (depthToIndex < this.minDepth || this.minDepth == -1)
			this.minDepth = depthToIndex;
		if (depthToIndex > this.maxDepth)
			this.maxDepth = depthToIndex;
	};
	
CmDepthQueue.prototype.removeNode = 
	function (node, depth)
	{
		var depthToIndex = depth - 1; 
	
		this.depthArrayOfLists[depthToIndex].removeNode(node);
		
		this.length = this.length - 1;
		if (this.length == 0)
		{
			this.minDepth = -1;
			this.maxDepth = -1;
		}
	};
	
CmDepthQueue.prototype.removeSmallest = 
	function ()
	{
		if (this.length == 0)
			return null;
		
		for (var i = this.minDepth; i < this.depthArrayOfLists.length; i++)
		{
			this.minDepth = i;
			if (this.depthArrayOfLists[i] == null || this.depthArrayOfLists[i].length == 0)
				continue;
			
			var node = this.depthArrayOfLists[i].front;
			this.depthArrayOfLists[i].removeNode(node);
			
			this.length = this.length - 1;
			if (this.length == 0)
			{
				this.minDepth = -1;
				this.maxDepth = -1;
			}
			
			return node;
		}
	};
	
CmDepthQueue.prototype.removeLargest = 
	function ()
	{
		if (this.length == 0)
			return null;
		
		for (var i = this.maxDepth; i >= 0; i--)
		{
			this.maxDepth = i;
			if (this.depthArrayOfLists[i] == null || this.depthArrayOfLists[i].length == 0)
				continue;
			
			var node = this.depthArrayOfLists[i].back;
			this.depthArrayOfLists[i].removeNode(node);
			
			this.length = this.length - 1;
			if (this.length == 0)
			{
				this.minDepth = -1;
				this.maxDepth = -1;
			}
			
			return node;
		}
	};
	
//Basic linked list	
function CmLinkedList()
{
	this.front = null;
	this.back = null;
	
	this.length = 0;
}

CmLinkedList.prototype.pushFront = 
	function (cmLinkedNode)
	{
		this.length++;
		
		if (this.front == null)
		{
			cmLinkedNode.prev = null;
			cmLinkedNode.next = null;
			
			this.front = cmLinkedNode;
			this.back = cmLinkedNode;
		}
		else
		{
			cmLinkedNode.prev = null;
			cmLinkedNode.next = this.front;
			
			this.front.prev = cmLinkedNode;
			this.front = cmLinkedNode;
		}
	};
	
CmLinkedList.prototype.pushBack =
	function (cmLinkedNode)
	{
		this.length++;
	
		if (this.back == null)
		{
			cmLinkedNode.prev = null;
			cmLinkedNode.next = null;
			
			this.front = cmLinkedNode;
			this.back = cmLinkedNode;
		}
		else
		{
			cmLinkedNode.prev = this.back;
			cmLinkedNode.next = null;
			
			this.back.next = cmLinkedNode;
			this.back = cmLinkedNode;
		}
	};

CmLinkedList.prototype.insertBefore = 
	function (cmLinkedNode, beforeCmLinkedNode)	
	{
		this.length++;
		
		if (this.front == beforeCmLinkedNode)
			this.front = cmLinkedNode;
		
		if (beforeCmLinkedNode.prev != null)
			beforeCmLinkedNode.prev.next = cmLinkedNode;
		
		cmLinkedNode.prev = beforeCmLinkedNode.prev;
		cmLinkedNode.next = beforeCmLinkedNode;
		beforeCmLinkedNode.prev = cmLinkedNode;
	};

CmLinkedList.prototype.insertAfter = 
	function (cmLinkedNode, afterCmLinkedNode)
	{
		this.length++;
		
		if (this.back == afterCmLinkedNode)
			this.back = cmLinkedNode;
		
		if (afterCmLinkedNode.next != null)
			afterCmLinkedNode.next.prev = cmLinkedNode;
		
		cmLinkedNode.next = afterCmLinkedNode.next;
		cmLinkedNode.prev = afterCmLinkedNode;
		afterCmLinkedNode.next = cmLinkedNode;		
	};
	
CmLinkedList.prototype.removeNode = 
	function (cmLinkedNode)
	{
		if (cmLinkedNode == null)
			return null;
		
		this.length--;
		
		if (this.front == cmLinkedNode)
			this.front = cmLinkedNode.next;
		if (this.back == cmLinkedNode)
			this.back = cmLinkedNode.prev;
		
		if (cmLinkedNode.prev != null)
			cmLinkedNode.prev.next = cmLinkedNode.next;
		if (cmLinkedNode.next != null)
			cmLinkedNode.next.prev = cmLinkedNode.prev;
		
		cmLinkedNode.next = null;
		cmLinkedNode.prev = null;
	};
	
//Linked list iterator	
function CmLinkedNode()
{
	this.prev = null;
	this.next = null;
	
	this.data = null;
}






